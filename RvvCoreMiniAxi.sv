// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Include register initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Standard header to adapt well known macros for register randomization.

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_
module CoreCSR(
  input          clock,
                 reset,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  output         io_fabric_writeResp,
                 io_reset,
                 io_cg,
  output [31:0]  io_pcStart,
  input          io_halted,
                 io_fault,
  input  [31:0]  io_coralnpu_csr_value_0,
                 io_coralnpu_csr_value_1,
                 io_coralnpu_csr_value_2,
                 io_coralnpu_csr_value_3,
                 io_coralnpu_csr_value_4,
                 io_coralnpu_csr_value_5,
                 io_coralnpu_csr_value_6,
                 io_coralnpu_csr_value_7,
                 io_coralnpu_csr_value_8
);

  reg  [31:0]  resetReg;
  reg  [31:0]  pcStartReg;
  reg  [31:0]  statusReg;
  wire         readDataValid =
    io_fabric_readDataAddr_bits == 32'h0 | io_fabric_readDataAddr_bits == 32'h108
    | io_fabric_readDataAddr_bits == 32'h100 | io_fabric_readDataAddr_bits == 32'h118
    | io_fabric_readDataAddr_bits == 32'h110 | io_fabric_readDataAddr_bits == 32'h10C
    | io_fabric_readDataAddr_bits == 32'h11C | io_fabric_readDataAddr_bits == 32'h114
    | io_fabric_readDataAddr_bits == 32'h120 | io_fabric_readDataAddr_bits == 32'h104
    | io_fabric_readDataAddr_bits == 32'h8 | io_fabric_readDataAddr_bits == 32'h4;
  reg          readDataNext_pipe_v;
  reg  [127:0] readDataNext_pipe_b;
  wire         _io_fabric_writeResp_T_1 = io_fabric_writeDataAddr_bits == 32'h0;
  wire         _io_fabric_writeResp_T_2 = io_fabric_writeDataAddr_bits == 32'h4;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      resetReg <= 32'h3;
      pcStartReg <= 32'h0;
      statusReg <= 32'h0;
      readDataNext_pipe_v <= 1'h0;
    end
    else begin
      if (io_fabric_writeDataAddr_valid & _io_fabric_writeResp_T_1)
        resetReg <= io_fabric_writeDataBits[31:0];
      if (io_fabric_writeDataAddr_valid & _io_fabric_writeResp_T_2)
        pcStartReg <= io_fabric_writeDataBits[63:32];
      statusReg <= {30'h0, io_fault, io_halted};
      readDataNext_pipe_v <= readDataValid;
    end
  end // always @(posedge, posedge)
  wire         _GEN = io_fabric_readDataAddr_bits[31:4] == 28'h0;
  wire         _GEN_0 = io_fabric_readDataAddr_bits[31:4] == 28'h10;
  wire         _GEN_1 = io_fabric_readDataAddr_bits[31:4] == 28'h11;
  always @(posedge clock) begin
    if (readDataValid)
      readDataNext_pipe_b <=
        {_GEN_1 ? io_coralnpu_csr_value_7 : _GEN_0 ? io_coralnpu_csr_value_3 : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_6
           : _GEN_0 ? io_coralnpu_csr_value_2 : _GEN ? statusReg : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_5
           : _GEN_0 ? io_coralnpu_csr_value_1 : _GEN ? pcStartReg : 32'h0,
         _GEN_1
           ? io_coralnpu_csr_value_4
           : _GEN_0
               ? io_coralnpu_csr_value_0
               : io_fabric_readDataAddr_bits[31:4] == 28'h12
                   ? io_coralnpu_csr_value_8
                   : _GEN ? resetReg : 32'h0};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:7];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h8; i += 4'h1) begin
          _RANDOM[i[2:0]] = `RANDOM;
        end
        resetReg = _RANDOM[3'h0];
        pcStartReg = _RANDOM[3'h1];
        statusReg = _RANDOM[3'h2];
        readDataNext_pipe_v = _RANDOM[3'h3][0];
        readDataNext_pipe_b =
          {_RANDOM[3'h3][31:1],
           _RANDOM[3'h4],
           _RANDOM[3'h5],
           _RANDOM[3'h6],
           _RANDOM[3'h7][0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        resetReg = 32'h3;
        pcStartReg = 32'h0;
        statusReg = 32'h0;
        readDataNext_pipe_v = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readDataNext_pipe_v;
  assign io_fabric_readData_bits = readDataNext_pipe_b;
  assign io_fabric_writeResp =
    io_fabric_writeDataAddr_valid & (_io_fabric_writeResp_T_2 | _io_fabric_writeResp_T_1);
  assign io_reset = resetReg[0];
  assign io_cg = resetReg[1];
  assign io_pcStart = pcStartReg;
endmodule

module Regfile(
  input         clock,
                reset,
                io_readAddr_0_valid,
  input  [4:0]  io_readAddr_0_addr,
  input         io_readAddr_1_valid,
  input  [4:0]  io_readAddr_1_addr,
  input         io_readAddr_2_valid,
  input  [4:0]  io_readAddr_2_addr,
  input         io_readAddr_3_valid,
  input  [4:0]  io_readAddr_3_addr,
  input         io_readAddr_4_valid,
  input  [4:0]  io_readAddr_4_addr,
  input         io_readAddr_5_valid,
  input  [4:0]  io_readAddr_5_addr,
  input         io_readAddr_6_valid,
  input  [4:0]  io_readAddr_6_addr,
  input         io_readAddr_7_valid,
  input  [4:0]  io_readAddr_7_addr,
  input         io_readSet_0_valid,
  input  [31:0] io_readSet_0_value,
  input         io_readSet_1_valid,
  input  [31:0] io_readSet_1_value,
  input         io_readSet_2_valid,
  input  [31:0] io_readSet_2_value,
  input         io_readSet_3_valid,
  input  [31:0] io_readSet_3_value,
  input         io_readSet_4_valid,
  input  [31:0] io_readSet_4_value,
  input         io_readSet_5_valid,
  input  [31:0] io_readSet_5_value,
  input         io_readSet_6_valid,
  input  [31:0] io_readSet_6_value,
  input         io_readSet_7_valid,
  input  [31:0] io_readSet_7_value,
  input         io_writeAddr_0_valid,
  input  [4:0]  io_writeAddr_0_addr,
  input         io_writeAddr_1_valid,
  input  [4:0]  io_writeAddr_1_addr,
  input         io_writeAddr_2_valid,
  input  [4:0]  io_writeAddr_2_addr,
  input         io_writeAddr_3_valid,
  input  [4:0]  io_writeAddr_3_addr,
  input         io_busAddr_0_bypass,
                io_busAddr_0_immen,
  input  [31:0] io_busAddr_0_immed,
  input         io_busAddr_1_bypass,
  input  [31:0] io_busAddr_1_immed,
  input         io_busAddr_2_bypass,
  input  [31:0] io_busAddr_2_immed,
  input         io_busAddr_3_bypass,
  input  [31:0] io_busAddr_3_immed,
  output [31:0] io_target_0_data,
                io_target_1_data,
                io_target_2_data,
                io_target_3_data,
                io_busPort_addr_0,
                io_busPort_addr_1,
                io_busPort_addr_2,
                io_busPort_addr_3,
                io_busPort_data_0,
                io_busPort_data_1,
                io_busPort_data_2,
                io_busPort_data_3,
  output        io_readData_0_valid,
  output [31:0] io_readData_0_data,
  output        io_readData_1_valid,
  output [31:0] io_readData_1_data,
  output        io_readData_2_valid,
  output [31:0] io_readData_2_data,
  output        io_readData_3_valid,
  output [31:0] io_readData_3_data,
  output        io_readData_4_valid,
  output [31:0] io_readData_4_data,
  output        io_readData_5_valid,
  output [31:0] io_readData_5_data,
  output        io_readData_6_valid,
  output [31:0] io_readData_6_data,
  output        io_readData_7_valid,
  output [31:0] io_readData_7_data,
  input         io_writeData_0_valid,
  input  [4:0]  io_writeData_0_bits_addr,
  input  [31:0] io_writeData_0_bits_data,
  input         io_writeData_1_valid,
  input  [4:0]  io_writeData_1_bits_addr,
  input  [31:0] io_writeData_1_bits_data,
  input         io_writeData_2_valid,
  input  [4:0]  io_writeData_2_bits_addr,
  input  [31:0] io_writeData_2_bits_data,
  input         io_writeData_3_valid,
  input  [4:0]  io_writeData_3_bits_addr,
  input  [31:0] io_writeData_3_bits_data,
  input         io_writeData_4_valid,
  input  [4:0]  io_writeData_4_bits_addr,
  input  [31:0] io_writeData_4_bits_data,
  input         io_writeData_5_valid,
  input  [4:0]  io_writeData_5_bits_addr,
  input  [31:0] io_writeData_5_bits_data,
  input         io_writeMask_1_valid,
                io_writeMask_2_valid,
                io_writeMask_3_valid,
                io_writeMask_5_valid,
  output [31:0] io_scoreboard_regd,
                io_scoreboard_comb
);

  reg  [31:0] regfile_1;
  reg  [31:0] regfile_2;
  reg  [31:0] regfile_3;
  reg  [31:0] regfile_4;
  reg  [31:0] regfile_5;
  reg  [31:0] regfile_6;
  reg  [31:0] regfile_7;
  reg  [31:0] regfile_8;
  reg  [31:0] regfile_9;
  reg  [31:0] regfile_10;
  reg  [31:0] regfile_11;
  reg  [31:0] regfile_12;
  reg  [31:0] regfile_13;
  reg  [31:0] regfile_14;
  reg  [31:0] regfile_15;
  reg  [31:0] regfile_16;
  reg  [31:0] regfile_17;
  reg  [31:0] regfile_18;
  reg  [31:0] regfile_19;
  reg  [31:0] regfile_20;
  reg  [31:0] regfile_21;
  reg  [31:0] regfile_22;
  reg  [31:0] regfile_23;
  reg  [31:0] regfile_24;
  reg  [31:0] regfile_25;
  reg  [31:0] regfile_26;
  reg  [31:0] regfile_27;
  reg  [31:0] regfile_28;
  reg  [31:0] regfile_29;
  reg  [31:0] regfile_30;
  reg  [31:0] regfile_31;
  reg  [31:0] scoreboard;
  wire [31:0] _scoreboard_clr0_T_1 = 32'h1 << io_writeData_0_bits_addr;
  wire [31:0] _scoreboard_clr0_T_4 = 32'h1 << io_writeData_1_bits_addr;
  wire [31:0] _scoreboard_clr0_T_7 = 32'h1 << io_writeData_2_bits_addr;
  wire [31:0] _scoreboard_clr0_T_10 = 32'h1 << io_writeData_3_bits_addr;
  wire [31:0] _scoreboard_clr0_T_13 = 32'h1 << io_writeData_4_bits_addr;
  wire [31:0] _scoreboard_clr0_T_16 = 32'h1 << io_writeData_5_bits_addr;
  wire [30:0] scoreboard_clr0 =
    (io_writeData_0_valid ? _scoreboard_clr0_T_1[31:1] : 31'h0)
    | (io_writeData_1_valid ? _scoreboard_clr0_T_4[31:1] : 31'h0)
    | (io_writeData_2_valid ? _scoreboard_clr0_T_7[31:1] : 31'h0)
    | (io_writeData_3_valid ? _scoreboard_clr0_T_10[31:1] : 31'h0)
    | (io_writeData_4_valid ? _scoreboard_clr0_T_13[31:1] : 31'h0)
    | (io_writeData_5_valid ? _scoreboard_clr0_T_16[31:1] : 31'h0);
  reg         readDataReady_0;
  reg         readDataReady_1;
  reg         readDataReady_2;
  reg         readDataReady_3;
  reg         readDataReady_4;
  reg         readDataReady_5;
  reg         readDataReady_6;
  reg         readDataReady_7;
  reg  [31:0] readDataBits_0;
  reg  [31:0] readDataBits_1;
  reg  [31:0] readDataBits_2;
  reg  [31:0] readDataBits_3;
  reg  [31:0] readDataBits_4;
  reg  [31:0] readDataBits_5;
  reg  [31:0] readDataBits_6;
  reg  [31:0] readDataBits_7;
  wire        _valid_T = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1;
  wire        valid_1 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1 & ~io_writeMask_1_valid;
  wire        valid_2 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1 & ~io_writeMask_2_valid;
  wire        valid_3 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1 & ~io_writeMask_3_valid;
  wire        _valid_T_8 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1;
  wire        valid_5 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1 & ~io_writeMask_5_valid;
  wire [31:0] data =
    (_valid_T ? io_writeData_0_bits_data : 32'h0)
    | (valid_1 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_8 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_1_T =
    {_valid_T, valid_1, valid_2, valid_3, _valid_T_8, valid_5};
  wire        _valid_T_12 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h2;
  wire        valid_1_1 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h2 & ~io_writeMask_1_valid;
  wire        valid_2_1 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h2 & ~io_writeMask_2_valid;
  wire        valid_3_1 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h2 & ~io_writeMask_3_valid;
  wire        _valid_T_20 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h2;
  wire        valid_5_1 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h2 & ~io_writeMask_5_valid;
  wire [31:0] data_1 =
    (_valid_T_12 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_1 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_1 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_1 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_20 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_1 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_2_T =
    {_valid_T_12, valid_1_1, valid_2_1, valid_3_1, _valid_T_20, valid_5_1};
  wire        _valid_T_24 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h3;
  wire        valid_1_2 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h3 & ~io_writeMask_1_valid;
  wire        valid_2_2 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h3 & ~io_writeMask_2_valid;
  wire        valid_3_2 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h3 & ~io_writeMask_3_valid;
  wire        _valid_T_32 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h3;
  wire        valid_5_2 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h3 & ~io_writeMask_5_valid;
  wire [31:0] data_2 =
    (_valid_T_24 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_2 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_2 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_2 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_32 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_2 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_3_T =
    {_valid_T_24, valid_1_2, valid_2_2, valid_3_2, _valid_T_32, valid_5_2};
  wire        _valid_T_36 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h4;
  wire        valid_1_3 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h4 & ~io_writeMask_1_valid;
  wire        valid_2_3 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h4 & ~io_writeMask_2_valid;
  wire        valid_3_3 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h4 & ~io_writeMask_3_valid;
  wire        _valid_T_44 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h4;
  wire        valid_5_3 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h4 & ~io_writeMask_5_valid;
  wire [31:0] data_3 =
    (_valid_T_36 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_3 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_3 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_3 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_44 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_3 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_4_T =
    {_valid_T_36, valid_1_3, valid_2_3, valid_3_3, _valid_T_44, valid_5_3};
  wire        _valid_T_48 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h5;
  wire        valid_1_4 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h5 & ~io_writeMask_1_valid;
  wire        valid_2_4 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h5 & ~io_writeMask_2_valid;
  wire        valid_3_4 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h5 & ~io_writeMask_3_valid;
  wire        _valid_T_56 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h5;
  wire        valid_5_4 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h5 & ~io_writeMask_5_valid;
  wire [31:0] data_4 =
    (_valid_T_48 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_4 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_4 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_4 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_56 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_4 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_5_T =
    {_valid_T_48, valid_1_4, valid_2_4, valid_3_4, _valid_T_56, valid_5_4};
  wire        _valid_T_60 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h6;
  wire        valid_1_5 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h6 & ~io_writeMask_1_valid;
  wire        valid_2_5 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h6 & ~io_writeMask_2_valid;
  wire        valid_3_5 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h6 & ~io_writeMask_3_valid;
  wire        _valid_T_68 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h6;
  wire        valid_5_5 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h6 & ~io_writeMask_5_valid;
  wire [31:0] data_5 =
    (_valid_T_60 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_5 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_5 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_5 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_68 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_5 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_6_T =
    {_valid_T_60, valid_1_5, valid_2_5, valid_3_5, _valid_T_68, valid_5_5};
  wire        _valid_T_72 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h7;
  wire        valid_1_6 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h7 & ~io_writeMask_1_valid;
  wire        valid_2_6 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h7 & ~io_writeMask_2_valid;
  wire        valid_3_6 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h7 & ~io_writeMask_3_valid;
  wire        _valid_T_80 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h7;
  wire        valid_5_6 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h7 & ~io_writeMask_5_valid;
  wire [31:0] data_6 =
    (_valid_T_72 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_6 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_6 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_6 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_80 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_6 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_7_T =
    {_valid_T_72, valid_1_6, valid_2_6, valid_3_6, _valid_T_80, valid_5_6};
  wire        _valid_T_84 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h8;
  wire        valid_1_7 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h8 & ~io_writeMask_1_valid;
  wire        valid_2_7 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h8 & ~io_writeMask_2_valid;
  wire        valid_3_7 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h8 & ~io_writeMask_3_valid;
  wire        _valid_T_92 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h8;
  wire        valid_5_7 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h8 & ~io_writeMask_5_valid;
  wire [31:0] data_7 =
    (_valid_T_84 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_7 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_7 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_7 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_92 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_7 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_8_T =
    {_valid_T_84, valid_1_7, valid_2_7, valid_3_7, _valid_T_92, valid_5_7};
  wire        _valid_T_96 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h9;
  wire        valid_1_8 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h9 & ~io_writeMask_1_valid;
  wire        valid_2_8 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h9 & ~io_writeMask_2_valid;
  wire        valid_3_8 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h9 & ~io_writeMask_3_valid;
  wire        _valid_T_104 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h9;
  wire        valid_5_8 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h9 & ~io_writeMask_5_valid;
  wire [31:0] data_8 =
    (_valid_T_96 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_8 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_8 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_8 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_104 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_8 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_9_T =
    {_valid_T_96, valid_1_8, valid_2_8, valid_3_8, _valid_T_104, valid_5_8};
  wire        _valid_T_108 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hA;
  wire        valid_1_9 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hA & ~io_writeMask_1_valid;
  wire        valid_2_9 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hA & ~io_writeMask_2_valid;
  wire        valid_3_9 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hA & ~io_writeMask_3_valid;
  wire        _valid_T_116 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hA;
  wire        valid_5_9 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hA & ~io_writeMask_5_valid;
  wire [31:0] data_9 =
    (_valid_T_108 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_9 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_9 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_9 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_116 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_9 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_10_T =
    {_valid_T_108, valid_1_9, valid_2_9, valid_3_9, _valid_T_116, valid_5_9};
  wire        _valid_T_120 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hB;
  wire        valid_1_10 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hB & ~io_writeMask_1_valid;
  wire        valid_2_10 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hB & ~io_writeMask_2_valid;
  wire        valid_3_10 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hB & ~io_writeMask_3_valid;
  wire        _valid_T_128 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hB;
  wire        valid_5_10 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hB & ~io_writeMask_5_valid;
  wire [31:0] data_10 =
    (_valid_T_120 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_10 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_10 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_10 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_128 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_10 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_11_T =
    {_valid_T_120, valid_1_10, valid_2_10, valid_3_10, _valid_T_128, valid_5_10};
  wire        _valid_T_132 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hC;
  wire        valid_1_11 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hC & ~io_writeMask_1_valid;
  wire        valid_2_11 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hC & ~io_writeMask_2_valid;
  wire        valid_3_11 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hC & ~io_writeMask_3_valid;
  wire        _valid_T_140 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hC;
  wire        valid_5_11 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hC & ~io_writeMask_5_valid;
  wire [31:0] data_11 =
    (_valid_T_132 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_11 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_11 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_11 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_140 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_11 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_12_T =
    {_valid_T_132, valid_1_11, valid_2_11, valid_3_11, _valid_T_140, valid_5_11};
  wire        _valid_T_144 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hD;
  wire        valid_1_12 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hD & ~io_writeMask_1_valid;
  wire        valid_2_12 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hD & ~io_writeMask_2_valid;
  wire        valid_3_12 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hD & ~io_writeMask_3_valid;
  wire        _valid_T_152 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hD;
  wire        valid_5_12 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hD & ~io_writeMask_5_valid;
  wire [31:0] data_12 =
    (_valid_T_144 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_12 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_12 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_12 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_152 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_12 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_13_T =
    {_valid_T_144, valid_1_12, valid_2_12, valid_3_12, _valid_T_152, valid_5_12};
  wire        _valid_T_156 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hE;
  wire        valid_1_13 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hE & ~io_writeMask_1_valid;
  wire        valid_2_13 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hE & ~io_writeMask_2_valid;
  wire        valid_3_13 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hE & ~io_writeMask_3_valid;
  wire        _valid_T_164 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hE;
  wire        valid_5_13 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hE & ~io_writeMask_5_valid;
  wire [31:0] data_13 =
    (_valid_T_156 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_13 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_13 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_13 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_164 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_13 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_14_T =
    {_valid_T_156, valid_1_13, valid_2_13, valid_3_13, _valid_T_164, valid_5_13};
  wire        _valid_T_168 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'hF;
  wire        valid_1_14 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'hF & ~io_writeMask_1_valid;
  wire        valid_2_14 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'hF & ~io_writeMask_2_valid;
  wire        valid_3_14 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'hF & ~io_writeMask_3_valid;
  wire        _valid_T_176 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'hF;
  wire        valid_5_14 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'hF & ~io_writeMask_5_valid;
  wire [31:0] data_14 =
    (_valid_T_168 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_14 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_14 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_14 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_176 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_14 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_15_T =
    {_valid_T_168, valid_1_14, valid_2_14, valid_3_14, _valid_T_176, valid_5_14};
  wire        _valid_T_180 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h10;
  wire        valid_1_15 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h10 & ~io_writeMask_1_valid;
  wire        valid_2_15 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h10 & ~io_writeMask_2_valid;
  wire        valid_3_15 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h10 & ~io_writeMask_3_valid;
  wire        _valid_T_188 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h10;
  wire        valid_5_15 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h10 & ~io_writeMask_5_valid;
  wire [31:0] data_15 =
    (_valid_T_180 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_15 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_15 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_15 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_188 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_15 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_16_T =
    {_valid_T_180, valid_1_15, valid_2_15, valid_3_15, _valid_T_188, valid_5_15};
  wire        _valid_T_192 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h11;
  wire        valid_1_16 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h11 & ~io_writeMask_1_valid;
  wire        valid_2_16 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h11 & ~io_writeMask_2_valid;
  wire        valid_3_16 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h11 & ~io_writeMask_3_valid;
  wire        _valid_T_200 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h11;
  wire        valid_5_16 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h11 & ~io_writeMask_5_valid;
  wire [31:0] data_16 =
    (_valid_T_192 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_16 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_16 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_16 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_200 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_16 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_17_T =
    {_valid_T_192, valid_1_16, valid_2_16, valid_3_16, _valid_T_200, valid_5_16};
  wire        _valid_T_204 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h12;
  wire        valid_1_17 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h12 & ~io_writeMask_1_valid;
  wire        valid_2_17 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h12 & ~io_writeMask_2_valid;
  wire        valid_3_17 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h12 & ~io_writeMask_3_valid;
  wire        _valid_T_212 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h12;
  wire        valid_5_17 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h12 & ~io_writeMask_5_valid;
  wire [31:0] data_17 =
    (_valid_T_204 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_17 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_17 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_17 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_212 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_17 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_18_T =
    {_valid_T_204, valid_1_17, valid_2_17, valid_3_17, _valid_T_212, valid_5_17};
  wire        _valid_T_216 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h13;
  wire        valid_1_18 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h13 & ~io_writeMask_1_valid;
  wire        valid_2_18 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h13 & ~io_writeMask_2_valid;
  wire        valid_3_18 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h13 & ~io_writeMask_3_valid;
  wire        _valid_T_224 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h13;
  wire        valid_5_18 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h13 & ~io_writeMask_5_valid;
  wire [31:0] data_18 =
    (_valid_T_216 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_18 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_18 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_18 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_224 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_18 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_19_T =
    {_valid_T_216, valid_1_18, valid_2_18, valid_3_18, _valid_T_224, valid_5_18};
  wire        _valid_T_228 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h14;
  wire        valid_1_19 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h14 & ~io_writeMask_1_valid;
  wire        valid_2_19 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h14 & ~io_writeMask_2_valid;
  wire        valid_3_19 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h14 & ~io_writeMask_3_valid;
  wire        _valid_T_236 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h14;
  wire        valid_5_19 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h14 & ~io_writeMask_5_valid;
  wire [31:0] data_19 =
    (_valid_T_228 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_19 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_19 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_19 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_236 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_19 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_20_T =
    {_valid_T_228, valid_1_19, valid_2_19, valid_3_19, _valid_T_236, valid_5_19};
  wire        _valid_T_240 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h15;
  wire        valid_1_20 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h15 & ~io_writeMask_1_valid;
  wire        valid_2_20 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h15 & ~io_writeMask_2_valid;
  wire        valid_3_20 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h15 & ~io_writeMask_3_valid;
  wire        _valid_T_248 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h15;
  wire        valid_5_20 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h15 & ~io_writeMask_5_valid;
  wire [31:0] data_20 =
    (_valid_T_240 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_20 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_20 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_20 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_248 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_20 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_21_T =
    {_valid_T_240, valid_1_20, valid_2_20, valid_3_20, _valid_T_248, valid_5_20};
  wire        _valid_T_252 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h16;
  wire        valid_1_21 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h16 & ~io_writeMask_1_valid;
  wire        valid_2_21 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h16 & ~io_writeMask_2_valid;
  wire        valid_3_21 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h16 & ~io_writeMask_3_valid;
  wire        _valid_T_260 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h16;
  wire        valid_5_21 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h16 & ~io_writeMask_5_valid;
  wire [31:0] data_21 =
    (_valid_T_252 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_21 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_21 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_21 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_260 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_21 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_22_T =
    {_valid_T_252, valid_1_21, valid_2_21, valid_3_21, _valid_T_260, valid_5_21};
  wire        _valid_T_264 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h17;
  wire        valid_1_22 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h17 & ~io_writeMask_1_valid;
  wire        valid_2_22 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h17 & ~io_writeMask_2_valid;
  wire        valid_3_22 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h17 & ~io_writeMask_3_valid;
  wire        _valid_T_272 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h17;
  wire        valid_5_22 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h17 & ~io_writeMask_5_valid;
  wire [31:0] data_22 =
    (_valid_T_264 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_22 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_22 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_22 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_272 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_22 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_23_T =
    {_valid_T_264, valid_1_22, valid_2_22, valid_3_22, _valid_T_272, valid_5_22};
  wire        _valid_T_276 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h18;
  wire        valid_1_23 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h18 & ~io_writeMask_1_valid;
  wire        valid_2_23 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h18 & ~io_writeMask_2_valid;
  wire        valid_3_23 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h18 & ~io_writeMask_3_valid;
  wire        _valid_T_284 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h18;
  wire        valid_5_23 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h18 & ~io_writeMask_5_valid;
  wire [31:0] data_23 =
    (_valid_T_276 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_23 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_23 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_23 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_284 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_23 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_24_T =
    {_valid_T_276, valid_1_23, valid_2_23, valid_3_23, _valid_T_284, valid_5_23};
  wire        _valid_T_288 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h19;
  wire        valid_1_24 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h19 & ~io_writeMask_1_valid;
  wire        valid_2_24 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h19 & ~io_writeMask_2_valid;
  wire        valid_3_24 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h19 & ~io_writeMask_3_valid;
  wire        _valid_T_296 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h19;
  wire        valid_5_24 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h19 & ~io_writeMask_5_valid;
  wire [31:0] data_24 =
    (_valid_T_288 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_24 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_24 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_24 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_296 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_24 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_25_T =
    {_valid_T_288, valid_1_24, valid_2_24, valid_3_24, _valid_T_296, valid_5_24};
  wire        _valid_T_300 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1A;
  wire        valid_1_25 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1A & ~io_writeMask_1_valid;
  wire        valid_2_25 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1A & ~io_writeMask_2_valid;
  wire        valid_3_25 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1A & ~io_writeMask_3_valid;
  wire        _valid_T_308 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1A;
  wire        valid_5_25 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1A & ~io_writeMask_5_valid;
  wire [31:0] data_25 =
    (_valid_T_300 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_25 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_25 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_25 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_308 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_25 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_26_T =
    {_valid_T_300, valid_1_25, valid_2_25, valid_3_25, _valid_T_308, valid_5_25};
  wire        _valid_T_312 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1B;
  wire        valid_1_26 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1B & ~io_writeMask_1_valid;
  wire        valid_2_26 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1B & ~io_writeMask_2_valid;
  wire        valid_3_26 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1B & ~io_writeMask_3_valid;
  wire        _valid_T_320 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1B;
  wire        valid_5_26 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1B & ~io_writeMask_5_valid;
  wire [31:0] data_26 =
    (_valid_T_312 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_26 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_26 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_26 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_320 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_26 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_27_T =
    {_valid_T_312, valid_1_26, valid_2_26, valid_3_26, _valid_T_320, valid_5_26};
  wire        _valid_T_324 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1C;
  wire        valid_1_27 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1C & ~io_writeMask_1_valid;
  wire        valid_2_27 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1C & ~io_writeMask_2_valid;
  wire        valid_3_27 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1C & ~io_writeMask_3_valid;
  wire        _valid_T_332 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1C;
  wire        valid_5_27 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1C & ~io_writeMask_5_valid;
  wire [31:0] data_27 =
    (_valid_T_324 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_27 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_27 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_27 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_332 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_27 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_28_T =
    {_valid_T_324, valid_1_27, valid_2_27, valid_3_27, _valid_T_332, valid_5_27};
  wire        _valid_T_336 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1D;
  wire        valid_1_28 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1D & ~io_writeMask_1_valid;
  wire        valid_2_28 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1D & ~io_writeMask_2_valid;
  wire        valid_3_28 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1D & ~io_writeMask_3_valid;
  wire        _valid_T_344 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1D;
  wire        valid_5_28 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1D & ~io_writeMask_5_valid;
  wire [31:0] data_28 =
    (_valid_T_336 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_28 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_28 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_28 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_344 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_28 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_29_T =
    {_valid_T_336, valid_1_28, valid_2_28, valid_3_28, _valid_T_344, valid_5_28};
  wire        _valid_T_348 = io_writeData_0_valid & io_writeData_0_bits_addr == 5'h1E;
  wire        valid_1_29 =
    io_writeData_1_valid & io_writeData_1_bits_addr == 5'h1E & ~io_writeMask_1_valid;
  wire        valid_2_29 =
    io_writeData_2_valid & io_writeData_2_bits_addr == 5'h1E & ~io_writeMask_2_valid;
  wire        valid_3_29 =
    io_writeData_3_valid & io_writeData_3_bits_addr == 5'h1E & ~io_writeMask_3_valid;
  wire        _valid_T_356 = io_writeData_4_valid & io_writeData_4_bits_addr == 5'h1E;
  wire        valid_5_29 =
    io_writeData_5_valid & io_writeData_5_bits_addr == 5'h1E & ~io_writeMask_5_valid;
  wire [31:0] data_29 =
    (_valid_T_348 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_29 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_29 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_29 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_356 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_29 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_30_T =
    {_valid_T_348, valid_1_29, valid_2_29, valid_3_29, _valid_T_356, valid_5_29};
  wire        _valid_T_360 = io_writeData_0_valid & (&io_writeData_0_bits_addr);
  wire        valid_1_30 =
    io_writeData_1_valid & (&io_writeData_1_bits_addr) & ~io_writeMask_1_valid;
  wire        valid_2_30 =
    io_writeData_2_valid & (&io_writeData_2_bits_addr) & ~io_writeMask_2_valid;
  wire        valid_3_30 =
    io_writeData_3_valid & (&io_writeData_3_bits_addr) & ~io_writeMask_3_valid;
  wire        _valid_T_368 = io_writeData_4_valid & (&io_writeData_4_bits_addr);
  wire        valid_5_30 =
    io_writeData_5_valid & (&io_writeData_5_bits_addr) & ~io_writeMask_5_valid;
  wire [31:0] data_30 =
    (_valid_T_360 ? io_writeData_0_bits_data : 32'h0)
    | (valid_1_30 ? io_writeData_1_bits_data : 32'h0)
    | (valid_2_30 ? io_writeData_2_bits_data : 32'h0)
    | (valid_3_30 ? io_writeData_3_bits_data : 32'h0)
    | (_valid_T_368 ? io_writeData_4_bits_data : 32'h0)
    | (valid_5_30 ? io_writeData_5_bits_data : 32'h0);
  wire [5:0]  _writeValid_31_T =
    {_valid_T_360, valid_1_30, valid_2_30, valid_3_30, _valid_T_368, valid_5_30};
  wire        _wdata_0_value_1_T = io_readAddr_0_addr == 5'h1;
  wire        _wdata_0_value_2_T = io_readAddr_0_addr == 5'h2;
  wire        _wdata_0_value_3_T = io_readAddr_0_addr == 5'h3;
  wire        _wdata_0_value_4_T = io_readAddr_0_addr == 5'h4;
  wire        _wdata_0_value_5_T = io_readAddr_0_addr == 5'h5;
  wire        _wdata_0_value_6_T = io_readAddr_0_addr == 5'h6;
  wire        _wdata_0_value_7_T = io_readAddr_0_addr == 5'h7;
  wire        _wdata_0_value_8_T = io_readAddr_0_addr == 5'h8;
  wire        _wdata_0_value_9_T = io_readAddr_0_addr == 5'h9;
  wire        _wdata_0_value_10_T = io_readAddr_0_addr == 5'hA;
  wire        _wdata_0_value_11_T = io_readAddr_0_addr == 5'hB;
  wire        _wdata_0_value_12_T = io_readAddr_0_addr == 5'hC;
  wire        _wdata_0_value_13_T = io_readAddr_0_addr == 5'hD;
  wire        _wdata_0_value_14_T = io_readAddr_0_addr == 5'hE;
  wire        _wdata_0_value_15_T = io_readAddr_0_addr == 5'hF;
  wire        _wdata_0_value_16_T = io_readAddr_0_addr == 5'h10;
  wire        _wdata_0_value_17_T = io_readAddr_0_addr == 5'h11;
  wire        _wdata_0_value_18_T = io_readAddr_0_addr == 5'h12;
  wire        _wdata_0_value_19_T = io_readAddr_0_addr == 5'h13;
  wire        _wdata_0_value_20_T = io_readAddr_0_addr == 5'h14;
  wire        _wdata_0_value_21_T = io_readAddr_0_addr == 5'h15;
  wire        _wdata_0_value_22_T = io_readAddr_0_addr == 5'h16;
  wire        _wdata_0_value_23_T = io_readAddr_0_addr == 5'h17;
  wire        _wdata_0_value_24_T = io_readAddr_0_addr == 5'h18;
  wire        _wdata_0_value_25_T = io_readAddr_0_addr == 5'h19;
  wire        _wdata_0_value_26_T = io_readAddr_0_addr == 5'h1A;
  wire        _wdata_0_value_27_T = io_readAddr_0_addr == 5'h1B;
  wire        _wdata_0_value_28_T = io_readAddr_0_addr == 5'h1C;
  wire        _wdata_0_value_29_T = io_readAddr_0_addr == 5'h1D;
  wire        _wdata_0_value_30_T = io_readAddr_0_addr == 5'h1E;
  wire [31:0] rdata_0_value_5_0 =
    (_wdata_0_value_1_T ? regfile_1 : 32'h0) | (_wdata_0_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_0_value_3_T ? regfile_3 : 32'h0) | (_wdata_0_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_0_value_5_T ? regfile_5 : 32'h0) | (_wdata_0_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_0_value_7_T ? regfile_7 : 32'h0) | (_wdata_0_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_0_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_0_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_0_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_0_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_0_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_0_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_0_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_0_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_0_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_0_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_0_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_0_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_0_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_0_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_0_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_0_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_0_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_0_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_0_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_0_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_0_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_0_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_0_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_0 =
    io_readAddr_0_addr == 5'h0 | _wdata_0_value_1_T & (|_writeValid_1_T)
    | _wdata_0_value_2_T & (|_writeValid_2_T) | _wdata_0_value_3_T & (|_writeValid_3_T)
    | _wdata_0_value_4_T & (|_writeValid_4_T) | _wdata_0_value_5_T & (|_writeValid_5_T)
    | _wdata_0_value_6_T & (|_writeValid_6_T) | _wdata_0_value_7_T & (|_writeValid_7_T)
    | _wdata_0_value_8_T & (|_writeValid_8_T) | _wdata_0_value_9_T & (|_writeValid_9_T)
    | _wdata_0_value_10_T & (|_writeValid_10_T) | _wdata_0_value_11_T
    & (|_writeValid_11_T) | _wdata_0_value_12_T & (|_writeValid_12_T)
    | _wdata_0_value_13_T & (|_writeValid_13_T) | _wdata_0_value_14_T
    & (|_writeValid_14_T) | _wdata_0_value_15_T & (|_writeValid_15_T)
    | _wdata_0_value_16_T & (|_writeValid_16_T) | _wdata_0_value_17_T
    & (|_writeValid_17_T) | _wdata_0_value_18_T & (|_writeValid_18_T)
    | _wdata_0_value_19_T & (|_writeValid_19_T) | _wdata_0_value_20_T
    & (|_writeValid_20_T) | _wdata_0_value_21_T & (|_writeValid_21_T)
    | _wdata_0_value_22_T & (|_writeValid_22_T) | _wdata_0_value_23_T
    & (|_writeValid_23_T) | _wdata_0_value_24_T & (|_writeValid_24_T)
    | _wdata_0_value_25_T & (|_writeValid_25_T) | _wdata_0_value_26_T
    & (|_writeValid_26_T) | _wdata_0_value_27_T & (|_writeValid_27_T)
    | _wdata_0_value_28_T & (|_writeValid_28_T) | _wdata_0_value_29_T
    & (|_writeValid_29_T) | _wdata_0_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_0_addr) & (|_writeValid_31_T)
      ? (_wdata_0_value_1_T ? data : 32'h0) | (_wdata_0_value_2_T ? data_1 : 32'h0)
        | (_wdata_0_value_3_T ? data_2 : 32'h0) | (_wdata_0_value_4_T ? data_3 : 32'h0)
        | (_wdata_0_value_5_T ? data_4 : 32'h0) | (_wdata_0_value_6_T ? data_5 : 32'h0)
        | (_wdata_0_value_7_T ? data_6 : 32'h0) | (_wdata_0_value_8_T ? data_7 : 32'h0)
        | (_wdata_0_value_9_T ? data_8 : 32'h0) | (_wdata_0_value_10_T ? data_9 : 32'h0)
        | (_wdata_0_value_11_T ? data_10 : 32'h0)
        | (_wdata_0_value_12_T ? data_11 : 32'h0)
        | (_wdata_0_value_13_T ? data_12 : 32'h0)
        | (_wdata_0_value_14_T ? data_13 : 32'h0)
        | (_wdata_0_value_15_T ? data_14 : 32'h0)
        | (_wdata_0_value_16_T ? data_15 : 32'h0)
        | (_wdata_0_value_17_T ? data_16 : 32'h0)
        | (_wdata_0_value_18_T ? data_17 : 32'h0)
        | (_wdata_0_value_19_T ? data_18 : 32'h0)
        | (_wdata_0_value_20_T ? data_19 : 32'h0)
        | (_wdata_0_value_21_T ? data_20 : 32'h0)
        | (_wdata_0_value_22_T ? data_21 : 32'h0)
        | (_wdata_0_value_23_T ? data_22 : 32'h0)
        | (_wdata_0_value_24_T ? data_23 : 32'h0)
        | (_wdata_0_value_25_T ? data_24 : 32'h0)
        | (_wdata_0_value_26_T ? data_25 : 32'h0)
        | (_wdata_0_value_27_T ? data_26 : 32'h0)
        | (_wdata_0_value_28_T ? data_27 : 32'h0)
        | (_wdata_0_value_29_T ? data_28 : 32'h0)
        | (_wdata_0_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_0_addr) ? data_30 : 32'h0)
      : rdata_0_value_5_0;
  wire        _wdata_1_value_1_T = io_readAddr_1_addr == 5'h1;
  wire        _wdata_1_value_2_T = io_readAddr_1_addr == 5'h2;
  wire        _wdata_1_value_3_T = io_readAddr_1_addr == 5'h3;
  wire        _wdata_1_value_4_T = io_readAddr_1_addr == 5'h4;
  wire        _wdata_1_value_5_T = io_readAddr_1_addr == 5'h5;
  wire        _wdata_1_value_6_T = io_readAddr_1_addr == 5'h6;
  wire        _wdata_1_value_7_T = io_readAddr_1_addr == 5'h7;
  wire        _wdata_1_value_8_T = io_readAddr_1_addr == 5'h8;
  wire        _wdata_1_value_9_T = io_readAddr_1_addr == 5'h9;
  wire        _wdata_1_value_10_T = io_readAddr_1_addr == 5'hA;
  wire        _wdata_1_value_11_T = io_readAddr_1_addr == 5'hB;
  wire        _wdata_1_value_12_T = io_readAddr_1_addr == 5'hC;
  wire        _wdata_1_value_13_T = io_readAddr_1_addr == 5'hD;
  wire        _wdata_1_value_14_T = io_readAddr_1_addr == 5'hE;
  wire        _wdata_1_value_15_T = io_readAddr_1_addr == 5'hF;
  wire        _wdata_1_value_16_T = io_readAddr_1_addr == 5'h10;
  wire        _wdata_1_value_17_T = io_readAddr_1_addr == 5'h11;
  wire        _wdata_1_value_18_T = io_readAddr_1_addr == 5'h12;
  wire        _wdata_1_value_19_T = io_readAddr_1_addr == 5'h13;
  wire        _wdata_1_value_20_T = io_readAddr_1_addr == 5'h14;
  wire        _wdata_1_value_21_T = io_readAddr_1_addr == 5'h15;
  wire        _wdata_1_value_22_T = io_readAddr_1_addr == 5'h16;
  wire        _wdata_1_value_23_T = io_readAddr_1_addr == 5'h17;
  wire        _wdata_1_value_24_T = io_readAddr_1_addr == 5'h18;
  wire        _wdata_1_value_25_T = io_readAddr_1_addr == 5'h19;
  wire        _wdata_1_value_26_T = io_readAddr_1_addr == 5'h1A;
  wire        _wdata_1_value_27_T = io_readAddr_1_addr == 5'h1B;
  wire        _wdata_1_value_28_T = io_readAddr_1_addr == 5'h1C;
  wire        _wdata_1_value_29_T = io_readAddr_1_addr == 5'h1D;
  wire        _wdata_1_value_30_T = io_readAddr_1_addr == 5'h1E;
  wire [31:0] rwdata_1 =
    io_readAddr_1_addr == 5'h0 | _wdata_1_value_1_T & (|_writeValid_1_T)
    | _wdata_1_value_2_T & (|_writeValid_2_T) | _wdata_1_value_3_T & (|_writeValid_3_T)
    | _wdata_1_value_4_T & (|_writeValid_4_T) | _wdata_1_value_5_T & (|_writeValid_5_T)
    | _wdata_1_value_6_T & (|_writeValid_6_T) | _wdata_1_value_7_T & (|_writeValid_7_T)
    | _wdata_1_value_8_T & (|_writeValid_8_T) | _wdata_1_value_9_T & (|_writeValid_9_T)
    | _wdata_1_value_10_T & (|_writeValid_10_T) | _wdata_1_value_11_T
    & (|_writeValid_11_T) | _wdata_1_value_12_T & (|_writeValid_12_T)
    | _wdata_1_value_13_T & (|_writeValid_13_T) | _wdata_1_value_14_T
    & (|_writeValid_14_T) | _wdata_1_value_15_T & (|_writeValid_15_T)
    | _wdata_1_value_16_T & (|_writeValid_16_T) | _wdata_1_value_17_T
    & (|_writeValid_17_T) | _wdata_1_value_18_T & (|_writeValid_18_T)
    | _wdata_1_value_19_T & (|_writeValid_19_T) | _wdata_1_value_20_T
    & (|_writeValid_20_T) | _wdata_1_value_21_T & (|_writeValid_21_T)
    | _wdata_1_value_22_T & (|_writeValid_22_T) | _wdata_1_value_23_T
    & (|_writeValid_23_T) | _wdata_1_value_24_T & (|_writeValid_24_T)
    | _wdata_1_value_25_T & (|_writeValid_25_T) | _wdata_1_value_26_T
    & (|_writeValid_26_T) | _wdata_1_value_27_T & (|_writeValid_27_T)
    | _wdata_1_value_28_T & (|_writeValid_28_T) | _wdata_1_value_29_T
    & (|_writeValid_29_T) | _wdata_1_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_1_addr) & (|_writeValid_31_T)
      ? (_wdata_1_value_1_T ? data : 32'h0) | (_wdata_1_value_2_T ? data_1 : 32'h0)
        | (_wdata_1_value_3_T ? data_2 : 32'h0) | (_wdata_1_value_4_T ? data_3 : 32'h0)
        | (_wdata_1_value_5_T ? data_4 : 32'h0) | (_wdata_1_value_6_T ? data_5 : 32'h0)
        | (_wdata_1_value_7_T ? data_6 : 32'h0) | (_wdata_1_value_8_T ? data_7 : 32'h0)
        | (_wdata_1_value_9_T ? data_8 : 32'h0) | (_wdata_1_value_10_T ? data_9 : 32'h0)
        | (_wdata_1_value_11_T ? data_10 : 32'h0)
        | (_wdata_1_value_12_T ? data_11 : 32'h0)
        | (_wdata_1_value_13_T ? data_12 : 32'h0)
        | (_wdata_1_value_14_T ? data_13 : 32'h0)
        | (_wdata_1_value_15_T ? data_14 : 32'h0)
        | (_wdata_1_value_16_T ? data_15 : 32'h0)
        | (_wdata_1_value_17_T ? data_16 : 32'h0)
        | (_wdata_1_value_18_T ? data_17 : 32'h0)
        | (_wdata_1_value_19_T ? data_18 : 32'h0)
        | (_wdata_1_value_20_T ? data_19 : 32'h0)
        | (_wdata_1_value_21_T ? data_20 : 32'h0)
        | (_wdata_1_value_22_T ? data_21 : 32'h0)
        | (_wdata_1_value_23_T ? data_22 : 32'h0)
        | (_wdata_1_value_24_T ? data_23 : 32'h0)
        | (_wdata_1_value_25_T ? data_24 : 32'h0)
        | (_wdata_1_value_26_T ? data_25 : 32'h0)
        | (_wdata_1_value_27_T ? data_26 : 32'h0)
        | (_wdata_1_value_28_T ? data_27 : 32'h0)
        | (_wdata_1_value_29_T ? data_28 : 32'h0)
        | (_wdata_1_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_1_addr) ? data_30 : 32'h0)
      : (_wdata_1_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_1_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_1_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_1_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_1_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_1_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_1_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_1_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_1_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_1_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_1_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_1_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_1_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_1_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_1_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_1_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_1_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_1_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_1_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_1_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_1_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_1_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_1_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_1_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_1_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_1_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_1_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_1_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_1_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_1_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_1_addr) ? regfile_31 : 32'h0);
  wire        _wdata_2_value_1_T = io_readAddr_2_addr == 5'h1;
  wire        _wdata_2_value_2_T = io_readAddr_2_addr == 5'h2;
  wire        _wdata_2_value_3_T = io_readAddr_2_addr == 5'h3;
  wire        _wdata_2_value_4_T = io_readAddr_2_addr == 5'h4;
  wire        _wdata_2_value_5_T = io_readAddr_2_addr == 5'h5;
  wire        _wdata_2_value_6_T = io_readAddr_2_addr == 5'h6;
  wire        _wdata_2_value_7_T = io_readAddr_2_addr == 5'h7;
  wire        _wdata_2_value_8_T = io_readAddr_2_addr == 5'h8;
  wire        _wdata_2_value_9_T = io_readAddr_2_addr == 5'h9;
  wire        _wdata_2_value_10_T = io_readAddr_2_addr == 5'hA;
  wire        _wdata_2_value_11_T = io_readAddr_2_addr == 5'hB;
  wire        _wdata_2_value_12_T = io_readAddr_2_addr == 5'hC;
  wire        _wdata_2_value_13_T = io_readAddr_2_addr == 5'hD;
  wire        _wdata_2_value_14_T = io_readAddr_2_addr == 5'hE;
  wire        _wdata_2_value_15_T = io_readAddr_2_addr == 5'hF;
  wire        _wdata_2_value_16_T = io_readAddr_2_addr == 5'h10;
  wire        _wdata_2_value_17_T = io_readAddr_2_addr == 5'h11;
  wire        _wdata_2_value_18_T = io_readAddr_2_addr == 5'h12;
  wire        _wdata_2_value_19_T = io_readAddr_2_addr == 5'h13;
  wire        _wdata_2_value_20_T = io_readAddr_2_addr == 5'h14;
  wire        _wdata_2_value_21_T = io_readAddr_2_addr == 5'h15;
  wire        _wdata_2_value_22_T = io_readAddr_2_addr == 5'h16;
  wire        _wdata_2_value_23_T = io_readAddr_2_addr == 5'h17;
  wire        _wdata_2_value_24_T = io_readAddr_2_addr == 5'h18;
  wire        _wdata_2_value_25_T = io_readAddr_2_addr == 5'h19;
  wire        _wdata_2_value_26_T = io_readAddr_2_addr == 5'h1A;
  wire        _wdata_2_value_27_T = io_readAddr_2_addr == 5'h1B;
  wire        _wdata_2_value_28_T = io_readAddr_2_addr == 5'h1C;
  wire        _wdata_2_value_29_T = io_readAddr_2_addr == 5'h1D;
  wire        _wdata_2_value_30_T = io_readAddr_2_addr == 5'h1E;
  wire [31:0] rdata_2_value_5_0 =
    (_wdata_2_value_1_T ? regfile_1 : 32'h0) | (_wdata_2_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_2_value_3_T ? regfile_3 : 32'h0) | (_wdata_2_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_2_value_5_T ? regfile_5 : 32'h0) | (_wdata_2_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_2_value_7_T ? regfile_7 : 32'h0) | (_wdata_2_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_2_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_2_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_2_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_2_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_2_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_2_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_2_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_2_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_2_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_2_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_2_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_2_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_2_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_2_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_2_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_2_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_2_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_2_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_2_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_2_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_2_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_2_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_2_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_2 =
    io_readAddr_2_addr == 5'h0 | _wdata_2_value_1_T & (|_writeValid_1_T)
    | _wdata_2_value_2_T & (|_writeValid_2_T) | _wdata_2_value_3_T & (|_writeValid_3_T)
    | _wdata_2_value_4_T & (|_writeValid_4_T) | _wdata_2_value_5_T & (|_writeValid_5_T)
    | _wdata_2_value_6_T & (|_writeValid_6_T) | _wdata_2_value_7_T & (|_writeValid_7_T)
    | _wdata_2_value_8_T & (|_writeValid_8_T) | _wdata_2_value_9_T & (|_writeValid_9_T)
    | _wdata_2_value_10_T & (|_writeValid_10_T) | _wdata_2_value_11_T
    & (|_writeValid_11_T) | _wdata_2_value_12_T & (|_writeValid_12_T)
    | _wdata_2_value_13_T & (|_writeValid_13_T) | _wdata_2_value_14_T
    & (|_writeValid_14_T) | _wdata_2_value_15_T & (|_writeValid_15_T)
    | _wdata_2_value_16_T & (|_writeValid_16_T) | _wdata_2_value_17_T
    & (|_writeValid_17_T) | _wdata_2_value_18_T & (|_writeValid_18_T)
    | _wdata_2_value_19_T & (|_writeValid_19_T) | _wdata_2_value_20_T
    & (|_writeValid_20_T) | _wdata_2_value_21_T & (|_writeValid_21_T)
    | _wdata_2_value_22_T & (|_writeValid_22_T) | _wdata_2_value_23_T
    & (|_writeValid_23_T) | _wdata_2_value_24_T & (|_writeValid_24_T)
    | _wdata_2_value_25_T & (|_writeValid_25_T) | _wdata_2_value_26_T
    & (|_writeValid_26_T) | _wdata_2_value_27_T & (|_writeValid_27_T)
    | _wdata_2_value_28_T & (|_writeValid_28_T) | _wdata_2_value_29_T
    & (|_writeValid_29_T) | _wdata_2_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_2_addr) & (|_writeValid_31_T)
      ? (_wdata_2_value_1_T ? data : 32'h0) | (_wdata_2_value_2_T ? data_1 : 32'h0)
        | (_wdata_2_value_3_T ? data_2 : 32'h0) | (_wdata_2_value_4_T ? data_3 : 32'h0)
        | (_wdata_2_value_5_T ? data_4 : 32'h0) | (_wdata_2_value_6_T ? data_5 : 32'h0)
        | (_wdata_2_value_7_T ? data_6 : 32'h0) | (_wdata_2_value_8_T ? data_7 : 32'h0)
        | (_wdata_2_value_9_T ? data_8 : 32'h0) | (_wdata_2_value_10_T ? data_9 : 32'h0)
        | (_wdata_2_value_11_T ? data_10 : 32'h0)
        | (_wdata_2_value_12_T ? data_11 : 32'h0)
        | (_wdata_2_value_13_T ? data_12 : 32'h0)
        | (_wdata_2_value_14_T ? data_13 : 32'h0)
        | (_wdata_2_value_15_T ? data_14 : 32'h0)
        | (_wdata_2_value_16_T ? data_15 : 32'h0)
        | (_wdata_2_value_17_T ? data_16 : 32'h0)
        | (_wdata_2_value_18_T ? data_17 : 32'h0)
        | (_wdata_2_value_19_T ? data_18 : 32'h0)
        | (_wdata_2_value_20_T ? data_19 : 32'h0)
        | (_wdata_2_value_21_T ? data_20 : 32'h0)
        | (_wdata_2_value_22_T ? data_21 : 32'h0)
        | (_wdata_2_value_23_T ? data_22 : 32'h0)
        | (_wdata_2_value_24_T ? data_23 : 32'h0)
        | (_wdata_2_value_25_T ? data_24 : 32'h0)
        | (_wdata_2_value_26_T ? data_25 : 32'h0)
        | (_wdata_2_value_27_T ? data_26 : 32'h0)
        | (_wdata_2_value_28_T ? data_27 : 32'h0)
        | (_wdata_2_value_29_T ? data_28 : 32'h0)
        | (_wdata_2_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_2_addr) ? data_30 : 32'h0)
      : rdata_2_value_5_0;
  wire        _wdata_3_value_1_T = io_readAddr_3_addr == 5'h1;
  wire        _wdata_3_value_2_T = io_readAddr_3_addr == 5'h2;
  wire        _wdata_3_value_3_T = io_readAddr_3_addr == 5'h3;
  wire        _wdata_3_value_4_T = io_readAddr_3_addr == 5'h4;
  wire        _wdata_3_value_5_T = io_readAddr_3_addr == 5'h5;
  wire        _wdata_3_value_6_T = io_readAddr_3_addr == 5'h6;
  wire        _wdata_3_value_7_T = io_readAddr_3_addr == 5'h7;
  wire        _wdata_3_value_8_T = io_readAddr_3_addr == 5'h8;
  wire        _wdata_3_value_9_T = io_readAddr_3_addr == 5'h9;
  wire        _wdata_3_value_10_T = io_readAddr_3_addr == 5'hA;
  wire        _wdata_3_value_11_T = io_readAddr_3_addr == 5'hB;
  wire        _wdata_3_value_12_T = io_readAddr_3_addr == 5'hC;
  wire        _wdata_3_value_13_T = io_readAddr_3_addr == 5'hD;
  wire        _wdata_3_value_14_T = io_readAddr_3_addr == 5'hE;
  wire        _wdata_3_value_15_T = io_readAddr_3_addr == 5'hF;
  wire        _wdata_3_value_16_T = io_readAddr_3_addr == 5'h10;
  wire        _wdata_3_value_17_T = io_readAddr_3_addr == 5'h11;
  wire        _wdata_3_value_18_T = io_readAddr_3_addr == 5'h12;
  wire        _wdata_3_value_19_T = io_readAddr_3_addr == 5'h13;
  wire        _wdata_3_value_20_T = io_readAddr_3_addr == 5'h14;
  wire        _wdata_3_value_21_T = io_readAddr_3_addr == 5'h15;
  wire        _wdata_3_value_22_T = io_readAddr_3_addr == 5'h16;
  wire        _wdata_3_value_23_T = io_readAddr_3_addr == 5'h17;
  wire        _wdata_3_value_24_T = io_readAddr_3_addr == 5'h18;
  wire        _wdata_3_value_25_T = io_readAddr_3_addr == 5'h19;
  wire        _wdata_3_value_26_T = io_readAddr_3_addr == 5'h1A;
  wire        _wdata_3_value_27_T = io_readAddr_3_addr == 5'h1B;
  wire        _wdata_3_value_28_T = io_readAddr_3_addr == 5'h1C;
  wire        _wdata_3_value_29_T = io_readAddr_3_addr == 5'h1D;
  wire        _wdata_3_value_30_T = io_readAddr_3_addr == 5'h1E;
  wire [31:0] rwdata_3 =
    io_readAddr_3_addr == 5'h0 | _wdata_3_value_1_T & (|_writeValid_1_T)
    | _wdata_3_value_2_T & (|_writeValid_2_T) | _wdata_3_value_3_T & (|_writeValid_3_T)
    | _wdata_3_value_4_T & (|_writeValid_4_T) | _wdata_3_value_5_T & (|_writeValid_5_T)
    | _wdata_3_value_6_T & (|_writeValid_6_T) | _wdata_3_value_7_T & (|_writeValid_7_T)
    | _wdata_3_value_8_T & (|_writeValid_8_T) | _wdata_3_value_9_T & (|_writeValid_9_T)
    | _wdata_3_value_10_T & (|_writeValid_10_T) | _wdata_3_value_11_T
    & (|_writeValid_11_T) | _wdata_3_value_12_T & (|_writeValid_12_T)
    | _wdata_3_value_13_T & (|_writeValid_13_T) | _wdata_3_value_14_T
    & (|_writeValid_14_T) | _wdata_3_value_15_T & (|_writeValid_15_T)
    | _wdata_3_value_16_T & (|_writeValid_16_T) | _wdata_3_value_17_T
    & (|_writeValid_17_T) | _wdata_3_value_18_T & (|_writeValid_18_T)
    | _wdata_3_value_19_T & (|_writeValid_19_T) | _wdata_3_value_20_T
    & (|_writeValid_20_T) | _wdata_3_value_21_T & (|_writeValid_21_T)
    | _wdata_3_value_22_T & (|_writeValid_22_T) | _wdata_3_value_23_T
    & (|_writeValid_23_T) | _wdata_3_value_24_T & (|_writeValid_24_T)
    | _wdata_3_value_25_T & (|_writeValid_25_T) | _wdata_3_value_26_T
    & (|_writeValid_26_T) | _wdata_3_value_27_T & (|_writeValid_27_T)
    | _wdata_3_value_28_T & (|_writeValid_28_T) | _wdata_3_value_29_T
    & (|_writeValid_29_T) | _wdata_3_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_3_addr) & (|_writeValid_31_T)
      ? (_wdata_3_value_1_T ? data : 32'h0) | (_wdata_3_value_2_T ? data_1 : 32'h0)
        | (_wdata_3_value_3_T ? data_2 : 32'h0) | (_wdata_3_value_4_T ? data_3 : 32'h0)
        | (_wdata_3_value_5_T ? data_4 : 32'h0) | (_wdata_3_value_6_T ? data_5 : 32'h0)
        | (_wdata_3_value_7_T ? data_6 : 32'h0) | (_wdata_3_value_8_T ? data_7 : 32'h0)
        | (_wdata_3_value_9_T ? data_8 : 32'h0) | (_wdata_3_value_10_T ? data_9 : 32'h0)
        | (_wdata_3_value_11_T ? data_10 : 32'h0)
        | (_wdata_3_value_12_T ? data_11 : 32'h0)
        | (_wdata_3_value_13_T ? data_12 : 32'h0)
        | (_wdata_3_value_14_T ? data_13 : 32'h0)
        | (_wdata_3_value_15_T ? data_14 : 32'h0)
        | (_wdata_3_value_16_T ? data_15 : 32'h0)
        | (_wdata_3_value_17_T ? data_16 : 32'h0)
        | (_wdata_3_value_18_T ? data_17 : 32'h0)
        | (_wdata_3_value_19_T ? data_18 : 32'h0)
        | (_wdata_3_value_20_T ? data_19 : 32'h0)
        | (_wdata_3_value_21_T ? data_20 : 32'h0)
        | (_wdata_3_value_22_T ? data_21 : 32'h0)
        | (_wdata_3_value_23_T ? data_22 : 32'h0)
        | (_wdata_3_value_24_T ? data_23 : 32'h0)
        | (_wdata_3_value_25_T ? data_24 : 32'h0)
        | (_wdata_3_value_26_T ? data_25 : 32'h0)
        | (_wdata_3_value_27_T ? data_26 : 32'h0)
        | (_wdata_3_value_28_T ? data_27 : 32'h0)
        | (_wdata_3_value_29_T ? data_28 : 32'h0)
        | (_wdata_3_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_3_addr) ? data_30 : 32'h0)
      : (_wdata_3_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_3_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_3_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_3_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_3_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_3_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_3_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_3_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_3_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_3_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_3_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_3_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_3_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_3_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_3_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_3_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_3_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_3_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_3_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_3_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_3_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_3_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_3_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_3_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_3_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_3_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_3_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_3_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_3_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_3_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_3_addr) ? regfile_31 : 32'h0);
  wire        _wdata_4_value_1_T = io_readAddr_4_addr == 5'h1;
  wire        _wdata_4_value_2_T = io_readAddr_4_addr == 5'h2;
  wire        _wdata_4_value_3_T = io_readAddr_4_addr == 5'h3;
  wire        _wdata_4_value_4_T = io_readAddr_4_addr == 5'h4;
  wire        _wdata_4_value_5_T = io_readAddr_4_addr == 5'h5;
  wire        _wdata_4_value_6_T = io_readAddr_4_addr == 5'h6;
  wire        _wdata_4_value_7_T = io_readAddr_4_addr == 5'h7;
  wire        _wdata_4_value_8_T = io_readAddr_4_addr == 5'h8;
  wire        _wdata_4_value_9_T = io_readAddr_4_addr == 5'h9;
  wire        _wdata_4_value_10_T = io_readAddr_4_addr == 5'hA;
  wire        _wdata_4_value_11_T = io_readAddr_4_addr == 5'hB;
  wire        _wdata_4_value_12_T = io_readAddr_4_addr == 5'hC;
  wire        _wdata_4_value_13_T = io_readAddr_4_addr == 5'hD;
  wire        _wdata_4_value_14_T = io_readAddr_4_addr == 5'hE;
  wire        _wdata_4_value_15_T = io_readAddr_4_addr == 5'hF;
  wire        _wdata_4_value_16_T = io_readAddr_4_addr == 5'h10;
  wire        _wdata_4_value_17_T = io_readAddr_4_addr == 5'h11;
  wire        _wdata_4_value_18_T = io_readAddr_4_addr == 5'h12;
  wire        _wdata_4_value_19_T = io_readAddr_4_addr == 5'h13;
  wire        _wdata_4_value_20_T = io_readAddr_4_addr == 5'h14;
  wire        _wdata_4_value_21_T = io_readAddr_4_addr == 5'h15;
  wire        _wdata_4_value_22_T = io_readAddr_4_addr == 5'h16;
  wire        _wdata_4_value_23_T = io_readAddr_4_addr == 5'h17;
  wire        _wdata_4_value_24_T = io_readAddr_4_addr == 5'h18;
  wire        _wdata_4_value_25_T = io_readAddr_4_addr == 5'h19;
  wire        _wdata_4_value_26_T = io_readAddr_4_addr == 5'h1A;
  wire        _wdata_4_value_27_T = io_readAddr_4_addr == 5'h1B;
  wire        _wdata_4_value_28_T = io_readAddr_4_addr == 5'h1C;
  wire        _wdata_4_value_29_T = io_readAddr_4_addr == 5'h1D;
  wire        _wdata_4_value_30_T = io_readAddr_4_addr == 5'h1E;
  wire [31:0] rdata_4_value_5_0 =
    (_wdata_4_value_1_T ? regfile_1 : 32'h0) | (_wdata_4_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_4_value_3_T ? regfile_3 : 32'h0) | (_wdata_4_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_4_value_5_T ? regfile_5 : 32'h0) | (_wdata_4_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_4_value_7_T ? regfile_7 : 32'h0) | (_wdata_4_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_4_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_4_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_4_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_4_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_4_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_4_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_4_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_4_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_4_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_4_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_4_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_4_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_4_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_4_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_4_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_4_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_4_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_4_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_4_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_4_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_4_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_4_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_4_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_4 =
    io_readAddr_4_addr == 5'h0 | _wdata_4_value_1_T & (|_writeValid_1_T)
    | _wdata_4_value_2_T & (|_writeValid_2_T) | _wdata_4_value_3_T & (|_writeValid_3_T)
    | _wdata_4_value_4_T & (|_writeValid_4_T) | _wdata_4_value_5_T & (|_writeValid_5_T)
    | _wdata_4_value_6_T & (|_writeValid_6_T) | _wdata_4_value_7_T & (|_writeValid_7_T)
    | _wdata_4_value_8_T & (|_writeValid_8_T) | _wdata_4_value_9_T & (|_writeValid_9_T)
    | _wdata_4_value_10_T & (|_writeValid_10_T) | _wdata_4_value_11_T
    & (|_writeValid_11_T) | _wdata_4_value_12_T & (|_writeValid_12_T)
    | _wdata_4_value_13_T & (|_writeValid_13_T) | _wdata_4_value_14_T
    & (|_writeValid_14_T) | _wdata_4_value_15_T & (|_writeValid_15_T)
    | _wdata_4_value_16_T & (|_writeValid_16_T) | _wdata_4_value_17_T
    & (|_writeValid_17_T) | _wdata_4_value_18_T & (|_writeValid_18_T)
    | _wdata_4_value_19_T & (|_writeValid_19_T) | _wdata_4_value_20_T
    & (|_writeValid_20_T) | _wdata_4_value_21_T & (|_writeValid_21_T)
    | _wdata_4_value_22_T & (|_writeValid_22_T) | _wdata_4_value_23_T
    & (|_writeValid_23_T) | _wdata_4_value_24_T & (|_writeValid_24_T)
    | _wdata_4_value_25_T & (|_writeValid_25_T) | _wdata_4_value_26_T
    & (|_writeValid_26_T) | _wdata_4_value_27_T & (|_writeValid_27_T)
    | _wdata_4_value_28_T & (|_writeValid_28_T) | _wdata_4_value_29_T
    & (|_writeValid_29_T) | _wdata_4_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_4_addr) & (|_writeValid_31_T)
      ? (_wdata_4_value_1_T ? data : 32'h0) | (_wdata_4_value_2_T ? data_1 : 32'h0)
        | (_wdata_4_value_3_T ? data_2 : 32'h0) | (_wdata_4_value_4_T ? data_3 : 32'h0)
        | (_wdata_4_value_5_T ? data_4 : 32'h0) | (_wdata_4_value_6_T ? data_5 : 32'h0)
        | (_wdata_4_value_7_T ? data_6 : 32'h0) | (_wdata_4_value_8_T ? data_7 : 32'h0)
        | (_wdata_4_value_9_T ? data_8 : 32'h0) | (_wdata_4_value_10_T ? data_9 : 32'h0)
        | (_wdata_4_value_11_T ? data_10 : 32'h0)
        | (_wdata_4_value_12_T ? data_11 : 32'h0)
        | (_wdata_4_value_13_T ? data_12 : 32'h0)
        | (_wdata_4_value_14_T ? data_13 : 32'h0)
        | (_wdata_4_value_15_T ? data_14 : 32'h0)
        | (_wdata_4_value_16_T ? data_15 : 32'h0)
        | (_wdata_4_value_17_T ? data_16 : 32'h0)
        | (_wdata_4_value_18_T ? data_17 : 32'h0)
        | (_wdata_4_value_19_T ? data_18 : 32'h0)
        | (_wdata_4_value_20_T ? data_19 : 32'h0)
        | (_wdata_4_value_21_T ? data_20 : 32'h0)
        | (_wdata_4_value_22_T ? data_21 : 32'h0)
        | (_wdata_4_value_23_T ? data_22 : 32'h0)
        | (_wdata_4_value_24_T ? data_23 : 32'h0)
        | (_wdata_4_value_25_T ? data_24 : 32'h0)
        | (_wdata_4_value_26_T ? data_25 : 32'h0)
        | (_wdata_4_value_27_T ? data_26 : 32'h0)
        | (_wdata_4_value_28_T ? data_27 : 32'h0)
        | (_wdata_4_value_29_T ? data_28 : 32'h0)
        | (_wdata_4_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_4_addr) ? data_30 : 32'h0)
      : rdata_4_value_5_0;
  wire        _wdata_5_value_1_T = io_readAddr_5_addr == 5'h1;
  wire        _wdata_5_value_2_T = io_readAddr_5_addr == 5'h2;
  wire        _wdata_5_value_3_T = io_readAddr_5_addr == 5'h3;
  wire        _wdata_5_value_4_T = io_readAddr_5_addr == 5'h4;
  wire        _wdata_5_value_5_T = io_readAddr_5_addr == 5'h5;
  wire        _wdata_5_value_6_T = io_readAddr_5_addr == 5'h6;
  wire        _wdata_5_value_7_T = io_readAddr_5_addr == 5'h7;
  wire        _wdata_5_value_8_T = io_readAddr_5_addr == 5'h8;
  wire        _wdata_5_value_9_T = io_readAddr_5_addr == 5'h9;
  wire        _wdata_5_value_10_T = io_readAddr_5_addr == 5'hA;
  wire        _wdata_5_value_11_T = io_readAddr_5_addr == 5'hB;
  wire        _wdata_5_value_12_T = io_readAddr_5_addr == 5'hC;
  wire        _wdata_5_value_13_T = io_readAddr_5_addr == 5'hD;
  wire        _wdata_5_value_14_T = io_readAddr_5_addr == 5'hE;
  wire        _wdata_5_value_15_T = io_readAddr_5_addr == 5'hF;
  wire        _wdata_5_value_16_T = io_readAddr_5_addr == 5'h10;
  wire        _wdata_5_value_17_T = io_readAddr_5_addr == 5'h11;
  wire        _wdata_5_value_18_T = io_readAddr_5_addr == 5'h12;
  wire        _wdata_5_value_19_T = io_readAddr_5_addr == 5'h13;
  wire        _wdata_5_value_20_T = io_readAddr_5_addr == 5'h14;
  wire        _wdata_5_value_21_T = io_readAddr_5_addr == 5'h15;
  wire        _wdata_5_value_22_T = io_readAddr_5_addr == 5'h16;
  wire        _wdata_5_value_23_T = io_readAddr_5_addr == 5'h17;
  wire        _wdata_5_value_24_T = io_readAddr_5_addr == 5'h18;
  wire        _wdata_5_value_25_T = io_readAddr_5_addr == 5'h19;
  wire        _wdata_5_value_26_T = io_readAddr_5_addr == 5'h1A;
  wire        _wdata_5_value_27_T = io_readAddr_5_addr == 5'h1B;
  wire        _wdata_5_value_28_T = io_readAddr_5_addr == 5'h1C;
  wire        _wdata_5_value_29_T = io_readAddr_5_addr == 5'h1D;
  wire        _wdata_5_value_30_T = io_readAddr_5_addr == 5'h1E;
  wire [31:0] rwdata_5 =
    io_readAddr_5_addr == 5'h0 | _wdata_5_value_1_T & (|_writeValid_1_T)
    | _wdata_5_value_2_T & (|_writeValid_2_T) | _wdata_5_value_3_T & (|_writeValid_3_T)
    | _wdata_5_value_4_T & (|_writeValid_4_T) | _wdata_5_value_5_T & (|_writeValid_5_T)
    | _wdata_5_value_6_T & (|_writeValid_6_T) | _wdata_5_value_7_T & (|_writeValid_7_T)
    | _wdata_5_value_8_T & (|_writeValid_8_T) | _wdata_5_value_9_T & (|_writeValid_9_T)
    | _wdata_5_value_10_T & (|_writeValid_10_T) | _wdata_5_value_11_T
    & (|_writeValid_11_T) | _wdata_5_value_12_T & (|_writeValid_12_T)
    | _wdata_5_value_13_T & (|_writeValid_13_T) | _wdata_5_value_14_T
    & (|_writeValid_14_T) | _wdata_5_value_15_T & (|_writeValid_15_T)
    | _wdata_5_value_16_T & (|_writeValid_16_T) | _wdata_5_value_17_T
    & (|_writeValid_17_T) | _wdata_5_value_18_T & (|_writeValid_18_T)
    | _wdata_5_value_19_T & (|_writeValid_19_T) | _wdata_5_value_20_T
    & (|_writeValid_20_T) | _wdata_5_value_21_T & (|_writeValid_21_T)
    | _wdata_5_value_22_T & (|_writeValid_22_T) | _wdata_5_value_23_T
    & (|_writeValid_23_T) | _wdata_5_value_24_T & (|_writeValid_24_T)
    | _wdata_5_value_25_T & (|_writeValid_25_T) | _wdata_5_value_26_T
    & (|_writeValid_26_T) | _wdata_5_value_27_T & (|_writeValid_27_T)
    | _wdata_5_value_28_T & (|_writeValid_28_T) | _wdata_5_value_29_T
    & (|_writeValid_29_T) | _wdata_5_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_5_addr) & (|_writeValid_31_T)
      ? (_wdata_5_value_1_T ? data : 32'h0) | (_wdata_5_value_2_T ? data_1 : 32'h0)
        | (_wdata_5_value_3_T ? data_2 : 32'h0) | (_wdata_5_value_4_T ? data_3 : 32'h0)
        | (_wdata_5_value_5_T ? data_4 : 32'h0) | (_wdata_5_value_6_T ? data_5 : 32'h0)
        | (_wdata_5_value_7_T ? data_6 : 32'h0) | (_wdata_5_value_8_T ? data_7 : 32'h0)
        | (_wdata_5_value_9_T ? data_8 : 32'h0) | (_wdata_5_value_10_T ? data_9 : 32'h0)
        | (_wdata_5_value_11_T ? data_10 : 32'h0)
        | (_wdata_5_value_12_T ? data_11 : 32'h0)
        | (_wdata_5_value_13_T ? data_12 : 32'h0)
        | (_wdata_5_value_14_T ? data_13 : 32'h0)
        | (_wdata_5_value_15_T ? data_14 : 32'h0)
        | (_wdata_5_value_16_T ? data_15 : 32'h0)
        | (_wdata_5_value_17_T ? data_16 : 32'h0)
        | (_wdata_5_value_18_T ? data_17 : 32'h0)
        | (_wdata_5_value_19_T ? data_18 : 32'h0)
        | (_wdata_5_value_20_T ? data_19 : 32'h0)
        | (_wdata_5_value_21_T ? data_20 : 32'h0)
        | (_wdata_5_value_22_T ? data_21 : 32'h0)
        | (_wdata_5_value_23_T ? data_22 : 32'h0)
        | (_wdata_5_value_24_T ? data_23 : 32'h0)
        | (_wdata_5_value_25_T ? data_24 : 32'h0)
        | (_wdata_5_value_26_T ? data_25 : 32'h0)
        | (_wdata_5_value_27_T ? data_26 : 32'h0)
        | (_wdata_5_value_28_T ? data_27 : 32'h0)
        | (_wdata_5_value_29_T ? data_28 : 32'h0)
        | (_wdata_5_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_5_addr) ? data_30 : 32'h0)
      : (_wdata_5_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_5_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_5_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_5_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_5_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_5_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_5_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_5_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_5_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_5_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_5_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_5_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_5_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_5_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_5_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_5_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_5_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_5_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_5_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_5_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_5_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_5_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_5_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_5_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_5_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_5_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_5_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_5_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_5_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_5_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_5_addr) ? regfile_31 : 32'h0);
  wire        _wdata_6_value_1_T = io_readAddr_6_addr == 5'h1;
  wire        _wdata_6_value_2_T = io_readAddr_6_addr == 5'h2;
  wire        _wdata_6_value_3_T = io_readAddr_6_addr == 5'h3;
  wire        _wdata_6_value_4_T = io_readAddr_6_addr == 5'h4;
  wire        _wdata_6_value_5_T = io_readAddr_6_addr == 5'h5;
  wire        _wdata_6_value_6_T = io_readAddr_6_addr == 5'h6;
  wire        _wdata_6_value_7_T = io_readAddr_6_addr == 5'h7;
  wire        _wdata_6_value_8_T = io_readAddr_6_addr == 5'h8;
  wire        _wdata_6_value_9_T = io_readAddr_6_addr == 5'h9;
  wire        _wdata_6_value_10_T = io_readAddr_6_addr == 5'hA;
  wire        _wdata_6_value_11_T = io_readAddr_6_addr == 5'hB;
  wire        _wdata_6_value_12_T = io_readAddr_6_addr == 5'hC;
  wire        _wdata_6_value_13_T = io_readAddr_6_addr == 5'hD;
  wire        _wdata_6_value_14_T = io_readAddr_6_addr == 5'hE;
  wire        _wdata_6_value_15_T = io_readAddr_6_addr == 5'hF;
  wire        _wdata_6_value_16_T = io_readAddr_6_addr == 5'h10;
  wire        _wdata_6_value_17_T = io_readAddr_6_addr == 5'h11;
  wire        _wdata_6_value_18_T = io_readAddr_6_addr == 5'h12;
  wire        _wdata_6_value_19_T = io_readAddr_6_addr == 5'h13;
  wire        _wdata_6_value_20_T = io_readAddr_6_addr == 5'h14;
  wire        _wdata_6_value_21_T = io_readAddr_6_addr == 5'h15;
  wire        _wdata_6_value_22_T = io_readAddr_6_addr == 5'h16;
  wire        _wdata_6_value_23_T = io_readAddr_6_addr == 5'h17;
  wire        _wdata_6_value_24_T = io_readAddr_6_addr == 5'h18;
  wire        _wdata_6_value_25_T = io_readAddr_6_addr == 5'h19;
  wire        _wdata_6_value_26_T = io_readAddr_6_addr == 5'h1A;
  wire        _wdata_6_value_27_T = io_readAddr_6_addr == 5'h1B;
  wire        _wdata_6_value_28_T = io_readAddr_6_addr == 5'h1C;
  wire        _wdata_6_value_29_T = io_readAddr_6_addr == 5'h1D;
  wire        _wdata_6_value_30_T = io_readAddr_6_addr == 5'h1E;
  wire [31:0] rdata_6_value_5_0 =
    (_wdata_6_value_1_T ? regfile_1 : 32'h0) | (_wdata_6_value_2_T ? regfile_2 : 32'h0)
    | (_wdata_6_value_3_T ? regfile_3 : 32'h0) | (_wdata_6_value_4_T ? regfile_4 : 32'h0)
    | (_wdata_6_value_5_T ? regfile_5 : 32'h0) | (_wdata_6_value_6_T ? regfile_6 : 32'h0)
    | (_wdata_6_value_7_T ? regfile_7 : 32'h0) | (_wdata_6_value_8_T ? regfile_8 : 32'h0)
    | (_wdata_6_value_9_T ? regfile_9 : 32'h0)
    | (_wdata_6_value_10_T ? regfile_10 : 32'h0)
    | (_wdata_6_value_11_T ? regfile_11 : 32'h0)
    | (_wdata_6_value_12_T ? regfile_12 : 32'h0)
    | (_wdata_6_value_13_T ? regfile_13 : 32'h0)
    | (_wdata_6_value_14_T ? regfile_14 : 32'h0)
    | (_wdata_6_value_15_T ? regfile_15 : 32'h0)
    | (_wdata_6_value_16_T ? regfile_16 : 32'h0)
    | (_wdata_6_value_17_T ? regfile_17 : 32'h0)
    | (_wdata_6_value_18_T ? regfile_18 : 32'h0)
    | (_wdata_6_value_19_T ? regfile_19 : 32'h0)
    | (_wdata_6_value_20_T ? regfile_20 : 32'h0)
    | (_wdata_6_value_21_T ? regfile_21 : 32'h0)
    | (_wdata_6_value_22_T ? regfile_22 : 32'h0)
    | (_wdata_6_value_23_T ? regfile_23 : 32'h0)
    | (_wdata_6_value_24_T ? regfile_24 : 32'h0)
    | (_wdata_6_value_25_T ? regfile_25 : 32'h0)
    | (_wdata_6_value_26_T ? regfile_26 : 32'h0)
    | (_wdata_6_value_27_T ? regfile_27 : 32'h0)
    | (_wdata_6_value_28_T ? regfile_28 : 32'h0)
    | (_wdata_6_value_29_T ? regfile_29 : 32'h0)
    | (_wdata_6_value_30_T ? regfile_30 : 32'h0)
    | ((&io_readAddr_6_addr) ? regfile_31 : 32'h0);
  wire [31:0] rwdata_6 =
    io_readAddr_6_addr == 5'h0 | _wdata_6_value_1_T & (|_writeValid_1_T)
    | _wdata_6_value_2_T & (|_writeValid_2_T) | _wdata_6_value_3_T & (|_writeValid_3_T)
    | _wdata_6_value_4_T & (|_writeValid_4_T) | _wdata_6_value_5_T & (|_writeValid_5_T)
    | _wdata_6_value_6_T & (|_writeValid_6_T) | _wdata_6_value_7_T & (|_writeValid_7_T)
    | _wdata_6_value_8_T & (|_writeValid_8_T) | _wdata_6_value_9_T & (|_writeValid_9_T)
    | _wdata_6_value_10_T & (|_writeValid_10_T) | _wdata_6_value_11_T
    & (|_writeValid_11_T) | _wdata_6_value_12_T & (|_writeValid_12_T)
    | _wdata_6_value_13_T & (|_writeValid_13_T) | _wdata_6_value_14_T
    & (|_writeValid_14_T) | _wdata_6_value_15_T & (|_writeValid_15_T)
    | _wdata_6_value_16_T & (|_writeValid_16_T) | _wdata_6_value_17_T
    & (|_writeValid_17_T) | _wdata_6_value_18_T & (|_writeValid_18_T)
    | _wdata_6_value_19_T & (|_writeValid_19_T) | _wdata_6_value_20_T
    & (|_writeValid_20_T) | _wdata_6_value_21_T & (|_writeValid_21_T)
    | _wdata_6_value_22_T & (|_writeValid_22_T) | _wdata_6_value_23_T
    & (|_writeValid_23_T) | _wdata_6_value_24_T & (|_writeValid_24_T)
    | _wdata_6_value_25_T & (|_writeValid_25_T) | _wdata_6_value_26_T
    & (|_writeValid_26_T) | _wdata_6_value_27_T & (|_writeValid_27_T)
    | _wdata_6_value_28_T & (|_writeValid_28_T) | _wdata_6_value_29_T
    & (|_writeValid_29_T) | _wdata_6_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_6_addr) & (|_writeValid_31_T)
      ? (_wdata_6_value_1_T ? data : 32'h0) | (_wdata_6_value_2_T ? data_1 : 32'h0)
        | (_wdata_6_value_3_T ? data_2 : 32'h0) | (_wdata_6_value_4_T ? data_3 : 32'h0)
        | (_wdata_6_value_5_T ? data_4 : 32'h0) | (_wdata_6_value_6_T ? data_5 : 32'h0)
        | (_wdata_6_value_7_T ? data_6 : 32'h0) | (_wdata_6_value_8_T ? data_7 : 32'h0)
        | (_wdata_6_value_9_T ? data_8 : 32'h0) | (_wdata_6_value_10_T ? data_9 : 32'h0)
        | (_wdata_6_value_11_T ? data_10 : 32'h0)
        | (_wdata_6_value_12_T ? data_11 : 32'h0)
        | (_wdata_6_value_13_T ? data_12 : 32'h0)
        | (_wdata_6_value_14_T ? data_13 : 32'h0)
        | (_wdata_6_value_15_T ? data_14 : 32'h0)
        | (_wdata_6_value_16_T ? data_15 : 32'h0)
        | (_wdata_6_value_17_T ? data_16 : 32'h0)
        | (_wdata_6_value_18_T ? data_17 : 32'h0)
        | (_wdata_6_value_19_T ? data_18 : 32'h0)
        | (_wdata_6_value_20_T ? data_19 : 32'h0)
        | (_wdata_6_value_21_T ? data_20 : 32'h0)
        | (_wdata_6_value_22_T ? data_21 : 32'h0)
        | (_wdata_6_value_23_T ? data_22 : 32'h0)
        | (_wdata_6_value_24_T ? data_23 : 32'h0)
        | (_wdata_6_value_25_T ? data_24 : 32'h0)
        | (_wdata_6_value_26_T ? data_25 : 32'h0)
        | (_wdata_6_value_27_T ? data_26 : 32'h0)
        | (_wdata_6_value_28_T ? data_27 : 32'h0)
        | (_wdata_6_value_29_T ? data_28 : 32'h0)
        | (_wdata_6_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_6_addr) ? data_30 : 32'h0)
      : rdata_6_value_5_0;
  wire        _wdata_7_value_1_T = io_readAddr_7_addr == 5'h1;
  wire        _wdata_7_value_2_T = io_readAddr_7_addr == 5'h2;
  wire        _wdata_7_value_3_T = io_readAddr_7_addr == 5'h3;
  wire        _wdata_7_value_4_T = io_readAddr_7_addr == 5'h4;
  wire        _wdata_7_value_5_T = io_readAddr_7_addr == 5'h5;
  wire        _wdata_7_value_6_T = io_readAddr_7_addr == 5'h6;
  wire        _wdata_7_value_7_T = io_readAddr_7_addr == 5'h7;
  wire        _wdata_7_value_8_T = io_readAddr_7_addr == 5'h8;
  wire        _wdata_7_value_9_T = io_readAddr_7_addr == 5'h9;
  wire        _wdata_7_value_10_T = io_readAddr_7_addr == 5'hA;
  wire        _wdata_7_value_11_T = io_readAddr_7_addr == 5'hB;
  wire        _wdata_7_value_12_T = io_readAddr_7_addr == 5'hC;
  wire        _wdata_7_value_13_T = io_readAddr_7_addr == 5'hD;
  wire        _wdata_7_value_14_T = io_readAddr_7_addr == 5'hE;
  wire        _wdata_7_value_15_T = io_readAddr_7_addr == 5'hF;
  wire        _wdata_7_value_16_T = io_readAddr_7_addr == 5'h10;
  wire        _wdata_7_value_17_T = io_readAddr_7_addr == 5'h11;
  wire        _wdata_7_value_18_T = io_readAddr_7_addr == 5'h12;
  wire        _wdata_7_value_19_T = io_readAddr_7_addr == 5'h13;
  wire        _wdata_7_value_20_T = io_readAddr_7_addr == 5'h14;
  wire        _wdata_7_value_21_T = io_readAddr_7_addr == 5'h15;
  wire        _wdata_7_value_22_T = io_readAddr_7_addr == 5'h16;
  wire        _wdata_7_value_23_T = io_readAddr_7_addr == 5'h17;
  wire        _wdata_7_value_24_T = io_readAddr_7_addr == 5'h18;
  wire        _wdata_7_value_25_T = io_readAddr_7_addr == 5'h19;
  wire        _wdata_7_value_26_T = io_readAddr_7_addr == 5'h1A;
  wire        _wdata_7_value_27_T = io_readAddr_7_addr == 5'h1B;
  wire        _wdata_7_value_28_T = io_readAddr_7_addr == 5'h1C;
  wire        _wdata_7_value_29_T = io_readAddr_7_addr == 5'h1D;
  wire        _wdata_7_value_30_T = io_readAddr_7_addr == 5'h1E;
  wire [31:0] rwdata_7 =
    io_readAddr_7_addr == 5'h0 | _wdata_7_value_1_T & (|_writeValid_1_T)
    | _wdata_7_value_2_T & (|_writeValid_2_T) | _wdata_7_value_3_T & (|_writeValid_3_T)
    | _wdata_7_value_4_T & (|_writeValid_4_T) | _wdata_7_value_5_T & (|_writeValid_5_T)
    | _wdata_7_value_6_T & (|_writeValid_6_T) | _wdata_7_value_7_T & (|_writeValid_7_T)
    | _wdata_7_value_8_T & (|_writeValid_8_T) | _wdata_7_value_9_T & (|_writeValid_9_T)
    | _wdata_7_value_10_T & (|_writeValid_10_T) | _wdata_7_value_11_T
    & (|_writeValid_11_T) | _wdata_7_value_12_T & (|_writeValid_12_T)
    | _wdata_7_value_13_T & (|_writeValid_13_T) | _wdata_7_value_14_T
    & (|_writeValid_14_T) | _wdata_7_value_15_T & (|_writeValid_15_T)
    | _wdata_7_value_16_T & (|_writeValid_16_T) | _wdata_7_value_17_T
    & (|_writeValid_17_T) | _wdata_7_value_18_T & (|_writeValid_18_T)
    | _wdata_7_value_19_T & (|_writeValid_19_T) | _wdata_7_value_20_T
    & (|_writeValid_20_T) | _wdata_7_value_21_T & (|_writeValid_21_T)
    | _wdata_7_value_22_T & (|_writeValid_22_T) | _wdata_7_value_23_T
    & (|_writeValid_23_T) | _wdata_7_value_24_T & (|_writeValid_24_T)
    | _wdata_7_value_25_T & (|_writeValid_25_T) | _wdata_7_value_26_T
    & (|_writeValid_26_T) | _wdata_7_value_27_T & (|_writeValid_27_T)
    | _wdata_7_value_28_T & (|_writeValid_28_T) | _wdata_7_value_29_T
    & (|_writeValid_29_T) | _wdata_7_value_30_T & (|_writeValid_30_T)
    | (&io_readAddr_7_addr) & (|_writeValid_31_T)
      ? (_wdata_7_value_1_T ? data : 32'h0) | (_wdata_7_value_2_T ? data_1 : 32'h0)
        | (_wdata_7_value_3_T ? data_2 : 32'h0) | (_wdata_7_value_4_T ? data_3 : 32'h0)
        | (_wdata_7_value_5_T ? data_4 : 32'h0) | (_wdata_7_value_6_T ? data_5 : 32'h0)
        | (_wdata_7_value_7_T ? data_6 : 32'h0) | (_wdata_7_value_8_T ? data_7 : 32'h0)
        | (_wdata_7_value_9_T ? data_8 : 32'h0) | (_wdata_7_value_10_T ? data_9 : 32'h0)
        | (_wdata_7_value_11_T ? data_10 : 32'h0)
        | (_wdata_7_value_12_T ? data_11 : 32'h0)
        | (_wdata_7_value_13_T ? data_12 : 32'h0)
        | (_wdata_7_value_14_T ? data_13 : 32'h0)
        | (_wdata_7_value_15_T ? data_14 : 32'h0)
        | (_wdata_7_value_16_T ? data_15 : 32'h0)
        | (_wdata_7_value_17_T ? data_16 : 32'h0)
        | (_wdata_7_value_18_T ? data_17 : 32'h0)
        | (_wdata_7_value_19_T ? data_18 : 32'h0)
        | (_wdata_7_value_20_T ? data_19 : 32'h0)
        | (_wdata_7_value_21_T ? data_20 : 32'h0)
        | (_wdata_7_value_22_T ? data_21 : 32'h0)
        | (_wdata_7_value_23_T ? data_22 : 32'h0)
        | (_wdata_7_value_24_T ? data_23 : 32'h0)
        | (_wdata_7_value_25_T ? data_24 : 32'h0)
        | (_wdata_7_value_26_T ? data_25 : 32'h0)
        | (_wdata_7_value_27_T ? data_26 : 32'h0)
        | (_wdata_7_value_28_T ? data_27 : 32'h0)
        | (_wdata_7_value_29_T ? data_28 : 32'h0)
        | (_wdata_7_value_30_T ? data_29 : 32'h0)
        | ((&io_readAddr_7_addr) ? data_30 : 32'h0)
      : (_wdata_7_value_1_T ? regfile_1 : 32'h0)
        | (_wdata_7_value_2_T ? regfile_2 : 32'h0)
        | (_wdata_7_value_3_T ? regfile_3 : 32'h0)
        | (_wdata_7_value_4_T ? regfile_4 : 32'h0)
        | (_wdata_7_value_5_T ? regfile_5 : 32'h0)
        | (_wdata_7_value_6_T ? regfile_6 : 32'h0)
        | (_wdata_7_value_7_T ? regfile_7 : 32'h0)
        | (_wdata_7_value_8_T ? regfile_8 : 32'h0)
        | (_wdata_7_value_9_T ? regfile_9 : 32'h0)
        | (_wdata_7_value_10_T ? regfile_10 : 32'h0)
        | (_wdata_7_value_11_T ? regfile_11 : 32'h0)
        | (_wdata_7_value_12_T ? regfile_12 : 32'h0)
        | (_wdata_7_value_13_T ? regfile_13 : 32'h0)
        | (_wdata_7_value_14_T ? regfile_14 : 32'h0)
        | (_wdata_7_value_15_T ? regfile_15 : 32'h0)
        | (_wdata_7_value_16_T ? regfile_16 : 32'h0)
        | (_wdata_7_value_17_T ? regfile_17 : 32'h0)
        | (_wdata_7_value_18_T ? regfile_18 : 32'h0)
        | (_wdata_7_value_19_T ? regfile_19 : 32'h0)
        | (_wdata_7_value_20_T ? regfile_20 : 32'h0)
        | (_wdata_7_value_21_T ? regfile_21 : 32'h0)
        | (_wdata_7_value_22_T ? regfile_22 : 32'h0)
        | (_wdata_7_value_23_T ? regfile_23 : 32'h0)
        | (_wdata_7_value_24_T ? regfile_24 : 32'h0)
        | (_wdata_7_value_25_T ? regfile_25 : 32'h0)
        | (_wdata_7_value_26_T ? regfile_26 : 32'h0)
        | (_wdata_7_value_27_T ? regfile_27 : 32'h0)
        | (_wdata_7_value_28_T ? regfile_28 : 32'h0)
        | (_wdata_7_value_29_T ? regfile_29 : 32'h0)
        | (_wdata_7_value_30_T ? regfile_30 : 32'h0)
        | ((&io_readAddr_7_addr) ? regfile_31 : 32'h0);
  wire [31:0] busAddr_0 =
    io_busAddr_0_bypass
      ? rwdata_0
      : io_busAddr_0_immen ? rdata_0_value_5_0 + io_busAddr_0_immed : rdata_0_value_5_0;
  wire [31:0] busAddr_1 =
    io_busAddr_1_bypass ? rwdata_2 : rdata_2_value_5_0 + io_busAddr_1_immed;
  wire [31:0] busAddr_2 =
    io_busAddr_2_bypass ? rwdata_4 : rdata_4_value_5_0 + io_busAddr_2_immed;
  wire [31:0] busAddr_3 =
    io_busAddr_3_bypass ? rwdata_6 : rdata_6_value_5_0 + io_busAddr_3_immed;
  reg         write_fail;
  reg         write_fail_1;
  reg         write_fail_2;
  reg         write_fail_3;
  reg         write_fail_4;
  reg         write_fail_5;
  reg         write_fail_6;
  reg         write_fail_7;
  reg         write_fail_8;
  reg         write_fail_9;
  reg         write_fail_10;
  reg         write_fail_11;
  reg         write_fail_12;
  reg         write_fail_13;
  reg         write_fail_14;
  reg         scoreboard_error;
  wire [31:0] scoreboard_set =
    (io_writeAddr_0_valid ? 32'h1 << io_writeAddr_0_addr : 32'h0)
    | (io_writeAddr_1_valid ? 32'h1 << io_writeAddr_1_addr : 32'h0)
    | (io_writeAddr_2_valid ? 32'h1 << io_writeAddr_2_addr : 32'h0)
    | (io_writeAddr_3_valid ? 32'h1 << io_writeAddr_3_addr : 32'h0);
  wire [31:0] scoreboard_clr = {scoreboard_clr0, 1'h0};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      regfile_1 <= 32'h0;
      regfile_2 <= 32'h0;
      regfile_3 <= 32'h0;
      regfile_4 <= 32'h0;
      regfile_5 <= 32'h0;
      regfile_6 <= 32'h0;
      regfile_7 <= 32'h0;
      regfile_8 <= 32'h0;
      regfile_9 <= 32'h0;
      regfile_10 <= 32'h0;
      regfile_11 <= 32'h0;
      regfile_12 <= 32'h0;
      regfile_13 <= 32'h0;
      regfile_14 <= 32'h0;
      regfile_15 <= 32'h0;
      regfile_16 <= 32'h0;
      regfile_17 <= 32'h0;
      regfile_18 <= 32'h0;
      regfile_19 <= 32'h0;
      regfile_20 <= 32'h0;
      regfile_21 <= 32'h0;
      regfile_22 <= 32'h0;
      regfile_23 <= 32'h0;
      regfile_24 <= 32'h0;
      regfile_25 <= 32'h0;
      regfile_26 <= 32'h0;
      regfile_27 <= 32'h0;
      regfile_28 <= 32'h0;
      regfile_29 <= 32'h0;
      regfile_30 <= 32'h0;
      regfile_31 <= 32'h0;
      scoreboard <= 32'h0;
      readDataReady_0 <= 1'h0;
      readDataReady_1 <= 1'h0;
      readDataReady_2 <= 1'h0;
      readDataReady_3 <= 1'h0;
      readDataReady_4 <= 1'h0;
      readDataReady_5 <= 1'h0;
      readDataReady_6 <= 1'h0;
      readDataReady_7 <= 1'h0;
      readDataBits_0 <= 32'h0;
      readDataBits_1 <= 32'h0;
      readDataBits_2 <= 32'h0;
      readDataBits_3 <= 32'h0;
      readDataBits_4 <= 32'h0;
      readDataBits_5 <= 32'h0;
      readDataBits_6 <= 32'h0;
      readDataBits_7 <= 32'h0;
      write_fail <= 1'h0;
      write_fail_1 <= 1'h0;
      write_fail_2 <= 1'h0;
      write_fail_3 <= 1'h0;
      write_fail_4 <= 1'h0;
      write_fail_5 <= 1'h0;
      write_fail_6 <= 1'h0;
      write_fail_7 <= 1'h0;
      write_fail_8 <= 1'h0;
      write_fail_9 <= 1'h0;
      write_fail_10 <= 1'h0;
      write_fail_11 <= 1'h0;
      write_fail_12 <= 1'h0;
      write_fail_13 <= 1'h0;
      write_fail_14 <= 1'h0;
      scoreboard_error <= 1'h0;
    end
    else begin
      if (|_writeValid_1_T)
        regfile_1 <= data;
      if (|_writeValid_2_T)
        regfile_2 <= data_1;
      if (|_writeValid_3_T)
        regfile_3 <= data_2;
      if (|_writeValid_4_T)
        regfile_4 <= data_3;
      if (|_writeValid_5_T)
        regfile_5 <= data_4;
      if (|_writeValid_6_T)
        regfile_6 <= data_5;
      if (|_writeValid_7_T)
        regfile_7 <= data_6;
      if (|_writeValid_8_T)
        regfile_8 <= data_7;
      if (|_writeValid_9_T)
        regfile_9 <= data_8;
      if (|_writeValid_10_T)
        regfile_10 <= data_9;
      if (|_writeValid_11_T)
        regfile_11 <= data_10;
      if (|_writeValid_12_T)
        regfile_12 <= data_11;
      if (|_writeValid_13_T)
        regfile_13 <= data_12;
      if (|_writeValid_14_T)
        regfile_14 <= data_13;
      if (|_writeValid_15_T)
        regfile_15 <= data_14;
      if (|_writeValid_16_T)
        regfile_16 <= data_15;
      if (|_writeValid_17_T)
        regfile_17 <= data_16;
      if (|_writeValid_18_T)
        regfile_18 <= data_17;
      if (|_writeValid_19_T)
        regfile_19 <= data_18;
      if (|_writeValid_20_T)
        regfile_20 <= data_19;
      if (|_writeValid_21_T)
        regfile_21 <= data_20;
      if (|_writeValid_22_T)
        regfile_22 <= data_21;
      if (|_writeValid_23_T)
        regfile_23 <= data_22;
      if (|_writeValid_24_T)
        regfile_24 <= data_23;
      if (|_writeValid_25_T)
        regfile_25 <= data_24;
      if (|_writeValid_26_T)
        regfile_26 <= data_25;
      if (|_writeValid_27_T)
        regfile_27 <= data_26;
      if (|_writeValid_28_T)
        regfile_28 <= data_27;
      if (|_writeValid_29_T)
        regfile_29 <= data_28;
      if (|_writeValid_30_T)
        regfile_30 <= data_29;
      if (|_writeValid_31_T)
        regfile_31 <= data_30;
      if (|{scoreboard_set, scoreboard_clr0})
        scoreboard <= {scoreboard[31:1] & ~scoreboard_clr0 | scoreboard_set[31:1], 1'h0};
      readDataReady_0 <= io_readAddr_0_valid | io_readSet_0_valid;
      readDataReady_1 <= io_readAddr_1_valid | io_readSet_1_valid;
      readDataReady_2 <= io_readAddr_2_valid | io_readSet_2_valid;
      readDataReady_3 <= io_readAddr_3_valid | io_readSet_3_valid;
      readDataReady_4 <= io_readAddr_4_valid | io_readSet_4_valid;
      readDataReady_5 <= io_readAddr_5_valid | io_readSet_5_valid;
      readDataReady_6 <= io_readAddr_6_valid | io_readSet_6_valid;
      readDataReady_7 <= io_readAddr_7_valid | io_readSet_7_valid;
      if (io_readSet_0_valid)
        readDataBits_0 <= io_readSet_0_value;
      else if (io_readAddr_0_valid)
        readDataBits_0 <= rwdata_0;
      if (io_readSet_1_valid)
        readDataBits_1 <= io_readSet_1_value;
      else if (io_readAddr_1_valid)
        readDataBits_1 <= rwdata_1;
      if (io_readSet_2_valid)
        readDataBits_2 <= io_readSet_2_value;
      else if (io_readAddr_2_valid)
        readDataBits_2 <= rwdata_2;
      if (io_readSet_3_valid)
        readDataBits_3 <= io_readSet_3_value;
      else if (io_readAddr_3_valid)
        readDataBits_3 <= rwdata_3;
      if (io_readSet_4_valid)
        readDataBits_4 <= io_readSet_4_value;
      else if (io_readAddr_4_valid)
        readDataBits_4 <= rwdata_4;
      if (io_readSet_5_valid)
        readDataBits_5 <= io_readSet_5_value;
      else if (io_readAddr_5_valid)
        readDataBits_5 <= rwdata_5;
      if (io_readSet_6_valid)
        readDataBits_6 <= io_readSet_6_value;
      else if (io_readAddr_6_valid)
        readDataBits_6 <= rwdata_6;
      if (io_readSet_7_valid)
        readDataBits_7 <= io_readSet_7_value;
      else if (io_readAddr_7_valid)
        readDataBits_7 <= rwdata_7;
      write_fail <=
        io_writeData_0_valid & io_writeData_1_valid
        & io_writeData_0_bits_addr == io_writeData_1_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_1 <=
        io_writeData_0_valid & io_writeData_2_valid
        & io_writeData_0_bits_addr == io_writeData_2_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_2 <=
        io_writeData_0_valid & io_writeData_3_valid
        & io_writeData_0_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_3 <=
        io_writeData_0_valid & io_writeData_4_valid
        & io_writeData_0_bits_addr == io_writeData_4_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_4 <=
        io_writeData_0_valid & io_writeData_5_valid
        & io_writeData_0_bits_addr == io_writeData_5_bits_addr
        & (|io_writeData_0_bits_addr);
      write_fail_5 <=
        io_writeData_1_valid & io_writeData_2_valid
        & io_writeData_1_bits_addr == io_writeData_2_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_6 <=
        io_writeData_1_valid & io_writeData_3_valid
        & io_writeData_1_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_7 <=
        io_writeData_1_valid & io_writeData_4_valid
        & io_writeData_1_bits_addr == io_writeData_4_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_8 <=
        io_writeData_1_valid & io_writeData_5_valid
        & io_writeData_1_bits_addr == io_writeData_5_bits_addr
        & (|io_writeData_1_bits_addr);
      write_fail_9 <=
        io_writeData_2_valid & io_writeData_3_valid
        & io_writeData_2_bits_addr == io_writeData_3_bits_addr
        & (|io_writeData_2_bits_addr);
      write_fail_10 <=
        io_writeData_2_valid & io_writeData_4_valid
        & io_writeData_2_bits_addr == io_writeData_4_bits_addr
        & (|io_writeData_2_bits_addr);
      write_fail_11 <=
        io_writeData_2_valid & io_writeData_5_valid
        & io_writeData_2_bits_addr == io_writeData_5_bits_addr
        & (|io_writeData_2_bits_addr);
      write_fail_12 <=
        io_writeData_3_valid & io_writeData_4_valid
        & io_writeData_3_bits_addr == io_writeData_4_bits_addr
        & (|io_writeData_3_bits_addr);
      write_fail_13 <=
        io_writeData_3_valid & io_writeData_5_valid
        & io_writeData_3_bits_addr == io_writeData_5_bits_addr
        & (|io_writeData_3_bits_addr);
      write_fail_14 <=
        io_writeData_4_valid & io_writeData_5_valid
        & io_writeData_4_bits_addr == io_writeData_5_bits_addr
        & (|io_writeData_4_bits_addr);
      scoreboard_error <= (scoreboard & scoreboard_clr) != scoreboard_clr;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:41];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [5:0] i = 6'h0; i < 6'h2A; i += 6'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        regfile_1 = _RANDOM[6'h1];
        regfile_2 = _RANDOM[6'h2];
        regfile_3 = _RANDOM[6'h3];
        regfile_4 = _RANDOM[6'h4];
        regfile_5 = _RANDOM[6'h5];
        regfile_6 = _RANDOM[6'h6];
        regfile_7 = _RANDOM[6'h7];
        regfile_8 = _RANDOM[6'h8];
        regfile_9 = _RANDOM[6'h9];
        regfile_10 = _RANDOM[6'hA];
        regfile_11 = _RANDOM[6'hB];
        regfile_12 = _RANDOM[6'hC];
        regfile_13 = _RANDOM[6'hD];
        regfile_14 = _RANDOM[6'hE];
        regfile_15 = _RANDOM[6'hF];
        regfile_16 = _RANDOM[6'h10];
        regfile_17 = _RANDOM[6'h11];
        regfile_18 = _RANDOM[6'h12];
        regfile_19 = _RANDOM[6'h13];
        regfile_20 = _RANDOM[6'h14];
        regfile_21 = _RANDOM[6'h15];
        regfile_22 = _RANDOM[6'h16];
        regfile_23 = _RANDOM[6'h17];
        regfile_24 = _RANDOM[6'h18];
        regfile_25 = _RANDOM[6'h19];
        regfile_26 = _RANDOM[6'h1A];
        regfile_27 = _RANDOM[6'h1B];
        regfile_28 = _RANDOM[6'h1C];
        regfile_29 = _RANDOM[6'h1D];
        regfile_30 = _RANDOM[6'h1E];
        regfile_31 = _RANDOM[6'h1F];
        scoreboard = _RANDOM[6'h20];
        readDataReady_0 = _RANDOM[6'h21][0];
        readDataReady_1 = _RANDOM[6'h21][1];
        readDataReady_2 = _RANDOM[6'h21][2];
        readDataReady_3 = _RANDOM[6'h21][3];
        readDataReady_4 = _RANDOM[6'h21][4];
        readDataReady_5 = _RANDOM[6'h21][5];
        readDataReady_6 = _RANDOM[6'h21][6];
        readDataReady_7 = _RANDOM[6'h21][7];
        readDataBits_0 = {_RANDOM[6'h21][31:8], _RANDOM[6'h22][7:0]};
        readDataBits_1 = {_RANDOM[6'h22][31:8], _RANDOM[6'h23][7:0]};
        readDataBits_2 = {_RANDOM[6'h23][31:8], _RANDOM[6'h24][7:0]};
        readDataBits_3 = {_RANDOM[6'h24][31:8], _RANDOM[6'h25][7:0]};
        readDataBits_4 = {_RANDOM[6'h25][31:8], _RANDOM[6'h26][7:0]};
        readDataBits_5 = {_RANDOM[6'h26][31:8], _RANDOM[6'h27][7:0]};
        readDataBits_6 = {_RANDOM[6'h27][31:8], _RANDOM[6'h28][7:0]};
        readDataBits_7 = {_RANDOM[6'h28][31:8], _RANDOM[6'h29][7:0]};
        write_fail = _RANDOM[6'h29][8];
        write_fail_1 = _RANDOM[6'h29][9];
        write_fail_2 = _RANDOM[6'h29][10];
        write_fail_3 = _RANDOM[6'h29][11];
        write_fail_4 = _RANDOM[6'h29][12];
        write_fail_5 = _RANDOM[6'h29][13];
        write_fail_6 = _RANDOM[6'h29][14];
        write_fail_7 = _RANDOM[6'h29][15];
        write_fail_8 = _RANDOM[6'h29][16];
        write_fail_9 = _RANDOM[6'h29][17];
        write_fail_10 = _RANDOM[6'h29][18];
        write_fail_11 = _RANDOM[6'h29][19];
        write_fail_12 = _RANDOM[6'h29][20];
        write_fail_13 = _RANDOM[6'h29][21];
        write_fail_14 = _RANDOM[6'h29][22];
        scoreboard_error = _RANDOM[6'h29][23];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        regfile_1 = 32'h0;
        regfile_2 = 32'h0;
        regfile_3 = 32'h0;
        regfile_4 = 32'h0;
        regfile_5 = 32'h0;
        regfile_6 = 32'h0;
        regfile_7 = 32'h0;
        regfile_8 = 32'h0;
        regfile_9 = 32'h0;
        regfile_10 = 32'h0;
        regfile_11 = 32'h0;
        regfile_12 = 32'h0;
        regfile_13 = 32'h0;
        regfile_14 = 32'h0;
        regfile_15 = 32'h0;
        regfile_16 = 32'h0;
        regfile_17 = 32'h0;
        regfile_18 = 32'h0;
        regfile_19 = 32'h0;
        regfile_20 = 32'h0;
        regfile_21 = 32'h0;
        regfile_22 = 32'h0;
        regfile_23 = 32'h0;
        regfile_24 = 32'h0;
        regfile_25 = 32'h0;
        regfile_26 = 32'h0;
        regfile_27 = 32'h0;
        regfile_28 = 32'h0;
        regfile_29 = 32'h0;
        regfile_30 = 32'h0;
        regfile_31 = 32'h0;
        scoreboard = 32'h0;
        readDataReady_0 = 1'h0;
        readDataReady_1 = 1'h0;
        readDataReady_2 = 1'h0;
        readDataReady_3 = 1'h0;
        readDataReady_4 = 1'h0;
        readDataReady_5 = 1'h0;
        readDataReady_6 = 1'h0;
        readDataReady_7 = 1'h0;
        readDataBits_0 = 32'h0;
        readDataBits_1 = 32'h0;
        readDataBits_2 = 32'h0;
        readDataBits_3 = 32'h0;
        readDataBits_4 = 32'h0;
        readDataBits_5 = 32'h0;
        readDataBits_6 = 32'h0;
        readDataBits_7 = 32'h0;
        write_fail = 1'h0;
        write_fail_1 = 1'h0;
        write_fail_2 = 1'h0;
        write_fail_3 = 1'h0;
        write_fail_4 = 1'h0;
        write_fail_5 = 1'h0;
        write_fail_6 = 1'h0;
        write_fail_7 = 1'h0;
        write_fail_8 = 1'h0;
        write_fail_9 = 1'h0;
        write_fail_10 = 1'h0;
        write_fail_11 = 1'h0;
        write_fail_12 = 1'h0;
        write_fail_13 = 1'h0;
        write_fail_14 = 1'h0;
        scoreboard_error = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_target_0_data = busAddr_0;
  assign io_target_1_data = busAddr_1;
  assign io_target_2_data = busAddr_2;
  assign io_target_3_data = busAddr_3;
  assign io_busPort_addr_0 = busAddr_0;
  assign io_busPort_addr_1 = busAddr_1;
  assign io_busPort_addr_2 = busAddr_2;
  assign io_busPort_addr_3 = busAddr_3;
  assign io_busPort_data_0 = io_readSet_1_valid ? io_readSet_1_value : rwdata_1;
  assign io_busPort_data_1 = io_readSet_3_valid ? io_readSet_3_value : rwdata_3;
  assign io_busPort_data_2 = io_readSet_5_valid ? io_readSet_5_value : rwdata_5;
  assign io_busPort_data_3 = io_readSet_7_valid ? io_readSet_7_value : rwdata_7;
  assign io_readData_0_valid = readDataReady_0;
  assign io_readData_0_data = readDataBits_0;
  assign io_readData_1_valid = readDataReady_1;
  assign io_readData_1_data = readDataBits_1;
  assign io_readData_2_valid = readDataReady_2;
  assign io_readData_2_data = readDataBits_2;
  assign io_readData_3_valid = readDataReady_3;
  assign io_readData_3_data = readDataBits_3;
  assign io_readData_4_valid = readDataReady_4;
  assign io_readData_4_data = readDataBits_4;
  assign io_readData_5_valid = readDataReady_5;
  assign io_readData_5_data = readDataBits_5;
  assign io_readData_6_valid = readDataReady_6;
  assign io_readData_6_data = readDataBits_6;
  assign io_readData_7_valid = readDataReady_7;
  assign io_readData_7_data = readDataBits_7;
  assign io_scoreboard_regd = scoreboard;
  assign io_scoreboard_comb = scoreboard & {~scoreboard_clr0, 1'h1};
endmodule

module FetchControl(
  input         clock,
                reset,
  output        io_fetchFault_valid,
  output [31:0] io_fetchFault_bits,
  input  [31:0] io_csr_value_0,
  input         io_iflush_valid,
  input  [31:0] io_iflush_bits,
  input         io_branch_valid,
  input  [31:0] io_branch_bits,
  input         io_fetchData_valid,
  input  [31:0] io_fetchData_bits_addr,
                io_fetchData_bits_inst_0,
                io_fetchData_bits_inst_1,
                io_fetchData_bits_inst_2,
                io_fetchData_bits_inst_3,
  input         io_fetchData_bits_fault,
  output        io_fetchAddr_valid,
  output [31:0] io_fetchAddr_bits,
  output [2:0]  io_bufferRequest_nValid,
  output [31:0] io_bufferRequest_bits_0_addr,
                io_bufferRequest_bits_0_inst,
  output        io_bufferRequest_bits_0_brchFwd,
  output [31:0] io_bufferRequest_bits_1_addr,
                io_bufferRequest_bits_1_inst,
  output        io_bufferRequest_bits_1_brchFwd,
  output [31:0] io_bufferRequest_bits_2_addr,
                io_bufferRequest_bits_2_inst,
  output        io_bufferRequest_bits_2_brchFwd,
  output [31:0] io_bufferRequest_bits_3_addr,
                io_bufferRequest_bits_3_inst,
  output        io_bufferRequest_bits_3_brchFwd,
  input  [3:0]  io_bufferSpaces
);

  wire [127:0] predecode_insts_shifted =
    {io_fetchData_bits_inst_3,
     io_fetchData_bits_inst_2,
     io_fetchData_bits_inst_1,
     io_fetchData_bits_inst_0} >> {121'h0, io_fetchData_bits_addr[3:2], 5'h0};
  wire [31:0]  predecode_addrs_1 = io_fetchData_bits_addr + 32'h4;
  wire [31:0]  predecode_addrs_2 = io_fetchData_bits_addr + 32'h8;
  wire [31:0]  predecode_addrs_3 = io_fetchData_bits_addr + 32'hC;
  wire [2:0]   _predecode_validsIn_T_9 = 3'h4 - {1'h0, io_fetchData_bits_addr[3:2]};
  wire         predecode_validsIn_2 = _predecode_validsIn_T_9 > 3'h2;
  wire         predecode_jumped_0 =
    (|_predecode_validsIn_T_9)
    & (predecode_insts_shifted[6:0] == 7'h6F | predecode_insts_shifted[6:0] == 7'h63
       & predecode_insts_shifted[31] & predecode_insts_shifted[14:13] != 2'h1);
  wire         predecode_jumped_1 =
    (|(_predecode_validsIn_T_9[2:1]))
    & (predecode_insts_shifted[38:32] == 7'h6F | predecode_insts_shifted[38:32] == 7'h63
       & predecode_insts_shifted[63] & predecode_insts_shifted[46:45] != 2'h1);
  wire         predecode_jumped_2 =
    predecode_validsIn_2
    & (predecode_insts_shifted[70:64] == 7'h6F | predecode_insts_shifted[70:64] == 7'h63
       & predecode_insts_shifted[95] & predecode_insts_shifted[78:77] != 2'h1);
  wire         predecode_jumped_3 =
    _predecode_validsIn_T_9[2]
    & (predecode_insts_shifted[102:96] == 7'h6F | predecode_insts_shifted[102:96] == 7'h63
       & predecode_insts_shifted[127] & predecode_insts_shifted[110:109] != 2'h1);
  wire [3:0]   predecode_firstJumpOH_enc =
    predecode_jumped_0
      ? 4'h1
      : predecode_jumped_1
          ? 4'h2
          : predecode_jumped_2 ? 4'h4 : {predecode_jumped_3, 3'h0};
  wire         predecode_hasJumpedBefore_2 = predecode_jumped_0 | predecode_jumped_1;
  reg          pastBranchOrFlush;
  wire         currentBranchOrFlush = io_iflush_valid | io_branch_valid;
  wire         ongoingBranchOrFlush = pastBranchOrFlush | currentBranchOrFlush;
  reg          faulted;
  wire         fetchFaultValid =
    (faulted | io_fetchData_valid & io_fetchData_bits_fault) & ~io_branch_valid;
  wire         writeToBuffer =
    io_fetchData_valid & ~fetchFaultValid & ~ongoingBranchOrFlush;
  wire [3:0]   nValid =
    writeToBuffer
      ? {1'h0,
         {1'h0,
          {1'h0, |_predecode_validsIn_T_9}
            + {1'h0, (|(_predecode_validsIn_T_9[2:1])) & ~predecode_jumped_0}}
           + {1'h0,
              {1'h0, predecode_validsIn_2 & ~predecode_hasJumpedBefore_2}
                + {1'h0,
                   _predecode_validsIn_T_9[2]
                     & ~(predecode_hasJumpedBefore_2 | predecode_jumped_2)}}}
      : 4'h0;
  reg          pc_valid;
  reg  [31:0]  pc_bits;
  wire         blockNewFetch =
    ~pc_valid | io_fetchData_valid | currentBranchOrFlush
    | {1'h0, io_bufferSpaces} < {1'h0, nValid} + 5'h4 | fetchFaultValid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      pastBranchOrFlush <= 1'h0;
      faulted <= 1'h0;
      pc_valid <= 1'h0;
      pc_bits <= 32'h0;
    end
    else begin
      pastBranchOrFlush <= ongoingBranchOrFlush & blockNewFetch;
      faulted <= fetchFaultValid;
      pc_valid <= 1'h1;
      if (pc_valid) begin
        if (io_iflush_valid)
          pc_bits <= io_iflush_bits;
        else if (io_branch_valid)
          pc_bits <= io_branch_bits;
        else if (writeToBuffer)
          pc_bits <=
            (predecode_firstJumpOH_enc[0]
               ? io_fetchData_bits_addr
                 + {{12{predecode_insts_shifted[31]}},
                    predecode_insts_shifted[2]
                      ? {predecode_insts_shifted[19:12],
                         predecode_insts_shifted[20],
                         predecode_insts_shifted[30:21]}
                      : {{8{predecode_insts_shifted[31]}},
                         predecode_insts_shifted[7],
                         predecode_insts_shifted[30:25],
                         predecode_insts_shifted[11:8]},
                    1'h0}
               : 32'h0)
            | (predecode_firstJumpOH_enc[1]
                 ? predecode_addrs_1
                   + {{12{predecode_insts_shifted[63]}},
                      predecode_insts_shifted[34]
                        ? {predecode_insts_shifted[51:44],
                           predecode_insts_shifted[52],
                           predecode_insts_shifted[62:53]}
                        : {{8{predecode_insts_shifted[63]}},
                           predecode_insts_shifted[39],
                           predecode_insts_shifted[62:57],
                           predecode_insts_shifted[43:40]},
                      1'h0}
                 : 32'h0)
            | (predecode_firstJumpOH_enc[2]
                 ? predecode_addrs_2
                   + {{12{predecode_insts_shifted[95]}},
                      predecode_insts_shifted[66]
                        ? {predecode_insts_shifted[83:76],
                           predecode_insts_shifted[84],
                           predecode_insts_shifted[94:85]}
                        : {{8{predecode_insts_shifted[95]}},
                           predecode_insts_shifted[71],
                           predecode_insts_shifted[94:89],
                           predecode_insts_shifted[75:72]},
                      1'h0}
                 : 32'h0)
            | (predecode_firstJumpOH_enc[3]
                 ? predecode_addrs_3
                   + {{12{predecode_insts_shifted[127]}},
                      predecode_insts_shifted[98]
                        ? {predecode_insts_shifted[115:108],
                           predecode_insts_shifted[116],
                           predecode_insts_shifted[126:117]}
                        : {{8{predecode_insts_shifted[127]}},
                           predecode_insts_shifted[103],
                           predecode_insts_shifted[126:121],
                           predecode_insts_shifted[107:104]},
                      1'h0}
                 : 32'h0)
            | (predecode_firstJumpOH_enc == 4'h0
                 ? {io_fetchData_bits_addr[31:4] + 28'h1, 4'h0}
                 : 32'h0);
      end
      else
        pc_bits <= {io_csr_value_0[31:2], 2'h0};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        pastBranchOrFlush = _RANDOM[1'h0][0];
        faulted = _RANDOM[1'h0][1];
        pc_valid = _RANDOM[1'h0][2];
        pc_bits = {_RANDOM[1'h0][31:3], _RANDOM[1'h1][2:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        pastBranchOrFlush = 1'h0;
        faulted = 1'h0;
        pc_valid = 1'h0;
        pc_bits = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fetchFault_valid = fetchFaultValid;
  assign io_fetchFault_bits = io_fetchData_bits_addr;
  assign io_fetchAddr_valid = ~blockNewFetch;
  assign io_fetchAddr_bits = blockNewFetch ? 32'h0 : pc_bits;
  assign io_bufferRequest_nValid = nValid[2:0];
  assign io_bufferRequest_bits_0_addr = io_fetchData_bits_addr;
  assign io_bufferRequest_bits_0_inst = predecode_insts_shifted[31:0];
  assign io_bufferRequest_bits_0_brchFwd = predecode_jumped_0;
  assign io_bufferRequest_bits_1_addr = predecode_addrs_1;
  assign io_bufferRequest_bits_1_inst = predecode_insts_shifted[63:32];
  assign io_bufferRequest_bits_1_brchFwd = predecode_jumped_1;
  assign io_bufferRequest_bits_2_addr = predecode_addrs_2;
  assign io_bufferRequest_bits_2_inst = predecode_insts_shifted[95:64];
  assign io_bufferRequest_bits_2_brchFwd = predecode_jumped_2;
  assign io_bufferRequest_bits_3_addr = predecode_addrs_3;
  assign io_bufferRequest_bits_3_inst = predecode_insts_shifted[127:96];
  assign io_bufferRequest_bits_3_brchFwd = predecode_jumped_3;
endmodule

module Fetcher(
  input          clock,
                 reset,
                 io_ctrl_valid,
  input  [31:0]  io_ctrl_bits,
  output         io_fetch_valid,
  output [31:0]  io_fetch_bits_addr,
                 io_fetch_bits_inst_0,
                 io_fetch_bits_inst_1,
                 io_fetch_bits_inst_2,
                 io_fetch_bits_inst_3,
  output         io_fetch_bits_fault,
                 io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid
);

  reg         ibusCmd_valid;
  reg  [31:0] ibusCmd_bits;
  reg         fault;
  wire        ibusFired = io_ctrl_valid & io_ibus_ready;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      ibusCmd_valid <= 1'h0;
      ibusCmd_bits <= 32'h0;
      fault <= 1'h0;
    end
    else begin
      ibusCmd_valid <= ibusFired;
      ibusCmd_bits <= ibusFired ? io_ctrl_bits : 32'h0;
      fault <= io_ibus_fault_valid;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        ibusCmd_valid = _RANDOM[1'h0][0];
        ibusCmd_bits = {_RANDOM[1'h0][31:1], _RANDOM[1'h1][0]};
        fault = _RANDOM[1'h1][1];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        ibusCmd_valid = 1'h0;
        ibusCmd_bits = 32'h0;
        fault = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fetch_valid = ibusCmd_valid;
  assign io_fetch_bits_addr = ibusCmd_bits;
  assign io_fetch_bits_inst_0 = io_ibus_rdata[31:0];
  assign io_fetch_bits_inst_1 = io_ibus_rdata[63:32];
  assign io_fetch_bits_inst_2 = io_ibus_rdata[95:64];
  assign io_fetch_bits_inst_3 = io_ibus_rdata[127:96];
  assign io_fetch_bits_fault = fault;
  assign io_ibus_valid = io_ctrl_valid;
  assign io_ibus_addr = {io_ctrl_bits[31:4], 4'h0};
endmodule

module CircularBufferMulti(
  input         clock,
                reset,
  input  [2:0]  io_enqValid,
  input  [31:0] io_enqData_0_addr,
                io_enqData_0_inst,
  input         io_enqData_0_brchFwd,
  input  [31:0] io_enqData_1_addr,
                io_enqData_1_inst,
  input         io_enqData_1_brchFwd,
  input  [31:0] io_enqData_2_addr,
                io_enqData_2_inst,
  input         io_enqData_2_brchFwd,
  input  [31:0] io_enqData_3_addr,
                io_enqData_3_inst,
  input         io_enqData_3_brchFwd,
  output [3:0]  io_nEnqueued,
                io_nSpace,
  output [31:0] io_dataOut_0_addr,
                io_dataOut_0_inst,
  output        io_dataOut_0_brchFwd,
  output [31:0] io_dataOut_1_addr,
                io_dataOut_1_inst,
  output        io_dataOut_1_brchFwd,
  output [31:0] io_dataOut_2_addr,
                io_dataOut_2_inst,
  output        io_dataOut_2_brchFwd,
  output [31:0] io_dataOut_3_addr,
                io_dataOut_3_inst,
  output        io_dataOut_3_brchFwd,
  input  [2:0]  io_deqReady,
  input         io_flush
);

  reg  [31:0]  buffer_0_addr;
  reg  [31:0]  buffer_0_inst;
  reg          buffer_0_brchFwd;
  reg  [31:0]  buffer_1_addr;
  reg  [31:0]  buffer_1_inst;
  reg          buffer_1_brchFwd;
  reg  [31:0]  buffer_2_addr;
  reg  [31:0]  buffer_2_inst;
  reg          buffer_2_brchFwd;
  reg  [31:0]  buffer_3_addr;
  reg  [31:0]  buffer_3_inst;
  reg          buffer_3_brchFwd;
  reg  [31:0]  buffer_4_addr;
  reg  [31:0]  buffer_4_inst;
  reg          buffer_4_brchFwd;
  reg  [31:0]  buffer_5_addr;
  reg  [31:0]  buffer_5_inst;
  reg          buffer_5_brchFwd;
  reg  [31:0]  buffer_6_addr;
  reg  [31:0]  buffer_6_inst;
  reg          buffer_6_brchFwd;
  reg  [31:0]  buffer_7_addr;
  reg  [31:0]  buffer_7_inst;
  reg          buffer_7_brchFwd;
  reg  [2:0]   enqPtr;
  reg  [2:0]   deqPtr;
  reg  [3:0]   nEnqueued;
  wire [9:0]   _outputBufferView_rotated_T_9 = {7'h0, deqPtr} * 10'h41;
  wire [519:0] _outputBufferView_rotated_T_23 =
    _outputBufferView_rotated_T_9[0]
      ? {buffer_0_brchFwd,
         buffer_7_addr,
         buffer_7_inst,
         buffer_7_brchFwd,
         buffer_6_addr,
         buffer_6_inst,
         buffer_6_brchFwd,
         buffer_5_addr,
         buffer_5_inst,
         buffer_5_brchFwd,
         buffer_4_addr,
         buffer_4_inst,
         buffer_4_brchFwd,
         buffer_3_addr,
         buffer_3_inst,
         buffer_3_brchFwd,
         buffer_2_addr,
         buffer_2_inst,
         buffer_2_brchFwd,
         buffer_1_addr,
         buffer_1_inst,
         buffer_1_brchFwd,
         buffer_0_addr,
         buffer_0_inst}
      : {buffer_7_addr,
         buffer_7_inst,
         buffer_7_brchFwd,
         buffer_6_addr,
         buffer_6_inst,
         buffer_6_brchFwd,
         buffer_5_addr,
         buffer_5_inst,
         buffer_5_brchFwd,
         buffer_4_addr,
         buffer_4_inst,
         buffer_4_brchFwd,
         buffer_3_addr,
         buffer_3_inst,
         buffer_3_brchFwd,
         buffer_2_addr,
         buffer_2_inst,
         buffer_2_brchFwd,
         buffer_1_addr,
         buffer_1_inst,
         buffer_1_brchFwd,
         buffer_0_addr,
         buffer_0_inst,
         buffer_0_brchFwd};
  wire [519:0] _outputBufferView_rotated_T_27 =
    _outputBufferView_rotated_T_9[1]
      ? {_outputBufferView_rotated_T_23[1:0], _outputBufferView_rotated_T_23[519:2]}
      : _outputBufferView_rotated_T_23;
  wire [519:0] _outputBufferView_rotated_T_31 =
    _outputBufferView_rotated_T_9[2]
      ? {_outputBufferView_rotated_T_27[3:0], _outputBufferView_rotated_T_27[519:4]}
      : _outputBufferView_rotated_T_27;
  wire [519:0] _outputBufferView_rotated_T_35 =
    _outputBufferView_rotated_T_9[3]
      ? {_outputBufferView_rotated_T_31[7:0], _outputBufferView_rotated_T_31[519:8]}
      : _outputBufferView_rotated_T_31;
  wire [519:0] _outputBufferView_rotated_T_39 =
    _outputBufferView_rotated_T_9[4]
      ? {_outputBufferView_rotated_T_35[15:0], _outputBufferView_rotated_T_35[519:16]}
      : _outputBufferView_rotated_T_35;
  wire [519:0] _outputBufferView_rotated_T_43 =
    _outputBufferView_rotated_T_9[5]
      ? {_outputBufferView_rotated_T_39[31:0], _outputBufferView_rotated_T_39[519:32]}
      : _outputBufferView_rotated_T_39;
  wire [519:0] _outputBufferView_rotated_T_47 =
    _outputBufferView_rotated_T_9[6]
      ? {_outputBufferView_rotated_T_43[63:0], _outputBufferView_rotated_T_43[519:64]}
      : _outputBufferView_rotated_T_43;
  wire [519:0] _outputBufferView_rotated_T_51 =
    _outputBufferView_rotated_T_9[7]
      ? {_outputBufferView_rotated_T_47[127:0], _outputBufferView_rotated_T_47[519:128]}
      : _outputBufferView_rotated_T_47;
  wire [519:0] _outputBufferView_rotated_T_55 =
    _outputBufferView_rotated_T_9[8]
      ? {_outputBufferView_rotated_T_51[255:0], _outputBufferView_rotated_T_51[519:256]}
      : _outputBufferView_rotated_T_51;
  wire [259:0] outputBufferView_rotated =
    _outputBufferView_rotated_T_9[9]
      ? {_outputBufferView_rotated_T_55[251:0], _outputBufferView_rotated_T_55[519:512]}
      : _outputBufferView_rotated_T_55[259:0];
  wire         expandedInput_2_ret_valid = io_enqValid > 3'h2;
  wire [9:0]   _rotatedInput_rotated_T_17 = {7'h0, enqPtr} * 10'h42;
  wire [527:0] _rotatedInput_rotated_T_31 =
    _rotatedInput_rotated_T_17[0]
      ? {263'h0,
         io_enqValid[2],
         io_enqData_3_addr,
         io_enqData_3_inst,
         io_enqData_3_brchFwd,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_inst,
         io_enqData_2_brchFwd,
         |(io_enqValid[2:1]),
         io_enqData_1_addr,
         io_enqData_1_inst,
         io_enqData_1_brchFwd,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_inst,
         io_enqData_0_brchFwd,
         1'h0}
      : {264'h0,
         io_enqValid[2],
         io_enqData_3_addr,
         io_enqData_3_inst,
         io_enqData_3_brchFwd,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_inst,
         io_enqData_2_brchFwd,
         |(io_enqValid[2:1]),
         io_enqData_1_addr,
         io_enqData_1_inst,
         io_enqData_1_brchFwd,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_inst,
         io_enqData_0_brchFwd};
  wire [527:0] _rotatedInput_rotated_T_35 =
    _rotatedInput_rotated_T_17[1]
      ? {_rotatedInput_rotated_T_31[525:0], _rotatedInput_rotated_T_31[527:526]}
      : _rotatedInput_rotated_T_31;
  wire [527:0] _rotatedInput_rotated_T_39 =
    _rotatedInput_rotated_T_17[2]
      ? {_rotatedInput_rotated_T_35[523:0], _rotatedInput_rotated_T_35[527:524]}
      : _rotatedInput_rotated_T_35;
  wire [527:0] _rotatedInput_rotated_T_43 =
    _rotatedInput_rotated_T_17[3]
      ? {_rotatedInput_rotated_T_39[519:0], _rotatedInput_rotated_T_39[527:520]}
      : _rotatedInput_rotated_T_39;
  wire [527:0] _rotatedInput_rotated_T_47 =
    _rotatedInput_rotated_T_17[4]
      ? {_rotatedInput_rotated_T_43[511:0], _rotatedInput_rotated_T_43[527:512]}
      : _rotatedInput_rotated_T_43;
  wire [527:0] _rotatedInput_rotated_T_51 =
    _rotatedInput_rotated_T_17[5]
      ? {_rotatedInput_rotated_T_47[495:0], _rotatedInput_rotated_T_47[527:496]}
      : _rotatedInput_rotated_T_47;
  wire [527:0] _rotatedInput_rotated_T_55 =
    _rotatedInput_rotated_T_17[6]
      ? {_rotatedInput_rotated_T_51[463:0], _rotatedInput_rotated_T_51[527:464]}
      : _rotatedInput_rotated_T_51;
  wire [527:0] _rotatedInput_rotated_T_59 =
    _rotatedInput_rotated_T_17[7]
      ? {_rotatedInput_rotated_T_55[399:0], _rotatedInput_rotated_T_55[527:400]}
      : _rotatedInput_rotated_T_55;
  wire [527:0] _rotatedInput_rotated_T_63 =
    _rotatedInput_rotated_T_17[8]
      ? {_rotatedInput_rotated_T_59[271:0], _rotatedInput_rotated_T_59[527:272]}
      : _rotatedInput_rotated_T_59;
  wire [527:0] rotatedInput_rotated =
    _rotatedInput_rotated_T_17[9]
      ? {_rotatedInput_rotated_T_63[15:0], _rotatedInput_rotated_T_63[527:16]}
      : _rotatedInput_rotated_T_63;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      buffer_0_addr <= 32'h0;
      buffer_0_inst <= 32'h0;
      buffer_0_brchFwd <= 1'h0;
      buffer_1_addr <= 32'h0;
      buffer_1_inst <= 32'h0;
      buffer_1_brchFwd <= 1'h0;
      buffer_2_addr <= 32'h0;
      buffer_2_inst <= 32'h0;
      buffer_2_brchFwd <= 1'h0;
      buffer_3_addr <= 32'h0;
      buffer_3_inst <= 32'h0;
      buffer_3_brchFwd <= 1'h0;
      buffer_4_addr <= 32'h0;
      buffer_4_inst <= 32'h0;
      buffer_4_brchFwd <= 1'h0;
      buffer_5_addr <= 32'h0;
      buffer_5_inst <= 32'h0;
      buffer_5_brchFwd <= 1'h0;
      buffer_6_addr <= 32'h0;
      buffer_6_inst <= 32'h0;
      buffer_6_brchFwd <= 1'h0;
      buffer_7_addr <= 32'h0;
      buffer_7_inst <= 32'h0;
      buffer_7_brchFwd <= 1'h0;
      enqPtr <= 3'h0;
      deqPtr <= 3'h0;
      nEnqueued <= 4'h0;
    end
    else begin
      if (rotatedInput_rotated[65]) begin
        buffer_0_addr <= rotatedInput_rotated[64:33];
        buffer_0_inst <= rotatedInput_rotated[32:1];
        buffer_0_brchFwd <= rotatedInput_rotated[0];
      end
      if (rotatedInput_rotated[131]) begin
        buffer_1_addr <= rotatedInput_rotated[130:99];
        buffer_1_inst <= rotatedInput_rotated[98:67];
        buffer_1_brchFwd <= rotatedInput_rotated[66];
      end
      if (rotatedInput_rotated[197]) begin
        buffer_2_addr <= rotatedInput_rotated[196:165];
        buffer_2_inst <= rotatedInput_rotated[164:133];
        buffer_2_brchFwd <= rotatedInput_rotated[132];
      end
      if (rotatedInput_rotated[263]) begin
        buffer_3_addr <= rotatedInput_rotated[262:231];
        buffer_3_inst <= rotatedInput_rotated[230:199];
        buffer_3_brchFwd <= rotatedInput_rotated[198];
      end
      if (rotatedInput_rotated[329]) begin
        buffer_4_addr <= rotatedInput_rotated[328:297];
        buffer_4_inst <= rotatedInput_rotated[296:265];
        buffer_4_brchFwd <= rotatedInput_rotated[264];
      end
      if (rotatedInput_rotated[395]) begin
        buffer_5_addr <= rotatedInput_rotated[394:363];
        buffer_5_inst <= rotatedInput_rotated[362:331];
        buffer_5_brchFwd <= rotatedInput_rotated[330];
      end
      if (rotatedInput_rotated[461]) begin
        buffer_6_addr <= rotatedInput_rotated[460:429];
        buffer_6_inst <= rotatedInput_rotated[428:397];
        buffer_6_brchFwd <= rotatedInput_rotated[396];
      end
      if (rotatedInput_rotated[527]) begin
        buffer_7_addr <= rotatedInput_rotated[526:495];
        buffer_7_inst <= rotatedInput_rotated[494:463];
        buffer_7_brchFwd <= rotatedInput_rotated[462];
      end
      enqPtr <= io_flush ? 3'h0 : enqPtr + io_enqValid;
      deqPtr <= io_flush ? 3'h0 : deqPtr + io_deqReady;
      nEnqueued <=
        io_flush ? 4'h0 : nEnqueued + {1'h0, io_enqValid} - {1'h0, io_deqReady};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:16];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h11; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        buffer_0_addr = _RANDOM[5'h0];
        buffer_0_inst = _RANDOM[5'h1];
        buffer_0_brchFwd = _RANDOM[5'h2][0];
        buffer_1_addr = {_RANDOM[5'h2][31:1], _RANDOM[5'h3][0]};
        buffer_1_inst = {_RANDOM[5'h3][31:1], _RANDOM[5'h4][0]};
        buffer_1_brchFwd = _RANDOM[5'h4][1];
        buffer_2_addr = {_RANDOM[5'h4][31:2], _RANDOM[5'h5][1:0]};
        buffer_2_inst = {_RANDOM[5'h5][31:2], _RANDOM[5'h6][1:0]};
        buffer_2_brchFwd = _RANDOM[5'h6][2];
        buffer_3_addr = {_RANDOM[5'h6][31:3], _RANDOM[5'h7][2:0]};
        buffer_3_inst = {_RANDOM[5'h7][31:3], _RANDOM[5'h8][2:0]};
        buffer_3_brchFwd = _RANDOM[5'h8][3];
        buffer_4_addr = {_RANDOM[5'h8][31:4], _RANDOM[5'h9][3:0]};
        buffer_4_inst = {_RANDOM[5'h9][31:4], _RANDOM[5'hA][3:0]};
        buffer_4_brchFwd = _RANDOM[5'hA][4];
        buffer_5_addr = {_RANDOM[5'hA][31:5], _RANDOM[5'hB][4:0]};
        buffer_5_inst = {_RANDOM[5'hB][31:5], _RANDOM[5'hC][4:0]};
        buffer_5_brchFwd = _RANDOM[5'hC][5];
        buffer_6_addr = {_RANDOM[5'hC][31:6], _RANDOM[5'hD][5:0]};
        buffer_6_inst = {_RANDOM[5'hD][31:6], _RANDOM[5'hE][5:0]};
        buffer_6_brchFwd = _RANDOM[5'hE][6];
        buffer_7_addr = {_RANDOM[5'hE][31:7], _RANDOM[5'hF][6:0]};
        buffer_7_inst = {_RANDOM[5'hF][31:7], _RANDOM[5'h10][6:0]};
        buffer_7_brchFwd = _RANDOM[5'h10][7];
        enqPtr = _RANDOM[5'h10][10:8];
        deqPtr = _RANDOM[5'h10][13:11];
        nEnqueued = _RANDOM[5'h10][17:14];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        buffer_0_addr = 32'h0;
        buffer_0_inst = 32'h0;
        buffer_0_brchFwd = 1'h0;
        buffer_1_addr = 32'h0;
        buffer_1_inst = 32'h0;
        buffer_1_brchFwd = 1'h0;
        buffer_2_addr = 32'h0;
        buffer_2_inst = 32'h0;
        buffer_2_brchFwd = 1'h0;
        buffer_3_addr = 32'h0;
        buffer_3_inst = 32'h0;
        buffer_3_brchFwd = 1'h0;
        buffer_4_addr = 32'h0;
        buffer_4_inst = 32'h0;
        buffer_4_brchFwd = 1'h0;
        buffer_5_addr = 32'h0;
        buffer_5_inst = 32'h0;
        buffer_5_brchFwd = 1'h0;
        buffer_6_addr = 32'h0;
        buffer_6_inst = 32'h0;
        buffer_6_brchFwd = 1'h0;
        buffer_7_addr = 32'h0;
        buffer_7_inst = 32'h0;
        buffer_7_brchFwd = 1'h0;
        enqPtr = 3'h0;
        deqPtr = 3'h0;
        nEnqueued = 4'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_nEnqueued = nEnqueued;
  assign io_nSpace = 4'h8 - nEnqueued;
  assign io_dataOut_0_addr = outputBufferView_rotated[64:33];
  assign io_dataOut_0_inst = outputBufferView_rotated[32:1];
  assign io_dataOut_0_brchFwd = outputBufferView_rotated[0];
  assign io_dataOut_1_addr = outputBufferView_rotated[129:98];
  assign io_dataOut_1_inst = outputBufferView_rotated[97:66];
  assign io_dataOut_1_brchFwd = outputBufferView_rotated[65];
  assign io_dataOut_2_addr = outputBufferView_rotated[194:163];
  assign io_dataOut_2_inst = outputBufferView_rotated[162:131];
  assign io_dataOut_2_brchFwd = outputBufferView_rotated[130];
  assign io_dataOut_3_addr = outputBufferView_rotated[259:228];
  assign io_dataOut_3_inst = outputBufferView_rotated[227:196];
  assign io_dataOut_3_brchFwd = outputBufferView_rotated[195];
endmodule

module InstructionBuffer(
  input         clock,
                reset,
  output [2:0]  io_feedIn_nReady,
  input  [2:0]  io_feedIn_nValid,
  input  [31:0] io_feedIn_bits_0_addr,
                io_feedIn_bits_0_inst,
  input         io_feedIn_bits_0_brchFwd,
  input  [31:0] io_feedIn_bits_1_addr,
                io_feedIn_bits_1_inst,
  input         io_feedIn_bits_1_brchFwd,
  input  [31:0] io_feedIn_bits_2_addr,
                io_feedIn_bits_2_inst,
  input         io_feedIn_bits_2_brchFwd,
  input  [31:0] io_feedIn_bits_3_addr,
                io_feedIn_bits_3_inst,
  input         io_feedIn_bits_3_brchFwd,
                io_out_0_ready,
  output        io_out_0_valid,
  output [31:0] io_out_0_bits_addr,
                io_out_0_bits_inst,
  output        io_out_0_bits_brchFwd,
  input         io_out_1_ready,
  output        io_out_1_valid,
  output [31:0] io_out_1_bits_addr,
                io_out_1_bits_inst,
  output        io_out_1_bits_brchFwd,
  input         io_out_2_ready,
  output        io_out_2_valid,
  output [31:0] io_out_2_bits_addr,
                io_out_2_bits_inst,
  output        io_out_2_bits_brchFwd,
  input         io_out_3_ready,
  output        io_out_3_valid,
  output [31:0] io_out_3_bits_addr,
                io_out_3_bits_inst,
  output        io_out_3_bits_brchFwd,
  input         io_flush,
  output [3:0]  io_nEnqueued,
                io_nSpace
);

  wire [3:0] _circularBuffer_io_nEnqueued;
  wire [3:0] _circularBuffer_io_nSpace;
  wire       io_out_0_valid_0 = (|_circularBuffer_io_nEnqueued) & ~io_flush;
  wire       io_out_1_valid_0 = (|(_circularBuffer_io_nEnqueued[3:1])) & ~io_flush;
  wire       io_out_2_valid_0 = _circularBuffer_io_nEnqueued > 4'h2 & ~io_flush;
  wire       io_out_3_valid_0 = (|(_circularBuffer_io_nEnqueued[3:2])) & ~io_flush;
  wire       _nReady_T = io_out_0_ready & io_out_0_valid_0;
  wire       _nReady_T_1 = io_out_1_ready & io_out_1_valid_0;
  wire       _nReady_T_2 = io_out_2_ready & io_out_2_valid_0;
  wire       _nReady_T_3 = io_out_3_ready & io_out_3_valid_0;
  CircularBufferMulti circularBuffer (
    .clock                (clock),
    .reset                (reset),
    .io_enqValid          (io_feedIn_nValid),
    .io_enqData_0_addr    (io_feedIn_bits_0_addr),
    .io_enqData_0_inst    (io_feedIn_bits_0_inst),
    .io_enqData_0_brchFwd (io_feedIn_bits_0_brchFwd),
    .io_enqData_1_addr    (io_feedIn_bits_1_addr),
    .io_enqData_1_inst    (io_feedIn_bits_1_inst),
    .io_enqData_1_brchFwd (io_feedIn_bits_1_brchFwd),
    .io_enqData_2_addr    (io_feedIn_bits_2_addr),
    .io_enqData_2_inst    (io_feedIn_bits_2_inst),
    .io_enqData_2_brchFwd (io_feedIn_bits_2_brchFwd),
    .io_enqData_3_addr    (io_feedIn_bits_3_addr),
    .io_enqData_3_inst    (io_feedIn_bits_3_inst),
    .io_enqData_3_brchFwd (io_feedIn_bits_3_brchFwd),
    .io_nEnqueued         (_circularBuffer_io_nEnqueued),
    .io_nSpace            (_circularBuffer_io_nSpace),
    .io_dataOut_0_addr    (io_out_0_bits_addr),
    .io_dataOut_0_inst    (io_out_0_bits_inst),
    .io_dataOut_0_brchFwd (io_out_0_bits_brchFwd),
    .io_dataOut_1_addr    (io_out_1_bits_addr),
    .io_dataOut_1_inst    (io_out_1_bits_inst),
    .io_dataOut_1_brchFwd (io_out_1_bits_brchFwd),
    .io_dataOut_2_addr    (io_out_2_bits_addr),
    .io_dataOut_2_inst    (io_out_2_bits_inst),
    .io_dataOut_2_brchFwd (io_out_2_bits_brchFwd),
    .io_dataOut_3_addr    (io_out_3_bits_addr),
    .io_dataOut_3_inst    (io_out_3_bits_inst),
    .io_dataOut_3_brchFwd (io_out_3_bits_brchFwd),
    .io_deqReady
      ({1'h0, {1'h0, _nReady_T} + {1'h0, _nReady_T_1}}
       + {1'h0, {1'h0, _nReady_T_2} + {1'h0, _nReady_T_3}}),
    .io_flush             (io_flush)
  );
  assign io_feedIn_nReady =
    _circularBuffer_io_nSpace < 4'h4 ? _circularBuffer_io_nSpace[2:0] : 3'h4;
  assign io_out_0_valid = io_out_0_valid_0;
  assign io_out_1_valid = io_out_1_valid_0;
  assign io_out_2_valid = io_out_2_valid_0;
  assign io_out_3_valid = io_out_3_valid_0;
  assign io_nEnqueued = _circularBuffer_io_nEnqueued;
  assign io_nSpace = _circularBuffer_io_nSpace;
endmodule

module UncachedFetch(
  input          clock,
                 reset,
  input  [31:0]  io_csr_value_0,
  output         io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
                 io_inst_lanes_0_ready,
  output         io_inst_lanes_0_valid,
  output [31:0]  io_inst_lanes_0_bits_addr,
                 io_inst_lanes_0_bits_inst,
  output         io_inst_lanes_0_bits_brchFwd,
  input          io_inst_lanes_1_ready,
  output         io_inst_lanes_1_valid,
  output [31:0]  io_inst_lanes_1_bits_addr,
                 io_inst_lanes_1_bits_inst,
  output         io_inst_lanes_1_bits_brchFwd,
  input          io_inst_lanes_2_ready,
  output         io_inst_lanes_2_valid,
  output [31:0]  io_inst_lanes_2_bits_addr,
                 io_inst_lanes_2_bits_inst,
  output         io_inst_lanes_2_bits_brchFwd,
  input          io_inst_lanes_3_ready,
  output         io_inst_lanes_3_valid,
  output [31:0]  io_inst_lanes_3_bits_addr,
                 io_inst_lanes_3_bits_inst,
  output         io_inst_lanes_3_bits_brchFwd,
  input          io_branch_0_valid,
  input  [31:0]  io_branch_0_value,
  input          io_branch_1_valid,
  input  [31:0]  io_branch_1_value,
  input          io_branch_2_valid,
  input  [31:0]  io_branch_2_value,
  input          io_branch_3_valid,
  input  [31:0]  io_branch_3_value,
  input          io_iflush_valid,
  input  [31:0]  io_iflush_pcNext,
  output [31:0]  io_pc,
  output         io_fault_valid,
  output [31:0]  io_fault_bits
);

  wire        _instructionBuffer_io_out_0_valid;
  wire [31:0] _instructionBuffer_io_out_0_bits_addr;
  wire [3:0]  _instructionBuffer_io_nSpace;
  wire        _fetcher_io_fetch_valid;
  wire [31:0] _fetcher_io_fetch_bits_addr;
  wire [31:0] _fetcher_io_fetch_bits_inst_0;
  wire [31:0] _fetcher_io_fetch_bits_inst_1;
  wire [31:0] _fetcher_io_fetch_bits_inst_2;
  wire [31:0] _fetcher_io_fetch_bits_inst_3;
  wire        _fetcher_io_fetch_bits_fault;
  wire        _ctrl_io_fetchAddr_valid;
  wire [31:0] _ctrl_io_fetchAddr_bits;
  wire [2:0]  _ctrl_io_bufferRequest_nValid;
  wire [31:0] _ctrl_io_bufferRequest_bits_0_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_0_inst;
  wire        _ctrl_io_bufferRequest_bits_0_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_1_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_1_inst;
  wire        _ctrl_io_bufferRequest_bits_1_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_2_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_2_inst;
  wire        _ctrl_io_bufferRequest_bits_2_brchFwd;
  wire [31:0] _ctrl_io_bufferRequest_bits_3_addr;
  wire [31:0] _ctrl_io_bufferRequest_bits_3_inst;
  wire        _ctrl_io_bufferRequest_bits_3_brchFwd;
  wire        branch_valid =
    io_branch_0_valid | io_branch_1_valid | io_branch_2_valid | io_branch_3_valid;
  reg  [31:0] pc;
  always @(posedge clock or posedge reset) begin
    if (reset)
      pc <= 32'h0;
    else if (_instructionBuffer_io_out_0_valid)
      pc <= _instructionBuffer_io_out_0_bits_addr;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        pc = _RANDOM[/*Zero width*/ 1'b0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        pc = 32'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  FetchControl ctrl (
    .clock                           (clock),
    .reset                           (reset),
    .io_fetchFault_valid             (io_fault_valid),
    .io_fetchFault_bits              (io_fault_bits),
    .io_csr_value_0                  (io_csr_value_0),
    .io_iflush_valid                 (io_iflush_valid),
    .io_iflush_bits                  (io_iflush_valid ? io_iflush_pcNext : 32'h0),
    .io_branch_valid                 (branch_valid),
    .io_branch_bits
      (io_branch_0_valid
         ? io_branch_0_value
         : io_branch_1_valid
             ? io_branch_1_value
             : io_branch_2_valid
                 ? io_branch_2_value
                 : io_branch_3_valid ? io_branch_3_value : 32'h0),
    .io_fetchData_valid              (_fetcher_io_fetch_valid),
    .io_fetchData_bits_addr          (_fetcher_io_fetch_bits_addr),
    .io_fetchData_bits_inst_0        (_fetcher_io_fetch_bits_inst_0),
    .io_fetchData_bits_inst_1        (_fetcher_io_fetch_bits_inst_1),
    .io_fetchData_bits_inst_2        (_fetcher_io_fetch_bits_inst_2),
    .io_fetchData_bits_inst_3        (_fetcher_io_fetch_bits_inst_3),
    .io_fetchData_bits_fault         (_fetcher_io_fetch_bits_fault),
    .io_fetchAddr_valid              (_ctrl_io_fetchAddr_valid),
    .io_fetchAddr_bits               (_ctrl_io_fetchAddr_bits),
    .io_bufferRequest_nValid         (_ctrl_io_bufferRequest_nValid),
    .io_bufferRequest_bits_0_addr    (_ctrl_io_bufferRequest_bits_0_addr),
    .io_bufferRequest_bits_0_inst    (_ctrl_io_bufferRequest_bits_0_inst),
    .io_bufferRequest_bits_0_brchFwd (_ctrl_io_bufferRequest_bits_0_brchFwd),
    .io_bufferRequest_bits_1_addr    (_ctrl_io_bufferRequest_bits_1_addr),
    .io_bufferRequest_bits_1_inst    (_ctrl_io_bufferRequest_bits_1_inst),
    .io_bufferRequest_bits_1_brchFwd (_ctrl_io_bufferRequest_bits_1_brchFwd),
    .io_bufferRequest_bits_2_addr    (_ctrl_io_bufferRequest_bits_2_addr),
    .io_bufferRequest_bits_2_inst    (_ctrl_io_bufferRequest_bits_2_inst),
    .io_bufferRequest_bits_2_brchFwd (_ctrl_io_bufferRequest_bits_2_brchFwd),
    .io_bufferRequest_bits_3_addr    (_ctrl_io_bufferRequest_bits_3_addr),
    .io_bufferRequest_bits_3_inst    (_ctrl_io_bufferRequest_bits_3_inst),
    .io_bufferRequest_bits_3_brchFwd (_ctrl_io_bufferRequest_bits_3_brchFwd),
    .io_bufferSpaces                 (_instructionBuffer_io_nSpace)
  );
  Fetcher fetcher (
    .clock                (clock),
    .reset                (reset),
    .io_ctrl_valid        (_ctrl_io_fetchAddr_valid),
    .io_ctrl_bits         (_ctrl_io_fetchAddr_bits),
    .io_fetch_valid       (_fetcher_io_fetch_valid),
    .io_fetch_bits_addr   (_fetcher_io_fetch_bits_addr),
    .io_fetch_bits_inst_0 (_fetcher_io_fetch_bits_inst_0),
    .io_fetch_bits_inst_1 (_fetcher_io_fetch_bits_inst_1),
    .io_fetch_bits_inst_2 (_fetcher_io_fetch_bits_inst_2),
    .io_fetch_bits_inst_3 (_fetcher_io_fetch_bits_inst_3),
    .io_fetch_bits_fault  (_fetcher_io_fetch_bits_fault),
    .io_ibus_valid        (io_ibus_valid),
    .io_ibus_ready        (io_ibus_ready),
    .io_ibus_addr         (io_ibus_addr),
    .io_ibus_rdata        (io_ibus_rdata),
    .io_ibus_fault_valid  (io_ibus_fault_valid)
  );
  InstructionBuffer instructionBuffer (
    .clock                    (clock),
    .reset                    (reset),
    .io_feedIn_nReady         (/* unused */),
    .io_feedIn_nValid         (_ctrl_io_bufferRequest_nValid),
    .io_feedIn_bits_0_addr    (_ctrl_io_bufferRequest_bits_0_addr),
    .io_feedIn_bits_0_inst    (_ctrl_io_bufferRequest_bits_0_inst),
    .io_feedIn_bits_0_brchFwd (_ctrl_io_bufferRequest_bits_0_brchFwd),
    .io_feedIn_bits_1_addr    (_ctrl_io_bufferRequest_bits_1_addr),
    .io_feedIn_bits_1_inst    (_ctrl_io_bufferRequest_bits_1_inst),
    .io_feedIn_bits_1_brchFwd (_ctrl_io_bufferRequest_bits_1_brchFwd),
    .io_feedIn_bits_2_addr    (_ctrl_io_bufferRequest_bits_2_addr),
    .io_feedIn_bits_2_inst    (_ctrl_io_bufferRequest_bits_2_inst),
    .io_feedIn_bits_2_brchFwd (_ctrl_io_bufferRequest_bits_2_brchFwd),
    .io_feedIn_bits_3_addr    (_ctrl_io_bufferRequest_bits_3_addr),
    .io_feedIn_bits_3_inst    (_ctrl_io_bufferRequest_bits_3_inst),
    .io_feedIn_bits_3_brchFwd (_ctrl_io_bufferRequest_bits_3_brchFwd),
    .io_out_0_ready           (io_inst_lanes_0_ready),
    .io_out_0_valid           (_instructionBuffer_io_out_0_valid),
    .io_out_0_bits_addr       (_instructionBuffer_io_out_0_bits_addr),
    .io_out_0_bits_inst       (io_inst_lanes_0_bits_inst),
    .io_out_0_bits_brchFwd    (io_inst_lanes_0_bits_brchFwd),
    .io_out_1_ready           (io_inst_lanes_1_ready),
    .io_out_1_valid           (io_inst_lanes_1_valid),
    .io_out_1_bits_addr       (io_inst_lanes_1_bits_addr),
    .io_out_1_bits_inst       (io_inst_lanes_1_bits_inst),
    .io_out_1_bits_brchFwd    (io_inst_lanes_1_bits_brchFwd),
    .io_out_2_ready           (io_inst_lanes_2_ready),
    .io_out_2_valid           (io_inst_lanes_2_valid),
    .io_out_2_bits_addr       (io_inst_lanes_2_bits_addr),
    .io_out_2_bits_inst       (io_inst_lanes_2_bits_inst),
    .io_out_2_bits_brchFwd    (io_inst_lanes_2_bits_brchFwd),
    .io_out_3_ready           (io_inst_lanes_3_ready),
    .io_out_3_valid           (io_inst_lanes_3_valid),
    .io_out_3_bits_addr       (io_inst_lanes_3_bits_addr),
    .io_out_3_bits_inst       (io_inst_lanes_3_bits_inst),
    .io_out_3_bits_brchFwd    (io_inst_lanes_3_bits_brchFwd),
    .io_flush                 (io_iflush_valid | branch_valid),
    .io_nEnqueued             (/* unused */),
    .io_nSpace                (_instructionBuffer_io_nSpace)
  );
  assign io_inst_lanes_0_valid = _instructionBuffer_io_out_0_valid;
  assign io_inst_lanes_0_bits_addr = _instructionBuffer_io_out_0_bits_addr;
  assign io_pc = pc;
endmodule

module Csr(
  input         clock,
                reset,
  input  [31:0] io_csr_in_value_12,
  output [31:0] io_csr_out_value_0,
                io_csr_out_value_1,
                io_csr_out_value_2,
                io_csr_out_value_3,
                io_csr_out_value_4,
                io_csr_out_value_5,
                io_csr_out_value_6,
                io_csr_out_value_7,
                io_csr_out_value_8,
  input         io_req_valid,
  input  [4:0]  io_req_bits_addr,
  input  [11:0] io_req_bits_index,
  input  [4:0]  io_req_bits_rs1,
  input  [1:0]  io_req_bits_op,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  input         io_bru_in_mode_valid,
  input  [1:0]  io_bru_in_mode_bits,
  input         io_bru_in_mcause_valid,
  input  [31:0] io_bru_in_mcause_bits,
  input         io_bru_in_mepc_valid,
  input  [31:0] io_bru_in_mepc_bits,
  input         io_bru_in_mtval_valid,
  input  [31:0] io_bru_in_mtval_bits,
  input         io_bru_in_halt,
                io_bru_in_fault,
                io_bru_in_wfi,
  output [1:0]  io_bru_out_mode,
  output [31:0] io_bru_out_mepc,
                io_bru_out_mtvec,
  input         io_float_in_fflags_valid,
  input  [4:0]  io_float_in_fflags_bits,
  output [2:0]  io_float_out_frm,
  input  [6:0]  io_rvv_vstart,
                io_rvv_vl,
  input  [31:0] io_rvv_vtype,
  input  [1:0]  io_rvv_vxrm,
  input         io_rvv_vxsat,
  output        io_rvv_vstart_write_valid,
  output [6:0]  io_rvv_vstart_write_bits,
  output        io_rvv_vxrm_write_valid,
  output [1:0]  io_rvv_vxrm_write_bits,
  output        io_rvv_vxsat_write_valid,
                io_rvv_vxsat_write_bits,
  output [2:0]  io_rvv_frm,
  input  [3:0]  io_counters_nRetired,
  output        io_halted,
                io_fault,
                io_wfi,
  input         io_irq
);

  reg              req_valid;
  reg  [4:0]       req_bits_addr;
  reg  [11:0]      req_bits_index;
  reg  [4:0]       req_bits_rs1;
  reg  [1:0]       req_bits_op;
  reg              halted;
  reg              fault;
  reg              wfi;
  reg  [1:0]       mode;
  reg  [31:0]      mpc;
  reg  [31:0]      msp;
  reg  [31:0]      mcause;
  reg  [31:0]      mtval;
  reg  [31:0]      mcontext0;
  reg  [31:0]      mcontext1;
  reg  [31:0]      mcontext2;
  reg  [31:0]      mcontext3;
  reg  [31:0]      mcontext4;
  reg  [31:0]      mcontext5;
  reg  [31:0]      mcontext6;
  reg  [31:0]      mcontext7;
  reg  [4:0]       fflags;
  reg  [2:0]       frm;
  reg              mie;
  reg  [31:0]      mtvec;
  reg  [31:0]      mscratch;
  reg  [31:0]      mepc;
  reg  [1:0]       mpp;
  reg  [63:0]      mcycle;
  reg  [63:0]      minstret;
  wire             fflagsEn = req_bits_index == 12'h1;
  wire             frmEn = req_bits_index == 12'h2;
  wire             fcsrEn = req_bits_index == 12'h3;
  wire             vstartEn = req_bits_index == 12'h8;
  wire             vxsatEn = req_bits_index == 12'h9;
  wire             vxrmEn = req_bits_index == 12'hA;
  wire             mstatusEn = req_bits_index == 12'h300;
  wire             misaEn = req_bits_index == 12'h301;
  wire             mieEn = req_bits_index == 12'h304;
  wire             mtvecEn = req_bits_index == 12'h305;
  wire             mscratchEn = req_bits_index == 12'h340;
  wire             mepcEn = req_bits_index == 12'h341;
  wire             mcauseEn = req_bits_index == 12'h342;
  wire             mtvalEn = req_bits_index == 12'h343;
  wire             mcontext0En = req_bits_index == 12'h7C0;
  wire             mcontext1En = req_bits_index == 12'h7C1;
  wire             mcontext2En = req_bits_index == 12'h7C2;
  wire             mcontext3En = req_bits_index == 12'h7C3;
  wire             mcontext4En = req_bits_index == 12'h7C4;
  wire             mcontext5En = req_bits_index == 12'h7C5;
  wire             mcontext6En = req_bits_index == 12'h7C6;
  wire             mcontext7En = req_bits_index == 12'h7C7;
  wire             mpcEn = req_bits_index == 12'h7E0;
  wire             mspEn = req_bits_index == 12'h7E1;
  wire             mcycleEn = req_bits_index == 12'hB00;
  wire             minstretEn = req_bits_index == 12'hB02;
  wire             mcyclehEn = req_bits_index == 12'hB80;
  wire             minstrethEn = req_bits_index == 12'hB82;
  wire             vlEn = req_bits_index == 12'hC20;
  wire             vtypeEn = req_bits_index == 12'hC21;
  wire             vlenbEn = req_bits_index == 12'hC22;
  wire             mvendoridEn = req_bits_index == 12'hF11;
  wire             kscm0En = req_bits_index == 12'hFC4;
  wire             kscm1En = req_bits_index == 12'hFC8;
  wire             kscm2En = req_bits_index == 12'hFCC;
  wire             kscm3En = req_bits_index == 12'hFD0;
  wire             kscm4En = req_bits_index == 12'hFD4;
  wire [31:0]      _rdata_T_174 =
    (fflagsEn ? {27'h0, fflags} : 32'h0) | (frmEn ? {29'h0, frm} : 32'h0)
    | (fcsrEn ? {24'h0, frm, fflags} : 32'h0)
    | (mstatusEn ? {19'h1, mpp, 11'h200} : 32'h0) | (misaEn ? 32'h40201120 : 32'h0)
    | (mieEn ? {31'h0, mie} : 32'h0) | (mtvecEn ? mtvec : 32'h0)
    | (mscratchEn ? mscratch : 32'h0) | (mepcEn ? mepc : 32'h0)
    | (mcauseEn ? mcause : 32'h0) | (mtvalEn ? mtval : 32'h0)
    | (mcontext0En ? mcontext0 : 32'h0) | (mcontext1En ? mcontext1 : 32'h0)
    | (mcontext2En ? mcontext2 : 32'h0) | (mcontext3En ? mcontext3 : 32'h0)
    | (mcontext4En ? mcontext4 : 32'h0) | (mcontext5En ? mcontext5 : 32'h0)
    | (mcontext6En ? mcontext6 : 32'h0) | (mcontext7En ? mcontext7 : 32'h0)
    | (mpcEn ? mpc : 32'h0) | (mspEn ? msp : 32'h0) | (mcycleEn ? mcycle[31:0] : 32'h0)
    | (mcyclehEn ? mcycle[63:32] : 32'h0) | (minstretEn ? minstret[31:0] : 32'h0)
    | (minstrethEn ? minstret[63:32] : 32'h0) | (mvendoridEn ? 32'h426 : 32'h0)
    | (kscm0En ? 32'hC677ABF9 : 32'h0) | (kscm1En ? 32'h485F73DF : 32'h0)
    | (kscm2En ? 32'h9A667D05 : 32'h0) | (kscm3En ? 32'h3579B71C : 32'h0)
    | (kscm4En ? 32'h3B3AFC6A : 32'h0);
  wire [31:0]      _rdata_T_177 =
    {_rdata_T_174[31:7],
     _rdata_T_174[6:0] | (vstartEn ? io_rvv_vstart : 7'h0) | (vlEn ? io_rvv_vl : 7'h0)}
    | (vtypeEn ? io_rvv_vtype : 32'h0);
  wire [1:0]       _GEN = _rdata_T_177[1:0] | (vxrmEn ? io_rvv_vxrm : 2'h0);
  wire [31:0]      rdata =
    {_rdata_T_177[31:2], _GEN[1], _GEN[0] | vxsatEn & io_rvv_vxsat}
    | {27'h0, vlenbEn, 4'h0};
  wire [3:0][31:0] _GEN_0 =
    {{32'h0}, {rdata & ~io_rs1_data}, {rdata | io_rs1_data}, {io_rs1_data}};
  wire [31:0]      wdata = _GEN_0[req_bits_op];
  wire             is_csr_write =
    req_valid & ~((|{req_bits_op == 2'h2, req_bits_op == 2'h1}) & req_bits_rs1 == 5'h0);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      req_valid <= 1'h0;
      req_bits_addr <= 5'h0;
      req_bits_index <= 12'h0;
      req_bits_rs1 <= 5'h0;
      req_bits_op <= 2'h0;
      halted <= 1'h0;
      fault <= 1'h0;
      wfi <= 1'h0;
      mode <= 2'h0;
      mpc <= 32'h0;
      msp <= 32'h0;
      mcause <= 32'h0;
      mtval <= 32'h0;
      mcontext0 <= 32'h0;
      mcontext1 <= 32'h0;
      mcontext2 <= 32'h0;
      mcontext3 <= 32'h0;
      mcontext4 <= 32'h0;
      mcontext5 <= 32'h0;
      mcontext6 <= 32'h0;
      mcontext7 <= 32'h0;
      fflags <= 5'h0;
      frm <= 3'h0;
      mie <= 1'h0;
      mtvec <= 32'h0;
      mscratch <= 32'h0;
      mepc <= 32'h0;
      mpp <= 2'h0;
      mcycle <= 64'h0;
      minstret <= 64'h0;
    end
    else begin
      req_valid <= io_req_valid;
      if (io_req_valid) begin
        req_bits_addr <= io_req_bits_addr;
        req_bits_index <= io_req_bits_index;
        req_bits_rs1 <= io_req_bits_rs1;
        req_bits_op <= io_req_bits_op;
      end
      halted <= io_bru_in_halt | halted;
      fault <= io_bru_in_fault | fault;
      if (wfi)
        wfi <= ~io_irq;
      else
        wfi <= io_bru_in_wfi;
      if (io_bru_in_mode_valid)
        mode <= io_bru_in_mode_bits;
      if (req_valid & mpcEn)
        mpc <= wdata;
      if (req_valid & mspEn)
        msp <= wdata;
      if (io_bru_in_mcause_valid)
        mcause <= io_bru_in_mcause_bits;
      else if (req_valid & mcauseEn)
        mcause <= wdata;
      if (io_bru_in_mtval_valid)
        mtval <= io_bru_in_mtval_bits;
      else if (req_valid & mtvalEn)
        mtval <= wdata;
      if (req_valid & mcontext0En)
        mcontext0 <= wdata;
      if (req_valid & mcontext1En)
        mcontext1 <= wdata;
      if (req_valid & mcontext2En)
        mcontext2 <= wdata;
      if (req_valid & mcontext3En)
        mcontext3 <= wdata;
      if (req_valid & mcontext4En)
        mcontext4 <= wdata;
      if (req_valid & mcontext5En)
        mcontext5 <= wdata;
      if (req_valid & mcontext6En)
        mcontext6 <= wdata;
      if (req_valid & mcontext7En)
        mcontext7 <= wdata;
      if (io_float_in_fflags_valid)
        fflags <= io_float_in_fflags_bits | fflags;
      else if (req_valid) begin
        if (fcsrEn)
          fflags <= wdata[4:0];
        else if (fflagsEn)
          fflags <= wdata[4:0];
      end
      if (req_valid) begin
        if (fcsrEn)
          frm <= wdata[7:5];
        else if (frmEn)
          frm <= wdata[2:0];
      end
      if (req_valid & mieEn)
        mie <= wdata[0];
      if (req_valid & mtvecEn)
        mtvec <= wdata;
      if (req_valid & mscratchEn)
        mscratch <= wdata;
      if (io_bru_in_mepc_valid)
        mepc <= io_bru_in_mepc_bits;
      else if (req_valid & mepcEn)
        mepc <= wdata;
      if (req_valid & mstatusEn)
        mpp <= wdata[12:11];
      mcycle <=
        is_csr_write & (mcycleEn | mcyclehEn)
          ? {mcyclehEn ? wdata : mcycle[63:32], mcycleEn ? wdata : mcycle[31:0]}
          : mcycle + 64'h1;
      minstret <=
        is_csr_write & (minstretEn | minstrethEn)
          ? {minstrethEn ? wdata : minstret[63:32], minstretEn ? wdata : minstret[31:0]}
          : minstret + {60'h0, io_counters_nRetired};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:21];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h16; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        req_valid = _RANDOM[5'h0][0];
        req_bits_addr = _RANDOM[5'h0][5:1];
        req_bits_index = _RANDOM[5'h0][17:6];
        req_bits_rs1 = _RANDOM[5'h0][22:18];
        req_bits_op = _RANDOM[5'h0][24:23];
        halted = _RANDOM[5'h0][25];
        fault = _RANDOM[5'h0][26];
        wfi = _RANDOM[5'h0][27];
        mode = _RANDOM[5'h0][29:28];
        mpc = {_RANDOM[5'h0][31:30], _RANDOM[5'h1][29:0]};
        msp = {_RANDOM[5'h1][31:30], _RANDOM[5'h2][29:0]};
        mcause = {_RANDOM[5'h2][31:30], _RANDOM[5'h3][29:0]};
        mtval = {_RANDOM[5'h3][31:30], _RANDOM[5'h4][29:0]};
        mcontext0 = {_RANDOM[5'h4][31:30], _RANDOM[5'h5][29:0]};
        mcontext1 = {_RANDOM[5'h5][31:30], _RANDOM[5'h6][29:0]};
        mcontext2 = {_RANDOM[5'h6][31:30], _RANDOM[5'h7][29:0]};
        mcontext3 = {_RANDOM[5'h7][31:30], _RANDOM[5'h8][29:0]};
        mcontext4 = {_RANDOM[5'h8][31:30], _RANDOM[5'h9][29:0]};
        mcontext5 = {_RANDOM[5'h9][31:30], _RANDOM[5'hA][29:0]};
        mcontext6 = {_RANDOM[5'hA][31:30], _RANDOM[5'hB][29:0]};
        mcontext7 = {_RANDOM[5'hB][31:30], _RANDOM[5'hC][29:0]};
        fflags = {_RANDOM[5'hC][31:30], _RANDOM[5'hD][2:0]};
        frm = _RANDOM[5'hD][5:3];
        mie = _RANDOM[5'hD][6];
        mtvec = {_RANDOM[5'hD][31:7], _RANDOM[5'hE][6:0]};
        mscratch = {_RANDOM[5'hE][31:7], _RANDOM[5'hF][6:0]};
        mepc = {_RANDOM[5'hF][31:7], _RANDOM[5'h10][6:0]};
        mpp = _RANDOM[5'h10][8:7];
        mcycle = {_RANDOM[5'h11][31:9], _RANDOM[5'h12], _RANDOM[5'h13][8:0]};
        minstret = {_RANDOM[5'h13][31:9], _RANDOM[5'h14], _RANDOM[5'h15][8:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        req_valid = 1'h0;
        req_bits_addr = 5'h0;
        req_bits_index = 12'h0;
        req_bits_rs1 = 5'h0;
        req_bits_op = 2'h0;
        halted = 1'h0;
        fault = 1'h0;
        wfi = 1'h0;
        mode = 2'h0;
        mpc = 32'h0;
        msp = 32'h0;
        mcause = 32'h0;
        mtval = 32'h0;
        mcontext0 = 32'h0;
        mcontext1 = 32'h0;
        mcontext2 = 32'h0;
        mcontext3 = 32'h0;
        mcontext4 = 32'h0;
        mcontext5 = 32'h0;
        mcontext6 = 32'h0;
        mcontext7 = 32'h0;
        fflags = 5'h0;
        frm = 3'h0;
        mie = 1'h0;
        mtvec = 32'h0;
        mscratch = 32'h0;
        mepc = 32'h0;
        mpp = 2'h0;
        mcycle = 64'h0;
        minstret = 64'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_csr_out_value_0 = io_csr_in_value_12;
  assign io_csr_out_value_1 = mepc;
  assign io_csr_out_value_2 = mtval;
  assign io_csr_out_value_3 = mcause;
  assign io_csr_out_value_4 = mcycle[31:0];
  assign io_csr_out_value_5 = mcycle[63:32];
  assign io_csr_out_value_6 = minstret[31:0];
  assign io_csr_out_value_7 = minstret[63:32];
  assign io_csr_out_value_8 = mcontext0;
  assign io_rd_valid = req_valid;
  assign io_rd_bits_addr = req_bits_addr;
  assign io_rd_bits_data = rdata;
  assign io_bru_out_mode = mode;
  assign io_bru_out_mepc = mepcEn & req_valid ? wdata : mepc;
  assign io_bru_out_mtvec = mtvecEn & req_valid ? wdata : mtvec;
  assign io_float_out_frm = frmEn & req_valid ? wdata[2:0] : frm;
  assign io_rvv_vstart_write_valid = req_valid & vstartEn;
  assign io_rvv_vstart_write_bits = wdata[6:0];
  assign io_rvv_vxrm_write_valid = req_valid & vxrmEn;
  assign io_rvv_vxrm_write_bits = wdata[1:0];
  assign io_rvv_vxsat_write_valid = req_valid & vxsatEn;
  assign io_rvv_vxsat_write_bits = wdata[0];
  assign io_rvv_frm = frm;
  assign io_halted = halted;
  assign io_fault = fault;
  assign io_wfi = wfi;
endmodule

module DispatchV2(
  input         clock,
                reset,
                io_halted,
                io_lsuActive,
  input  [31:0] io_scoreboard_regd,
                io_scoreboard_comb,
                io_fscoreboard,
  input         io_branchTaken,
  output        io_csrFault_0,
                io_jalFault_0,
                io_jalFault_1,
                io_jalFault_2,
                io_jalFault_3,
                io_jalrFault_0,
                io_jalrFault_1,
                io_jalrFault_2,
                io_jalrFault_3,
                io_bxxFault_0,
                io_bxxFault_1,
                io_bxxFault_2,
                io_bxxFault_3,
                io_undefFault_0,
                io_rvvFault_0,
  output [31:0] io_bruTarget_0,
                io_bruTarget_1,
                io_bruTarget_2,
                io_bruTarget_3,
  input  [31:0] io_jalrTarget_0_data,
                io_jalrTarget_1_data,
                io_jalrTarget_2_data,
                io_jalrTarget_3_data,
  input         io_interlock,
  output        io_inst_0_ready,
  input         io_inst_0_valid,
  input  [31:0] io_inst_0_bits_addr,
                io_inst_0_bits_inst,
  input         io_inst_0_bits_brchFwd,
  output        io_inst_1_ready,
  input         io_inst_1_valid,
  input  [31:0] io_inst_1_bits_addr,
                io_inst_1_bits_inst,
  input         io_inst_1_bits_brchFwd,
  output        io_inst_2_ready,
  input         io_inst_2_valid,
  input  [31:0] io_inst_2_bits_addr,
                io_inst_2_bits_inst,
  input         io_inst_2_bits_brchFwd,
  output        io_inst_3_ready,
  input         io_inst_3_valid,
  input  [31:0] io_inst_3_bits_addr,
                io_inst_3_bits_inst,
  input         io_inst_3_bits_brchFwd,
  output        io_rs1Read_0_valid,
  output [4:0]  io_rs1Read_0_addr,
  output        io_rs1Read_1_valid,
  output [4:0]  io_rs1Read_1_addr,
  output        io_rs1Read_2_valid,
  output [4:0]  io_rs1Read_2_addr,
  output        io_rs1Read_3_valid,
  output [4:0]  io_rs1Read_3_addr,
  output        io_rs1Set_0_valid,
  output [31:0] io_rs1Set_0_value,
  output        io_rs1Set_1_valid,
  output [31:0] io_rs1Set_1_value,
  output        io_rs1Set_2_valid,
  output [31:0] io_rs1Set_2_value,
  output        io_rs1Set_3_valid,
  output [31:0] io_rs1Set_3_value,
  output        io_rs2Read_0_valid,
  output [4:0]  io_rs2Read_0_addr,
  output        io_rs2Read_1_valid,
  output [4:0]  io_rs2Read_1_addr,
  output        io_rs2Read_2_valid,
  output [4:0]  io_rs2Read_2_addr,
  output        io_rs2Read_3_valid,
  output [4:0]  io_rs2Read_3_addr,
  output        io_rs2Set_0_valid,
  output [31:0] io_rs2Set_0_value,
  output        io_rs2Set_1_valid,
  output [31:0] io_rs2Set_1_value,
  output        io_rs2Set_2_valid,
  output [31:0] io_rs2Set_2_value,
  output        io_rs2Set_3_valid,
  output [31:0] io_rs2Set_3_value,
  output        io_rdMark_0_valid,
  output [4:0]  io_rdMark_0_addr,
  output        io_rdMark_1_valid,
  output [4:0]  io_rdMark_1_addr,
  output        io_rdMark_2_valid,
  output [4:0]  io_rdMark_2_addr,
  output        io_rdMark_3_valid,
  output [4:0]  io_rdMark_3_addr,
  output        io_busRead_0_bypass,
                io_busRead_0_immen,
  output [31:0] io_busRead_0_immed,
  output        io_busRead_1_bypass,
  output [31:0] io_busRead_1_immed,
  output        io_busRead_2_bypass,
  output [31:0] io_busRead_2_immed,
  output        io_busRead_3_bypass,
  output [31:0] io_busRead_3_immed,
  output        io_rdMark_flt_valid,
  output [4:0]  io_rdMark_flt_addr,
  output        io_rvvRdMark_0_valid,
  output [4:0]  io_rvvRdMark_0_addr,
  output        io_rvvRdMark_1_valid,
  output [4:0]  io_rvvRdMark_1_addr,
  output        io_rvvRdMark_2_valid,
  output [4:0]  io_rvvRdMark_2_addr,
  output        io_rvvRdMark_3_valid,
  output [4:0]  io_rvvRdMark_3_addr,
  output        io_alu_0_valid,
  output [4:0]  io_alu_0_bits_addr,
                io_alu_0_bits_op,
  output        io_alu_1_valid,
  output [4:0]  io_alu_1_bits_addr,
                io_alu_1_bits_op,
  output        io_alu_2_valid,
  output [4:0]  io_alu_2_bits_addr,
                io_alu_2_bits_op,
  output        io_alu_3_valid,
  output [4:0]  io_alu_3_bits_addr,
                io_alu_3_bits_op,
  output        io_bru_0_valid,
                io_bru_0_bits_fwd,
  output [3:0]  io_bru_0_bits_op,
  output [31:0] io_bru_0_bits_pc,
                io_bru_0_bits_target,
  output [4:0]  io_bru_0_bits_link,
  output        io_bru_1_valid,
                io_bru_1_bits_fwd,
  output [3:0]  io_bru_1_bits_op,
  output [31:0] io_bru_1_bits_pc,
                io_bru_1_bits_target,
  output [4:0]  io_bru_1_bits_link,
  output        io_bru_2_valid,
                io_bru_2_bits_fwd,
  output [3:0]  io_bru_2_bits_op,
  output [31:0] io_bru_2_bits_pc,
                io_bru_2_bits_target,
  output [4:0]  io_bru_2_bits_link,
  output        io_bru_3_valid,
                io_bru_3_bits_fwd,
  output [3:0]  io_bru_3_bits_op,
  output [31:0] io_bru_3_bits_pc,
                io_bru_3_bits_target,
  output [4:0]  io_bru_3_bits_link,
  output        io_csr_valid,
  output [4:0]  io_csr_bits_addr,
  output [11:0] io_csr_bits_index,
  output [4:0]  io_csr_bits_rs1,
  output [1:0]  io_csr_bits_op,
  input         io_lsu_0_ready,
  output        io_lsu_0_valid,
                io_lsu_0_bits_store,
  output [4:0]  io_lsu_0_bits_addr,
                io_lsu_0_bits_op,
  output [31:0] io_lsu_0_bits_pc,
  output [2:0]  io_lsu_0_bits_elemWidth,
                io_lsu_0_bits_nfields,
  output [4:0]  io_lsu_0_bits_umop,
  input         io_lsu_1_ready,
  output        io_lsu_1_valid,
                io_lsu_1_bits_store,
  output [4:0]  io_lsu_1_bits_addr,
                io_lsu_1_bits_op,
  output [31:0] io_lsu_1_bits_pc,
  output [2:0]  io_lsu_1_bits_elemWidth,
                io_lsu_1_bits_nfields,
  output [4:0]  io_lsu_1_bits_umop,
  input         io_lsu_2_ready,
  output        io_lsu_2_valid,
                io_lsu_2_bits_store,
  output [4:0]  io_lsu_2_bits_addr,
                io_lsu_2_bits_op,
  output [31:0] io_lsu_2_bits_pc,
  output [2:0]  io_lsu_2_bits_elemWidth,
                io_lsu_2_bits_nfields,
  output [4:0]  io_lsu_2_bits_umop,
  input         io_lsu_3_ready,
  output        io_lsu_3_valid,
                io_lsu_3_bits_store,
  output [4:0]  io_lsu_3_bits_addr,
                io_lsu_3_bits_op,
  output [31:0] io_lsu_3_bits_pc,
  output [2:0]  io_lsu_3_bits_elemWidth,
                io_lsu_3_bits_nfields,
  output [4:0]  io_lsu_3_bits_umop,
  input  [2:0]  io_lsuQueueCapacity,
  output        io_mlu_0_valid,
  output [4:0]  io_mlu_0_bits_addr,
  output [2:0]  io_mlu_0_bits_op,
  input         io_mlu_1_ready,
  output        io_mlu_1_valid,
  output [4:0]  io_mlu_1_bits_addr,
  output [2:0]  io_mlu_1_bits_op,
  input         io_mlu_2_ready,
  output        io_mlu_2_valid,
  output [4:0]  io_mlu_2_bits_addr,
  output [2:0]  io_mlu_2_bits_op,
  input         io_mlu_3_ready,
  output        io_mlu_3_valid,
  output [4:0]  io_mlu_3_bits_addr,
  output [2:0]  io_mlu_3_bits_op,
  input         io_dvu_0_ready,
  output        io_dvu_0_valid,
  output [4:0]  io_dvu_0_bits_addr,
  output [1:0]  io_dvu_0_bits_op,
  input         io_rvv_0_ready,
  output        io_rvv_0_valid,
  output [31:0] io_rvv_0_bits_pc,
  output [1:0]  io_rvv_0_bits_opcode,
  output [24:0] io_rvv_0_bits_bits,
  input         io_rvv_1_ready,
  output        io_rvv_1_valid,
  output [31:0] io_rvv_1_bits_pc,
  output [1:0]  io_rvv_1_bits_opcode,
  output [24:0] io_rvv_1_bits_bits,
  input         io_rvv_2_ready,
  output        io_rvv_2_valid,
  output [31:0] io_rvv_2_bits_pc,
  output [1:0]  io_rvv_2_bits_opcode,
  output [24:0] io_rvv_2_bits_bits,
  input         io_rvv_3_ready,
  output        io_rvv_3_valid,
  output [31:0] io_rvv_3_bits_pc,
  output [1:0]  io_rvv_3_bits_opcode,
  output [24:0] io_rvv_3_bits_bits,
  input         io_rvvState_valid,
  input  [6:0]  io_rvvState_bits_vstart,
  input         io_rvvIdle,
  input  [3:0]  io_rvvQueueCapacity,
  input         io_float_ready,
  output        io_float_valid,
  output [2:0]  io_float_bits_opcode,
  output [4:0]  io_float_bits_funct5,
                io_float_bits_rs3,
                io_float_bits_rs2,
                io_float_bits_rs1,
  output [2:0]  io_float_bits_rm,
  output [31:0] io_float_bits_inst,
                io_float_bits_pc,
  output        io_float_bits_scalar_rd,
                io_float_bits_scalar_rs1,
                io_float_bits_float_rs1,
  output [4:0]  io_float_bits_rd,
  output        io_float_bits_uses_rs3,
                io_float_bits_uses_rs2,
  input  [2:0]  io_csrFrm,
  output [4:0]  io_fbusPortAddr,
  output        io_slog,
  input  [4:0]  io_retirement_buffer_nSpace,
  input         io_retirement_buffer_empty,
                io_retirement_buffer_trap_pending,
  output        io_branch_0,
                io_branch_1,
                io_branch_2,
                io_branch_3,
                io_jump_0,
                io_jump_1,
                io_jump_2,
                io_jump_3
);

  wire [19:0] _decodedInsts_d_imm12_T_1 = {20{io_inst_0_bits_inst[31]}};
  wire [31:0] decodedInsts_0_immcsr = {27'h0, io_inst_0_bits_inst[19:15]};
  wire        decodedInsts_0_lui = io_inst_0_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_0_auipc = io_inst_0_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_0_jal = io_inst_0_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN = {io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_jalr = _GEN == 10'h67;
  wire        decodedInsts_0_beq = _GEN == 10'h63;
  wire        decodedInsts_0_bne = _GEN == 10'hE3;
  wire        decodedInsts_0_blt = _GEN == 10'h263;
  wire        decodedInsts_0_bge = _GEN == 10'h2E3;
  wire        decodedInsts_0_bltu = _GEN == 10'h363;
  wire        decodedInsts_0_bgeu = _GEN == 10'h3E3;
  wire [8:0]  _GEN_0 = {io_inst_0_bits_inst[13:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_csrrw = _GEN_0 == 9'hF3;
  wire        decodedInsts_0_csrrs = _GEN_0 == 9'h173;
  wire        decodedInsts_0_csrrc = _GEN_0 == 9'h1F3;
  wire        decodedInsts_0_lb = _GEN == 10'h3;
  wire        decodedInsts_0_lh = _GEN == 10'h83;
  wire        decodedInsts_0_lw = _GEN == 10'h103;
  wire        decodedInsts_0_lbu = _GEN == 10'h203;
  wire        decodedInsts_0_lhu = _GEN == 10'h283;
  wire        decodedInsts_0_sb = _GEN == 10'h23;
  wire        decodedInsts_0_sh = _GEN == 10'hA3;
  wire        decodedInsts_0_sw = _GEN == 10'h123;
  wire        decodedInsts_0_fence =
    {io_inst_0_bits_inst[31:28], io_inst_0_bits_inst[19:0]} == 24'hF;
  wire        decodedInsts_0_addi = _GEN == 10'h13;
  wire        decodedInsts_0_slti = _GEN == 10'h113;
  wire        decodedInsts_0_sltiu = _GEN == 10'h193;
  wire        decodedInsts_0_xori = _GEN == 10'h213;
  wire        decodedInsts_0_ori = _GEN == 10'h313;
  wire        decodedInsts_0_andi = _GEN == 10'h393;
  wire [16:0] _GEN_1 =
    {io_inst_0_bits_inst[31:25], io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_slli = _GEN_1 == 17'h93;
  wire        decodedInsts_0_srli = _GEN_1 == 17'h293;
  wire        decodedInsts_0_srai = _GEN_1 == 17'h8293;
  wire        decodedInsts_0_add = _GEN_1 == 17'h33;
  wire        decodedInsts_0_sub = _GEN_1 == 17'h8033;
  wire        decodedInsts_0_slt = _GEN_1 == 17'h133;
  wire        decodedInsts_0_sltu = _GEN_1 == 17'h1B3;
  wire        decodedInsts_0_xor = _GEN_1 == 17'h233;
  wire        decodedInsts_0_or = _GEN_1 == 17'h333;
  wire        decodedInsts_0_and = _GEN_1 == 17'h3B3;
  wire        decodedInsts_0_sll = _GEN_1 == 17'hB3;
  wire        decodedInsts_0_srl = _GEN_1 == 17'h2B3;
  wire        decodedInsts_0_sra = _GEN_1 == 17'h82B3;
  wire        decodedInsts_0_mul = _GEN_1 == 17'h433;
  wire        decodedInsts_0_mulh = _GEN_1 == 17'h4B3;
  wire        decodedInsts_0_mulhsu = _GEN_1 == 17'h533;
  wire        decodedInsts_0_mulhu = _GEN_1 == 17'h5B3;
  wire        decodedInsts_0_div = _GEN_1 == 17'h633;
  wire        decodedInsts_0_divu = _GEN_1 == 17'h6B3;
  wire        decodedInsts_0_rem = _GEN_1 == 17'h733;
  wire        decodedInsts_0_remu = _GEN_1 == 17'h7B3;
  wire        decodedInsts_0_andn = _GEN_1 == 17'h83B3;
  wire        decodedInsts_0_orn = _GEN_1 == 17'h8333;
  wire        decodedInsts_0_xnor = _GEN_1 == 17'h8233;
  wire [21:0] _GEN_2 =
    {io_inst_0_bits_inst[31:20], io_inst_0_bits_inst[14:12], io_inst_0_bits_inst[6:0]};
  wire        decodedInsts_0_clz = _GEN_2 == 22'h180093;
  wire        decodedInsts_0_ctz = _GEN_2 == 22'h180493;
  wire        decodedInsts_0_cpop = _GEN_2 == 22'h180893;
  wire        decodedInsts_0_max = _GEN_1 == 17'h1733;
  wire        decodedInsts_0_maxu = _GEN_1 == 17'h17B3;
  wire        decodedInsts_0_min = _GEN_1 == 17'h1633;
  wire        decodedInsts_0_minu = _GEN_1 == 17'h16B3;
  wire        decodedInsts_0_sextb = _GEN_2 == 22'h181093;
  wire        decodedInsts_0_sexth = _GEN_2 == 22'h181493;
  wire        decodedInsts_0_rol = _GEN_1 == 17'hC0B3;
  wire        decodedInsts_0_ror = _GEN_1 == 17'hC2B3;
  wire        decodedInsts_0_orcb = _GEN_2 == 22'hA1E93;
  wire        decodedInsts_0_rev8 = _GEN_2 == 22'h1A6293;
  wire        decodedInsts_0_zexth = _GEN_2 == 22'h20233;
  wire        decodedInsts_0_rori = _GEN_1 == 17'hC293;
  wire        decodedInsts_slog =
    {io_inst_0_bits_inst[31:20],
     io_inst_0_bits_inst[14],
     io_inst_0_bits_inst[11:0]} == 25'hF00077;
  wire        decodedInsts_0_ebreak = io_inst_0_bits_inst == 32'h100073;
  wire        decodedInsts_0_ecall = io_inst_0_bits_inst == 32'h73;
  wire        decodedInsts_0_mpause = io_inst_0_bits_inst == 32'h8000073;
  wire        decodedInsts_0_mret = io_inst_0_bits_inst == 32'h30200073;
  wire        decodedInsts_0_wfi = io_inst_0_bits_inst == 32'h10500073;
  wire        decodedInsts_0_fencei = io_inst_0_bits_inst == 32'h100F;
  wire        decodedInsts_0_flushat =
    {io_inst_0_bits_inst[31:28],
     io_inst_0_bits_inst[24:20],
     io_inst_0_bits_inst[14:0]} == 24'h200077 & (|(io_inst_0_bits_inst[19:15]));
  wire        decodedInsts_0_flushall =
    {io_inst_0_bits_inst[31:28], io_inst_0_bits_inst[24:0]} == 29'h4000077;
  wire        decodedInsts_float_load_store_rm_valid =
    io_inst_0_bits_inst[14:12] == 3'h1 | io_inst_0_bits_inst[14:12] == 3'h2;
  wire        _decodedInsts_float_opcode_T_4 = io_inst_0_bits_inst[6:2] == 5'h9;
  wire        _decodedInsts_float_opcode_T_6 = io_inst_0_bits_inst[6:2] == 5'h14;
  wire        _decodedInsts_float_opcode_T_8 = io_inst_0_bits_inst[6:2] == 5'h10;
  wire        _decodedInsts_float_opcode_T_10 = io_inst_0_bits_inst[6:2] == 5'h11;
  wire        _decodedInsts_float_opcode_T_12 = io_inst_0_bits_inst[6:2] == 5'h12;
  wire        _decodedInsts_float_opcode_T_14 = io_inst_0_bits_inst[6:2] == 5'h13;
  wire [2:0]  decodedInsts_float_bits_opcode =
    _decodedInsts_float_opcode_T_14
      ? 3'h5
      : _decodedInsts_float_opcode_T_12
          ? 3'h6
          : _decodedInsts_float_opcode_T_10
              ? 3'h4
              : _decodedInsts_float_opcode_T_8
                  ? 3'h3
                  : _decodedInsts_float_opcode_T_6
                      ? 3'h2
                      : {2'h0,
                         _decodedInsts_float_opcode_T_4
                           & decodedInsts_float_load_store_rm_valid};
  wire        _decodedInsts_float_uses_rs2_T_5 = io_inst_0_bits_inst[31:27] == 5'h1C;
  wire        _decodedInsts_float_uses_rs2_T_7 = io_inst_0_bits_inst[31:27] == 5'h18;
  wire        _decodedInsts_float_uses_rs2_T_2 = decodedInsts_float_bits_opcode == 3'h2;
  wire        decodedInsts_float_scalar_rd =
    (_decodedInsts_float_uses_rs2_T_7 | _decodedInsts_float_uses_rs2_T_5
     | io_inst_0_bits_inst[31:27] == 5'h14) & _decodedInsts_float_uses_rs2_T_2;
  wire        _decodedInsts_float_uses_rs2_T_9 = io_inst_0_bits_inst[31:27] == 5'h1E;
  wire        _decodedInsts_float_uses_rs2_T_11 = io_inst_0_bits_inst[31:27] == 5'h1A;
  wire        decodedInsts_float_scalar_rs1 =
    _decodedInsts_float_uses_rs2_T_11 | _decodedInsts_float_uses_rs2_T_9;
  wire [3:0]  _decodedInsts_float_uses_rs3_T_4 =
    {decodedInsts_float_bits_opcode == 3'h6,
     decodedInsts_float_bits_opcode == 3'h5,
     decodedInsts_float_bits_opcode == 3'h4,
     decodedInsts_float_bits_opcode == 3'h3};
  wire        _decodedInsts_float_T_1 = decodedInsts_float_bits_opcode == 3'h1;
  wire        decodedInsts_float_uses_rs2 =
    _decodedInsts_float_T_1 | _decodedInsts_float_uses_rs2_T_2
    & ~(io_inst_0_bits_inst[31:27] == 5'hB | _decodedInsts_float_uses_rs2_T_11
        | _decodedInsts_float_uses_rs2_T_9 | _decodedInsts_float_uses_rs2_T_7
        | _decodedInsts_float_uses_rs2_T_5) & io_inst_0_bits_inst[31:27] != 5'h1C;
  wire        _decodedInsts_float_T = decodedInsts_float_bits_opcode == 3'h0;
  wire        decodedInsts_float_float_rs1 =
    {_decodedInsts_float_T, _decodedInsts_float_T_1} == 2'h0
    & ~decodedInsts_float_scalar_rs1;
  wire        decodedInsts_floatValid =
    (_decodedInsts_float_opcode_T_14 | _decodedInsts_float_opcode_T_12
     | _decodedInsts_float_opcode_T_10 | _decodedInsts_float_opcode_T_8
     | _decodedInsts_float_opcode_T_6
     | (_decodedInsts_float_opcode_T_4 | io_inst_0_bits_inst[6:2] == 5'h1)
     & decodedInsts_float_load_store_rm_valid)
    & (_decodedInsts_float_T | _decodedInsts_float_T_1
       | io_inst_0_bits_inst[26:25] == 2'h0)
    & (~((|{decodedInsts_float_bits_opcode == 3'h5,
            decodedInsts_float_bits_opcode == 3'h6,
            decodedInsts_float_bits_opcode == 3'h4,
            decodedInsts_float_bits_opcode == 3'h3})
         | decodedInsts_float_bits_opcode == 3'h2
         & (io_inst_0_bits_inst[31:27] == 5'h0 | io_inst_0_bits_inst[31:27] == 5'h1
            | io_inst_0_bits_inst[31:27] == 5'h2 | io_inst_0_bits_inst[31:27] == 5'h3
            | io_inst_0_bits_inst[31:27] == 5'h4 | io_inst_0_bits_inst[31:27] == 5'h1A))
       | io_inst_0_bits_inst[14:12] < 3'h5 | (&(io_inst_0_bits_inst[14:12]))
       & io_csrFrm < 3'h5);
  wire        _decodedInsts_d_rvv_new_opcode_T_2 = io_inst_0_bits_inst[6:0] == 7'h27;
  wire        _decodedInsts_d_rvv_new_opcode_T_4 = io_inst_0_bits_inst[6:0] == 7'h57;
  wire        decodedInsts_d_rvv_ret_valid =
    _decodedInsts_d_rvv_new_opcode_T_4
    | (_decodedInsts_d_rvv_new_opcode_T_2 | io_inst_0_bits_inst[6:0] == 7'h7)
    & ~(io_inst_0_bits_inst[28])
    & (io_inst_0_bits_inst[14:12] == 3'h6 | io_inst_0_bits_inst[14:12] == 3'h5
       | io_inst_0_bits_inst[14:12] == 3'h0);
  wire [1:0]  decodedInsts_d_rvv_ret_bits_opcode =
    _decodedInsts_d_rvv_new_opcode_T_4
      ? 2'h2
      : {1'h0, _decodedInsts_d_rvv_new_opcode_T_2};
  wire [19:0] _decodedInsts_d_imm12_T_5 = {20{io_inst_1_bits_inst[31]}};
  wire        decodedInsts_1_lui = io_inst_1_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_1_auipc = io_inst_1_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_1_jal = io_inst_1_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN_3 = {io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_jalr = _GEN_3 == 10'h67;
  wire        decodedInsts_1_beq = _GEN_3 == 10'h63;
  wire        decodedInsts_1_bne = _GEN_3 == 10'hE3;
  wire        decodedInsts_1_blt = _GEN_3 == 10'h263;
  wire        decodedInsts_1_bge = _GEN_3 == 10'h2E3;
  wire        decodedInsts_1_bltu = _GEN_3 == 10'h363;
  wire        decodedInsts_1_bgeu = _GEN_3 == 10'h3E3;
  wire        decodedInsts_1_lb = _GEN_3 == 10'h3;
  wire        decodedInsts_1_lh = _GEN_3 == 10'h83;
  wire        decodedInsts_1_lw = _GEN_3 == 10'h103;
  wire        decodedInsts_1_lbu = _GEN_3 == 10'h203;
  wire        decodedInsts_1_lhu = _GEN_3 == 10'h283;
  wire        decodedInsts_1_sb = _GEN_3 == 10'h23;
  wire        decodedInsts_1_sh = _GEN_3 == 10'hA3;
  wire        decodedInsts_1_sw = _GEN_3 == 10'h123;
  wire        decodedInsts_1_addi = _GEN_3 == 10'h13;
  wire        decodedInsts_1_slti = _GEN_3 == 10'h113;
  wire        decodedInsts_1_sltiu = _GEN_3 == 10'h193;
  wire        decodedInsts_1_xori = _GEN_3 == 10'h213;
  wire        decodedInsts_1_ori = _GEN_3 == 10'h313;
  wire        decodedInsts_1_andi = _GEN_3 == 10'h393;
  wire [16:0] _GEN_4 =
    {io_inst_1_bits_inst[31:25], io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_slli = _GEN_4 == 17'h93;
  wire        decodedInsts_1_srli = _GEN_4 == 17'h293;
  wire        decodedInsts_1_srai = _GEN_4 == 17'h8293;
  wire        decodedInsts_1_add = _GEN_4 == 17'h33;
  wire        decodedInsts_1_sub = _GEN_4 == 17'h8033;
  wire        decodedInsts_1_slt = _GEN_4 == 17'h133;
  wire        decodedInsts_1_sltu = _GEN_4 == 17'h1B3;
  wire        decodedInsts_1_xor = _GEN_4 == 17'h233;
  wire        decodedInsts_1_or = _GEN_4 == 17'h333;
  wire        decodedInsts_1_and = _GEN_4 == 17'h3B3;
  wire        decodedInsts_1_sll = _GEN_4 == 17'hB3;
  wire        decodedInsts_1_srl = _GEN_4 == 17'h2B3;
  wire        decodedInsts_1_sra = _GEN_4 == 17'h82B3;
  wire        decodedInsts_1_mul = _GEN_4 == 17'h433;
  wire        decodedInsts_1_mulh = _GEN_4 == 17'h4B3;
  wire        decodedInsts_1_mulhsu = _GEN_4 == 17'h533;
  wire        decodedInsts_1_mulhu = _GEN_4 == 17'h5B3;
  wire        decodedInsts_1_andn = _GEN_4 == 17'h83B3;
  wire        decodedInsts_1_orn = _GEN_4 == 17'h8333;
  wire        decodedInsts_1_xnor = _GEN_4 == 17'h8233;
  wire [21:0] _GEN_5 =
    {io_inst_1_bits_inst[31:20], io_inst_1_bits_inst[14:12], io_inst_1_bits_inst[6:0]};
  wire        decodedInsts_1_clz = _GEN_5 == 22'h180093;
  wire        decodedInsts_1_ctz = _GEN_5 == 22'h180493;
  wire        decodedInsts_1_cpop = _GEN_5 == 22'h180893;
  wire        decodedInsts_1_max = _GEN_4 == 17'h1733;
  wire        decodedInsts_1_maxu = _GEN_4 == 17'h17B3;
  wire        decodedInsts_1_min = _GEN_4 == 17'h1633;
  wire        decodedInsts_1_minu = _GEN_4 == 17'h16B3;
  wire        decodedInsts_1_sextb = _GEN_5 == 22'h181093;
  wire        decodedInsts_1_sexth = _GEN_5 == 22'h181493;
  wire        decodedInsts_1_rol = _GEN_4 == 17'hC0B3;
  wire        decodedInsts_1_ror = _GEN_4 == 17'hC2B3;
  wire        decodedInsts_1_orcb = _GEN_5 == 22'hA1E93;
  wire        decodedInsts_1_rev8 = _GEN_5 == 22'h1A6293;
  wire        decodedInsts_1_zexth = _GEN_5 == 22'h20233;
  wire        decodedInsts_1_rori = _GEN_4 == 17'hC293;
  wire        _decodedInsts_d_rvv_new_opcode_T_7 = io_inst_1_bits_inst[6:0] == 7'h27;
  wire        _decodedInsts_d_rvv_new_opcode_T_9 = io_inst_1_bits_inst[6:0] == 7'h57;
  wire        decodedInsts_d_rvv_ret_1_valid =
    _decodedInsts_d_rvv_new_opcode_T_9
    | (_decodedInsts_d_rvv_new_opcode_T_7 | io_inst_1_bits_inst[6:0] == 7'h7)
    & ~(io_inst_1_bits_inst[28])
    & (io_inst_1_bits_inst[14:12] == 3'h6 | io_inst_1_bits_inst[14:12] == 3'h5
       | io_inst_1_bits_inst[14:12] == 3'h0);
  wire [1:0]  decodedInsts_d_rvv_ret_1_bits_opcode =
    _decodedInsts_d_rvv_new_opcode_T_9
      ? 2'h2
      : {1'h0, _decodedInsts_d_rvv_new_opcode_T_7};
  wire [19:0] _decodedInsts_d_imm12_T_9 = {20{io_inst_2_bits_inst[31]}};
  wire        decodedInsts_2_lui = io_inst_2_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_2_auipc = io_inst_2_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_2_jal = io_inst_2_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN_6 = {io_inst_2_bits_inst[14:12], io_inst_2_bits_inst[6:0]};
  wire        decodedInsts_2_jalr = _GEN_6 == 10'h67;
  wire        decodedInsts_2_beq = _GEN_6 == 10'h63;
  wire        decodedInsts_2_bne = _GEN_6 == 10'hE3;
  wire        decodedInsts_2_blt = _GEN_6 == 10'h263;
  wire        decodedInsts_2_bge = _GEN_6 == 10'h2E3;
  wire        decodedInsts_2_bltu = _GEN_6 == 10'h363;
  wire        decodedInsts_2_bgeu = _GEN_6 == 10'h3E3;
  wire        decodedInsts_2_lb = _GEN_6 == 10'h3;
  wire        decodedInsts_2_lh = _GEN_6 == 10'h83;
  wire        decodedInsts_2_lw = _GEN_6 == 10'h103;
  wire        decodedInsts_2_lbu = _GEN_6 == 10'h203;
  wire        decodedInsts_2_lhu = _GEN_6 == 10'h283;
  wire        decodedInsts_2_sb = _GEN_6 == 10'h23;
  wire        decodedInsts_2_sh = _GEN_6 == 10'hA3;
  wire        decodedInsts_2_sw = _GEN_6 == 10'h123;
  wire        decodedInsts_2_addi = _GEN_6 == 10'h13;
  wire        decodedInsts_2_slti = _GEN_6 == 10'h113;
  wire        decodedInsts_2_sltiu = _GEN_6 == 10'h193;
  wire        decodedInsts_2_xori = _GEN_6 == 10'h213;
  wire        decodedInsts_2_ori = _GEN_6 == 10'h313;
  wire        decodedInsts_2_andi = _GEN_6 == 10'h393;
  wire [16:0] _GEN_7 =
    {io_inst_2_bits_inst[31:25], io_inst_2_bits_inst[14:12], io_inst_2_bits_inst[6:0]};
  wire        decodedInsts_2_slli = _GEN_7 == 17'h93;
  wire        decodedInsts_2_srli = _GEN_7 == 17'h293;
  wire        decodedInsts_2_srai = _GEN_7 == 17'h8293;
  wire        decodedInsts_2_add = _GEN_7 == 17'h33;
  wire        decodedInsts_2_sub = _GEN_7 == 17'h8033;
  wire        decodedInsts_2_slt = _GEN_7 == 17'h133;
  wire        decodedInsts_2_sltu = _GEN_7 == 17'h1B3;
  wire        decodedInsts_2_xor = _GEN_7 == 17'h233;
  wire        decodedInsts_2_or = _GEN_7 == 17'h333;
  wire        decodedInsts_2_and = _GEN_7 == 17'h3B3;
  wire        decodedInsts_2_sll = _GEN_7 == 17'hB3;
  wire        decodedInsts_2_srl = _GEN_7 == 17'h2B3;
  wire        decodedInsts_2_sra = _GEN_7 == 17'h82B3;
  wire        decodedInsts_2_mul = _GEN_7 == 17'h433;
  wire        decodedInsts_2_mulh = _GEN_7 == 17'h4B3;
  wire        decodedInsts_2_mulhsu = _GEN_7 == 17'h533;
  wire        decodedInsts_2_mulhu = _GEN_7 == 17'h5B3;
  wire        decodedInsts_2_andn = _GEN_7 == 17'h83B3;
  wire        decodedInsts_2_orn = _GEN_7 == 17'h8333;
  wire        decodedInsts_2_xnor = _GEN_7 == 17'h8233;
  wire [21:0] _GEN_8 =
    {io_inst_2_bits_inst[31:20], io_inst_2_bits_inst[14:12], io_inst_2_bits_inst[6:0]};
  wire        decodedInsts_2_clz = _GEN_8 == 22'h180093;
  wire        decodedInsts_2_ctz = _GEN_8 == 22'h180493;
  wire        decodedInsts_2_cpop = _GEN_8 == 22'h180893;
  wire        decodedInsts_2_max = _GEN_7 == 17'h1733;
  wire        decodedInsts_2_maxu = _GEN_7 == 17'h17B3;
  wire        decodedInsts_2_min = _GEN_7 == 17'h1633;
  wire        decodedInsts_2_minu = _GEN_7 == 17'h16B3;
  wire        decodedInsts_2_sextb = _GEN_8 == 22'h181093;
  wire        decodedInsts_2_sexth = _GEN_8 == 22'h181493;
  wire        decodedInsts_2_rol = _GEN_7 == 17'hC0B3;
  wire        decodedInsts_2_ror = _GEN_7 == 17'hC2B3;
  wire        decodedInsts_2_orcb = _GEN_8 == 22'hA1E93;
  wire        decodedInsts_2_rev8 = _GEN_8 == 22'h1A6293;
  wire        decodedInsts_2_zexth = _GEN_8 == 22'h20233;
  wire        decodedInsts_2_rori = _GEN_7 == 17'hC293;
  wire        _decodedInsts_d_rvv_new_opcode_T_12 = io_inst_2_bits_inst[6:0] == 7'h27;
  wire        _decodedInsts_d_rvv_new_opcode_T_14 = io_inst_2_bits_inst[6:0] == 7'h57;
  wire        decodedInsts_d_rvv_ret_2_valid =
    _decodedInsts_d_rvv_new_opcode_T_14
    | (_decodedInsts_d_rvv_new_opcode_T_12 | io_inst_2_bits_inst[6:0] == 7'h7)
    & ~(io_inst_2_bits_inst[28])
    & (io_inst_2_bits_inst[14:12] == 3'h6 | io_inst_2_bits_inst[14:12] == 3'h5
       | io_inst_2_bits_inst[14:12] == 3'h0);
  wire [1:0]  decodedInsts_d_rvv_ret_2_bits_opcode =
    _decodedInsts_d_rvv_new_opcode_T_14
      ? 2'h2
      : {1'h0, _decodedInsts_d_rvv_new_opcode_T_12};
  wire [19:0] _decodedInsts_d_imm12_T_13 = {20{io_inst_3_bits_inst[31]}};
  wire        decodedInsts_3_lui = io_inst_3_bits_inst[6:0] == 7'h37;
  wire        decodedInsts_3_auipc = io_inst_3_bits_inst[6:0] == 7'h17;
  wire        decodedInsts_3_jal = io_inst_3_bits_inst[6:0] == 7'h6F;
  wire [9:0]  _GEN_9 = {io_inst_3_bits_inst[14:12], io_inst_3_bits_inst[6:0]};
  wire        decodedInsts_3_jalr = _GEN_9 == 10'h67;
  wire        decodedInsts_3_beq = _GEN_9 == 10'h63;
  wire        decodedInsts_3_bne = _GEN_9 == 10'hE3;
  wire        decodedInsts_3_blt = _GEN_9 == 10'h263;
  wire        decodedInsts_3_bge = _GEN_9 == 10'h2E3;
  wire        decodedInsts_3_bltu = _GEN_9 == 10'h363;
  wire        decodedInsts_3_bgeu = _GEN_9 == 10'h3E3;
  wire        decodedInsts_3_lb = _GEN_9 == 10'h3;
  wire        decodedInsts_3_lh = _GEN_9 == 10'h83;
  wire        decodedInsts_3_lw = _GEN_9 == 10'h103;
  wire        decodedInsts_3_lbu = _GEN_9 == 10'h203;
  wire        decodedInsts_3_lhu = _GEN_9 == 10'h283;
  wire        decodedInsts_3_sb = _GEN_9 == 10'h23;
  wire        decodedInsts_3_sh = _GEN_9 == 10'hA3;
  wire        decodedInsts_3_sw = _GEN_9 == 10'h123;
  wire        decodedInsts_3_addi = _GEN_9 == 10'h13;
  wire        decodedInsts_3_slti = _GEN_9 == 10'h113;
  wire        decodedInsts_3_sltiu = _GEN_9 == 10'h193;
  wire        decodedInsts_3_xori = _GEN_9 == 10'h213;
  wire        decodedInsts_3_ori = _GEN_9 == 10'h313;
  wire        decodedInsts_3_andi = _GEN_9 == 10'h393;
  wire [16:0] _GEN_10 =
    {io_inst_3_bits_inst[31:25], io_inst_3_bits_inst[14:12], io_inst_3_bits_inst[6:0]};
  wire        decodedInsts_3_slli = _GEN_10 == 17'h93;
  wire        decodedInsts_3_srli = _GEN_10 == 17'h293;
  wire        decodedInsts_3_srai = _GEN_10 == 17'h8293;
  wire        decodedInsts_3_add = _GEN_10 == 17'h33;
  wire        decodedInsts_3_sub = _GEN_10 == 17'h8033;
  wire        decodedInsts_3_slt = _GEN_10 == 17'h133;
  wire        decodedInsts_3_sltu = _GEN_10 == 17'h1B3;
  wire        decodedInsts_3_xor = _GEN_10 == 17'h233;
  wire        decodedInsts_3_or = _GEN_10 == 17'h333;
  wire        decodedInsts_3_and = _GEN_10 == 17'h3B3;
  wire        decodedInsts_3_sll = _GEN_10 == 17'hB3;
  wire        decodedInsts_3_srl = _GEN_10 == 17'h2B3;
  wire        decodedInsts_3_sra = _GEN_10 == 17'h82B3;
  wire        decodedInsts_3_mul = _GEN_10 == 17'h433;
  wire        decodedInsts_3_mulh = _GEN_10 == 17'h4B3;
  wire        decodedInsts_3_mulhsu = _GEN_10 == 17'h533;
  wire        decodedInsts_3_mulhu = _GEN_10 == 17'h5B3;
  wire        decodedInsts_3_andn = _GEN_10 == 17'h83B3;
  wire        decodedInsts_3_orn = _GEN_10 == 17'h8333;
  wire        decodedInsts_3_xnor = _GEN_10 == 17'h8233;
  wire [21:0] _GEN_11 =
    {io_inst_3_bits_inst[31:20], io_inst_3_bits_inst[14:12], io_inst_3_bits_inst[6:0]};
  wire        decodedInsts_3_clz = _GEN_11 == 22'h180093;
  wire        decodedInsts_3_ctz = _GEN_11 == 22'h180493;
  wire        decodedInsts_3_cpop = _GEN_11 == 22'h180893;
  wire        decodedInsts_3_max = _GEN_10 == 17'h1733;
  wire        decodedInsts_3_maxu = _GEN_10 == 17'h17B3;
  wire        decodedInsts_3_min = _GEN_10 == 17'h1633;
  wire        decodedInsts_3_minu = _GEN_10 == 17'h16B3;
  wire        decodedInsts_3_sextb = _GEN_11 == 22'h181093;
  wire        decodedInsts_3_sexth = _GEN_11 == 22'h181493;
  wire        decodedInsts_3_rol = _GEN_10 == 17'hC0B3;
  wire        decodedInsts_3_ror = _GEN_10 == 17'hC2B3;
  wire        decodedInsts_3_orcb = _GEN_11 == 22'hA1E93;
  wire        decodedInsts_3_rev8 = _GEN_11 == 22'h1A6293;
  wire        decodedInsts_3_zexth = _GEN_11 == 22'h20233;
  wire        decodedInsts_3_rori = _GEN_10 == 17'hC293;
  wire        _decodedInsts_d_rvv_new_opcode_T_17 = io_inst_3_bits_inst[6:0] == 7'h27;
  wire        _decodedInsts_d_rvv_new_opcode_T_19 = io_inst_3_bits_inst[6:0] == 7'h57;
  wire        decodedInsts_d_rvv_ret_3_valid =
    _decodedInsts_d_rvv_new_opcode_T_19
    | (_decodedInsts_d_rvv_new_opcode_T_17 | io_inst_3_bits_inst[6:0] == 7'h7)
    & ~(io_inst_3_bits_inst[28])
    & (io_inst_3_bits_inst[14:12] == 3'h6 | io_inst_3_bits_inst[14:12] == 3'h5
       | io_inst_3_bits_inst[14:12] == 3'h0);
  wire [1:0]  decodedInsts_d_rvv_ret_3_bits_opcode =
    _decodedInsts_d_rvv_new_opcode_T_19
      ? 2'h2
      : {1'h0, _decodedInsts_d_rvv_new_opcode_T_17};
  wire        _bru_defaultSel_T = decodedInsts_0_jal | decodedInsts_0_jalr;
  wire        _slot0Interlock_T_36 = decodedInsts_0_fencei | decodedInsts_0_ebreak;
  wire        isJump_0 =
    _bru_defaultSel_T | decodedInsts_0_ecall | decodedInsts_0_mpause | decodedInsts_0_mret
    | _slot0Interlock_T_36 | decodedInsts_0_wfi | decodedInsts_0_flushat
    | decodedInsts_0_flushall;
  wire        isJump_1 = decodedInsts_1_jal | decodedInsts_1_jalr;
  wire        isJump_2 = decodedInsts_2_jal | decodedInsts_2_jalr;
  wire        jumped_2 = isJump_0 | isJump_1;
  wire        _io_rs2Read_0_valid_T_1 = decodedInsts_0_beq | decodedInsts_0_bne;
  wire        isBranch_0 =
    _io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
    | decodedInsts_0_bltu | decodedInsts_0_bgeu;
  wire        _io_rs2Read_1_valid_T_1 = decodedInsts_1_beq | decodedInsts_1_bne;
  wire        isBranch_1 =
    _io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
    | decodedInsts_1_bltu | decodedInsts_1_bgeu;
  wire        _io_rs2Read_2_valid_T_1 = decodedInsts_2_beq | decodedInsts_2_bne;
  wire        isBranch_2 =
    _io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
    | decodedInsts_2_bltu | decodedInsts_2_bgeu;
  wire        _io_rs2Read_3_valid_T_1 = decodedInsts_3_beq | decodedInsts_3_bne;
  wire        branched_2 = isBranch_0 | isBranch_1;
  wire        _io_rs2Read_0_valid_T_25 = decodedInsts_0_sb | decodedInsts_0_sh;
  wire        _writesFloatRd_T = decodedInsts_floatValid & decodedInsts_float_scalar_rd;
  wire        _rvvRdMark_valid_T_7 = decodedInsts_d_rvv_ret_bits_opcode == 2'h2;
  wire        _io_rs2Read_1_valid_T_25 = decodedInsts_1_sb | decodedInsts_1_sh;
  wire        _rvvRdMark_valid_T_25 = decodedInsts_d_rvv_ret_1_bits_opcode == 2'h2;
  wire        _io_rs2Read_2_valid_T_25 = decodedInsts_2_sb | decodedInsts_2_sh;
  wire        _rvvRdMark_valid_T_43 = decodedInsts_d_rvv_ret_2_bits_opcode == 2'h2;
  wire        _io_rs2Read_3_valid_T_25 = decodedInsts_3_sb | decodedInsts_3_sh;
  wire        _rvvRdMark_valid_T_61 = decodedInsts_d_rvv_ret_3_bits_opcode == 2'h2;
  wire [31:0] _GEN_12 = {27'h0, io_inst_0_bits_inst[11:7]};
  wire [31:0] rdScoreboard_0 =
    ~(_io_rs2Read_0_valid_T_25 | decodedInsts_0_sw)
    & ~(_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
        | decodedInsts_0_bltu | decodedInsts_0_bgeu) | _writesFloatRd_T
    | decodedInsts_d_rvv_ret_valid
    & (_rvvRdMark_valid_T_7 & (&(io_inst_0_bits_inst[14:12])) | _rvvRdMark_valid_T_7
       & io_inst_0_bits_inst[14:12] == 3'h2 & io_inst_0_bits_inst[31:26] == 6'h10)
      ? 32'h1 << _GEN_12
      : 32'h0;
  wire [31:0] rdScoreboard_1 =
    ~(_io_rs2Read_1_valid_T_25 | decodedInsts_1_sw)
    & ~(_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
        | decodedInsts_1_bltu | decodedInsts_1_bgeu) | decodedInsts_d_rvv_ret_1_valid
    & (_rvvRdMark_valid_T_25 & (&(io_inst_1_bits_inst[14:12])) | _rvvRdMark_valid_T_25
       & io_inst_1_bits_inst[14:12] == 3'h2 & io_inst_1_bits_inst[31:26] == 6'h10)
      ? 32'h1 << io_inst_1_bits_inst[11:7]
      : 32'h0;
  wire [31:0] rdScoreboard_2 =
    ~(_io_rs2Read_2_valid_T_25 | decodedInsts_2_sw)
    & ~(_io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
        | decodedInsts_2_bltu | decodedInsts_2_bgeu) | decodedInsts_d_rvv_ret_2_valid
    & (_rvvRdMark_valid_T_43 & (&(io_inst_2_bits_inst[14:12])) | _rvvRdMark_valid_T_43
       & io_inst_2_bits_inst[14:12] == 3'h2 & io_inst_2_bits_inst[31:26] == 6'h10)
      ? 32'h1 << io_inst_2_bits_inst[11:7]
      : 32'h0;
  wire [31:0] scoreboardScan_2 = rdScoreboard_0 | rdScoreboard_1;
  wire [31:0] scoreboardScan_3 = scoreboardScan_2 | rdScoreboard_2;
  wire [31:0] comb_1 = rdScoreboard_0 | io_scoreboard_comb;
  wire [31:0] comb_2 = scoreboardScan_2 | io_scoreboard_comb;
  wire [31:0] comb_3 = scoreboardScan_3 | io_scoreboard_comb;
  wire        _rdMark_valid_T_5 = decodedInsts_0_lb | decodedInsts_0_lh;
  wire        _rdMark_flt_valid_T_4 = decodedInsts_float_bits_opcode == 3'h0;
  wire        _io_float_valid_T_3 = decodedInsts_float_bits_opcode == 3'h1;
  wire        _rvvRdMark_valid_T_1 = decodedInsts_d_rvv_ret_bits_opcode == 2'h0;
  wire        _io_rs2Read_0_valid_T_44 = decodedInsts_d_rvv_ret_bits_opcode == 2'h1;
  wire        _rdMark_valid_T_42 = decodedInsts_1_lb | decodedInsts_1_lh;
  wire        _rvvRdMark_valid_T_19 = decodedInsts_d_rvv_ret_1_bits_opcode == 2'h0;
  wire        _io_rs2Read_1_valid_T_44 = decodedInsts_d_rvv_ret_1_bits_opcode == 2'h1;
  wire        _rdMark_valid_T_77 = decodedInsts_2_lb | decodedInsts_2_lh;
  wire        _rvvRdMark_valid_T_37 = decodedInsts_d_rvv_ret_2_bits_opcode == 2'h0;
  wire        _io_rs2Read_2_valid_T_44 = decodedInsts_d_rvv_ret_2_bits_opcode == 2'h1;
  wire        _rdMark_valid_T_112 = decodedInsts_3_lb | decodedInsts_3_lh;
  wire        _rvvRdMark_valid_T_55 = decodedInsts_d_rvv_ret_3_bits_opcode == 2'h0;
  wire        _io_rs2Read_3_valid_T_44 = decodedInsts_d_rvv_ret_3_bits_opcode == 2'h1;
  wire [31:0] _GEN_13 = {27'h0, io_inst_0_bits_inst[24:20]};
  wire [31:0] _GEN_14 = {27'h0, io_inst_1_bits_inst[19:15]};
  wire [31:0] _GEN_15 = {27'h0, io_inst_1_bits_inst[24:20]};
  wire [31:0] _GEN_16 = {27'h0, io_inst_2_bits_inst[19:15]};
  wire [31:0] _GEN_17 = {27'h0, io_inst_2_bits_inst[24:20]};
  wire [31:0] _GEN_18 = {27'h0, io_inst_3_bits_inst[19:15]};
  wire [31:0] _GEN_19 = {27'h0, io_inst_3_bits_inst[24:20]};
  wire        _io_rs2Read_0_valid_T_6 = decodedInsts_0_add | decodedInsts_0_sub;
  wire        _io_rs2Set_0_valid_T_6 = decodedInsts_0_addi | decodedInsts_0_slti;
  wire        _io_rs2Set_0_valid_T_16 = decodedInsts_0_clz | decodedInsts_0_ctz;
  wire        _io_rs2Read_0_valid_T_19 = decodedInsts_0_min | decodedInsts_0_minu;
  wire        _io_rs2Set_0_valid_T_1 = decodedInsts_0_csrrw | decodedInsts_0_csrrs;
  wire        _io_rs2Read_0_valid_T_34 = decodedInsts_0_mul | decodedInsts_0_mulh;
  wire        _io_rs2Read_0_valid_T_38 = decodedInsts_0_div | decodedInsts_0_divu;
  wire        _io_rs1Read_0_valid_T_56 =
    decodedInsts_floatValid & decodedInsts_float_scalar_rs1;
  wire        _io_rs2Read_1_valid_T_6 = decodedInsts_1_add | decodedInsts_1_sub;
  wire        _io_rs2Set_1_valid_T_6 = decodedInsts_1_addi | decodedInsts_1_slti;
  wire        _io_rs2Set_1_valid_T_16 = decodedInsts_1_clz | decodedInsts_1_ctz;
  wire        _io_rs2Read_1_valid_T_19 = decodedInsts_1_min | decodedInsts_1_minu;
  wire        _io_rs2Read_1_valid_T_34 = decodedInsts_1_mul | decodedInsts_1_mulh;
  wire        _io_rs2Read_2_valid_T_6 = decodedInsts_2_add | decodedInsts_2_sub;
  wire        _io_rs2Set_2_valid_T_6 = decodedInsts_2_addi | decodedInsts_2_slti;
  wire        _io_rs2Set_2_valid_T_16 = decodedInsts_2_clz | decodedInsts_2_ctz;
  wire        _io_rs2Read_2_valid_T_19 = decodedInsts_2_min | decodedInsts_2_minu;
  wire        _io_rs2Read_2_valid_T_34 = decodedInsts_2_mul | decodedInsts_2_mulh;
  wire        _io_rs2Read_3_valid_T_6 = decodedInsts_3_add | decodedInsts_3_sub;
  wire        _io_rs2Set_3_valid_T_6 = decodedInsts_3_addi | decodedInsts_3_slti;
  wire        _io_rs2Set_3_valid_T_16 = decodedInsts_3_clz | decodedInsts_3_ctz;
  wire        _io_rs2Read_3_valid_T_19 = decodedInsts_3_min | decodedInsts_3_minu;
  wire        _io_rs2Read_3_valid_T_34 = decodedInsts_3_mul | decodedInsts_3_mulh;
  wire        configInvalid_1 =
    ~io_rvvState_valid | decodedInsts_d_rvv_ret_valid & _rvvRdMark_valid_T_7
    & (&(io_inst_0_bits_inst[14:12]));
  wire        configInvalid_2 =
    configInvalid_1 | decodedInsts_d_rvv_ret_1_valid & _rvvRdMark_valid_T_25
    & (&(io_inst_1_bits_inst[14:12]));
  wire        configInvalid_3 =
    configInvalid_2 | decodedInsts_d_rvv_ret_2_valid & _rvvRdMark_valid_T_43
    & (&(io_inst_2_bits_inst[14:12]));
  wire [3:0]  _rvvInterlock_isRvvCount_T_1 =
    {3'h0, decodedInsts_d_rvv_ret_valid} + {3'h0, decodedInsts_d_rvv_ret_1_valid};
  wire        isLsu_0 =
    _rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu | decodedInsts_0_lhu
    | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw | decodedInsts_0_flushat
    | decodedInsts_0_flushall | decodedInsts_floatValid & _rdMark_flt_valid_T_4
    | decodedInsts_floatValid & _io_float_valid_T_3 | decodedInsts_d_rvv_ret_valid
    & (|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1});
  wire [3:0]  _isLsuCount_T_1 =
    {3'h0, isLsu_0}
    + {3'h0,
       _rdMark_valid_T_42 | decodedInsts_1_lw | decodedInsts_1_lbu | decodedInsts_1_lhu
         | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw | decodedInsts_d_rvv_ret_1_valid
         & (|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})};
  wire [3:0]  _GEN_20 = {1'h0, io_lsuQueueCapacity};
  wire        tryDispatch =
    ~io_halted & ~io_interlock & io_inst_0_valid
    & {((decodedInsts_0_jalr | _rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu
         | decodedInsts_0_lhu | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
         | decodedInsts_0_flushat | decodedInsts_0_flushall | decodedInsts_floatValid
         & _rdMark_flt_valid_T_4 | decodedInsts_floatValid & _io_float_valid_T_3
         | decodedInsts_d_rvv_ret_valid
         & (|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1})
           ? 32'h1 << decodedInsts_0_immcsr
           : 32'h0)
        | (_io_rs2Read_0_valid_T_25 | decodedInsts_0_sw ? 32'h1 << _GEN_13 : 32'h0))
         & io_scoreboard_regd,
       ((_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
         | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
         | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor
         | decodedInsts_0_or | decodedInsts_0_and | decodedInsts_0_xnor
         | decodedInsts_0_orn | decodedInsts_0_andn | decodedInsts_0_sll
         | decodedInsts_0_srl | decodedInsts_0_sra | _io_rs2Set_0_valid_T_6
         | decodedInsts_0_sltiu | decodedInsts_0_xori | decodedInsts_0_ori
         | decodedInsts_0_andi | decodedInsts_0_slli | decodedInsts_0_srli
         | decodedInsts_0_srai | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16
         | decodedInsts_0_cpop | decodedInsts_0_sextb | decodedInsts_0_sexth
         | decodedInsts_0_zexth | decodedInsts_0_orcb | decodedInsts_0_rev8
         | _io_rs2Read_0_valid_T_19 | decodedInsts_0_max | decodedInsts_0_maxu
         | decodedInsts_0_rol | decodedInsts_0_ror | _io_rs2Set_0_valid_T_1
         | decodedInsts_0_csrrc | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu
         | decodedInsts_0_mulhu | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem
         | decodedInsts_0_remu | decodedInsts_slog | decodedInsts_0_jalr
         | _io_rs1Read_0_valid_T_56 | decodedInsts_d_rvv_ret_valid
         & ((|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1})
            | io_inst_0_bits_inst[14:12] == 3'h4 | io_inst_0_bits_inst[14:12] == 3'h6
            | (&(io_inst_0_bits_inst[14:12])) & ~(&(io_inst_0_bits_inst[31:30])))
           ? 32'h1 << decodedInsts_0_immcsr
           : 32'h0)
        | (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
           | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
           | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor
           | decodedInsts_0_or | decodedInsts_0_and | decodedInsts_0_xnor
           | decodedInsts_0_orn | decodedInsts_0_andn | decodedInsts_0_sll
           | decodedInsts_0_srl | decodedInsts_0_sra | _io_rs2Read_0_valid_T_19
           | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_rol
           | decodedInsts_0_ror | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
           | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc) & ~(io_inst_0_bits_inst[14])
           | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
           | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
           | decodedInsts_slog | decodedInsts_d_rvv_ret_valid
           & ((|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1})
              & io_inst_0_bits_inst[27:26] == 2'h2 | (&(io_inst_0_bits_inst[14:12]))
              & io_inst_0_bits_inst[31:25] == 7'h40)
             ? 32'h1 << _GEN_13
             : 32'h0)) & io_scoreboard_comb} == 64'h0
    & (rdScoreboard_0 & io_scoreboard_comb) == 32'h0
    & (((decodedInsts_floatValid & decodedInsts_float_float_rs1
           ? 32'h1 << decodedInsts_0_immcsr
           : 32'h0)
        | (decodedInsts_floatValid & decodedInsts_float_uses_rs2
             ? 32'h1 << _GEN_13
             : 32'h0)
        | (decodedInsts_floatValid & (|_decodedInsts_float_uses_rs3_T_4)
             ? 32'h1 << io_inst_0_bits_inst[31:27]
             : 32'h0)) & io_fscoreboard) == 32'h0
    & ((decodedInsts_floatValid & ~_writesFloatRd_T ? 32'h1 << _GEN_12 : 32'h0)
       & io_fscoreboard) == 32'h0
    & ~((_slot0Interlock_T_36 | decodedInsts_0_wfi | decodedInsts_0_mpause
         | decodedInsts_0_flushat | decodedInsts_0_flushall) & io_lsuActive)
    & (~decodedInsts_d_rvv_ret_valid
       | {_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1} == 2'h0 | io_rvvState_valid)
    & ~(decodedInsts_d_rvv_ret_valid & _rvvRdMark_valid_T_7
        & io_inst_0_bits_inst[14:12] == 3'h2
        & (io_inst_0_bits_inst[31:26] == 6'h31 | io_inst_0_bits_inst[31:26] == 6'h30
           | io_inst_0_bits_inst[31:26] == 6'h17
           | (io_inst_0_bits_inst[31:26] == 6'h14
                ? io_inst_0_bits_inst[19:15] == 5'h10 | io_inst_0_bits_inst[19:15] == 5'h3
                  | io_inst_0_bits_inst[19:15] == 5'h2
                  | io_inst_0_bits_inst[19:15] == 5'h1
                : io_inst_0_bits_inst[31:26] == 6'h10
                    ? io_inst_0_bits_inst[19:15] == 5'h11
                      | io_inst_0_bits_inst[19:15] == 5'h10
                    : io_inst_0_bits_inst[31:26] == 6'h7
                      | io_inst_0_bits_inst[31:26] == 6'h6
                      | io_inst_0_bits_inst[31:26] == 6'h5
                      | io_inst_0_bits_inst[31:26] == 6'h4
                      | io_inst_0_bits_inst[31:26] == 6'h3
                      | io_inst_0_bits_inst[31:26] == 6'h2
                      | io_inst_0_bits_inst[31:26] == 6'h1
                      | ~(|(io_inst_0_bits_inst[31:26]))))
        & (|{~io_rvvState_valid, io_rvvState_bits_vstart})) & (|io_lsuQueueCapacity)
    & (|io_rvvQueueCapacity) & (|io_retirement_buffer_nSpace)
    & ~io_retirement_buffer_trap_pending
    & (~(_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc) | io_retirement_buffer_empty)
    & (~decodedInsts_0_mpause | io_scoreboard_regd == 32'h0 & io_fscoreboard == 32'h0
       & io_rvvIdle & ~io_lsuActive);
  wire        _alu_T_158 =
    decodedInsts_0_auipc | decodedInsts_0_addi | decodedInsts_0_add;
  wire        _alu_T_160 = decodedInsts_0_slti | decodedInsts_0_slt;
  wire        _alu_T_161 = decodedInsts_0_sltiu | decodedInsts_0_sltu;
  wire        _alu_T_162 = decodedInsts_0_xori | decodedInsts_0_xor;
  wire        _alu_T_163 = decodedInsts_0_ori | decodedInsts_0_or;
  wire        _alu_T_164 = decodedInsts_0_andi | decodedInsts_0_and;
  wire        _alu_T_165 = decodedInsts_0_slli | decodedInsts_0_sll;
  wire        _alu_T_166 = decodedInsts_0_srli | decodedInsts_0_srl;
  wire        _alu_T_167 = decodedInsts_0_srai | decodedInsts_0_sra;
  wire        io_alu_0_valid_0 =
    tryDispatch
    & (_alu_T_158 | decodedInsts_0_sub | _alu_T_160 | _alu_T_161 | _alu_T_162 | _alu_T_163
       | _alu_T_164 | _alu_T_165 | _alu_T_166 | _alu_T_167 | decodedInsts_0_lui
       | decodedInsts_0_andn | decodedInsts_0_orn | decodedInsts_0_xnor
       | decodedInsts_0_clz | decodedInsts_0_ctz | decodedInsts_0_cpop
       | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_min
       | decodedInsts_0_minu | decodedInsts_0_sextb | decodedInsts_0_sexth
       | decodedInsts_0_rol | decodedInsts_0_ror | decodedInsts_0_orcb
       | decodedInsts_0_rev8 | decodedInsts_0_zexth | decodedInsts_0_rori);
  wire [3:0]  _bru_T_67 =
    {3'h0, decodedInsts_0_jalr} | {2'h0, decodedInsts_0_beq, 1'h0}
    | (decodedInsts_0_bne ? 4'h3 : 4'h0) | {1'h0, decodedInsts_0_blt, 2'h0}
    | (decodedInsts_0_bge ? 4'h5 : 4'h0) | (decodedInsts_0_bltu ? 4'h6 : 4'h0)
    | (decodedInsts_0_bgeu ? 4'h7 : 4'h0) | {decodedInsts_0_ebreak, 3'h0}
    | (decodedInsts_0_ecall ? 4'h9 : 4'h0) | (decodedInsts_0_mpause ? 4'hA : 4'h0)
    | (decodedInsts_0_mret ? 4'hB : 4'h0) | (decodedInsts_0_wfi ? 4'hC : 4'h0);
  wire [31:0] _bru_target_T_2 =
    io_inst_0_bits_addr
    + {{12{io_inst_0_bits_inst[31]}},
       io_inst_0_bits_inst[2]
         ? {io_inst_0_bits_inst[19:12],
            io_inst_0_bits_inst[20],
            io_inst_0_bits_inst[30:21]}
         : {{8{io_inst_0_bits_inst[31]}},
            io_inst_0_bits_inst[7],
            io_inst_0_bits_inst[30:25],
            io_inst_0_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_0_valid_T =
    tryDispatch
    & (decodedInsts_0_jal | decodedInsts_0_jalr | decodedInsts_0_beq | decodedInsts_0_bne
       | decodedInsts_0_blt | decodedInsts_0_bge | decodedInsts_0_bltu
       | decodedInsts_0_bgeu | decodedInsts_0_ebreak | decodedInsts_0_ecall
       | decodedInsts_0_mpause | decodedInsts_0_mret | decodedInsts_0_wfi);
  wire        jalFault =
    _io_bru_0_valid_T & _bru_T_67 == 4'h0 & (|(_bru_target_T_2[1:0])) & ~io_branchTaken;
  wire        jalrFault =
    _io_bru_0_valid_T & _bru_T_67 == 4'h1 & io_jalrTarget_0_data[1] & ~io_branchTaken;
  wire        bxxFault =
    _io_bru_0_valid_T
    & (|{_bru_T_67 == 4'h7,
         _bru_T_67 == 4'h6,
         _bru_T_67 == 4'h5,
         _bru_T_67 == 4'h4,
         _bru_T_67 == 4'h3,
         _bru_T_67 == 4'h2}) & (|(_bru_target_T_2[1:0])) & ~io_branchTaken;
  wire        io_bru_0_valid_0 = _io_bru_0_valid_T & ~(jalFault | jalrFault | bxxFault);
  wire        io_mlu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_mul | decodedInsts_0_mulh | decodedInsts_0_mulhsu
       | decodedInsts_0_mulhu);
  wire        io_dvu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_div | decodedInsts_0_divu | decodedInsts_0_rem
       | decodedInsts_0_remu);
  wire        _lsu_T_141 =
    decodedInsts_floatValid & _rdMark_flt_valid_T_4 | decodedInsts_floatValid
    & _io_float_valid_T_3;
  wire        lsu_isRvvLoad = decodedInsts_d_rvv_ret_valid & _rvvRdMark_valid_T_1;
  wire        lsu_isRvvStore = decodedInsts_d_rvv_ret_valid & _io_rs2Read_0_valid_T_44;
  wire        _lsu_T_13 = io_inst_0_bits_inst[27:26] == 2'h0;
  wire        _lsu_T_142 = lsu_isRvvLoad & _lsu_T_13;
  wire        _lsu_T_15 = io_inst_0_bits_inst[27:26] == 2'h1;
  wire        _lsu_T_143 = lsu_isRvvLoad & _lsu_T_15;
  wire        _lsu_T_17 = io_inst_0_bits_inst[27:26] == 2'h2;
  wire        _lsu_T_144 = lsu_isRvvLoad & _lsu_T_17;
  wire        _lsu_T_145 = lsu_isRvvLoad & (&(io_inst_0_bits_inst[27:26]));
  wire        _lsu_T_146 = lsu_isRvvStore & _lsu_T_13;
  wire        _lsu_T_147 = lsu_isRvvStore & _lsu_T_15;
  wire        _lsu_T_148 = lsu_isRvvStore & _lsu_T_17;
  wire        _lsu_T_149 = lsu_isRvvStore & (&(io_inst_0_bits_inst[27:26]));
  wire        io_lsu_0_valid_0 =
    tryDispatch
    & (decodedInsts_0_lb | decodedInsts_0_lh | decodedInsts_0_lw | decodedInsts_0_lbu
       | decodedInsts_0_lhu | decodedInsts_0_sb | decodedInsts_0_sh | decodedInsts_0_sw
       | decodedInsts_0_wfi | decodedInsts_0_fencei | decodedInsts_0_flushat
       | decodedInsts_0_flushall | _lsu_T_141 | _lsu_T_142 | _lsu_T_143 | _lsu_T_144
       | _lsu_T_145 | _lsu_T_146 | _lsu_T_147 | _lsu_T_148 | _lsu_T_149);
  wire        csr_valid =
    decodedInsts_0_csrrw | decodedInsts_0_csrrs | decodedInsts_0_csrrc;
  wire        csr_address_valid =
    io_inst_0_bits_inst[31:20] == 12'h0 | io_inst_0_bits_inst[31:20] == 12'h1
    | io_inst_0_bits_inst[31:20] == 12'h2 | io_inst_0_bits_inst[31:20] == 12'h3
    | io_inst_0_bits_inst[31:20] == 12'h8 | io_inst_0_bits_inst[31:20] == 12'h9
    | io_inst_0_bits_inst[31:20] == 12'hA | io_inst_0_bits_inst[31:20] == 12'h300
    | io_inst_0_bits_inst[31:20] == 12'h301 | io_inst_0_bits_inst[31:20] == 12'h304
    | io_inst_0_bits_inst[31:20] == 12'h305 | io_inst_0_bits_inst[31:20] == 12'h340
    | io_inst_0_bits_inst[31:20] == 12'h341 | io_inst_0_bits_inst[31:20] == 12'h342
    | io_inst_0_bits_inst[31:20] == 12'h343 | io_inst_0_bits_inst[31:20] == 12'h7A0
    | io_inst_0_bits_inst[31:20] == 12'h7A1 | io_inst_0_bits_inst[31:20] == 12'h7A2
    | io_inst_0_bits_inst[31:20] == 12'h7A4 | io_inst_0_bits_inst[31:20] == 12'h7B0
    | io_inst_0_bits_inst[31:20] == 12'h7B1 | io_inst_0_bits_inst[31:20] == 12'h7B2
    | io_inst_0_bits_inst[31:20] == 12'h7B3 | io_inst_0_bits_inst[31:20] == 12'h7C0
    | io_inst_0_bits_inst[31:20] == 12'h7C1 | io_inst_0_bits_inst[31:20] == 12'h7C2
    | io_inst_0_bits_inst[31:20] == 12'h7C3 | io_inst_0_bits_inst[31:20] == 12'h7C4
    | io_inst_0_bits_inst[31:20] == 12'h7C5 | io_inst_0_bits_inst[31:20] == 12'h7C6
    | io_inst_0_bits_inst[31:20] == 12'h7C7 | io_inst_0_bits_inst[31:20] == 12'h7E0
    | io_inst_0_bits_inst[31:20] == 12'h7E1 | io_inst_0_bits_inst[31:20] == 12'hB00
    | io_inst_0_bits_inst[31:20] == 12'hB02 | io_inst_0_bits_inst[31:20] == 12'hB80
    | io_inst_0_bits_inst[31:20] == 12'hB82 | io_inst_0_bits_inst[31:20] == 12'hC20
    | io_inst_0_bits_inst[31:20] == 12'hC21 | io_inst_0_bits_inst[31:20] == 12'hC22
    | io_inst_0_bits_inst[31:20] == 12'hF11 | io_inst_0_bits_inst[31:20] == 12'hF12
    | io_inst_0_bits_inst[31:20] == 12'hF13 | io_inst_0_bits_inst[31:20] == 12'hF14
    | io_inst_0_bits_inst[31:20] == 12'hFC0 | io_inst_0_bits_inst[31:20] == 12'hFC4
    | io_inst_0_bits_inst[31:20] == 12'hFC8 | io_inst_0_bits_inst[31:20] == 12'hFCC
    | io_inst_0_bits_inst[31:20] == 12'hFD0 | io_inst_0_bits_inst[31:20] == 12'hFD4;
  wire        io_csr_valid_0 =
    tryDispatch & csr_valid & csr_address_valid & io_float_ready
    & (io_rvvIdle
       | ~(io_inst_0_bits_inst[31:20] == 12'h9 | io_inst_0_bits_inst[31:20] == 12'hF));
  wire        io_slog_0 = tryDispatch & decodedInsts_slog;
  wire        io_rvv_0_valid_0 = tryDispatch & decodedInsts_d_rvv_ret_valid;
  wire        io_float_valid_0 =
    tryDispatch & decodedInsts_floatValid
    & ~(decodedInsts_floatValid & _rdMark_flt_valid_T_4 | decodedInsts_floatValid
        & _io_float_valid_T_3);
  wire        dispatched_3 = io_dvu_0_ready & io_dvu_0_valid_0;
  wire        dispatched_4 = io_lsu_0_ready & io_lsu_0_valid_0;
  wire        dispatched_8 = io_rvv_0_ready & io_rvv_0_valid_0;
  wire        dispatched_9 = io_float_ready & io_float_valid_0;
  wire        lastReady_1 =
    io_alu_0_valid_0 | io_bru_0_valid_0 | io_mlu_0_valid_0 | dispatched_3 | dispatched_4
    | io_csr_valid_0 | io_slog_0 | tryDispatch & decodedInsts_0_fence | dispatched_8
    | dispatched_9;
  wire        tryDispatch_1 =
    lastReady_1 & ~io_halted & ~io_interlock & io_inst_1_valid & ~isJump_0
    & {((decodedInsts_1_jalr | _rdMark_valid_T_42 | decodedInsts_1_lw | decodedInsts_1_lbu
         | decodedInsts_1_lhu | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw
         | decodedInsts_d_rvv_ret_1_valid
         & (|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})
           ? 32'h1 << _GEN_14
           : 32'h0)
        | (_io_rs2Read_1_valid_T_25 | decodedInsts_1_sw ? 32'h1 << _GEN_15 : 32'h0))
         & (rdScoreboard_0 | io_scoreboard_regd),
       ((_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
         | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
         | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor
         | decodedInsts_1_or | decodedInsts_1_and | decodedInsts_1_xnor
         | decodedInsts_1_orn | decodedInsts_1_andn | decodedInsts_1_sll
         | decodedInsts_1_srl | decodedInsts_1_sra | _io_rs2Set_1_valid_T_6
         | decodedInsts_1_sltiu | decodedInsts_1_xori | decodedInsts_1_ori
         | decodedInsts_1_andi | decodedInsts_1_slli | decodedInsts_1_srli
         | decodedInsts_1_srai | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16
         | decodedInsts_1_cpop | decodedInsts_1_sextb | decodedInsts_1_sexth
         | decodedInsts_1_zexth | decodedInsts_1_orcb | decodedInsts_1_rev8
         | _io_rs2Read_1_valid_T_19 | decodedInsts_1_max | decodedInsts_1_maxu
         | decodedInsts_1_rol | decodedInsts_1_ror | _io_rs2Read_1_valid_T_34
         | decodedInsts_1_mulhsu | decodedInsts_1_mulhu | decodedInsts_1_jalr
         | decodedInsts_d_rvv_ret_1_valid
         & ((|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})
            | io_inst_1_bits_inst[14:12] == 3'h4 | io_inst_1_bits_inst[14:12] == 3'h6
            | (&(io_inst_1_bits_inst[14:12])) & ~(&(io_inst_1_bits_inst[31:30])))
           ? 32'h1 << _GEN_14
           : 32'h0)
        | (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
           | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
           | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor
           | decodedInsts_1_or | decodedInsts_1_and | decodedInsts_1_xnor
           | decodedInsts_1_orn | decodedInsts_1_andn | decodedInsts_1_sll
           | decodedInsts_1_srl | decodedInsts_1_sra | _io_rs2Read_1_valid_T_19
           | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_rol
           | decodedInsts_1_ror | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw
           | _io_rs2Read_1_valid_T_34 | decodedInsts_1_mulhsu | decodedInsts_1_mulhu
           | decodedInsts_d_rvv_ret_1_valid
           & ((|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})
              & io_inst_1_bits_inst[27:26] == 2'h2 | (&(io_inst_1_bits_inst[14:12]))
              & io_inst_1_bits_inst[31:25] == 7'h40)
             ? 32'h1 << _GEN_15
             : 32'h0)) & comb_1} == 64'h0 & (rdScoreboard_1 & comb_1) == 32'h0
    & ~isBranch_0
    & ~(_slot0Interlock_T_36 | decodedInsts_0_wfi | decodedInsts_0_mpause
        | decodedInsts_0_flushat | decodedInsts_0_flushall | _io_rs2Set_0_valid_T_1
        | decodedInsts_0_csrrc)
    & (~decodedInsts_d_rvv_ret_1_valid
       | {_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19} == 2'h0 | ~configInvalid_1)
    & ~(decodedInsts_d_rvv_ret_1_valid & _rvvRdMark_valid_T_25
        & io_inst_1_bits_inst[14:12] == 3'h2
        & (io_inst_1_bits_inst[31:26] == 6'h31 | io_inst_1_bits_inst[31:26] == 6'h30
           | io_inst_1_bits_inst[31:26] == 6'h17
           | (io_inst_1_bits_inst[31:26] == 6'h14
                ? io_inst_1_bits_inst[19:15] == 5'h10 | io_inst_1_bits_inst[19:15] == 5'h3
                  | io_inst_1_bits_inst[19:15] == 5'h2
                  | io_inst_1_bits_inst[19:15] == 5'h1
                : io_inst_1_bits_inst[31:26] == 6'h10
                    ? io_inst_1_bits_inst[19:15] == 5'h11
                      | io_inst_1_bits_inst[19:15] == 5'h10
                    : io_inst_1_bits_inst[31:26] == 6'h7
                      | io_inst_1_bits_inst[31:26] == 6'h6
                      | io_inst_1_bits_inst[31:26] == 6'h5
                      | io_inst_1_bits_inst[31:26] == 6'h4
                      | io_inst_1_bits_inst[31:26] == 6'h3
                      | io_inst_1_bits_inst[31:26] == 6'h2
                      | io_inst_1_bits_inst[31:26] == 6'h1
                      | io_inst_1_bits_inst[31:26] == 6'h0))
        & (|{configInvalid_1, io_rvvState_bits_vstart})) & {3'h0, isLsu_0} < _GEN_20
    & {3'h0, decodedInsts_d_rvv_ret_valid} < io_rvvQueueCapacity
    & (|{decodedInsts_1_lui,
         decodedInsts_1_auipc,
         decodedInsts_1_jal,
         decodedInsts_1_jalr,
         decodedInsts_1_beq,
         decodedInsts_1_bne,
         decodedInsts_1_blt,
         decodedInsts_1_bge,
         decodedInsts_1_bltu,
         decodedInsts_1_bgeu,
         decodedInsts_1_lb,
         decodedInsts_1_lh,
         decodedInsts_1_lw,
         decodedInsts_1_lbu,
         decodedInsts_1_lhu,
         decodedInsts_1_sb,
         decodedInsts_1_sh,
         decodedInsts_1_sw,
         decodedInsts_1_addi,
         decodedInsts_1_slti,
         decodedInsts_1_sltiu,
         decodedInsts_1_xori,
         decodedInsts_1_ori,
         decodedInsts_1_andi,
         decodedInsts_1_add,
         decodedInsts_1_sub,
         decodedInsts_1_slt,
         decodedInsts_1_sltu,
         decodedInsts_1_xor,
         decodedInsts_1_or,
         decodedInsts_1_and,
         decodedInsts_1_xnor,
         decodedInsts_1_orn,
         decodedInsts_1_andn,
         decodedInsts_1_slli,
         decodedInsts_1_srli,
         decodedInsts_1_srai,
         decodedInsts_1_sll,
         decodedInsts_1_srl,
         decodedInsts_1_sra,
         decodedInsts_1_mul,
         decodedInsts_1_mulh,
         decodedInsts_1_mulhsu,
         decodedInsts_1_mulhu,
         decodedInsts_1_clz,
         decodedInsts_1_ctz,
         decodedInsts_1_cpop,
         decodedInsts_1_min,
         decodedInsts_1_minu,
         decodedInsts_1_max,
         decodedInsts_1_maxu,
         decodedInsts_1_sextb,
         decodedInsts_1_sexth,
         decodedInsts_1_zexth,
         decodedInsts_1_rol,
         decodedInsts_1_ror,
         decodedInsts_1_orcb,
         decodedInsts_1_rev8,
         decodedInsts_1_rori,
         decodedInsts_d_rvv_ret_1_valid}) & (|(io_retirement_buffer_nSpace[4:1]))
    & ~io_retirement_buffer_trap_pending;
  wire        _alu_T_376 =
    decodedInsts_1_auipc | decodedInsts_1_addi | decodedInsts_1_add;
  wire        _alu_T_378 = decodedInsts_1_slti | decodedInsts_1_slt;
  wire        _alu_T_379 = decodedInsts_1_sltiu | decodedInsts_1_sltu;
  wire        _alu_T_380 = decodedInsts_1_xori | decodedInsts_1_xor;
  wire        _alu_T_381 = decodedInsts_1_ori | decodedInsts_1_or;
  wire        _alu_T_382 = decodedInsts_1_andi | decodedInsts_1_and;
  wire        _alu_T_383 = decodedInsts_1_slli | decodedInsts_1_sll;
  wire        _alu_T_384 = decodedInsts_1_srli | decodedInsts_1_srl;
  wire        _alu_T_385 = decodedInsts_1_srai | decodedInsts_1_sra;
  wire        io_alu_1_valid_0 =
    tryDispatch_1
    & (_alu_T_376 | decodedInsts_1_sub | _alu_T_378 | _alu_T_379 | _alu_T_380 | _alu_T_381
       | _alu_T_382 | _alu_T_383 | _alu_T_384 | _alu_T_385 | decodedInsts_1_lui
       | decodedInsts_1_andn | decodedInsts_1_orn | decodedInsts_1_xnor
       | decodedInsts_1_clz | decodedInsts_1_ctz | decodedInsts_1_cpop
       | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_min
       | decodedInsts_1_minu | decodedInsts_1_sextb | decodedInsts_1_sexth
       | decodedInsts_1_rol | decodedInsts_1_ror | decodedInsts_1_orcb
       | decodedInsts_1_rev8 | decodedInsts_1_zexth | decodedInsts_1_rori);
  wire [3:0]  _bru_T_163 =
    {3'h0, decodedInsts_1_jalr} | {2'h0, decodedInsts_1_beq, 1'h0}
    | (decodedInsts_1_bne ? 4'h3 : 4'h0) | {1'h0, decodedInsts_1_blt, 2'h0}
    | (decodedInsts_1_bge ? 4'h5 : 4'h0) | (decodedInsts_1_bltu ? 4'h6 : 4'h0)
    | (decodedInsts_1_bgeu ? 4'h7 : 4'h0);
  wire [31:0] _bru_target_T_5 =
    io_inst_1_bits_addr
    + {{12{io_inst_1_bits_inst[31]}},
       io_inst_1_bits_inst[2]
         ? {io_inst_1_bits_inst[19:12],
            io_inst_1_bits_inst[20],
            io_inst_1_bits_inst[30:21]}
         : {{8{io_inst_1_bits_inst[31]}},
            io_inst_1_bits_inst[7],
            io_inst_1_bits_inst[30:25],
            io_inst_1_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_1_valid_T =
    tryDispatch_1
    & (decodedInsts_1_jal | decodedInsts_1_jalr | decodedInsts_1_beq | decodedInsts_1_bne
       | decodedInsts_1_blt | decodedInsts_1_bge | decodedInsts_1_bltu
       | decodedInsts_1_bgeu);
  wire        jalFault_1 =
    _io_bru_1_valid_T & _bru_T_163[2:0] == 3'h0 & (|(_bru_target_T_5[1:0]))
    & ~io_branchTaken;
  wire        jalrFault_1 =
    _io_bru_1_valid_T & _bru_T_163[2:0] == 3'h1 & io_jalrTarget_1_data[1]
    & ~io_branchTaken;
  wire        bxxFault_1 =
    _io_bru_1_valid_T
    & (|{&(_bru_T_163[2:0]),
         _bru_T_163[2:0] == 3'h6,
         _bru_T_163[2:0] == 3'h5,
         _bru_T_163[2:0] == 3'h4,
         _bru_T_163[2:0] == 3'h3,
         _bru_T_163[2:0] == 3'h2}) & (|(_bru_target_T_5[1:0])) & ~io_branchTaken;
  wire        io_bru_1_valid_0 =
    _io_bru_1_valid_T & ~(jalFault_1 | jalrFault_1 | bxxFault_1);
  wire        io_mlu_1_valid_0 =
    tryDispatch_1
    & (decodedInsts_1_mul | decodedInsts_1_mulh | decodedInsts_1_mulhsu
       | decodedInsts_1_mulhu);
  wire        lsu_isRvvLoad_1 = decodedInsts_d_rvv_ret_1_valid & _rvvRdMark_valid_T_19;
  wire        lsu_isRvvStore_1 =
    decodedInsts_d_rvv_ret_1_valid & _io_rs2Read_1_valid_T_44;
  wire        _lsu_T_186 = io_inst_1_bits_inst[27:26] == 2'h0;
  wire        _lsu_T_315 = lsu_isRvvLoad_1 & _lsu_T_186;
  wire        _lsu_T_188 = io_inst_1_bits_inst[27:26] == 2'h1;
  wire        _lsu_T_316 = lsu_isRvvLoad_1 & _lsu_T_188;
  wire        _lsu_T_190 = io_inst_1_bits_inst[27:26] == 2'h2;
  wire        _lsu_T_317 = lsu_isRvvLoad_1 & _lsu_T_190;
  wire        _lsu_T_318 = lsu_isRvvLoad_1 & (&(io_inst_1_bits_inst[27:26]));
  wire        _lsu_T_319 = lsu_isRvvStore_1 & _lsu_T_186;
  wire        _lsu_T_320 = lsu_isRvvStore_1 & _lsu_T_188;
  wire        _lsu_T_321 = lsu_isRvvStore_1 & _lsu_T_190;
  wire        _lsu_T_322 = lsu_isRvvStore_1 & (&(io_inst_1_bits_inst[27:26]));
  wire        io_lsu_1_valid_0 =
    tryDispatch_1
    & (decodedInsts_1_lb | decodedInsts_1_lh | decodedInsts_1_lw | decodedInsts_1_lbu
       | decodedInsts_1_lhu | decodedInsts_1_sb | decodedInsts_1_sh | decodedInsts_1_sw
       | _lsu_T_315 | _lsu_T_316 | _lsu_T_317 | _lsu_T_318 | _lsu_T_319 | _lsu_T_320
       | _lsu_T_321 | _lsu_T_322);
  wire        io_rvv_1_valid_0 = tryDispatch_1 & decodedInsts_d_rvv_ret_1_valid;
  wire        dispatched_2_1 = io_mlu_1_ready & io_mlu_1_valid_0;
  wire        dispatched_4_1 = io_lsu_1_ready & io_lsu_1_valid_0;
  wire        dispatched_5 = io_rvv_1_ready & io_rvv_1_valid_0;
  wire        lastReady_2 =
    io_alu_1_valid_0 | io_bru_1_valid_0 | dispatched_2_1 | dispatched_4_1 | dispatched_5;
  wire        tryDispatch_2 =
    lastReady_2 & ~io_halted & ~io_interlock & io_inst_2_valid & ~jumped_2
    & {((decodedInsts_2_jalr | _rdMark_valid_T_77 | decodedInsts_2_lw | decodedInsts_2_lbu
         | decodedInsts_2_lhu | _io_rs2Read_2_valid_T_25 | decodedInsts_2_sw
         | decodedInsts_d_rvv_ret_2_valid
         & (|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})
           ? 32'h1 << _GEN_16
           : 32'h0)
        | (_io_rs2Read_2_valid_T_25 | decodedInsts_2_sw ? 32'h1 << _GEN_17 : 32'h0))
         & (scoreboardScan_2 | io_scoreboard_regd),
       ((_io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
         | decodedInsts_2_bltu | decodedInsts_2_bgeu | _io_rs2Read_2_valid_T_6
         | decodedInsts_2_slt | decodedInsts_2_sltu | decodedInsts_2_xor
         | decodedInsts_2_or | decodedInsts_2_and | decodedInsts_2_xnor
         | decodedInsts_2_orn | decodedInsts_2_andn | decodedInsts_2_sll
         | decodedInsts_2_srl | decodedInsts_2_sra | _io_rs2Set_2_valid_T_6
         | decodedInsts_2_sltiu | decodedInsts_2_xori | decodedInsts_2_ori
         | decodedInsts_2_andi | decodedInsts_2_slli | decodedInsts_2_srli
         | decodedInsts_2_srai | decodedInsts_2_rori | _io_rs2Set_2_valid_T_16
         | decodedInsts_2_cpop | decodedInsts_2_sextb | decodedInsts_2_sexth
         | decodedInsts_2_zexth | decodedInsts_2_orcb | decodedInsts_2_rev8
         | _io_rs2Read_2_valid_T_19 | decodedInsts_2_max | decodedInsts_2_maxu
         | decodedInsts_2_rol | decodedInsts_2_ror | _io_rs2Read_2_valid_T_34
         | decodedInsts_2_mulhsu | decodedInsts_2_mulhu | decodedInsts_2_jalr
         | decodedInsts_d_rvv_ret_2_valid
         & ((|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})
            | io_inst_2_bits_inst[14:12] == 3'h4 | io_inst_2_bits_inst[14:12] == 3'h6
            | (&(io_inst_2_bits_inst[14:12])) & ~(&(io_inst_2_bits_inst[31:30])))
           ? 32'h1 << _GEN_16
           : 32'h0)
        | (_io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
           | decodedInsts_2_bltu | decodedInsts_2_bgeu | _io_rs2Read_2_valid_T_6
           | decodedInsts_2_slt | decodedInsts_2_sltu | decodedInsts_2_xor
           | decodedInsts_2_or | decodedInsts_2_and | decodedInsts_2_xnor
           | decodedInsts_2_orn | decodedInsts_2_andn | decodedInsts_2_sll
           | decodedInsts_2_srl | decodedInsts_2_sra | _io_rs2Read_2_valid_T_19
           | decodedInsts_2_max | decodedInsts_2_maxu | decodedInsts_2_rol
           | decodedInsts_2_ror | _io_rs2Read_2_valid_T_25 | decodedInsts_2_sw
           | _io_rs2Read_2_valid_T_34 | decodedInsts_2_mulhsu | decodedInsts_2_mulhu
           | decodedInsts_d_rvv_ret_2_valid
           & ((|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})
              & io_inst_2_bits_inst[27:26] == 2'h2 | (&(io_inst_2_bits_inst[14:12]))
              & io_inst_2_bits_inst[31:25] == 7'h40)
             ? 32'h1 << _GEN_17
             : 32'h0)) & comb_2} == 64'h0 & (rdScoreboard_2 & comb_2) == 32'h0
    & ~branched_2
    & ~(_slot0Interlock_T_36 | decodedInsts_0_wfi | decodedInsts_0_mpause
        | decodedInsts_0_flushat | decodedInsts_0_flushall | _io_rs2Set_0_valid_T_1
        | decodedInsts_0_csrrc)
    & (~decodedInsts_d_rvv_ret_2_valid
       | {_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37} == 2'h0 | ~configInvalid_2)
    & ~(decodedInsts_d_rvv_ret_2_valid & _rvvRdMark_valid_T_43
        & io_inst_2_bits_inst[14:12] == 3'h2
        & (io_inst_2_bits_inst[31:26] == 6'h31 | io_inst_2_bits_inst[31:26] == 6'h30
           | io_inst_2_bits_inst[31:26] == 6'h17
           | (io_inst_2_bits_inst[31:26] == 6'h14
                ? io_inst_2_bits_inst[19:15] == 5'h10 | io_inst_2_bits_inst[19:15] == 5'h3
                  | io_inst_2_bits_inst[19:15] == 5'h2
                  | io_inst_2_bits_inst[19:15] == 5'h1
                : io_inst_2_bits_inst[31:26] == 6'h10
                    ? io_inst_2_bits_inst[19:15] == 5'h11
                      | io_inst_2_bits_inst[19:15] == 5'h10
                    : io_inst_2_bits_inst[31:26] == 6'h7
                      | io_inst_2_bits_inst[31:26] == 6'h6
                      | io_inst_2_bits_inst[31:26] == 6'h5
                      | io_inst_2_bits_inst[31:26] == 6'h4
                      | io_inst_2_bits_inst[31:26] == 6'h3
                      | io_inst_2_bits_inst[31:26] == 6'h2
                      | io_inst_2_bits_inst[31:26] == 6'h1
                      | io_inst_2_bits_inst[31:26] == 6'h0))
        & (|{configInvalid_2, io_rvvState_bits_vstart})) & _isLsuCount_T_1 < _GEN_20
    & _rvvInterlock_isRvvCount_T_1 < io_rvvQueueCapacity
    & (|{decodedInsts_2_lui,
         decodedInsts_2_auipc,
         decodedInsts_2_jal,
         decodedInsts_2_jalr,
         decodedInsts_2_beq,
         decodedInsts_2_bne,
         decodedInsts_2_blt,
         decodedInsts_2_bge,
         decodedInsts_2_bltu,
         decodedInsts_2_bgeu,
         decodedInsts_2_lb,
         decodedInsts_2_lh,
         decodedInsts_2_lw,
         decodedInsts_2_lbu,
         decodedInsts_2_lhu,
         decodedInsts_2_sb,
         decodedInsts_2_sh,
         decodedInsts_2_sw,
         decodedInsts_2_addi,
         decodedInsts_2_slti,
         decodedInsts_2_sltiu,
         decodedInsts_2_xori,
         decodedInsts_2_ori,
         decodedInsts_2_andi,
         decodedInsts_2_add,
         decodedInsts_2_sub,
         decodedInsts_2_slt,
         decodedInsts_2_sltu,
         decodedInsts_2_xor,
         decodedInsts_2_or,
         decodedInsts_2_and,
         decodedInsts_2_xnor,
         decodedInsts_2_orn,
         decodedInsts_2_andn,
         decodedInsts_2_slli,
         decodedInsts_2_srli,
         decodedInsts_2_srai,
         decodedInsts_2_sll,
         decodedInsts_2_srl,
         decodedInsts_2_sra,
         decodedInsts_2_mul,
         decodedInsts_2_mulh,
         decodedInsts_2_mulhsu,
         decodedInsts_2_mulhu,
         decodedInsts_2_clz,
         decodedInsts_2_ctz,
         decodedInsts_2_cpop,
         decodedInsts_2_min,
         decodedInsts_2_minu,
         decodedInsts_2_max,
         decodedInsts_2_maxu,
         decodedInsts_2_sextb,
         decodedInsts_2_sexth,
         decodedInsts_2_zexth,
         decodedInsts_2_rol,
         decodedInsts_2_ror,
         decodedInsts_2_orcb,
         decodedInsts_2_rev8,
         decodedInsts_2_rori,
         decodedInsts_d_rvv_ret_2_valid}) & io_retirement_buffer_nSpace > 5'h2
    & ~io_retirement_buffer_trap_pending;
  wire        _alu_T_594 =
    decodedInsts_2_auipc | decodedInsts_2_addi | decodedInsts_2_add;
  wire        _alu_T_596 = decodedInsts_2_slti | decodedInsts_2_slt;
  wire        _alu_T_597 = decodedInsts_2_sltiu | decodedInsts_2_sltu;
  wire        _alu_T_598 = decodedInsts_2_xori | decodedInsts_2_xor;
  wire        _alu_T_599 = decodedInsts_2_ori | decodedInsts_2_or;
  wire        _alu_T_600 = decodedInsts_2_andi | decodedInsts_2_and;
  wire        _alu_T_601 = decodedInsts_2_slli | decodedInsts_2_sll;
  wire        _alu_T_602 = decodedInsts_2_srli | decodedInsts_2_srl;
  wire        _alu_T_603 = decodedInsts_2_srai | decodedInsts_2_sra;
  wire        io_alu_2_valid_0 =
    tryDispatch_2
    & (_alu_T_594 | decodedInsts_2_sub | _alu_T_596 | _alu_T_597 | _alu_T_598 | _alu_T_599
       | _alu_T_600 | _alu_T_601 | _alu_T_602 | _alu_T_603 | decodedInsts_2_lui
       | decodedInsts_2_andn | decodedInsts_2_orn | decodedInsts_2_xnor
       | decodedInsts_2_clz | decodedInsts_2_ctz | decodedInsts_2_cpop
       | decodedInsts_2_max | decodedInsts_2_maxu | decodedInsts_2_min
       | decodedInsts_2_minu | decodedInsts_2_sextb | decodedInsts_2_sexth
       | decodedInsts_2_rol | decodedInsts_2_ror | decodedInsts_2_orcb
       | decodedInsts_2_rev8 | decodedInsts_2_zexth | decodedInsts_2_rori);
  wire [3:0]  _bru_T_259 =
    {3'h0, decodedInsts_2_jalr} | {2'h0, decodedInsts_2_beq, 1'h0}
    | (decodedInsts_2_bne ? 4'h3 : 4'h0) | {1'h0, decodedInsts_2_blt, 2'h0}
    | (decodedInsts_2_bge ? 4'h5 : 4'h0) | (decodedInsts_2_bltu ? 4'h6 : 4'h0)
    | (decodedInsts_2_bgeu ? 4'h7 : 4'h0);
  wire [31:0] _bru_target_T_8 =
    io_inst_2_bits_addr
    + {{12{io_inst_2_bits_inst[31]}},
       io_inst_2_bits_inst[2]
         ? {io_inst_2_bits_inst[19:12],
            io_inst_2_bits_inst[20],
            io_inst_2_bits_inst[30:21]}
         : {{8{io_inst_2_bits_inst[31]}},
            io_inst_2_bits_inst[7],
            io_inst_2_bits_inst[30:25],
            io_inst_2_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_2_valid_T =
    tryDispatch_2
    & (decodedInsts_2_jal | decodedInsts_2_jalr | decodedInsts_2_beq | decodedInsts_2_bne
       | decodedInsts_2_blt | decodedInsts_2_bge | decodedInsts_2_bltu
       | decodedInsts_2_bgeu);
  wire        jalFault_2 =
    _io_bru_2_valid_T & _bru_T_259[2:0] == 3'h0 & (|(_bru_target_T_8[1:0]))
    & ~io_branchTaken;
  wire        jalrFault_2 =
    _io_bru_2_valid_T & _bru_T_259[2:0] == 3'h1 & io_jalrTarget_2_data[1]
    & ~io_branchTaken;
  wire        bxxFault_2 =
    _io_bru_2_valid_T
    & (|{&(_bru_T_259[2:0]),
         _bru_T_259[2:0] == 3'h6,
         _bru_T_259[2:0] == 3'h5,
         _bru_T_259[2:0] == 3'h4,
         _bru_T_259[2:0] == 3'h3,
         _bru_T_259[2:0] == 3'h2}) & (|(_bru_target_T_8[1:0])) & ~io_branchTaken;
  wire        io_bru_2_valid_0 =
    _io_bru_2_valid_T & ~(jalFault_2 | jalrFault_2 | bxxFault_2);
  wire        io_mlu_2_valid_0 =
    tryDispatch_2
    & (decodedInsts_2_mul | decodedInsts_2_mulh | decodedInsts_2_mulhsu
       | decodedInsts_2_mulhu);
  wire        lsu_isRvvLoad_2 = decodedInsts_d_rvv_ret_2_valid & _rvvRdMark_valid_T_37;
  wire        lsu_isRvvStore_2 =
    decodedInsts_d_rvv_ret_2_valid & _io_rs2Read_2_valid_T_44;
  wire        _lsu_T_359 = io_inst_2_bits_inst[27:26] == 2'h0;
  wire        _lsu_T_488 = lsu_isRvvLoad_2 & _lsu_T_359;
  wire        _lsu_T_361 = io_inst_2_bits_inst[27:26] == 2'h1;
  wire        _lsu_T_489 = lsu_isRvvLoad_2 & _lsu_T_361;
  wire        _lsu_T_363 = io_inst_2_bits_inst[27:26] == 2'h2;
  wire        _lsu_T_490 = lsu_isRvvLoad_2 & _lsu_T_363;
  wire        _lsu_T_491 = lsu_isRvvLoad_2 & (&(io_inst_2_bits_inst[27:26]));
  wire        _lsu_T_492 = lsu_isRvvStore_2 & _lsu_T_359;
  wire        _lsu_T_493 = lsu_isRvvStore_2 & _lsu_T_361;
  wire        _lsu_T_494 = lsu_isRvvStore_2 & _lsu_T_363;
  wire        _lsu_T_495 = lsu_isRvvStore_2 & (&(io_inst_2_bits_inst[27:26]));
  wire        io_lsu_2_valid_0 =
    tryDispatch_2
    & (decodedInsts_2_lb | decodedInsts_2_lh | decodedInsts_2_lw | decodedInsts_2_lbu
       | decodedInsts_2_lhu | decodedInsts_2_sb | decodedInsts_2_sh | decodedInsts_2_sw
       | _lsu_T_488 | _lsu_T_489 | _lsu_T_490 | _lsu_T_491 | _lsu_T_492 | _lsu_T_493
       | _lsu_T_494 | _lsu_T_495);
  wire        io_rvv_2_valid_0 = tryDispatch_2 & decodedInsts_d_rvv_ret_2_valid;
  wire        dispatched_2_2 = io_mlu_2_ready & io_mlu_2_valid_0;
  wire        dispatched_4_2 = io_lsu_2_ready & io_lsu_2_valid_0;
  wire        dispatched_5_1 = io_rvv_2_ready & io_rvv_2_valid_0;
  wire        lastReady_3 =
    io_alu_2_valid_0 | io_bru_2_valid_0 | dispatched_2_2 | dispatched_4_2
    | dispatched_5_1;
  wire        tryDispatch_3 =
    lastReady_3 & ~io_halted & ~io_interlock & io_inst_3_valid & ~(jumped_2 | isJump_2)
    & {((decodedInsts_3_jalr | _rdMark_valid_T_112 | decodedInsts_3_lw
         | decodedInsts_3_lbu | decodedInsts_3_lhu | _io_rs2Read_3_valid_T_25
         | decodedInsts_3_sw | decodedInsts_d_rvv_ret_3_valid
         & (|{_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55})
           ? 32'h1 << _GEN_18
           : 32'h0)
        | (_io_rs2Read_3_valid_T_25 | decodedInsts_3_sw ? 32'h1 << _GEN_19 : 32'h0))
         & (scoreboardScan_3 | io_scoreboard_regd),
       ((_io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
         | decodedInsts_3_bltu | decodedInsts_3_bgeu | _io_rs2Read_3_valid_T_6
         | decodedInsts_3_slt | decodedInsts_3_sltu | decodedInsts_3_xor
         | decodedInsts_3_or | decodedInsts_3_and | decodedInsts_3_xnor
         | decodedInsts_3_orn | decodedInsts_3_andn | decodedInsts_3_sll
         | decodedInsts_3_srl | decodedInsts_3_sra | _io_rs2Set_3_valid_T_6
         | decodedInsts_3_sltiu | decodedInsts_3_xori | decodedInsts_3_ori
         | decodedInsts_3_andi | decodedInsts_3_slli | decodedInsts_3_srli
         | decodedInsts_3_srai | decodedInsts_3_rori | _io_rs2Set_3_valid_T_16
         | decodedInsts_3_cpop | decodedInsts_3_sextb | decodedInsts_3_sexth
         | decodedInsts_3_zexth | decodedInsts_3_orcb | decodedInsts_3_rev8
         | _io_rs2Read_3_valid_T_19 | decodedInsts_3_max | decodedInsts_3_maxu
         | decodedInsts_3_rol | decodedInsts_3_ror | _io_rs2Read_3_valid_T_34
         | decodedInsts_3_mulhsu | decodedInsts_3_mulhu | decodedInsts_3_jalr
         | decodedInsts_d_rvv_ret_3_valid
         & ((|{_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55})
            | io_inst_3_bits_inst[14:12] == 3'h4 | io_inst_3_bits_inst[14:12] == 3'h6
            | (&(io_inst_3_bits_inst[14:12])) & ~(&(io_inst_3_bits_inst[31:30])))
           ? 32'h1 << _GEN_18
           : 32'h0)
        | (_io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
           | decodedInsts_3_bltu | decodedInsts_3_bgeu | _io_rs2Read_3_valid_T_6
           | decodedInsts_3_slt | decodedInsts_3_sltu | decodedInsts_3_xor
           | decodedInsts_3_or | decodedInsts_3_and | decodedInsts_3_xnor
           | decodedInsts_3_orn | decodedInsts_3_andn | decodedInsts_3_sll
           | decodedInsts_3_srl | decodedInsts_3_sra | _io_rs2Read_3_valid_T_19
           | decodedInsts_3_max | decodedInsts_3_maxu | decodedInsts_3_rol
           | decodedInsts_3_ror | _io_rs2Read_3_valid_T_25 | decodedInsts_3_sw
           | _io_rs2Read_3_valid_T_34 | decodedInsts_3_mulhsu | decodedInsts_3_mulhu
           | decodedInsts_d_rvv_ret_3_valid
           & ((|{_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55})
              & io_inst_3_bits_inst[27:26] == 2'h2 | (&(io_inst_3_bits_inst[14:12]))
              & io_inst_3_bits_inst[31:25] == 7'h40)
             ? 32'h1 << _GEN_19
             : 32'h0)) & comb_3} == 64'h0
    & ((~(_io_rs2Read_3_valid_T_25 | decodedInsts_3_sw)
        & ~(_io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
            | decodedInsts_3_bltu | decodedInsts_3_bgeu) | decodedInsts_d_rvv_ret_3_valid
        & (_rvvRdMark_valid_T_61 & (&(io_inst_3_bits_inst[14:12])) | _rvvRdMark_valid_T_61
           & io_inst_3_bits_inst[14:12] == 3'h2 & io_inst_3_bits_inst[31:26] == 6'h10)
          ? 32'h1 << io_inst_3_bits_inst[11:7]
          : 32'h0) & comb_3) == 32'h0 & ~(branched_2 | isBranch_2)
    & ~(_slot0Interlock_T_36 | decodedInsts_0_wfi | decodedInsts_0_mpause
        | decodedInsts_0_flushat | decodedInsts_0_flushall | _io_rs2Set_0_valid_T_1
        | decodedInsts_0_csrrc)
    & (~decodedInsts_d_rvv_ret_3_valid
       | {_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55} == 2'h0 | ~configInvalid_3)
    & ~(decodedInsts_d_rvv_ret_3_valid & _rvvRdMark_valid_T_61
        & io_inst_3_bits_inst[14:12] == 3'h2
        & (io_inst_3_bits_inst[31:26] == 6'h31 | io_inst_3_bits_inst[31:26] == 6'h30
           | io_inst_3_bits_inst[31:26] == 6'h17
           | (io_inst_3_bits_inst[31:26] == 6'h14
                ? io_inst_3_bits_inst[19:15] == 5'h10 | io_inst_3_bits_inst[19:15] == 5'h3
                  | io_inst_3_bits_inst[19:15] == 5'h2
                  | io_inst_3_bits_inst[19:15] == 5'h1
                : io_inst_3_bits_inst[31:26] == 6'h10
                    ? io_inst_3_bits_inst[19:15] == 5'h11
                      | io_inst_3_bits_inst[19:15] == 5'h10
                    : io_inst_3_bits_inst[31:26] == 6'h7
                      | io_inst_3_bits_inst[31:26] == 6'h6
                      | io_inst_3_bits_inst[31:26] == 6'h5
                      | io_inst_3_bits_inst[31:26] == 6'h4
                      | io_inst_3_bits_inst[31:26] == 6'h3
                      | io_inst_3_bits_inst[31:26] == 6'h2
                      | io_inst_3_bits_inst[31:26] == 6'h1
                      | io_inst_3_bits_inst[31:26] == 6'h0))
        & (|{configInvalid_3, io_rvvState_bits_vstart})) & _isLsuCount_T_1
    + {3'h0,
       _rdMark_valid_T_77 | decodedInsts_2_lw | decodedInsts_2_lbu | decodedInsts_2_lhu
         | _io_rs2Read_2_valid_T_25 | decodedInsts_2_sw | decodedInsts_d_rvv_ret_2_valid
         & (|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})} < _GEN_20
    & _rvvInterlock_isRvvCount_T_1
    + {3'h0, decodedInsts_d_rvv_ret_2_valid} < io_rvvQueueCapacity
    & (|{decodedInsts_3_lui,
         decodedInsts_3_auipc,
         decodedInsts_3_jal,
         decodedInsts_3_jalr,
         decodedInsts_3_beq,
         decodedInsts_3_bne,
         decodedInsts_3_blt,
         decodedInsts_3_bge,
         decodedInsts_3_bltu,
         decodedInsts_3_bgeu,
         decodedInsts_3_lb,
         decodedInsts_3_lh,
         decodedInsts_3_lw,
         decodedInsts_3_lbu,
         decodedInsts_3_lhu,
         decodedInsts_3_sb,
         decodedInsts_3_sh,
         decodedInsts_3_sw,
         decodedInsts_3_addi,
         decodedInsts_3_slti,
         decodedInsts_3_sltiu,
         decodedInsts_3_xori,
         decodedInsts_3_ori,
         decodedInsts_3_andi,
         decodedInsts_3_add,
         decodedInsts_3_sub,
         decodedInsts_3_slt,
         decodedInsts_3_sltu,
         decodedInsts_3_xor,
         decodedInsts_3_or,
         decodedInsts_3_and,
         decodedInsts_3_xnor,
         decodedInsts_3_orn,
         decodedInsts_3_andn,
         decodedInsts_3_slli,
         decodedInsts_3_srli,
         decodedInsts_3_srai,
         decodedInsts_3_sll,
         decodedInsts_3_srl,
         decodedInsts_3_sra,
         decodedInsts_3_mul,
         decodedInsts_3_mulh,
         decodedInsts_3_mulhsu,
         decodedInsts_3_mulhu,
         decodedInsts_3_clz,
         decodedInsts_3_ctz,
         decodedInsts_3_cpop,
         decodedInsts_3_min,
         decodedInsts_3_minu,
         decodedInsts_3_max,
         decodedInsts_3_maxu,
         decodedInsts_3_sextb,
         decodedInsts_3_sexth,
         decodedInsts_3_zexth,
         decodedInsts_3_rol,
         decodedInsts_3_ror,
         decodedInsts_3_orcb,
         decodedInsts_3_rev8,
         decodedInsts_3_rori,
         decodedInsts_d_rvv_ret_3_valid}) & (|(io_retirement_buffer_nSpace[4:2]))
    & ~io_retirement_buffer_trap_pending;
  wire        _alu_T_812 =
    decodedInsts_3_auipc | decodedInsts_3_addi | decodedInsts_3_add;
  wire        _alu_T_814 = decodedInsts_3_slti | decodedInsts_3_slt;
  wire        _alu_T_815 = decodedInsts_3_sltiu | decodedInsts_3_sltu;
  wire        _alu_T_816 = decodedInsts_3_xori | decodedInsts_3_xor;
  wire        _alu_T_817 = decodedInsts_3_ori | decodedInsts_3_or;
  wire        _alu_T_818 = decodedInsts_3_andi | decodedInsts_3_and;
  wire        _alu_T_819 = decodedInsts_3_slli | decodedInsts_3_sll;
  wire        _alu_T_820 = decodedInsts_3_srli | decodedInsts_3_srl;
  wire        _alu_T_821 = decodedInsts_3_srai | decodedInsts_3_sra;
  wire        io_alu_3_valid_0 =
    tryDispatch_3
    & (_alu_T_812 | decodedInsts_3_sub | _alu_T_814 | _alu_T_815 | _alu_T_816 | _alu_T_817
       | _alu_T_818 | _alu_T_819 | _alu_T_820 | _alu_T_821 | decodedInsts_3_lui
       | decodedInsts_3_andn | decodedInsts_3_orn | decodedInsts_3_xnor
       | decodedInsts_3_clz | decodedInsts_3_ctz | decodedInsts_3_cpop
       | decodedInsts_3_max | decodedInsts_3_maxu | decodedInsts_3_min
       | decodedInsts_3_minu | decodedInsts_3_sextb | decodedInsts_3_sexth
       | decodedInsts_3_rol | decodedInsts_3_ror | decodedInsts_3_orcb
       | decodedInsts_3_rev8 | decodedInsts_3_zexth | decodedInsts_3_rori);
  wire [3:0]  _bru_T_355 =
    {3'h0, decodedInsts_3_jalr} | {2'h0, decodedInsts_3_beq, 1'h0}
    | (decodedInsts_3_bne ? 4'h3 : 4'h0) | {1'h0, decodedInsts_3_blt, 2'h0}
    | (decodedInsts_3_bge ? 4'h5 : 4'h0) | (decodedInsts_3_bltu ? 4'h6 : 4'h0)
    | (decodedInsts_3_bgeu ? 4'h7 : 4'h0);
  wire [31:0] _bru_target_T_11 =
    io_inst_3_bits_addr
    + {{12{io_inst_3_bits_inst[31]}},
       io_inst_3_bits_inst[2]
         ? {io_inst_3_bits_inst[19:12],
            io_inst_3_bits_inst[20],
            io_inst_3_bits_inst[30:21]}
         : {{8{io_inst_3_bits_inst[31]}},
            io_inst_3_bits_inst[7],
            io_inst_3_bits_inst[30:25],
            io_inst_3_bits_inst[11:8]},
       1'h0};
  wire        _io_bru_3_valid_T =
    tryDispatch_3
    & (decodedInsts_3_jal | decodedInsts_3_jalr | decodedInsts_3_beq | decodedInsts_3_bne
       | decodedInsts_3_blt | decodedInsts_3_bge | decodedInsts_3_bltu
       | decodedInsts_3_bgeu);
  wire        jalFault_3 =
    _io_bru_3_valid_T & _bru_T_355[2:0] == 3'h0 & (|(_bru_target_T_11[1:0]))
    & ~io_branchTaken;
  wire        jalrFault_3 =
    _io_bru_3_valid_T & _bru_T_355[2:0] == 3'h1 & io_jalrTarget_3_data[1]
    & ~io_branchTaken;
  wire        bxxFault_3 =
    _io_bru_3_valid_T
    & (|{&(_bru_T_355[2:0]),
         _bru_T_355[2:0] == 3'h6,
         _bru_T_355[2:0] == 3'h5,
         _bru_T_355[2:0] == 3'h4,
         _bru_T_355[2:0] == 3'h3,
         _bru_T_355[2:0] == 3'h2}) & (|(_bru_target_T_11[1:0])) & ~io_branchTaken;
  wire        io_bru_3_valid_0 =
    _io_bru_3_valid_T & ~(jalFault_3 | jalrFault_3 | bxxFault_3);
  wire        io_mlu_3_valid_0 =
    tryDispatch_3
    & (decodedInsts_3_mul | decodedInsts_3_mulh | decodedInsts_3_mulhsu
       | decodedInsts_3_mulhu);
  wire        lsu_isRvvLoad_3 = decodedInsts_d_rvv_ret_3_valid & _rvvRdMark_valid_T_55;
  wire        lsu_isRvvStore_3 =
    decodedInsts_d_rvv_ret_3_valid & _io_rs2Read_3_valid_T_44;
  wire        _lsu_T_532 = io_inst_3_bits_inst[27:26] == 2'h0;
  wire        _lsu_T_661 = lsu_isRvvLoad_3 & _lsu_T_532;
  wire        _lsu_T_534 = io_inst_3_bits_inst[27:26] == 2'h1;
  wire        _lsu_T_662 = lsu_isRvvLoad_3 & _lsu_T_534;
  wire        _lsu_T_536 = io_inst_3_bits_inst[27:26] == 2'h2;
  wire        _lsu_T_663 = lsu_isRvvLoad_3 & _lsu_T_536;
  wire        _lsu_T_664 = lsu_isRvvLoad_3 & (&(io_inst_3_bits_inst[27:26]));
  wire        _lsu_T_665 = lsu_isRvvStore_3 & _lsu_T_532;
  wire        _lsu_T_666 = lsu_isRvvStore_3 & _lsu_T_534;
  wire        _lsu_T_667 = lsu_isRvvStore_3 & _lsu_T_536;
  wire        _lsu_T_668 = lsu_isRvvStore_3 & (&(io_inst_3_bits_inst[27:26]));
  wire        io_lsu_3_valid_0 =
    tryDispatch_3
    & (decodedInsts_3_lb | decodedInsts_3_lh | decodedInsts_3_lw | decodedInsts_3_lbu
       | decodedInsts_3_lhu | decodedInsts_3_sb | decodedInsts_3_sh | decodedInsts_3_sw
       | _lsu_T_661 | _lsu_T_662 | _lsu_T_663 | _lsu_T_664 | _lsu_T_665 | _lsu_T_666
       | _lsu_T_667 | _lsu_T_668);
  wire        io_rvv_3_valid_0 = tryDispatch_3 & decodedInsts_d_rvv_ret_3_valid;
  wire        dispatched_2_3 = io_mlu_3_ready & io_mlu_3_valid_0;
  wire        dispatched_4_3 = io_lsu_3_ready & io_lsu_3_valid_0;
  wire        dispatched_5_2 = io_rvv_3_ready & io_rvv_3_valid_0;
  wire        lastReady_4 =
    io_alu_3_valid_0 | io_bru_3_valid_0 | dispatched_2_3 | dispatched_4_3
    | dispatched_5_2;
  wire        _io_rs2Set_0_valid_T = lastReady_1 & io_inst_0_valid;
  wire        _rdMark_valid_T_17 = decodedInsts_d_rvv_ret_bits_opcode == 2'h2;
  wire        _io_rs2Set_1_valid_T = lastReady_2 & io_inst_1_valid;
  wire        _rdMark_valid_T_54 = decodedInsts_d_rvv_ret_1_bits_opcode == 2'h2;
  wire        _io_rs2Set_2_valid_T = lastReady_3 & io_inst_2_valid;
  wire        _rdMark_valid_T_89 = decodedInsts_d_rvv_ret_2_bits_opcode == 2'h2;
  wire        _io_rs2Set_3_valid_T = lastReady_4 & io_inst_3_valid;
  wire        _rdMark_valid_T_124 = decodedInsts_d_rvv_ret_3_bits_opcode == 2'h2;
  assign io_csrFault_0 = csr_valid & ~csr_address_valid & tryDispatch;
  assign io_jalFault_0 = jalFault;
  assign io_jalFault_1 = jalFault_1;
  assign io_jalFault_2 = jalFault_2;
  assign io_jalFault_3 = jalFault_3;
  assign io_jalrFault_0 = jalrFault;
  assign io_jalrFault_1 = jalrFault_1;
  assign io_jalrFault_2 = jalrFault_2;
  assign io_jalrFault_3 = jalrFault_3;
  assign io_bxxFault_0 = bxxFault;
  assign io_bxxFault_1 = bxxFault_1;
  assign io_bxxFault_2 = bxxFault_2;
  assign io_bxxFault_3 = bxxFault_3;
  assign io_undefFault_0 =
    io_inst_0_valid
    & {decodedInsts_0_lui,
       decodedInsts_0_auipc,
       decodedInsts_0_jal,
       decodedInsts_0_jalr,
       decodedInsts_0_beq,
       decodedInsts_0_bne,
       decodedInsts_0_blt,
       decodedInsts_0_bge,
       decodedInsts_0_bltu,
       decodedInsts_0_bgeu,
       decodedInsts_0_csrrw,
       decodedInsts_0_csrrs,
       decodedInsts_0_csrrc,
       decodedInsts_0_lb,
       decodedInsts_0_lh,
       decodedInsts_0_lw,
       decodedInsts_0_lbu,
       decodedInsts_0_lhu,
       decodedInsts_0_sb,
       decodedInsts_0_sh,
       decodedInsts_0_sw,
       decodedInsts_0_fence,
       decodedInsts_0_addi,
       decodedInsts_0_slti,
       decodedInsts_0_sltiu,
       decodedInsts_0_xori,
       decodedInsts_0_ori,
       decodedInsts_0_andi,
       decodedInsts_0_add,
       decodedInsts_0_sub,
       decodedInsts_0_slt,
       decodedInsts_0_sltu,
       decodedInsts_0_xor,
       decodedInsts_0_or,
       decodedInsts_0_and,
       decodedInsts_0_xnor,
       decodedInsts_0_orn,
       decodedInsts_0_andn,
       decodedInsts_0_slli,
       decodedInsts_0_srli,
       decodedInsts_0_srai,
       decodedInsts_0_sll,
       decodedInsts_0_srl,
       decodedInsts_0_sra,
       decodedInsts_0_mul,
       decodedInsts_0_mulh,
       decodedInsts_0_mulhsu,
       decodedInsts_0_mulhu,
       decodedInsts_0_div,
       decodedInsts_0_divu,
       decodedInsts_0_rem,
       decodedInsts_0_remu,
       decodedInsts_0_clz,
       decodedInsts_0_ctz,
       decodedInsts_0_cpop,
       decodedInsts_0_min,
       decodedInsts_0_minu,
       decodedInsts_0_max,
       decodedInsts_0_maxu,
       decodedInsts_0_sextb,
       decodedInsts_0_sexth,
       decodedInsts_0_zexth,
       decodedInsts_0_rol,
       decodedInsts_0_ror,
       decodedInsts_0_orcb,
       decodedInsts_0_rev8,
       decodedInsts_0_rori,
       decodedInsts_0_ebreak,
       decodedInsts_0_ecall,
       decodedInsts_0_wfi,
       decodedInsts_0_mpause,
       decodedInsts_0_mret,
       decodedInsts_0_fencei,
       decodedInsts_0_flushat,
       decodedInsts_0_flushall,
       decodedInsts_slog,
       decodedInsts_d_rvv_ret_valid,
       decodedInsts_floatValid} == 78'h0;
  assign io_rvvFault_0 =
    io_inst_0_valid & decodedInsts_d_rvv_ret_valid & _rvvRdMark_valid_T_7
    & io_inst_0_bits_inst[14:12] == 3'h2
    & (io_inst_0_bits_inst[31:26] == 6'h31 | io_inst_0_bits_inst[31:26] == 6'h30
       | io_inst_0_bits_inst[31:26] == 6'h17
       | (io_inst_0_bits_inst[31:26] == 6'h14
            ? io_inst_0_bits_inst[19:15] == 5'h10 | io_inst_0_bits_inst[19:15] == 5'h3
              | io_inst_0_bits_inst[19:15] == 5'h2 | io_inst_0_bits_inst[19:15] == 5'h1
            : io_inst_0_bits_inst[31:26] == 6'h10
                ? io_inst_0_bits_inst[19:15] == 5'h11
                  | io_inst_0_bits_inst[19:15] == 5'h10
                : io_inst_0_bits_inst[31:26] == 6'h7 | io_inst_0_bits_inst[31:26] == 6'h6
                  | io_inst_0_bits_inst[31:26] == 6'h5
                  | io_inst_0_bits_inst[31:26] == 6'h4
                  | io_inst_0_bits_inst[31:26] == 6'h3
                  | io_inst_0_bits_inst[31:26] == 6'h2
                  | io_inst_0_bits_inst[31:26] == 6'h1
                  | ~(|(io_inst_0_bits_inst[31:26])))) & io_rvvState_valid
    & (|io_rvvState_bits_vstart);
  assign io_bruTarget_0 = _bru_target_T_2;
  assign io_bruTarget_1 = _bru_target_T_5;
  assign io_bruTarget_2 = _bru_target_T_8;
  assign io_bruTarget_3 = _bru_target_T_11;
  assign io_inst_0_ready = lastReady_1;
  assign io_inst_1_ready = lastReady_2;
  assign io_inst_2_ready = lastReady_3;
  assign io_inst_3_ready = lastReady_4;
  assign io_rs1Read_0_valid =
    _io_rs2Set_0_valid_T
    & (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
       | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
       | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor | decodedInsts_0_or
       | decodedInsts_0_and | decodedInsts_0_xnor | decodedInsts_0_orn
       | decodedInsts_0_andn | decodedInsts_0_sll | decodedInsts_0_srl
       | decodedInsts_0_sra | _io_rs2Set_0_valid_T_6 | decodedInsts_0_sltiu
       | decodedInsts_0_xori | decodedInsts_0_ori | decodedInsts_0_andi
       | decodedInsts_0_slli | decodedInsts_0_srli | decodedInsts_0_srai
       | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16 | decodedInsts_0_cpop
       | decodedInsts_0_sextb | decodedInsts_0_sexth | decodedInsts_0_zexth
       | decodedInsts_0_orcb | decodedInsts_0_rev8 | _io_rs2Read_0_valid_T_19
       | decodedInsts_0_max | decodedInsts_0_maxu | decodedInsts_0_rol
       | decodedInsts_0_ror | _io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc
       | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
       | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
       | decodedInsts_slog | decodedInsts_0_jalr | _io_rs1Read_0_valid_T_56
       | decodedInsts_d_rvv_ret_valid
       & ((|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1})
          | io_inst_0_bits_inst[14:12] == 3'h4 | io_inst_0_bits_inst[14:12] == 3'h6
          | (&(io_inst_0_bits_inst[14:12])) & ~(&(io_inst_0_bits_inst[31:30]))));
  assign io_rs1Read_0_addr =
    io_inst_0_bits_inst[0] ? io_inst_0_bits_inst[19:15] : {4'h0, io_inst_0_bits_inst[27]};
  assign io_rs1Read_1_valid =
    _io_rs2Set_1_valid_T
    & (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
       | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
       | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor | decodedInsts_1_or
       | decodedInsts_1_and | decodedInsts_1_xnor | decodedInsts_1_orn
       | decodedInsts_1_andn | decodedInsts_1_sll | decodedInsts_1_srl
       | decodedInsts_1_sra | _io_rs2Set_1_valid_T_6 | decodedInsts_1_sltiu
       | decodedInsts_1_xori | decodedInsts_1_ori | decodedInsts_1_andi
       | decodedInsts_1_slli | decodedInsts_1_srli | decodedInsts_1_srai
       | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16 | decodedInsts_1_cpop
       | decodedInsts_1_sextb | decodedInsts_1_sexth | decodedInsts_1_zexth
       | decodedInsts_1_orcb | decodedInsts_1_rev8 | _io_rs2Read_1_valid_T_19
       | decodedInsts_1_max | decodedInsts_1_maxu | decodedInsts_1_rol
       | decodedInsts_1_ror | _io_rs2Read_1_valid_T_34 | decodedInsts_1_mulhsu
       | decodedInsts_1_mulhu | decodedInsts_1_jalr | decodedInsts_d_rvv_ret_1_valid
       & ((|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})
          | io_inst_1_bits_inst[14:12] == 3'h4 | io_inst_1_bits_inst[14:12] == 3'h6
          | (&(io_inst_1_bits_inst[14:12])) & ~(&(io_inst_1_bits_inst[31:30]))));
  assign io_rs1Read_1_addr =
    io_inst_1_bits_inst[0] ? io_inst_1_bits_inst[19:15] : {4'h0, io_inst_1_bits_inst[28]};
  assign io_rs1Read_2_valid =
    _io_rs2Set_2_valid_T
    & (_io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
       | decodedInsts_2_bltu | decodedInsts_2_bgeu | _io_rs2Read_2_valid_T_6
       | decodedInsts_2_slt | decodedInsts_2_sltu | decodedInsts_2_xor | decodedInsts_2_or
       | decodedInsts_2_and | decodedInsts_2_xnor | decodedInsts_2_orn
       | decodedInsts_2_andn | decodedInsts_2_sll | decodedInsts_2_srl
       | decodedInsts_2_sra | _io_rs2Set_2_valid_T_6 | decodedInsts_2_sltiu
       | decodedInsts_2_xori | decodedInsts_2_ori | decodedInsts_2_andi
       | decodedInsts_2_slli | decodedInsts_2_srli | decodedInsts_2_srai
       | decodedInsts_2_rori | _io_rs2Set_2_valid_T_16 | decodedInsts_2_cpop
       | decodedInsts_2_sextb | decodedInsts_2_sexth | decodedInsts_2_zexth
       | decodedInsts_2_orcb | decodedInsts_2_rev8 | _io_rs2Read_2_valid_T_19
       | decodedInsts_2_max | decodedInsts_2_maxu | decodedInsts_2_rol
       | decodedInsts_2_ror | _io_rs2Read_2_valid_T_34 | decodedInsts_2_mulhsu
       | decodedInsts_2_mulhu | decodedInsts_2_jalr | decodedInsts_d_rvv_ret_2_valid
       & ((|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})
          | io_inst_2_bits_inst[14:12] == 3'h4 | io_inst_2_bits_inst[14:12] == 3'h6
          | (&(io_inst_2_bits_inst[14:12])) & ~(&(io_inst_2_bits_inst[31:30]))));
  assign io_rs1Read_2_addr =
    io_inst_2_bits_inst[0] ? io_inst_2_bits_inst[19:15] : {4'h0, io_inst_2_bits_inst[29]};
  assign io_rs1Read_3_valid =
    _io_rs2Set_3_valid_T
    & (_io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
       | decodedInsts_3_bltu | decodedInsts_3_bgeu | _io_rs2Read_3_valid_T_6
       | decodedInsts_3_slt | decodedInsts_3_sltu | decodedInsts_3_xor | decodedInsts_3_or
       | decodedInsts_3_and | decodedInsts_3_xnor | decodedInsts_3_orn
       | decodedInsts_3_andn | decodedInsts_3_sll | decodedInsts_3_srl
       | decodedInsts_3_sra | _io_rs2Set_3_valid_T_6 | decodedInsts_3_sltiu
       | decodedInsts_3_xori | decodedInsts_3_ori | decodedInsts_3_andi
       | decodedInsts_3_slli | decodedInsts_3_srli | decodedInsts_3_srai
       | decodedInsts_3_rori | _io_rs2Set_3_valid_T_16 | decodedInsts_3_cpop
       | decodedInsts_3_sextb | decodedInsts_3_sexth | decodedInsts_3_zexth
       | decodedInsts_3_orcb | decodedInsts_3_rev8 | _io_rs2Read_3_valid_T_19
       | decodedInsts_3_max | decodedInsts_3_maxu | decodedInsts_3_rol
       | decodedInsts_3_ror | _io_rs2Read_3_valid_T_34 | decodedInsts_3_mulhsu
       | decodedInsts_3_mulhu | decodedInsts_3_jalr | decodedInsts_d_rvv_ret_3_valid
       & ((|{_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55})
          | io_inst_3_bits_inst[14:12] == 3'h4 | io_inst_3_bits_inst[14:12] == 3'h6
          | (&(io_inst_3_bits_inst[14:12])) & ~(&(io_inst_3_bits_inst[31:30]))));
  assign io_rs1Read_3_addr =
    io_inst_3_bits_inst[0] ? io_inst_3_bits_inst[19:15] : {4'h0, io_inst_3_bits_inst[30]};
  assign io_rs1Set_0_valid =
    _io_rs2Set_0_valid_T
    & (decodedInsts_0_auipc | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc)
       & io_inst_0_bits_inst[14]);
  assign io_rs1Set_0_value =
    _io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc
      ? decodedInsts_0_immcsr
      : io_inst_0_bits_addr;
  assign io_rs1Set_1_valid = _io_rs2Set_1_valid_T & decodedInsts_1_auipc;
  assign io_rs1Set_1_value = io_inst_1_bits_addr;
  assign io_rs1Set_2_valid = _io_rs2Set_2_valid_T & decodedInsts_2_auipc;
  assign io_rs1Set_2_value = io_inst_2_bits_addr;
  assign io_rs1Set_3_valid = _io_rs2Set_3_valid_T & decodedInsts_3_auipc;
  assign io_rs1Set_3_value = io_inst_3_bits_addr;
  assign io_rs2Read_0_valid =
    _io_rs2Set_0_valid_T
    & (_io_rs2Read_0_valid_T_1 | decodedInsts_0_blt | decodedInsts_0_bge
       | decodedInsts_0_bltu | decodedInsts_0_bgeu | _io_rs2Read_0_valid_T_6
       | decodedInsts_0_slt | decodedInsts_0_sltu | decodedInsts_0_xor | decodedInsts_0_or
       | decodedInsts_0_and | decodedInsts_0_xnor | decodedInsts_0_orn
       | decodedInsts_0_andn | decodedInsts_0_sll | decodedInsts_0_srl
       | decodedInsts_0_sra | _io_rs2Read_0_valid_T_19 | decodedInsts_0_max
       | decodedInsts_0_maxu | decodedInsts_0_rol | decodedInsts_0_ror
       | _io_rs2Read_0_valid_T_25 | decodedInsts_0_sw
       | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc) & ~(io_inst_0_bits_inst[14])
       | _io_rs2Read_0_valid_T_34 | decodedInsts_0_mulhsu | decodedInsts_0_mulhu
       | _io_rs2Read_0_valid_T_38 | decodedInsts_0_rem | decodedInsts_0_remu
       | decodedInsts_slog | decodedInsts_d_rvv_ret_valid
       & ((|{_io_rs2Read_0_valid_T_44, _rvvRdMark_valid_T_1})
          & io_inst_0_bits_inst[27:26] == 2'h2 | (&(io_inst_0_bits_inst[14:12]))
          & io_inst_0_bits_inst[31:25] == 7'h40));
  assign io_rs2Read_0_addr = io_inst_0_bits_inst[24:20];
  assign io_rs2Read_1_valid =
    _io_rs2Set_1_valid_T
    & (_io_rs2Read_1_valid_T_1 | decodedInsts_1_blt | decodedInsts_1_bge
       | decodedInsts_1_bltu | decodedInsts_1_bgeu | _io_rs2Read_1_valid_T_6
       | decodedInsts_1_slt | decodedInsts_1_sltu | decodedInsts_1_xor | decodedInsts_1_or
       | decodedInsts_1_and | decodedInsts_1_xnor | decodedInsts_1_orn
       | decodedInsts_1_andn | decodedInsts_1_sll | decodedInsts_1_srl
       | decodedInsts_1_sra | _io_rs2Read_1_valid_T_19 | decodedInsts_1_max
       | decodedInsts_1_maxu | decodedInsts_1_rol | decodedInsts_1_ror
       | _io_rs2Read_1_valid_T_25 | decodedInsts_1_sw | _io_rs2Read_1_valid_T_34
       | decodedInsts_1_mulhsu | decodedInsts_1_mulhu | decodedInsts_d_rvv_ret_1_valid
       & ((|{_io_rs2Read_1_valid_T_44, _rvvRdMark_valid_T_19})
          & io_inst_1_bits_inst[27:26] == 2'h2 | (&(io_inst_1_bits_inst[14:12]))
          & io_inst_1_bits_inst[31:25] == 7'h40));
  assign io_rs2Read_1_addr = io_inst_1_bits_inst[24:20];
  assign io_rs2Read_2_valid =
    _io_rs2Set_2_valid_T
    & (_io_rs2Read_2_valid_T_1 | decodedInsts_2_blt | decodedInsts_2_bge
       | decodedInsts_2_bltu | decodedInsts_2_bgeu | _io_rs2Read_2_valid_T_6
       | decodedInsts_2_slt | decodedInsts_2_sltu | decodedInsts_2_xor | decodedInsts_2_or
       | decodedInsts_2_and | decodedInsts_2_xnor | decodedInsts_2_orn
       | decodedInsts_2_andn | decodedInsts_2_sll | decodedInsts_2_srl
       | decodedInsts_2_sra | _io_rs2Read_2_valid_T_19 | decodedInsts_2_max
       | decodedInsts_2_maxu | decodedInsts_2_rol | decodedInsts_2_ror
       | _io_rs2Read_2_valid_T_25 | decodedInsts_2_sw | _io_rs2Read_2_valid_T_34
       | decodedInsts_2_mulhsu | decodedInsts_2_mulhu | decodedInsts_d_rvv_ret_2_valid
       & ((|{_io_rs2Read_2_valid_T_44, _rvvRdMark_valid_T_37})
          & io_inst_2_bits_inst[27:26] == 2'h2 | (&(io_inst_2_bits_inst[14:12]))
          & io_inst_2_bits_inst[31:25] == 7'h40));
  assign io_rs2Read_2_addr = io_inst_2_bits_inst[24:20];
  assign io_rs2Read_3_valid =
    _io_rs2Set_3_valid_T
    & (_io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
       | decodedInsts_3_bltu | decodedInsts_3_bgeu | _io_rs2Read_3_valid_T_6
       | decodedInsts_3_slt | decodedInsts_3_sltu | decodedInsts_3_xor | decodedInsts_3_or
       | decodedInsts_3_and | decodedInsts_3_xnor | decodedInsts_3_orn
       | decodedInsts_3_andn | decodedInsts_3_sll | decodedInsts_3_srl
       | decodedInsts_3_sra | _io_rs2Read_3_valid_T_19 | decodedInsts_3_max
       | decodedInsts_3_maxu | decodedInsts_3_rol | decodedInsts_3_ror
       | _io_rs2Read_3_valid_T_25 | decodedInsts_3_sw | _io_rs2Read_3_valid_T_34
       | decodedInsts_3_mulhsu | decodedInsts_3_mulhu | decodedInsts_d_rvv_ret_3_valid
       & ((|{_io_rs2Read_3_valid_T_44, _rvvRdMark_valid_T_55})
          & io_inst_3_bits_inst[27:26] == 2'h2 | (&(io_inst_3_bits_inst[14:12]))
          & io_inst_3_bits_inst[31:25] == 7'h40));
  assign io_rs2Read_3_addr = io_inst_3_bits_inst[24:20];
  assign io_rs2Set_0_valid =
    _io_rs2Set_0_valid_T
    & (decodedInsts_0_auipc | (_io_rs2Set_0_valid_T_1 | decodedInsts_0_csrrc)
       & io_inst_0_bits_inst[14] | _io_rs2Set_0_valid_T_6 | decodedInsts_0_sltiu
       | decodedInsts_0_xori | decodedInsts_0_ori | decodedInsts_0_andi
       | decodedInsts_0_slli | decodedInsts_0_srli | decodedInsts_0_srai
       | decodedInsts_0_rori | _io_rs2Set_0_valid_T_16 | decodedInsts_0_cpop
       | decodedInsts_0_sextb | decodedInsts_0_sexth | decodedInsts_0_zexth
       | decodedInsts_0_orcb | decodedInsts_0_rev8 | decodedInsts_0_lui);
  assign io_rs2Set_0_value =
    decodedInsts_0_auipc | decodedInsts_0_lui
      ? {io_inst_0_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_1, io_inst_0_bits_inst[31:20]};
  assign io_rs2Set_1_valid =
    _io_rs2Set_1_valid_T
    & (decodedInsts_1_auipc | _io_rs2Set_1_valid_T_6 | decodedInsts_1_sltiu
       | decodedInsts_1_xori | decodedInsts_1_ori | decodedInsts_1_andi
       | decodedInsts_1_slli | decodedInsts_1_srli | decodedInsts_1_srai
       | decodedInsts_1_rori | _io_rs2Set_1_valid_T_16 | decodedInsts_1_cpop
       | decodedInsts_1_sextb | decodedInsts_1_sexth | decodedInsts_1_zexth
       | decodedInsts_1_orcb | decodedInsts_1_rev8 | decodedInsts_1_lui);
  assign io_rs2Set_1_value =
    decodedInsts_1_auipc | decodedInsts_1_lui
      ? {io_inst_1_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_5, io_inst_1_bits_inst[31:20]};
  assign io_rs2Set_2_valid =
    _io_rs2Set_2_valid_T
    & (decodedInsts_2_auipc | _io_rs2Set_2_valid_T_6 | decodedInsts_2_sltiu
       | decodedInsts_2_xori | decodedInsts_2_ori | decodedInsts_2_andi
       | decodedInsts_2_slli | decodedInsts_2_srli | decodedInsts_2_srai
       | decodedInsts_2_rori | _io_rs2Set_2_valid_T_16 | decodedInsts_2_cpop
       | decodedInsts_2_sextb | decodedInsts_2_sexth | decodedInsts_2_zexth
       | decodedInsts_2_orcb | decodedInsts_2_rev8 | decodedInsts_2_lui);
  assign io_rs2Set_2_value =
    decodedInsts_2_auipc | decodedInsts_2_lui
      ? {io_inst_2_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_9, io_inst_2_bits_inst[31:20]};
  assign io_rs2Set_3_valid =
    _io_rs2Set_3_valid_T
    & (decodedInsts_3_auipc | _io_rs2Set_3_valid_T_6 | decodedInsts_3_sltiu
       | decodedInsts_3_xori | decodedInsts_3_ori | decodedInsts_3_andi
       | decodedInsts_3_slli | decodedInsts_3_srli | decodedInsts_3_srai
       | decodedInsts_3_rori | _io_rs2Set_3_valid_T_16 | decodedInsts_3_cpop
       | decodedInsts_3_sextb | decodedInsts_3_sexth | decodedInsts_3_zexth
       | decodedInsts_3_orcb | decodedInsts_3_rev8 | decodedInsts_3_lui);
  assign io_rs2Set_3_value =
    decodedInsts_3_auipc | decodedInsts_3_lui
      ? {io_inst_3_bits_inst[31:12], 12'h0}
      : {_decodedInsts_d_imm12_T_13, io_inst_3_bits_inst[31:20]};
  assign io_rdMark_0_valid =
    io_alu_0_valid_0 | io_mlu_0_valid_0 | dispatched_3 | dispatched_4
    & (_rdMark_valid_T_5 | decodedInsts_0_lw | decodedInsts_0_lbu | decodedInsts_0_lhu)
    | io_csr_valid_0 | dispatched_8
    & (_rdMark_valid_T_17 & (&(io_inst_0_bits_inst[14:12])) | _rdMark_valid_T_17
       & io_inst_0_bits_inst[14:12] == 3'h2 & io_inst_0_bits_inst[31:26] == 6'h10)
    | dispatched_9 & decodedInsts_float_scalar_rd | io_bru_0_valid_0
    & (|{_bru_T_67 == 4'h1, _bru_T_67 == 4'h0}) & (|(io_inst_0_bits_inst[11:7]));
  assign io_rdMark_0_addr = io_inst_0_bits_inst[11:7];
  assign io_rdMark_1_valid =
    io_alu_1_valid_0 | dispatched_2_1 | dispatched_4_1
    & (_rdMark_valid_T_42 | decodedInsts_1_lw | decodedInsts_1_lbu | decodedInsts_1_lhu)
    | dispatched_5
    & (_rdMark_valid_T_54 & (&(io_inst_1_bits_inst[14:12])) | _rdMark_valid_T_54
       & io_inst_1_bits_inst[14:12] == 3'h2 & io_inst_1_bits_inst[31:26] == 6'h10)
    | io_bru_1_valid_0 & (|{_bru_T_163[2:0] == 3'h1, _bru_T_163[2:0] == 3'h0})
    & (|(io_inst_1_bits_inst[11:7]));
  assign io_rdMark_1_addr = io_inst_1_bits_inst[11:7];
  assign io_rdMark_2_valid =
    io_alu_2_valid_0 | dispatched_2_2 | dispatched_4_2
    & (_rdMark_valid_T_77 | decodedInsts_2_lw | decodedInsts_2_lbu | decodedInsts_2_lhu)
    | dispatched_5_1
    & (_rdMark_valid_T_89 & (&(io_inst_2_bits_inst[14:12])) | _rdMark_valid_T_89
       & io_inst_2_bits_inst[14:12] == 3'h2 & io_inst_2_bits_inst[31:26] == 6'h10)
    | io_bru_2_valid_0 & (|{_bru_T_259[2:0] == 3'h1, _bru_T_259[2:0] == 3'h0})
    & (|(io_inst_2_bits_inst[11:7]));
  assign io_rdMark_2_addr = io_inst_2_bits_inst[11:7];
  assign io_rdMark_3_valid =
    io_alu_3_valid_0 | dispatched_2_3 | dispatched_4_3
    & (_rdMark_valid_T_112 | decodedInsts_3_lw | decodedInsts_3_lbu | decodedInsts_3_lhu)
    | dispatched_5_2
    & (_rdMark_valid_T_124 & (&(io_inst_3_bits_inst[14:12])) | _rdMark_valid_T_124
       & io_inst_3_bits_inst[14:12] == 3'h2 & io_inst_3_bits_inst[31:26] == 6'h10)
    | io_bru_3_valid_0 & (|{_bru_T_355[2:0] == 3'h1, _bru_T_355[2:0] == 3'h0})
    & (|(io_inst_3_bits_inst[11:7]));
  assign io_rdMark_3_addr = io_inst_3_bits_inst[11:7];
  assign io_busRead_0_bypass =
    io_inst_0_bits_inst[31:25] == 7'h0
    & (~(io_inst_0_bits_inst[5]) | io_inst_0_bits_inst[6]
         ? io_inst_0_bits_inst[24:20] == 5'h0
         : io_inst_0_bits_inst[11:7] == 5'h0);
  assign io_busRead_0_immen = ~decodedInsts_0_flushat;
  assign io_busRead_0_immed =
    decodedInsts_d_rvv_ret_valid
      ? 32'h0
      : {_decodedInsts_d_imm12_T_1,
         io_inst_0_bits_inst[31:25],
         io_inst_0_bits_inst[6:3] == 4'h4 & (&(io_inst_0_bits_inst[1:0]))
           ? io_inst_0_bits_inst[11:7]
           : io_inst_0_bits_inst[24:20]};
  assign io_busRead_1_bypass =
    io_inst_1_bits_inst[31:25] == 7'h0
    & (~(io_inst_1_bits_inst[5]) | io_inst_1_bits_inst[6]
         ? io_inst_1_bits_inst[24:20] == 5'h0
         : io_inst_1_bits_inst[11:7] == 5'h0);
  assign io_busRead_1_immed =
    decodedInsts_d_rvv_ret_1_valid
      ? 32'h0
      : {_decodedInsts_d_imm12_T_5,
         io_inst_1_bits_inst[31:25],
         io_inst_1_bits_inst[6:3] == 4'h4 & (&(io_inst_1_bits_inst[1:0]))
           ? io_inst_1_bits_inst[11:7]
           : io_inst_1_bits_inst[24:20]};
  assign io_busRead_2_bypass =
    io_inst_2_bits_inst[31:25] == 7'h0
    & (~(io_inst_2_bits_inst[5]) | io_inst_2_bits_inst[6]
         ? io_inst_2_bits_inst[24:20] == 5'h0
         : io_inst_2_bits_inst[11:7] == 5'h0);
  assign io_busRead_2_immed =
    decodedInsts_d_rvv_ret_2_valid
      ? 32'h0
      : {_decodedInsts_d_imm12_T_9,
         io_inst_2_bits_inst[31:25],
         io_inst_2_bits_inst[6:3] == 4'h4 & (&(io_inst_2_bits_inst[1:0]))
           ? io_inst_2_bits_inst[11:7]
           : io_inst_2_bits_inst[24:20]};
  assign io_busRead_3_bypass =
    io_inst_3_bits_inst[31:25] == 7'h0
    & (~(io_inst_3_bits_inst[5]) | io_inst_3_bits_inst[6]
         ? io_inst_3_bits_inst[24:20] == 5'h0
         : io_inst_3_bits_inst[11:7] == 5'h0);
  assign io_busRead_3_immed =
    decodedInsts_d_rvv_ret_3_valid
      ? 32'h0
      : {_decodedInsts_d_imm12_T_13,
         io_inst_3_bits_inst[31:25],
         io_inst_3_bits_inst[6:3] == 4'h4 & (&(io_inst_3_bits_inst[1:0]))
           ? io_inst_3_bits_inst[11:7]
           : io_inst_3_bits_inst[24:20]};
  assign io_rdMark_flt_valid =
    dispatched_9 & ~decodedInsts_float_scalar_rd | dispatched_4 & decodedInsts_floatValid
    & _rdMark_flt_valid_T_4;
  assign io_rdMark_flt_addr = io_inst_0_bits_inst[11:7];
  assign io_rvvRdMark_0_valid =
    dispatched_8
    & (_rvvRdMark_valid_T_1 | _rvvRdMark_valid_T_7
       & ~(_rvvRdMark_valid_T_7 & (&(io_inst_0_bits_inst[14:12])) | _rvvRdMark_valid_T_7
           & io_inst_0_bits_inst[14:12] == 3'h2 & io_inst_0_bits_inst[31:26] == 6'h10));
  assign io_rvvRdMark_0_addr = io_inst_0_bits_inst[11:7];
  assign io_rvvRdMark_1_valid =
    dispatched_5
    & (_rvvRdMark_valid_T_19 | _rvvRdMark_valid_T_25
       & ~(_rvvRdMark_valid_T_25 & (&(io_inst_1_bits_inst[14:12])) | _rvvRdMark_valid_T_25
           & io_inst_1_bits_inst[14:12] == 3'h2 & io_inst_1_bits_inst[31:26] == 6'h10));
  assign io_rvvRdMark_1_addr = io_inst_1_bits_inst[11:7];
  assign io_rvvRdMark_2_valid =
    dispatched_5_1
    & (_rvvRdMark_valid_T_37 | _rvvRdMark_valid_T_43
       & ~(_rvvRdMark_valid_T_43 & (&(io_inst_2_bits_inst[14:12])) | _rvvRdMark_valid_T_43
           & io_inst_2_bits_inst[14:12] == 3'h2 & io_inst_2_bits_inst[31:26] == 6'h10));
  assign io_rvvRdMark_2_addr = io_inst_2_bits_inst[11:7];
  assign io_rvvRdMark_3_valid =
    dispatched_5_2
    & (_rvvRdMark_valid_T_55 | _rvvRdMark_valid_T_61
       & ~(_rvvRdMark_valid_T_61 & (&(io_inst_3_bits_inst[14:12])) | _rvvRdMark_valid_T_61
           & io_inst_3_bits_inst[14:12] == 3'h2 & io_inst_3_bits_inst[31:26] == 6'h10));
  assign io_rvvRdMark_3_addr = io_inst_3_bits_inst[11:7];
  assign io_alu_0_valid = io_alu_0_valid_0;
  assign io_alu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_alu_0_bits_op =
    {4'h0, decodedInsts_0_sub} | {3'h0, _alu_T_160, 1'h0} | (_alu_T_161 ? 5'h3 : 5'h0)
    | {2'h0, _alu_T_162, 2'h0} | (_alu_T_163 ? 5'h5 : 5'h0) | (_alu_T_164 ? 5'h6 : 5'h0)
    | (_alu_T_165 ? 5'h7 : 5'h0) | {1'h0, _alu_T_166, 3'h0} | (_alu_T_167 ? 5'h9 : 5'h0)
    | (decodedInsts_0_lui ? 5'hA : 5'h0) | (decodedInsts_0_andn ? 5'hB : 5'h0)
    | (decodedInsts_0_orn ? 5'hC : 5'h0) | (decodedInsts_0_xnor ? 5'hD : 5'h0)
    | (decodedInsts_0_clz ? 5'hE : 5'h0) | (decodedInsts_0_ctz ? 5'hF : 5'h0)
    | {decodedInsts_0_cpop, 4'h0} | (decodedInsts_0_max ? 5'h11 : 5'h0)
    | (decodedInsts_0_maxu ? 5'h12 : 5'h0) | (decodedInsts_0_min ? 5'h13 : 5'h0)
    | (decodedInsts_0_minu ? 5'h14 : 5'h0) | (decodedInsts_0_sextb ? 5'h15 : 5'h0)
    | (decodedInsts_0_sexth ? 5'h16 : 5'h0) | (decodedInsts_0_rol ? 5'h17 : 5'h0)
    | (decodedInsts_0_ror ? 5'h18 : 5'h0) | (decodedInsts_0_orcb ? 5'h19 : 5'h0)
    | (decodedInsts_0_rev8 ? 5'h1A : 5'h0) | (decodedInsts_0_zexth ? 5'h1B : 5'h0)
    | (decodedInsts_0_rori ? 5'h18 : 5'h0);
  assign io_alu_1_valid = io_alu_1_valid_0;
  assign io_alu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_alu_1_bits_op =
    {4'h0, decodedInsts_1_sub} | {3'h0, _alu_T_378, 1'h0} | (_alu_T_379 ? 5'h3 : 5'h0)
    | {2'h0, _alu_T_380, 2'h0} | (_alu_T_381 ? 5'h5 : 5'h0) | (_alu_T_382 ? 5'h6 : 5'h0)
    | (_alu_T_383 ? 5'h7 : 5'h0) | {1'h0, _alu_T_384, 3'h0} | (_alu_T_385 ? 5'h9 : 5'h0)
    | (decodedInsts_1_lui ? 5'hA : 5'h0) | (decodedInsts_1_andn ? 5'hB : 5'h0)
    | (decodedInsts_1_orn ? 5'hC : 5'h0) | (decodedInsts_1_xnor ? 5'hD : 5'h0)
    | (decodedInsts_1_clz ? 5'hE : 5'h0) | (decodedInsts_1_ctz ? 5'hF : 5'h0)
    | {decodedInsts_1_cpop, 4'h0} | (decodedInsts_1_max ? 5'h11 : 5'h0)
    | (decodedInsts_1_maxu ? 5'h12 : 5'h0) | (decodedInsts_1_min ? 5'h13 : 5'h0)
    | (decodedInsts_1_minu ? 5'h14 : 5'h0) | (decodedInsts_1_sextb ? 5'h15 : 5'h0)
    | (decodedInsts_1_sexth ? 5'h16 : 5'h0) | (decodedInsts_1_rol ? 5'h17 : 5'h0)
    | (decodedInsts_1_ror ? 5'h18 : 5'h0) | (decodedInsts_1_orcb ? 5'h19 : 5'h0)
    | (decodedInsts_1_rev8 ? 5'h1A : 5'h0) | (decodedInsts_1_zexth ? 5'h1B : 5'h0)
    | (decodedInsts_1_rori ? 5'h18 : 5'h0);
  assign io_alu_2_valid = io_alu_2_valid_0;
  assign io_alu_2_bits_addr = io_inst_2_bits_inst[11:7];
  assign io_alu_2_bits_op =
    {4'h0, decodedInsts_2_sub} | {3'h0, _alu_T_596, 1'h0} | (_alu_T_597 ? 5'h3 : 5'h0)
    | {2'h0, _alu_T_598, 2'h0} | (_alu_T_599 ? 5'h5 : 5'h0) | (_alu_T_600 ? 5'h6 : 5'h0)
    | (_alu_T_601 ? 5'h7 : 5'h0) | {1'h0, _alu_T_602, 3'h0} | (_alu_T_603 ? 5'h9 : 5'h0)
    | (decodedInsts_2_lui ? 5'hA : 5'h0) | (decodedInsts_2_andn ? 5'hB : 5'h0)
    | (decodedInsts_2_orn ? 5'hC : 5'h0) | (decodedInsts_2_xnor ? 5'hD : 5'h0)
    | (decodedInsts_2_clz ? 5'hE : 5'h0) | (decodedInsts_2_ctz ? 5'hF : 5'h0)
    | {decodedInsts_2_cpop, 4'h0} | (decodedInsts_2_max ? 5'h11 : 5'h0)
    | (decodedInsts_2_maxu ? 5'h12 : 5'h0) | (decodedInsts_2_min ? 5'h13 : 5'h0)
    | (decodedInsts_2_minu ? 5'h14 : 5'h0) | (decodedInsts_2_sextb ? 5'h15 : 5'h0)
    | (decodedInsts_2_sexth ? 5'h16 : 5'h0) | (decodedInsts_2_rol ? 5'h17 : 5'h0)
    | (decodedInsts_2_ror ? 5'h18 : 5'h0) | (decodedInsts_2_orcb ? 5'h19 : 5'h0)
    | (decodedInsts_2_rev8 ? 5'h1A : 5'h0) | (decodedInsts_2_zexth ? 5'h1B : 5'h0)
    | (decodedInsts_2_rori ? 5'h18 : 5'h0);
  assign io_alu_3_valid = io_alu_3_valid_0;
  assign io_alu_3_bits_addr = io_inst_3_bits_inst[11:7];
  assign io_alu_3_bits_op =
    {4'h0, decodedInsts_3_sub} | {3'h0, _alu_T_814, 1'h0} | (_alu_T_815 ? 5'h3 : 5'h0)
    | {2'h0, _alu_T_816, 2'h0} | (_alu_T_817 ? 5'h5 : 5'h0) | (_alu_T_818 ? 5'h6 : 5'h0)
    | (_alu_T_819 ? 5'h7 : 5'h0) | {1'h0, _alu_T_820, 3'h0} | (_alu_T_821 ? 5'h9 : 5'h0)
    | (decodedInsts_3_lui ? 5'hA : 5'h0) | (decodedInsts_3_andn ? 5'hB : 5'h0)
    | (decodedInsts_3_orn ? 5'hC : 5'h0) | (decodedInsts_3_xnor ? 5'hD : 5'h0)
    | (decodedInsts_3_clz ? 5'hE : 5'h0) | (decodedInsts_3_ctz ? 5'hF : 5'h0)
    | {decodedInsts_3_cpop, 4'h0} | (decodedInsts_3_max ? 5'h11 : 5'h0)
    | (decodedInsts_3_maxu ? 5'h12 : 5'h0) | (decodedInsts_3_min ? 5'h13 : 5'h0)
    | (decodedInsts_3_minu ? 5'h14 : 5'h0) | (decodedInsts_3_sextb ? 5'h15 : 5'h0)
    | (decodedInsts_3_sexth ? 5'h16 : 5'h0) | (decodedInsts_3_rol ? 5'h17 : 5'h0)
    | (decodedInsts_3_ror ? 5'h18 : 5'h0) | (decodedInsts_3_orcb ? 5'h19 : 5'h0)
    | (decodedInsts_3_rev8 ? 5'h1A : 5'h0) | (decodedInsts_3_zexth ? 5'h1B : 5'h0)
    | (decodedInsts_3_rori ? 5'h18 : 5'h0);
  assign io_bru_0_valid = io_bru_0_valid_0;
  assign io_bru_0_bits_fwd = io_inst_0_bits_brchFwd;
  assign io_bru_0_bits_op = _bru_T_67;
  assign io_bru_0_bits_pc = io_inst_0_bits_addr;
  assign io_bru_0_bits_target = _bru_target_T_2;
  assign io_bru_0_bits_link = io_inst_0_bits_inst[11:7];
  assign io_bru_1_valid = io_bru_1_valid_0;
  assign io_bru_1_bits_fwd = io_inst_1_bits_brchFwd;
  assign io_bru_1_bits_op = _bru_T_163;
  assign io_bru_1_bits_pc = io_inst_1_bits_addr;
  assign io_bru_1_bits_target = _bru_target_T_5;
  assign io_bru_1_bits_link = io_inst_1_bits_inst[11:7];
  assign io_bru_2_valid = io_bru_2_valid_0;
  assign io_bru_2_bits_fwd = io_inst_2_bits_brchFwd;
  assign io_bru_2_bits_op = _bru_T_259;
  assign io_bru_2_bits_pc = io_inst_2_bits_addr;
  assign io_bru_2_bits_target = _bru_target_T_8;
  assign io_bru_2_bits_link = io_inst_2_bits_inst[11:7];
  assign io_bru_3_valid = io_bru_3_valid_0;
  assign io_bru_3_bits_fwd = io_inst_3_bits_brchFwd;
  assign io_bru_3_bits_op = _bru_T_355;
  assign io_bru_3_bits_pc = io_inst_3_bits_addr;
  assign io_bru_3_bits_target = _bru_target_T_11;
  assign io_bru_3_bits_link = io_inst_3_bits_inst[11:7];
  assign io_csr_valid = io_csr_valid_0;
  assign io_csr_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_csr_bits_index = io_inst_0_bits_inst[31:20];
  assign io_csr_bits_rs1 = io_inst_0_bits_inst[19:15];
  assign io_csr_bits_op = {1'h0, decodedInsts_0_csrrs} | {decodedInsts_0_csrrc, 1'h0};
  assign io_lsu_0_valid = io_lsu_0_valid_0;
  assign io_lsu_0_bits_store = io_inst_0_bits_inst[5];
  assign io_lsu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_lsu_0_bits_op =
    {4'h0, decodedInsts_0_lh} | {3'h0, decodedInsts_0_lw, 1'h0}
    | (decodedInsts_0_lbu ? 5'h3 : 5'h0) | {2'h0, decodedInsts_0_lhu, 2'h0}
    | (decodedInsts_0_sb ? 5'h5 : 5'h0) | (decodedInsts_0_sh ? 5'h6 : 5'h0)
    | (decodedInsts_0_sw ? 5'h7 : 5'h0) | {1'h0, decodedInsts_0_wfi, 3'h0}
    | {1'h0, decodedInsts_0_fencei, 3'h0} | (decodedInsts_0_flushat ? 5'h9 : 5'h0)
    | (decodedInsts_0_flushall ? 5'hA : 5'h0) | (_lsu_T_141 ? 5'hC : 5'h0)
    | (_lsu_T_142 ? 5'hD : 5'h0) | {_lsu_T_143, 4'h0} | (_lsu_T_144 ? 5'hE : 5'h0)
    | (_lsu_T_145 ? 5'hF : 5'h0) | (_lsu_T_146 ? 5'h11 : 5'h0)
    | (_lsu_T_147 ? 5'h14 : 5'h0) | (_lsu_T_148 ? 5'h12 : 5'h0)
    | (_lsu_T_149 ? 5'h13 : 5'h0);
  assign io_lsu_0_bits_pc = io_inst_0_bits_addr;
  assign io_lsu_0_bits_elemWidth = io_inst_0_bits_inst[14:12];
  assign io_lsu_0_bits_nfields = io_inst_0_bits_inst[31:29];
  assign io_lsu_0_bits_umop = io_inst_0_bits_inst[24:20];
  assign io_lsu_1_valid = io_lsu_1_valid_0;
  assign io_lsu_1_bits_store = io_inst_1_bits_inst[5];
  assign io_lsu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_lsu_1_bits_op =
    {4'h0, decodedInsts_1_lh} | {3'h0, decodedInsts_1_lw, 1'h0}
    | (decodedInsts_1_lbu ? 5'h3 : 5'h0) | {2'h0, decodedInsts_1_lhu, 2'h0}
    | (decodedInsts_1_sb ? 5'h5 : 5'h0) | (decodedInsts_1_sh ? 5'h6 : 5'h0)
    | (decodedInsts_1_sw ? 5'h7 : 5'h0) | (_lsu_T_315 ? 5'hD : 5'h0) | {_lsu_T_316, 4'h0}
    | (_lsu_T_317 ? 5'hE : 5'h0) | (_lsu_T_318 ? 5'hF : 5'h0)
    | (_lsu_T_319 ? 5'h11 : 5'h0) | (_lsu_T_320 ? 5'h14 : 5'h0)
    | (_lsu_T_321 ? 5'h12 : 5'h0) | (_lsu_T_322 ? 5'h13 : 5'h0);
  assign io_lsu_1_bits_pc = io_inst_1_bits_addr;
  assign io_lsu_1_bits_elemWidth = io_inst_1_bits_inst[14:12];
  assign io_lsu_1_bits_nfields = io_inst_1_bits_inst[31:29];
  assign io_lsu_1_bits_umop = io_inst_1_bits_inst[24:20];
  assign io_lsu_2_valid = io_lsu_2_valid_0;
  assign io_lsu_2_bits_store = io_inst_2_bits_inst[5];
  assign io_lsu_2_bits_addr = io_inst_2_bits_inst[11:7];
  assign io_lsu_2_bits_op =
    {4'h0, decodedInsts_2_lh} | {3'h0, decodedInsts_2_lw, 1'h0}
    | (decodedInsts_2_lbu ? 5'h3 : 5'h0) | {2'h0, decodedInsts_2_lhu, 2'h0}
    | (decodedInsts_2_sb ? 5'h5 : 5'h0) | (decodedInsts_2_sh ? 5'h6 : 5'h0)
    | (decodedInsts_2_sw ? 5'h7 : 5'h0) | (_lsu_T_488 ? 5'hD : 5'h0) | {_lsu_T_489, 4'h0}
    | (_lsu_T_490 ? 5'hE : 5'h0) | (_lsu_T_491 ? 5'hF : 5'h0)
    | (_lsu_T_492 ? 5'h11 : 5'h0) | (_lsu_T_493 ? 5'h14 : 5'h0)
    | (_lsu_T_494 ? 5'h12 : 5'h0) | (_lsu_T_495 ? 5'h13 : 5'h0);
  assign io_lsu_2_bits_pc = io_inst_2_bits_addr;
  assign io_lsu_2_bits_elemWidth = io_inst_2_bits_inst[14:12];
  assign io_lsu_2_bits_nfields = io_inst_2_bits_inst[31:29];
  assign io_lsu_2_bits_umop = io_inst_2_bits_inst[24:20];
  assign io_lsu_3_valid = io_lsu_3_valid_0;
  assign io_lsu_3_bits_store = io_inst_3_bits_inst[5];
  assign io_lsu_3_bits_addr = io_inst_3_bits_inst[11:7];
  assign io_lsu_3_bits_op =
    {4'h0, decodedInsts_3_lh} | {3'h0, decodedInsts_3_lw, 1'h0}
    | (decodedInsts_3_lbu ? 5'h3 : 5'h0) | {2'h0, decodedInsts_3_lhu, 2'h0}
    | (decodedInsts_3_sb ? 5'h5 : 5'h0) | (decodedInsts_3_sh ? 5'h6 : 5'h0)
    | (decodedInsts_3_sw ? 5'h7 : 5'h0) | (_lsu_T_661 ? 5'hD : 5'h0) | {_lsu_T_662, 4'h0}
    | (_lsu_T_663 ? 5'hE : 5'h0) | (_lsu_T_664 ? 5'hF : 5'h0)
    | (_lsu_T_665 ? 5'h11 : 5'h0) | (_lsu_T_666 ? 5'h14 : 5'h0)
    | (_lsu_T_667 ? 5'h12 : 5'h0) | (_lsu_T_668 ? 5'h13 : 5'h0);
  assign io_lsu_3_bits_pc = io_inst_3_bits_addr;
  assign io_lsu_3_bits_elemWidth = io_inst_3_bits_inst[14:12];
  assign io_lsu_3_bits_nfields = io_inst_3_bits_inst[31:29];
  assign io_lsu_3_bits_umop = io_inst_3_bits_inst[24:20];
  assign io_mlu_0_valid = io_mlu_0_valid_0;
  assign io_mlu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_mlu_0_bits_op =
    {2'h0, decodedInsts_0_mulh} | {1'h0, decodedInsts_0_mulhsu, 1'h0}
    | (decodedInsts_0_mulhu ? 3'h3 : 3'h0);
  assign io_mlu_1_valid = io_mlu_1_valid_0;
  assign io_mlu_1_bits_addr = io_inst_1_bits_inst[11:7];
  assign io_mlu_1_bits_op =
    {2'h0, decodedInsts_1_mulh} | {1'h0, decodedInsts_1_mulhsu, 1'h0}
    | (decodedInsts_1_mulhu ? 3'h3 : 3'h0);
  assign io_mlu_2_valid = io_mlu_2_valid_0;
  assign io_mlu_2_bits_addr = io_inst_2_bits_inst[11:7];
  assign io_mlu_2_bits_op =
    {2'h0, decodedInsts_2_mulh} | {1'h0, decodedInsts_2_mulhsu, 1'h0}
    | (decodedInsts_2_mulhu ? 3'h3 : 3'h0);
  assign io_mlu_3_valid = io_mlu_3_valid_0;
  assign io_mlu_3_bits_addr = io_inst_3_bits_inst[11:7];
  assign io_mlu_3_bits_op =
    {2'h0, decodedInsts_3_mulh} | {1'h0, decodedInsts_3_mulhsu, 1'h0}
    | (decodedInsts_3_mulhu ? 3'h3 : 3'h0);
  assign io_dvu_0_valid = io_dvu_0_valid_0;
  assign io_dvu_0_bits_addr = io_inst_0_bits_inst[11:7];
  assign io_dvu_0_bits_op =
    {1'h0, decodedInsts_0_divu} | {decodedInsts_0_rem, 1'h0} | {2{decodedInsts_0_remu}};
  assign io_rvv_0_valid = io_rvv_0_valid_0;
  assign io_rvv_0_bits_pc = io_inst_0_bits_addr;
  assign io_rvv_0_bits_opcode = decodedInsts_d_rvv_ret_bits_opcode;
  assign io_rvv_0_bits_bits = io_inst_0_bits_inst[31:7];
  assign io_rvv_1_valid = io_rvv_1_valid_0;
  assign io_rvv_1_bits_pc = io_inst_1_bits_addr;
  assign io_rvv_1_bits_opcode = decodedInsts_d_rvv_ret_1_bits_opcode;
  assign io_rvv_1_bits_bits = io_inst_1_bits_inst[31:7];
  assign io_rvv_2_valid = io_rvv_2_valid_0;
  assign io_rvv_2_bits_pc = io_inst_2_bits_addr;
  assign io_rvv_2_bits_opcode = decodedInsts_d_rvv_ret_2_bits_opcode;
  assign io_rvv_2_bits_bits = io_inst_2_bits_inst[31:7];
  assign io_rvv_3_valid = io_rvv_3_valid_0;
  assign io_rvv_3_bits_pc = io_inst_3_bits_addr;
  assign io_rvv_3_bits_opcode = decodedInsts_d_rvv_ret_3_bits_opcode;
  assign io_rvv_3_bits_bits = io_inst_3_bits_inst[31:7];
  assign io_float_valid = io_float_valid_0;
  assign io_float_bits_opcode = decodedInsts_float_bits_opcode;
  assign io_float_bits_funct5 = io_inst_0_bits_inst[31:27];
  assign io_float_bits_rs3 = io_inst_0_bits_inst[31:27];
  assign io_float_bits_rs2 = io_inst_0_bits_inst[24:20];
  assign io_float_bits_rs1 = io_inst_0_bits_inst[19:15];
  assign io_float_bits_rm = io_inst_0_bits_inst[14:12];
  assign io_float_bits_inst = io_inst_0_bits_inst;
  assign io_float_bits_pc = io_inst_0_bits_addr;
  assign io_float_bits_scalar_rd = decodedInsts_float_scalar_rd;
  assign io_float_bits_scalar_rs1 = decodedInsts_float_scalar_rs1;
  assign io_float_bits_float_rs1 = decodedInsts_float_float_rs1;
  assign io_float_bits_rd = io_inst_0_bits_inst[11:7];
  assign io_float_bits_uses_rs3 = |_decodedInsts_float_uses_rs3_T_4;
  assign io_float_bits_uses_rs2 = decodedInsts_float_uses_rs2;
  assign io_fbusPortAddr = io_inst_0_bits_inst[24:20];
  assign io_slog = io_slog_0;
  assign io_branch_0 = isBranch_0;
  assign io_branch_1 = isBranch_1;
  assign io_branch_2 = isBranch_2;
  assign io_branch_3 =
    _io_rs2Read_3_valid_T_1 | decodedInsts_3_blt | decodedInsts_3_bge
    | decodedInsts_3_bltu | decodedInsts_3_bgeu;
  assign io_jump_0 =
    (_bru_defaultSel_T | decodedInsts_0_ebreak | decodedInsts_0_ecall
     | decodedInsts_0_mpause | decodedInsts_0_mret) & ~decodedInsts_0_ecall
    & ~decodedInsts_0_mret;
  assign io_jump_1 = isJump_1;
  assign io_jump_2 = isJump_2;
  assign io_jump_3 = decodedInsts_3_jal | decodedInsts_3_jalr;
endmodule

module CircularBufferMulti_1(
  input         clock,
                reset,
  input  [2:0]  io_enqValid,
  input         io_enqData_0_store,
  input  [4:0]  io_enqData_0_rd,
                io_enqData_0_op,
  input  [31:0] io_enqData_0_pc,
                io_enqData_0_addr,
                io_enqData_0_data,
  input  [2:0]  io_enqData_0_elemWidth,
                io_enqData_0_sew,
                io_enqData_0_emul_data,
                io_enqData_0_nfields,
  input         io_enqData_1_store,
  input  [4:0]  io_enqData_1_rd,
                io_enqData_1_op,
  input  [31:0] io_enqData_1_pc,
                io_enqData_1_addr,
                io_enqData_1_data,
  input  [2:0]  io_enqData_1_elemWidth,
                io_enqData_1_sew,
                io_enqData_1_emul_data,
                io_enqData_1_nfields,
  input         io_enqData_2_store,
  input  [4:0]  io_enqData_2_rd,
                io_enqData_2_op,
  input  [31:0] io_enqData_2_pc,
                io_enqData_2_addr,
                io_enqData_2_data,
  input  [2:0]  io_enqData_2_elemWidth,
                io_enqData_2_sew,
                io_enqData_2_emul_data,
                io_enqData_2_nfields,
  input         io_enqData_3_store,
  input  [4:0]  io_enqData_3_rd,
                io_enqData_3_op,
  input  [31:0] io_enqData_3_pc,
                io_enqData_3_addr,
                io_enqData_3_data,
  input  [2:0]  io_enqData_3_elemWidth,
                io_enqData_3_sew,
                io_enqData_3_emul_data,
                io_enqData_3_nfields,
  output [2:0]  io_nEnqueued,
                io_nSpace,
  output        io_dataOut_0_store,
  output [4:0]  io_dataOut_0_rd,
                io_dataOut_0_op,
  output [31:0] io_dataOut_0_pc,
                io_dataOut_0_addr,
                io_dataOut_0_data,
  output [2:0]  io_dataOut_0_elemWidth,
                io_dataOut_0_sew,
                io_dataOut_0_emul_data,
                io_dataOut_0_nfields,
  output        io_dataOut_1_store,
  output [4:0]  io_dataOut_1_rd,
                io_dataOut_1_op,
  output [31:0] io_dataOut_1_pc,
                io_dataOut_1_addr,
                io_dataOut_1_data,
  output [2:0]  io_dataOut_1_elemWidth,
                io_dataOut_1_sew,
                io_dataOut_1_emul_data,
                io_dataOut_1_nfields,
  output        io_dataOut_2_store,
  output [4:0]  io_dataOut_2_rd,
                io_dataOut_2_op,
  output [31:0] io_dataOut_2_pc,
                io_dataOut_2_addr,
                io_dataOut_2_data,
  output [2:0]  io_dataOut_2_elemWidth,
                io_dataOut_2_sew,
                io_dataOut_2_emul_data,
                io_dataOut_2_nfields,
  output        io_dataOut_3_store,
  output [4:0]  io_dataOut_3_rd,
                io_dataOut_3_op,
  output [31:0] io_dataOut_3_pc,
                io_dataOut_3_addr,
                io_dataOut_3_data,
  output [2:0]  io_dataOut_3_elemWidth,
                io_dataOut_3_sew,
                io_dataOut_3_emul_data,
                io_dataOut_3_nfields,
  input  [2:0]  io_deqReady,
  input         io_flush
);

  reg          buffer_0_store;
  reg  [4:0]   buffer_0_rd;
  reg  [4:0]   buffer_0_op;
  reg  [31:0]  buffer_0_pc;
  reg  [31:0]  buffer_0_addr;
  reg  [31:0]  buffer_0_data;
  reg  [2:0]   buffer_0_elemWidth;
  reg  [2:0]   buffer_0_sew;
  reg  [2:0]   buffer_0_emul_data;
  reg  [2:0]   buffer_0_nfields;
  reg          buffer_1_store;
  reg  [4:0]   buffer_1_rd;
  reg  [4:0]   buffer_1_op;
  reg  [31:0]  buffer_1_pc;
  reg  [31:0]  buffer_1_addr;
  reg  [31:0]  buffer_1_data;
  reg  [2:0]   buffer_1_elemWidth;
  reg  [2:0]   buffer_1_sew;
  reg  [2:0]   buffer_1_emul_data;
  reg  [2:0]   buffer_1_nfields;
  reg          buffer_2_store;
  reg  [4:0]   buffer_2_rd;
  reg  [4:0]   buffer_2_op;
  reg  [31:0]  buffer_2_pc;
  reg  [31:0]  buffer_2_addr;
  reg  [31:0]  buffer_2_data;
  reg  [2:0]   buffer_2_elemWidth;
  reg  [2:0]   buffer_2_sew;
  reg  [2:0]   buffer_2_emul_data;
  reg  [2:0]   buffer_2_nfields;
  reg          buffer_3_store;
  reg  [4:0]   buffer_3_rd;
  reg  [4:0]   buffer_3_op;
  reg  [31:0]  buffer_3_pc;
  reg  [31:0]  buffer_3_addr;
  reg  [31:0]  buffer_3_data;
  reg  [2:0]   buffer_3_elemWidth;
  reg  [2:0]   buffer_3_sew;
  reg  [2:0]   buffer_3_emul_data;
  reg  [2:0]   buffer_3_nfields;
  reg  [1:0]   enqPtr;
  reg  [1:0]   deqPtr;
  reg  [2:0]   nEnqueued;
  wire [8:0]   _outputBufferView_rotated_T_9 = {7'h0, deqPtr} * 9'h77;
  wire [475:0] _outputBufferView_rotated_T_22 =
    _outputBufferView_rotated_T_9[0]
      ? {buffer_0_nfields[0],
         buffer_3_store,
         buffer_3_rd,
         buffer_3_op,
         buffer_3_pc,
         buffer_3_addr,
         buffer_3_data,
         buffer_3_elemWidth,
         buffer_3_sew,
         buffer_3_emul_data,
         buffer_3_nfields,
         buffer_2_store,
         buffer_2_rd,
         buffer_2_op,
         buffer_2_pc,
         buffer_2_addr,
         buffer_2_data,
         buffer_2_elemWidth,
         buffer_2_sew,
         buffer_2_emul_data,
         buffer_2_nfields,
         buffer_1_store,
         buffer_1_rd,
         buffer_1_op,
         buffer_1_pc,
         buffer_1_addr,
         buffer_1_data,
         buffer_1_elemWidth,
         buffer_1_sew,
         buffer_1_emul_data,
         buffer_1_nfields,
         buffer_0_store,
         buffer_0_rd,
         buffer_0_op,
         buffer_0_pc,
         buffer_0_addr,
         buffer_0_data,
         buffer_0_elemWidth,
         buffer_0_sew,
         buffer_0_emul_data,
         buffer_0_nfields[2:1]}
      : {buffer_3_store,
         buffer_3_rd,
         buffer_3_op,
         buffer_3_pc,
         buffer_3_addr,
         buffer_3_data,
         buffer_3_elemWidth,
         buffer_3_sew,
         buffer_3_emul_data,
         buffer_3_nfields,
         buffer_2_store,
         buffer_2_rd,
         buffer_2_op,
         buffer_2_pc,
         buffer_2_addr,
         buffer_2_data,
         buffer_2_elemWidth,
         buffer_2_sew,
         buffer_2_emul_data,
         buffer_2_nfields,
         buffer_1_store,
         buffer_1_rd,
         buffer_1_op,
         buffer_1_pc,
         buffer_1_addr,
         buffer_1_data,
         buffer_1_elemWidth,
         buffer_1_sew,
         buffer_1_emul_data,
         buffer_1_nfields,
         buffer_0_store,
         buffer_0_rd,
         buffer_0_op,
         buffer_0_pc,
         buffer_0_addr,
         buffer_0_data,
         buffer_0_elemWidth,
         buffer_0_sew,
         buffer_0_emul_data,
         buffer_0_nfields};
  wire [475:0] _outputBufferView_rotated_T_26 =
    _outputBufferView_rotated_T_9[1]
      ? {_outputBufferView_rotated_T_22[1:0], _outputBufferView_rotated_T_22[475:2]}
      : _outputBufferView_rotated_T_22;
  wire [475:0] _outputBufferView_rotated_T_30 =
    _outputBufferView_rotated_T_9[2]
      ? {_outputBufferView_rotated_T_26[3:0], _outputBufferView_rotated_T_26[475:4]}
      : _outputBufferView_rotated_T_26;
  wire [475:0] _outputBufferView_rotated_T_34 =
    _outputBufferView_rotated_T_9[3]
      ? {_outputBufferView_rotated_T_30[7:0], _outputBufferView_rotated_T_30[475:8]}
      : _outputBufferView_rotated_T_30;
  wire [475:0] _outputBufferView_rotated_T_38 =
    _outputBufferView_rotated_T_9[4]
      ? {_outputBufferView_rotated_T_34[15:0], _outputBufferView_rotated_T_34[475:16]}
      : _outputBufferView_rotated_T_34;
  wire [475:0] _outputBufferView_rotated_T_42 =
    _outputBufferView_rotated_T_9[5]
      ? {_outputBufferView_rotated_T_38[31:0], _outputBufferView_rotated_T_38[475:32]}
      : _outputBufferView_rotated_T_38;
  wire [475:0] _outputBufferView_rotated_T_46 =
    _outputBufferView_rotated_T_9[6]
      ? {_outputBufferView_rotated_T_42[63:0], _outputBufferView_rotated_T_42[475:64]}
      : _outputBufferView_rotated_T_42;
  wire [475:0] _outputBufferView_rotated_T_50 =
    _outputBufferView_rotated_T_9[7]
      ? {_outputBufferView_rotated_T_46[127:0], _outputBufferView_rotated_T_46[475:128]}
      : _outputBufferView_rotated_T_46;
  wire [475:0] outputBufferView_rotated =
    _outputBufferView_rotated_T_9[8]
      ? {_outputBufferView_rotated_T_50[255:0], _outputBufferView_rotated_T_50[475:256]}
      : _outputBufferView_rotated_T_50;
  wire         expandedInput_2_ret_valid = io_enqValid > 3'h2;
  wire [8:0]   _rotatedInput_rotated_T_13 = {7'h0, enqPtr} * 9'h78;
  wire [479:0] _rotatedInput_rotated_T_26 =
    _rotatedInput_rotated_T_13[0]
      ? {io_enqData_3_store,
         io_enqData_3_rd,
         io_enqData_3_op,
         io_enqData_3_pc,
         io_enqData_3_addr,
         io_enqData_3_data,
         io_enqData_3_elemWidth,
         io_enqData_3_sew,
         io_enqData_3_emul_data,
         io_enqData_3_nfields,
         expandedInput_2_ret_valid,
         io_enqData_2_store,
         io_enqData_2_rd,
         io_enqData_2_op,
         io_enqData_2_pc,
         io_enqData_2_addr,
         io_enqData_2_data,
         io_enqData_2_elemWidth,
         io_enqData_2_sew,
         io_enqData_2_emul_data,
         io_enqData_2_nfields,
         |(io_enqValid[2:1]),
         io_enqData_1_store,
         io_enqData_1_rd,
         io_enqData_1_op,
         io_enqData_1_pc,
         io_enqData_1_addr,
         io_enqData_1_data,
         io_enqData_1_elemWidth,
         io_enqData_1_sew,
         io_enqData_1_emul_data,
         io_enqData_1_nfields,
         |io_enqValid,
         io_enqData_0_store,
         io_enqData_0_rd,
         io_enqData_0_op,
         io_enqData_0_pc,
         io_enqData_0_addr,
         io_enqData_0_data,
         io_enqData_0_elemWidth,
         io_enqData_0_sew,
         io_enqData_0_emul_data,
         io_enqData_0_nfields,
         io_enqValid[2]}
      : {io_enqValid[2],
         io_enqData_3_store,
         io_enqData_3_rd,
         io_enqData_3_op,
         io_enqData_3_pc,
         io_enqData_3_addr,
         io_enqData_3_data,
         io_enqData_3_elemWidth,
         io_enqData_3_sew,
         io_enqData_3_emul_data,
         io_enqData_3_nfields,
         expandedInput_2_ret_valid,
         io_enqData_2_store,
         io_enqData_2_rd,
         io_enqData_2_op,
         io_enqData_2_pc,
         io_enqData_2_addr,
         io_enqData_2_data,
         io_enqData_2_elemWidth,
         io_enqData_2_sew,
         io_enqData_2_emul_data,
         io_enqData_2_nfields,
         |(io_enqValid[2:1]),
         io_enqData_1_store,
         io_enqData_1_rd,
         io_enqData_1_op,
         io_enqData_1_pc,
         io_enqData_1_addr,
         io_enqData_1_data,
         io_enqData_1_elemWidth,
         io_enqData_1_sew,
         io_enqData_1_emul_data,
         io_enqData_1_nfields,
         |io_enqValid,
         io_enqData_0_store,
         io_enqData_0_rd,
         io_enqData_0_op,
         io_enqData_0_pc,
         io_enqData_0_addr,
         io_enqData_0_data,
         io_enqData_0_elemWidth,
         io_enqData_0_sew,
         io_enqData_0_emul_data,
         io_enqData_0_nfields};
  wire [479:0] _rotatedInput_rotated_T_30 =
    _rotatedInput_rotated_T_13[1]
      ? {_rotatedInput_rotated_T_26[477:0], _rotatedInput_rotated_T_26[479:478]}
      : _rotatedInput_rotated_T_26;
  wire [479:0] _rotatedInput_rotated_T_34 =
    _rotatedInput_rotated_T_13[2]
      ? {_rotatedInput_rotated_T_30[475:0], _rotatedInput_rotated_T_30[479:476]}
      : _rotatedInput_rotated_T_30;
  wire [479:0] _rotatedInput_rotated_T_38 =
    _rotatedInput_rotated_T_13[3]
      ? {_rotatedInput_rotated_T_34[471:0], _rotatedInput_rotated_T_34[479:472]}
      : _rotatedInput_rotated_T_34;
  wire [479:0] _rotatedInput_rotated_T_42 =
    _rotatedInput_rotated_T_13[4]
      ? {_rotatedInput_rotated_T_38[463:0], _rotatedInput_rotated_T_38[479:464]}
      : _rotatedInput_rotated_T_38;
  wire [479:0] _rotatedInput_rotated_T_46 =
    _rotatedInput_rotated_T_13[5]
      ? {_rotatedInput_rotated_T_42[447:0], _rotatedInput_rotated_T_42[479:448]}
      : _rotatedInput_rotated_T_42;
  wire [479:0] _rotatedInput_rotated_T_50 =
    _rotatedInput_rotated_T_13[6]
      ? {_rotatedInput_rotated_T_46[415:0], _rotatedInput_rotated_T_46[479:416]}
      : _rotatedInput_rotated_T_46;
  wire [479:0] _rotatedInput_rotated_T_54 =
    _rotatedInput_rotated_T_13[7]
      ? {_rotatedInput_rotated_T_50[351:0], _rotatedInput_rotated_T_50[479:352]}
      : _rotatedInput_rotated_T_50;
  wire [479:0] rotatedInput_rotated =
    _rotatedInput_rotated_T_13[8]
      ? {_rotatedInput_rotated_T_54[223:0], _rotatedInput_rotated_T_54[479:224]}
      : _rotatedInput_rotated_T_54;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      buffer_0_store <= 1'h0;
      buffer_0_rd <= 5'h0;
      buffer_0_op <= 5'h0;
      buffer_0_pc <= 32'h0;
      buffer_0_addr <= 32'h0;
      buffer_0_data <= 32'h0;
      buffer_0_elemWidth <= 3'h0;
      buffer_0_sew <= 3'h0;
      buffer_0_emul_data <= 3'h0;
      buffer_0_nfields <= 3'h0;
      buffer_1_store <= 1'h0;
      buffer_1_rd <= 5'h0;
      buffer_1_op <= 5'h0;
      buffer_1_pc <= 32'h0;
      buffer_1_addr <= 32'h0;
      buffer_1_data <= 32'h0;
      buffer_1_elemWidth <= 3'h0;
      buffer_1_sew <= 3'h0;
      buffer_1_emul_data <= 3'h0;
      buffer_1_nfields <= 3'h0;
      buffer_2_store <= 1'h0;
      buffer_2_rd <= 5'h0;
      buffer_2_op <= 5'h0;
      buffer_2_pc <= 32'h0;
      buffer_2_addr <= 32'h0;
      buffer_2_data <= 32'h0;
      buffer_2_elemWidth <= 3'h0;
      buffer_2_sew <= 3'h0;
      buffer_2_emul_data <= 3'h0;
      buffer_2_nfields <= 3'h0;
      buffer_3_store <= 1'h0;
      buffer_3_rd <= 5'h0;
      buffer_3_op <= 5'h0;
      buffer_3_pc <= 32'h0;
      buffer_3_addr <= 32'h0;
      buffer_3_data <= 32'h0;
      buffer_3_elemWidth <= 3'h0;
      buffer_3_sew <= 3'h0;
      buffer_3_emul_data <= 3'h0;
      buffer_3_nfields <= 3'h0;
      enqPtr <= 2'h0;
      deqPtr <= 2'h0;
      nEnqueued <= 3'h0;
    end
    else begin
      if (rotatedInput_rotated[119]) begin
        buffer_0_store <= rotatedInput_rotated[118];
        buffer_0_rd <= rotatedInput_rotated[117:113];
        buffer_0_op <= rotatedInput_rotated[112:108];
        buffer_0_pc <= rotatedInput_rotated[107:76];
        buffer_0_addr <= rotatedInput_rotated[75:44];
        buffer_0_data <= rotatedInput_rotated[43:12];
        buffer_0_elemWidth <= rotatedInput_rotated[11:9];
        buffer_0_sew <= rotatedInput_rotated[8:6];
        buffer_0_emul_data <= rotatedInput_rotated[5:3];
        buffer_0_nfields <= rotatedInput_rotated[2:0];
      end
      if (rotatedInput_rotated[239]) begin
        buffer_1_store <= rotatedInput_rotated[238];
        buffer_1_rd <= rotatedInput_rotated[237:233];
        buffer_1_op <= rotatedInput_rotated[232:228];
        buffer_1_pc <= rotatedInput_rotated[227:196];
        buffer_1_addr <= rotatedInput_rotated[195:164];
        buffer_1_data <= rotatedInput_rotated[163:132];
        buffer_1_elemWidth <= rotatedInput_rotated[131:129];
        buffer_1_sew <= rotatedInput_rotated[128:126];
        buffer_1_emul_data <= rotatedInput_rotated[125:123];
        buffer_1_nfields <= rotatedInput_rotated[122:120];
      end
      if (rotatedInput_rotated[359]) begin
        buffer_2_store <= rotatedInput_rotated[358];
        buffer_2_rd <= rotatedInput_rotated[357:353];
        buffer_2_op <= rotatedInput_rotated[352:348];
        buffer_2_pc <= rotatedInput_rotated[347:316];
        buffer_2_addr <= rotatedInput_rotated[315:284];
        buffer_2_data <= rotatedInput_rotated[283:252];
        buffer_2_elemWidth <= rotatedInput_rotated[251:249];
        buffer_2_sew <= rotatedInput_rotated[248:246];
        buffer_2_emul_data <= rotatedInput_rotated[245:243];
        buffer_2_nfields <= rotatedInput_rotated[242:240];
      end
      if (rotatedInput_rotated[479]) begin
        buffer_3_store <= rotatedInput_rotated[478];
        buffer_3_rd <= rotatedInput_rotated[477:473];
        buffer_3_op <= rotatedInput_rotated[472:468];
        buffer_3_pc <= rotatedInput_rotated[467:436];
        buffer_3_addr <= rotatedInput_rotated[435:404];
        buffer_3_data <= rotatedInput_rotated[403:372];
        buffer_3_elemWidth <= rotatedInput_rotated[371:369];
        buffer_3_sew <= rotatedInput_rotated[368:366];
        buffer_3_emul_data <= rotatedInput_rotated[365:363];
        buffer_3_nfields <= rotatedInput_rotated[362:360];
      end
      enqPtr <= io_flush ? 2'h0 : enqPtr + io_enqValid[1:0];
      deqPtr <= io_flush ? 2'h0 : deqPtr + io_deqReady[1:0];
      nEnqueued <= io_flush ? 3'h0 : nEnqueued + io_enqValid - io_deqReady;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:15];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h10; i += 5'h1) begin
          _RANDOM[i[3:0]] = `RANDOM;
        end
        buffer_0_store = _RANDOM[4'h0][0];
        buffer_0_rd = _RANDOM[4'h0][5:1];
        buffer_0_op = _RANDOM[4'h0][10:6];
        buffer_0_pc = {_RANDOM[4'h0][31:11], _RANDOM[4'h1][10:0]};
        buffer_0_addr = {_RANDOM[4'h1][31:11], _RANDOM[4'h2][10:0]};
        buffer_0_data = {_RANDOM[4'h2][31:11], _RANDOM[4'h3][10:0]};
        buffer_0_elemWidth = _RANDOM[4'h3][13:11];
        buffer_0_sew = _RANDOM[4'h3][16:14];
        buffer_0_emul_data = _RANDOM[4'h3][19:17];
        buffer_0_nfields = _RANDOM[4'h3][22:20];
        buffer_1_store = _RANDOM[4'h3][23];
        buffer_1_rd = _RANDOM[4'h3][28:24];
        buffer_1_op = {_RANDOM[4'h3][31:29], _RANDOM[4'h4][1:0]};
        buffer_1_pc = {_RANDOM[4'h4][31:2], _RANDOM[4'h5][1:0]};
        buffer_1_addr = {_RANDOM[4'h5][31:2], _RANDOM[4'h6][1:0]};
        buffer_1_data = {_RANDOM[4'h6][31:2], _RANDOM[4'h7][1:0]};
        buffer_1_elemWidth = _RANDOM[4'h7][4:2];
        buffer_1_sew = _RANDOM[4'h7][7:5];
        buffer_1_emul_data = _RANDOM[4'h7][10:8];
        buffer_1_nfields = _RANDOM[4'h7][13:11];
        buffer_2_store = _RANDOM[4'h7][14];
        buffer_2_rd = _RANDOM[4'h7][19:15];
        buffer_2_op = _RANDOM[4'h7][24:20];
        buffer_2_pc = {_RANDOM[4'h7][31:25], _RANDOM[4'h8][24:0]};
        buffer_2_addr = {_RANDOM[4'h8][31:25], _RANDOM[4'h9][24:0]};
        buffer_2_data = {_RANDOM[4'h9][31:25], _RANDOM[4'hA][24:0]};
        buffer_2_elemWidth = _RANDOM[4'hA][27:25];
        buffer_2_sew = _RANDOM[4'hA][30:28];
        buffer_2_emul_data = {_RANDOM[4'hA][31], _RANDOM[4'hB][1:0]};
        buffer_2_nfields = _RANDOM[4'hB][4:2];
        buffer_3_store = _RANDOM[4'hB][5];
        buffer_3_rd = _RANDOM[4'hB][10:6];
        buffer_3_op = _RANDOM[4'hB][15:11];
        buffer_3_pc = {_RANDOM[4'hB][31:16], _RANDOM[4'hC][15:0]};
        buffer_3_addr = {_RANDOM[4'hC][31:16], _RANDOM[4'hD][15:0]};
        buffer_3_data = {_RANDOM[4'hD][31:16], _RANDOM[4'hE][15:0]};
        buffer_3_elemWidth = _RANDOM[4'hE][18:16];
        buffer_3_sew = _RANDOM[4'hE][21:19];
        buffer_3_emul_data = _RANDOM[4'hE][24:22];
        buffer_3_nfields = _RANDOM[4'hE][27:25];
        enqPtr = _RANDOM[4'hE][29:28];
        deqPtr = _RANDOM[4'hE][31:30];
        nEnqueued = _RANDOM[4'hF][2:0];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        buffer_0_store = 1'h0;
        buffer_0_rd = 5'h0;
        buffer_0_op = 5'h0;
        buffer_0_pc = 32'h0;
        buffer_0_addr = 32'h0;
        buffer_0_data = 32'h0;
        buffer_0_elemWidth = 3'h0;
        buffer_0_sew = 3'h0;
        buffer_0_emul_data = 3'h0;
        buffer_0_nfields = 3'h0;
        buffer_1_store = 1'h0;
        buffer_1_rd = 5'h0;
        buffer_1_op = 5'h0;
        buffer_1_pc = 32'h0;
        buffer_1_addr = 32'h0;
        buffer_1_data = 32'h0;
        buffer_1_elemWidth = 3'h0;
        buffer_1_sew = 3'h0;
        buffer_1_emul_data = 3'h0;
        buffer_1_nfields = 3'h0;
        buffer_2_store = 1'h0;
        buffer_2_rd = 5'h0;
        buffer_2_op = 5'h0;
        buffer_2_pc = 32'h0;
        buffer_2_addr = 32'h0;
        buffer_2_data = 32'h0;
        buffer_2_elemWidth = 3'h0;
        buffer_2_sew = 3'h0;
        buffer_2_emul_data = 3'h0;
        buffer_2_nfields = 3'h0;
        buffer_3_store = 1'h0;
        buffer_3_rd = 5'h0;
        buffer_3_op = 5'h0;
        buffer_3_pc = 32'h0;
        buffer_3_addr = 32'h0;
        buffer_3_data = 32'h0;
        buffer_3_elemWidth = 3'h0;
        buffer_3_sew = 3'h0;
        buffer_3_emul_data = 3'h0;
        buffer_3_nfields = 3'h0;
        enqPtr = 2'h0;
        deqPtr = 2'h0;
        nEnqueued = 3'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_nEnqueued = nEnqueued;
  assign io_nSpace = 3'h4 - nEnqueued;
  assign io_dataOut_0_store = outputBufferView_rotated[118];
  assign io_dataOut_0_rd = outputBufferView_rotated[117:113];
  assign io_dataOut_0_op = outputBufferView_rotated[112:108];
  assign io_dataOut_0_pc = outputBufferView_rotated[107:76];
  assign io_dataOut_0_addr = outputBufferView_rotated[75:44];
  assign io_dataOut_0_data = outputBufferView_rotated[43:12];
  assign io_dataOut_0_elemWidth = outputBufferView_rotated[11:9];
  assign io_dataOut_0_sew = outputBufferView_rotated[8:6];
  assign io_dataOut_0_emul_data = outputBufferView_rotated[5:3];
  assign io_dataOut_0_nfields = outputBufferView_rotated[2:0];
  assign io_dataOut_1_store = outputBufferView_rotated[237];
  assign io_dataOut_1_rd = outputBufferView_rotated[236:232];
  assign io_dataOut_1_op = outputBufferView_rotated[231:227];
  assign io_dataOut_1_pc = outputBufferView_rotated[226:195];
  assign io_dataOut_1_addr = outputBufferView_rotated[194:163];
  assign io_dataOut_1_data = outputBufferView_rotated[162:131];
  assign io_dataOut_1_elemWidth = outputBufferView_rotated[130:128];
  assign io_dataOut_1_sew = outputBufferView_rotated[127:125];
  assign io_dataOut_1_emul_data = outputBufferView_rotated[124:122];
  assign io_dataOut_1_nfields = outputBufferView_rotated[121:119];
  assign io_dataOut_2_store = outputBufferView_rotated[356];
  assign io_dataOut_2_rd = outputBufferView_rotated[355:351];
  assign io_dataOut_2_op = outputBufferView_rotated[350:346];
  assign io_dataOut_2_pc = outputBufferView_rotated[345:314];
  assign io_dataOut_2_addr = outputBufferView_rotated[313:282];
  assign io_dataOut_2_data = outputBufferView_rotated[281:250];
  assign io_dataOut_2_elemWidth = outputBufferView_rotated[249:247];
  assign io_dataOut_2_sew = outputBufferView_rotated[246:244];
  assign io_dataOut_2_emul_data = outputBufferView_rotated[243:241];
  assign io_dataOut_2_nfields = outputBufferView_rotated[240:238];
  assign io_dataOut_3_store = outputBufferView_rotated[475];
  assign io_dataOut_3_rd = outputBufferView_rotated[474:470];
  assign io_dataOut_3_op = outputBufferView_rotated[469:465];
  assign io_dataOut_3_pc = outputBufferView_rotated[464:433];
  assign io_dataOut_3_addr = outputBufferView_rotated[432:401];
  assign io_dataOut_3_data = outputBufferView_rotated[400:369];
  assign io_dataOut_3_elemWidth = outputBufferView_rotated[368:366];
  assign io_dataOut_3_sew = outputBufferView_rotated[365:363];
  assign io_dataOut_3_emul_data = outputBufferView_rotated[362:360];
  assign io_dataOut_3_nfields = outputBufferView_rotated[359:357];
endmodule

module LsuV2(
  input          clock,
                 reset,
  output         io_req_0_ready,
  input          io_req_0_valid,
                 io_req_0_bits_store,
  input  [4:0]   io_req_0_bits_addr,
                 io_req_0_bits_op,
  input  [31:0]  io_req_0_bits_pc,
  input  [2:0]   io_req_0_bits_elemWidth,
                 io_req_0_bits_nfields,
  input  [4:0]   io_req_0_bits_umop,
  output         io_req_1_ready,
  input          io_req_1_valid,
                 io_req_1_bits_store,
  input  [4:0]   io_req_1_bits_addr,
                 io_req_1_bits_op,
  input  [31:0]  io_req_1_bits_pc,
  input  [2:0]   io_req_1_bits_elemWidth,
                 io_req_1_bits_nfields,
  input  [4:0]   io_req_1_bits_umop,
  output         io_req_2_ready,
  input          io_req_2_valid,
                 io_req_2_bits_store,
  input  [4:0]   io_req_2_bits_addr,
                 io_req_2_bits_op,
  input  [31:0]  io_req_2_bits_pc,
  input  [2:0]   io_req_2_bits_elemWidth,
                 io_req_2_bits_nfields,
  input  [4:0]   io_req_2_bits_umop,
  output         io_req_3_ready,
  input          io_req_3_valid,
                 io_req_3_bits_store,
  input  [4:0]   io_req_3_bits_addr,
                 io_req_3_bits_op,
  input  [31:0]  io_req_3_bits_pc,
  input  [2:0]   io_req_3_bits_elemWidth,
                 io_req_3_bits_nfields,
  input  [4:0]   io_req_3_bits_umop,
  input  [31:0]  io_busPort_addr_0,
                 io_busPort_addr_1,
                 io_busPort_addr_2,
                 io_busPort_addr_3,
                 io_busPort_data_0,
                 io_busPort_data_1,
                 io_busPort_data_2,
                 io_busPort_data_3,
                 io_busPort_flt_data_0,
  output         io_rd_valid,
  output [4:0]   io_rd_bits_addr,
  output [31:0]  io_rd_bits_data,
  output         io_rd_flt_valid,
  output [4:0]   io_rd_flt_bits_addr,
  output [31:0]  io_rd_flt_bits_data,
  output         io_ibus_valid,
  input          io_ibus_ready,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_flush_valid,
  input          io_flush_ready,
  output         io_flush_fencei,
  output [31:0]  io_flush_pcNext,
  output         io_fault_valid,
                 io_fault_bits_write,
  output [31:0]  io_fault_bits_addr,
                 io_fault_bits_epc,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  output         io_rvv2lsu_0_ready,
  input          io_rvv2lsu_0_valid,
                 io_rvv2lsu_0_bits_idx_valid,
  input  [127:0] io_rvv2lsu_0_bits_idx_bits_data,
  input          io_rvv2lsu_0_bits_vregfile_valid,
  input  [127:0] io_rvv2lsu_0_bits_vregfile_bits_data,
  input          io_rvv2lsu_0_bits_mask_valid,
  input  [15:0]  io_rvv2lsu_0_bits_mask_bits,
  input          io_lsu2rvv_0_ready,
  output         io_lsu2rvv_0_valid,
  output [4:0]   io_lsu2rvv_0_bits_addr,
  output [127:0] io_lsu2rvv_0_bits_data,
  output         io_lsu2rvv_0_bits_last,
  input  [2:0]   io_rvvState_bits_sew,
                 io_rvvState_bits_lmul,
  output [2:0]   io_queueCapacity,
  output         io_active,
                 io_storeComplete_valid,
  output [31:0]  io_storeComplete_bits
);

  wire              io_lsu2rvv_0_bits_last_0;
  wire              io_lsu2rvv_0_valid_0;
  wire              io_req_0_ready_0;
  wire              _alignedOps_aligner_out_0_valid;
  wire [118:0]      _alignedOps_aligner_out_0_bits;
  wire              _alignedOps_aligner_out_1_valid;
  wire [118:0]      _alignedOps_aligner_out_1_bits;
  wire              _alignedOps_aligner_out_2_valid;
  wire [118:0]      _alignedOps_aligner_out_2_bits;
  wire              _alignedOps_aligner_out_3_valid;
  wire [118:0]      _alignedOps_aligner_out_3_bits;
  wire [2:0]        _opQueue_io_nEnqueued;
  wire [2:0]        _opQueue_io_nSpace;
  wire              _opQueue_io_dataOut_0_store;
  wire [4:0]        _opQueue_io_dataOut_0_rd;
  wire [4:0]        _opQueue_io_dataOut_0_op;
  wire [31:0]       _opQueue_io_dataOut_0_pc;
  wire [31:0]       _opQueue_io_dataOut_0_addr;
  wire [31:0]       _opQueue_io_dataOut_0_data;
  wire [2:0]        _opQueue_io_dataOut_0_elemWidth;
  wire [2:0]        _opQueue_io_dataOut_0_sew;
  wire [2:0]        _opQueue_io_dataOut_0_emul_data;
  wire [2:0]        _opQueue_io_dataOut_0_nfields;
  reg               flushCmd_valid;
  reg               flushCmd_bits_fencei;
  reg  [31:0]       flushCmd_bits_pcNext;
  wire              _ops_T = io_req_0_ready_0 & io_req_0_valid;
  wire              flushCmd_result_fencei = io_req_0_bits_op == 5'h8;
  wire              _ops_T_2 = io_req_0_bits_op == 5'h9;
  wire              _ops_T_3 = io_req_0_bits_op == 5'hA;
  wire [2:0]        _validSum_T_1 = {2'h0, io_req_0_valid} + {2'h0, io_req_1_valid};
  assign io_req_0_ready_0 = (|_opQueue_io_nSpace) & ~flushCmd_valid;
  wire              io_req_1_ready_0 =
    {2'h0, io_req_0_valid} < _opQueue_io_nSpace & ~flushCmd_valid;
  wire              io_req_2_ready_0 =
    _validSum_T_1 < _opQueue_io_nSpace & ~flushCmd_valid;
  wire              io_req_3_ready_0 =
    _validSum_T_1 + {2'h0, io_req_2_valid} < _opQueue_io_nSpace & ~flushCmd_valid;
  wire              _ops_emul_data_T_5 = io_req_0_bits_elemWidth == 3'h0;
  wire              _ops_emul_data_T_144 = io_rvvState_bits_sew == 3'h2;
  wire              _ops_emul_data_T_2 = _ops_emul_data_T_5 & _ops_emul_data_T_144;
  wire [2:0]        _ops_emul_data_T_138 = io_rvvState_bits_lmul - 3'h2;
  wire              _ops_emul_data_T_153 = io_rvvState_bits_sew == 3'h1;
  wire              _ops_emul_data_T_14 = io_req_0_bits_elemWidth == 3'h5;
  wire              _ops_emul_data_T_11 =
    _ops_emul_data_T_5 & _ops_emul_data_T_153 | _ops_emul_data_T_14
    & _ops_emul_data_T_144;
  wire [2:0]        _ops_emul_data_T_147 = io_rvvState_bits_lmul - 3'h1;
  wire              _ops_emul_data_T_159 = io_rvvState_bits_sew == 3'h0;
  wire              _ops_emul_data_T_23 = io_req_0_bits_elemWidth == 3'h6;
  wire              _ops_emul_data_T_20 =
    _ops_emul_data_T_14 & _ops_emul_data_T_159 | _ops_emul_data_T_23
    & _ops_emul_data_T_153;
  wire [2:0]        _ops_emul_data_T_156 = io_rvvState_bits_lmul + 3'h1;
  wire              _ops_emul_data_T_25 = _ops_emul_data_T_23 & _ops_emul_data_T_159;
  wire [2:0]        _ops_emul_data_T_161 = io_rvvState_bits_lmul + 3'h2;
  wire              _ops_result_nfields_T = io_req_0_bits_umop == 5'hB;
  wire              _ops_result_nfields_T_7 = io_req_0_bits_op == 5'hD;
  wire              _ops_result_nfields_T_8 = io_req_0_bits_op == 5'h11;
  wire              _ops_result_nfields_T_6 = io_req_0_bits_umop == 5'h8;
  wire              _ops_result_emul_data_T_30 = io_req_0_bits_nfields == 3'h1;
  wire              _ops_result_emul_data_T_14 = io_req_0_bits_nfields == 3'h3;
  wire              _ops_result_nfields_T_5 =
    _ops_result_nfields_T & (|{_ops_result_nfields_T_8, _ops_result_nfields_T_7});
  wire              _ops_result_nfields_T_11 =
    _ops_result_nfields_T_6 & (|{_ops_result_nfields_T_8, _ops_result_nfields_T_7});
  wire              _ops_emul_data_T_50 = io_req_1_bits_elemWidth == 3'h0;
  wire              _ops_emul_data_T_47 = _ops_emul_data_T_50 & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_59 = io_req_1_bits_elemWidth == 3'h5;
  wire              _ops_emul_data_T_56 =
    _ops_emul_data_T_50 & _ops_emul_data_T_153 | _ops_emul_data_T_59
    & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_68 = io_req_1_bits_elemWidth == 3'h6;
  wire              _ops_emul_data_T_65 =
    _ops_emul_data_T_59 & _ops_emul_data_T_159 | _ops_emul_data_T_68
    & _ops_emul_data_T_153;
  wire              _ops_emul_data_T_70 = _ops_emul_data_T_68 & _ops_emul_data_T_159;
  wire              _ops_result_nfields_T_22 = io_req_1_bits_umop == 5'hB;
  wire              _ops_result_nfields_T_29 = io_req_1_bits_op == 5'hD;
  wire              _ops_result_nfields_T_30 = io_req_1_bits_op == 5'h11;
  wire              _ops_result_nfields_T_28 = io_req_1_bits_umop == 5'h8;
  wire              _ops_result_emul_data_T_73 = io_req_1_bits_nfields == 3'h1;
  wire              _ops_result_emul_data_T_57 = io_req_1_bits_nfields == 3'h3;
  wire              _ops_result_nfields_T_27 =
    _ops_result_nfields_T_22 & (|{_ops_result_nfields_T_30, _ops_result_nfields_T_29});
  wire              _ops_result_nfields_T_33 =
    _ops_result_nfields_T_28 & (|{_ops_result_nfields_T_30, _ops_result_nfields_T_29});
  wire              _ops_emul_data_T_95 = io_req_2_bits_elemWidth == 3'h0;
  wire              _ops_emul_data_T_92 = _ops_emul_data_T_95 & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_104 = io_req_2_bits_elemWidth == 3'h5;
  wire              _ops_emul_data_T_101 =
    _ops_emul_data_T_95 & _ops_emul_data_T_153 | _ops_emul_data_T_104
    & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_113 = io_req_2_bits_elemWidth == 3'h6;
  wire              _ops_emul_data_T_110 =
    _ops_emul_data_T_104 & _ops_emul_data_T_159 | _ops_emul_data_T_113
    & _ops_emul_data_T_153;
  wire              _ops_emul_data_T_115 = _ops_emul_data_T_113 & _ops_emul_data_T_159;
  wire              _ops_result_nfields_T_44 = io_req_2_bits_umop == 5'hB;
  wire              _ops_result_nfields_T_51 = io_req_2_bits_op == 5'hD;
  wire              _ops_result_nfields_T_52 = io_req_2_bits_op == 5'h11;
  wire              _ops_result_nfields_T_50 = io_req_2_bits_umop == 5'h8;
  wire              _ops_result_emul_data_T_116 = io_req_2_bits_nfields == 3'h1;
  wire              _ops_result_emul_data_T_100 = io_req_2_bits_nfields == 3'h3;
  wire              _ops_result_nfields_T_49 =
    _ops_result_nfields_T_44 & (|{_ops_result_nfields_T_52, _ops_result_nfields_T_51});
  wire              _ops_result_nfields_T_55 =
    _ops_result_nfields_T_50 & (|{_ops_result_nfields_T_52, _ops_result_nfields_T_51});
  wire              _ops_emul_data_T_140 = io_req_3_bits_elemWidth == 3'h0;
  wire              _ops_emul_data_T_137 = _ops_emul_data_T_140 & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_149 = io_req_3_bits_elemWidth == 3'h5;
  wire              _ops_emul_data_T_146 =
    _ops_emul_data_T_140 & _ops_emul_data_T_153 | _ops_emul_data_T_149
    & _ops_emul_data_T_144;
  wire              _ops_emul_data_T_158 = io_req_3_bits_elemWidth == 3'h6;
  wire              _ops_emul_data_T_155 =
    _ops_emul_data_T_149 & _ops_emul_data_T_159 | _ops_emul_data_T_158
    & _ops_emul_data_T_153;
  wire              _ops_emul_data_T_160 = _ops_emul_data_T_158 & _ops_emul_data_T_159;
  wire              _ops_result_nfields_T_66 = io_req_3_bits_umop == 5'hB;
  wire              _ops_result_nfields_T_73 = io_req_3_bits_op == 5'hD;
  wire              _ops_result_nfields_T_74 = io_req_3_bits_op == 5'h11;
  wire              _ops_result_nfields_T_72 = io_req_3_bits_umop == 5'h8;
  wire              _ops_result_emul_data_T_159 = io_req_3_bits_nfields == 3'h1;
  wire              _ops_result_emul_data_T_143 = io_req_3_bits_nfields == 3'h3;
  wire              _ops_result_nfields_T_71 =
    _ops_result_nfields_T_66 & (|{_ops_result_nfields_T_74, _ops_result_nfields_T_73});
  wire              _ops_result_nfields_T_77 =
    _ops_result_nfields_T_72 & (|{_ops_result_nfields_T_74, _ops_result_nfields_T_73});
  wire [2:0]        opQueue_io_enqValid =
    {1'h0,
     {1'h0, _alignedOps_aligner_out_0_valid} + {1'h0, _alignedOps_aligner_out_1_valid}}
    + {1'h0,
       {1'h0, _alignedOps_aligner_out_2_valid} + {1'h0, _alignedOps_aligner_out_3_valid}};
  wire              _nextSlot_result_elemStride_T = _opQueue_io_dataOut_0_op == 5'hD;
  wire              _nextSlot_T_16 = _opQueue_io_dataOut_0_op == 5'hE;
  wire              _nextSlot_unitStride_T = _opQueue_io_dataOut_0_op == 5'hF;
  wire              _nextSlot_unitStride_T_1 = _opQueue_io_dataOut_0_op == 5'h10;
  wire              _nextSlot_result_elemStride_T_1 = _opQueue_io_dataOut_0_op == 5'h11;
  wire              _nextSlot_T_17 = _opQueue_io_dataOut_0_op == 5'h12;
  wire              _nextSlot_unitStride_T_2 = _opQueue_io_dataOut_0_op == 5'h13;
  wire              _nextSlot_unitStride_T_3 = _opQueue_io_dataOut_0_op == 5'h14;
  wire              _nextSlot_unitStride_T_24 = _opQueue_io_dataOut_0_elemWidth == 3'h5;
  wire              _nextSlot_elemMultiplier_T_4 = _opQueue_io_dataOut_0_sew == 3'h0;
  wire              _nextSlot_elemMultiplier_T_2 =
    _nextSlot_unitStride_T_24 & _nextSlot_elemMultiplier_T_4;
  wire              _nextSlot_unitStride_T_25 = _opQueue_io_dataOut_0_elemWidth == 3'h6;
  wire              _nextSlot_elemMultiplier_T_5 =
    _nextSlot_unitStride_T_25 & _nextSlot_elemMultiplier_T_4;
  wire              _nextSlot_result_indexParitions_T_1 =
    _opQueue_io_dataOut_0_sew == 3'h1;
  wire              _nextSlot_elemMultiplier_T_8 =
    _nextSlot_unitStride_T_25 & _nextSlot_result_indexParitions_T_1;
  wire [2:0]        _nextSlot_elemMultiplier_T_20 =
    {1'h0, _nextSlot_elemMultiplier_T_2, 1'h0} | {_nextSlot_elemMultiplier_T_5, 2'h0};
  wire [1:0]        _GEN =
    _nextSlot_elemMultiplier_T_20[1:0] | {_nextSlot_elemMultiplier_T_8, 1'h0};
  wire [2:0]        nextSlot_elemMultiplier =
    {_nextSlot_elemMultiplier_T_20[2],
     _GEN[1],
     _GEN[0]
       | ~(_nextSlot_elemMultiplier_T_2 | _nextSlot_elemMultiplier_T_5
           | _nextSlot_elemMultiplier_T_8)};
  wire              _nextSlot_max_subvector_T_3 =
    nextSlot_elemMultiplier == 3'h2 & $signed(_opQueue_io_dataOut_0_emul_data) > -3'sh1;
  wire              _nextSlot_max_subvector_T_8 = nextSlot_elemMultiplier == 3'h4;
  wire              _nextSlot_max_subvector_T_7 =
    _nextSlot_max_subvector_T_8 & $signed(_opQueue_io_dataOut_0_emul_data) > -3'sh1;
  wire              _nextSlot_max_subvector_T_11 =
    _nextSlot_max_subvector_T_8 & (&_opQueue_io_dataOut_0_emul_data);
  wire              _nextSlot_unitStride_T_33 = _opQueue_io_dataOut_0_elemWidth == 3'h0;
  wire              _nextSlot_result_indexParitions_T_2 =
    _nextSlot_unitStride_T_33 & _nextSlot_result_indexParitions_T_1;
  wire              _nextSlot_result_indexParitions_T_7 =
    _opQueue_io_dataOut_0_sew == 3'h2;
  wire              _nextSlot_result_indexParitions_T_5 =
    _nextSlot_unitStride_T_33 & _nextSlot_result_indexParitions_T_7;
  wire              _nextSlot_result_indexParitions_T_8 =
    _nextSlot_unitStride_T_24 & _nextSlot_result_indexParitions_T_7;
  wire [2:0]        _nextSlot_active_T_3 =
    {_opQueue_io_dataOut_0_op == 5'h5,
     _opQueue_io_dataOut_0_op == 5'h3,
     _opQueue_io_dataOut_0_op == 5'h0};
  wire [2:0]        _nextSlot_active_T_8 =
    {_opQueue_io_dataOut_0_op == 5'h6,
     _opQueue_io_dataOut_0_op == 5'h4,
     _opQueue_io_dataOut_0_op == 5'h1};
  wire [2:0]        _nextSlot_active_T_13 =
    {_opQueue_io_dataOut_0_op == 5'hC,
     _opQueue_io_dataOut_0_op == 5'h7,
     _opQueue_io_dataOut_0_op == 5'h2};
  wire              _nextSlot_unitStride_T_16 = _opQueue_io_dataOut_0_sew == 3'h0;
  wire              _nextSlot_unitStride_T_7 = _opQueue_io_dataOut_0_sew == 3'h1;
  wire              _nextSlot_unitStride_T_8 = _opQueue_io_dataOut_0_sew == 3'h2;
  reg               readFired_valid;
  reg  [1:0]        readFired_bits_bus;
  reg  [27:0]       readFired_bits_lineAddr;
  reg  [4:0]        slot_op;
  reg  [4:0]        slot_rd;
  reg               slot_store;
  reg  [31:0]       slot_pc;
  reg  [31:0]       slot_baseAddr;
  reg               slot_active_0;
  reg               slot_active_1;
  reg               slot_active_2;
  reg               slot_active_3;
  reg               slot_active_4;
  reg               slot_active_5;
  reg               slot_active_6;
  reg               slot_active_7;
  reg               slot_active_8;
  reg               slot_active_9;
  reg               slot_active_10;
  reg               slot_active_11;
  reg               slot_active_12;
  reg               slot_active_13;
  reg               slot_active_14;
  reg               slot_active_15;
  reg  [31:0]       slot_addrs_0;
  reg  [31:0]       slot_addrs_1;
  reg  [31:0]       slot_addrs_2;
  reg  [31:0]       slot_addrs_3;
  reg  [31:0]       slot_addrs_4;
  reg  [31:0]       slot_addrs_5;
  reg  [31:0]       slot_addrs_6;
  reg  [31:0]       slot_addrs_7;
  reg  [31:0]       slot_addrs_8;
  reg  [31:0]       slot_addrs_9;
  reg  [31:0]       slot_addrs_10;
  reg  [31:0]       slot_addrs_11;
  reg  [31:0]       slot_addrs_12;
  reg  [31:0]       slot_addrs_13;
  reg  [31:0]       slot_addrs_14;
  reg  [31:0]       slot_addrs_15;
  reg  [7:0]        slot_data_0;
  reg  [7:0]        slot_data_1;
  reg  [7:0]        slot_data_2;
  reg  [7:0]        slot_data_3;
  reg  [7:0]        slot_data_4;
  reg  [7:0]        slot_data_5;
  reg  [7:0]        slot_data_6;
  reg  [7:0]        slot_data_7;
  reg  [7:0]        slot_data_8;
  reg  [7:0]        slot_data_9;
  reg  [7:0]        slot_data_10;
  reg  [7:0]        slot_data_11;
  reg  [7:0]        slot_data_12;
  reg  [7:0]        slot_data_13;
  reg  [7:0]        slot_data_14;
  reg  [7:0]        slot_data_15;
  reg               slot_pendingWriteback;
  reg  [31:0]       slot_elemStride;
  reg  [31:0]       slot_segmentStride;
  reg  [2:0]        slot_elemWidth;
  reg  [2:0]        slot_sew;
  reg  [2:0]        slot_indexParitions;
  reg  [2:0]        slot_vectorLoop_subvector_curr;
  reg  [2:0]        slot_vectorLoop_subvector_max;
  reg  [3:0]        slot_vectorLoop_segment_curr;
  reg  [3:0]        slot_vectorLoop_segment_max;
  reg  [3:0]        slot_vectorLoop_lmul_curr;
  reg  [3:0]        slot_vectorLoop_lmul_max;
  reg  [4:0]        slot_vectorLoop_rdStart;
  reg  [4:0]        slot_vectorLoop_rd;
  wire              io_rvv2lsu_0_ready_0 =
    slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max;
  wire              _vectorUpdatedSlot_indices_T_3 =
    slot_indexParitions == 3'h2 & slot_vectorLoop_lmul_curr[0];
  wire              _vectorUpdatedSlot_indices_T_15 = slot_indexParitions == 3'h4;
  wire              _vectorUpdatedSlot_indices_T_8 =
    _vectorUpdatedSlot_indices_T_15 & slot_vectorLoop_lmul_curr[1:0] == 2'h1;
  wire              _vectorUpdatedSlot_indices_T_13 =
    _vectorUpdatedSlot_indices_T_15 & slot_vectorLoop_lmul_curr[1:0] == 2'h2;
  wire              _vectorUpdatedSlot_indices_T_18 =
    _vectorUpdatedSlot_indices_T_15 & (&(slot_vectorLoop_lmul_curr[1:0]));
  wire              _writebackUpdatedSlot_result_baseAddr_T_1 = slot_op == 5'hD;
  wire              _writebackUpdatedSlot_result_baseAddr_T_10 = slot_op == 5'hE;
  wire              _writebackUpdatedSlot_result_baseAddr_T_2 = slot_op == 5'h11;
  wire              _writebackUpdatedSlot_result_baseAddr_T_11 = slot_op == 5'h12;
  wire              _scalarStoreComplete_T_58 = slot_op == 5'hF;
  wire              _scalarStoreComplete_T_59 = slot_op == 5'h10;
  wire              _scalarStoreComplete_T_62 = slot_op == 5'h13;
  wire              _scalarStoreComplete_T_63 = slot_op == 5'h14;
  wire [1:0]        _vectorUpdatedSlot_updateAddrs_T_2 =
    {_writebackUpdatedSlot_result_baseAddr_T_2,
     _writebackUpdatedSlot_result_baseAddr_T_1};
  wire              _writebackUpdatedSlot_result_baseAddr_T_17 = slot_elemWidth == 3'h0;
  wire              _writebackUpdatedSlot_result_baseAddr_T_21 = slot_elemWidth == 3'h5;
  wire              _writebackUpdatedSlot_result_baseAddr_T_25 = slot_elemWidth == 3'h6;
  wire [1:0]        _vectorUpdatedSlot_updateAddrs_T_384 =
    {_writebackUpdatedSlot_result_baseAddr_T_11,
     _writebackUpdatedSlot_result_baseAddr_T_10};
  wire [3:0]        _vectorUpdatedSlot_updateAddrs_T_768 =
    {_scalarStoreComplete_T_63,
     _scalarStoreComplete_T_62,
     _scalarStoreComplete_T_59,
     _scalarStoreComplete_T_58};
  wire              _vectorUpdatedSlot_updateAddrs_T_770 = slot_sew == 3'h0;
  wire              _vectorUpdatedSlot_updateAddrs_T_803 = slot_sew == 3'h1;
  wire              _vectorUpdatedSlot_updateAddrs_T_868 = slot_sew == 3'h2;
  reg               faultReg_valid;
  reg               faultReg_bits_info_write;
  reg  [31:0]       faultReg_bits_info_addr;
  reg  [31:0]       faultReg_bits_info_epc;
  reg  [4:0]        faultReg_bits_rd;
  reg  [4:0]        faultReg_bits_op;
  reg               faultReg_bits_store;
  wire              loadUpdatedSlot_lineActive_0 =
    slot_active_0 & slot_addrs_0[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_1 =
    slot_active_1 & slot_addrs_1[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_2 =
    slot_active_2 & slot_addrs_2[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_3 =
    slot_active_3 & slot_addrs_3[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_4 =
    slot_active_4 & slot_addrs_4[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_5 =
    slot_active_5 & slot_addrs_5[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_6 =
    slot_active_6 & slot_addrs_6[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_7 =
    slot_active_7 & slot_addrs_7[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_8 =
    slot_active_8 & slot_addrs_8[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_9 =
    slot_active_9 & slot_addrs_9[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_10 =
    slot_active_10 & slot_addrs_10[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_11 =
    slot_active_11 & slot_addrs_11[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_12 =
    slot_active_12 & slot_addrs_12[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_13 =
    slot_active_13 & slot_addrs_13[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_14 =
    slot_active_14 & slot_addrs_14[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_lineActive_15 =
    slot_active_15 & slot_addrs_15[31:4] == readFired_bits_lineAddr;
  wire              loadUpdatedSlot_active_0 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_0) & slot_active_0;
  wire              loadUpdatedSlot_active_1 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_1) & slot_active_1;
  wire              loadUpdatedSlot_active_2 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_2) & slot_active_2;
  wire              loadUpdatedSlot_active_3 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_3) & slot_active_3;
  wire              loadUpdatedSlot_active_4 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_4) & slot_active_4;
  wire              loadUpdatedSlot_active_5 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_5) & slot_active_5;
  wire              loadUpdatedSlot_active_6 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_6) & slot_active_6;
  wire              loadUpdatedSlot_active_7 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_7) & slot_active_7;
  wire              loadUpdatedSlot_active_8 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_8) & slot_active_8;
  wire              loadUpdatedSlot_active_9 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_9) & slot_active_9;
  wire              loadUpdatedSlot_active_10 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_10) & slot_active_10;
  wire              loadUpdatedSlot_active_11 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_11) & slot_active_11;
  wire              loadUpdatedSlot_active_12 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_12) & slot_active_12;
  wire              loadUpdatedSlot_active_13 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_13) & slot_active_13;
  wire              loadUpdatedSlot_active_14 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_14) & slot_active_14;
  wire              loadUpdatedSlot_active_15 =
    (~readFired_valid | ~loadUpdatedSlot_lineActive_15) & slot_active_15;
  wire [31:0]       targetAddress_bits =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
    & loadUpdatedSlot_active_0
    & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_0[31:4])
      ? slot_addrs_0
      : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
        & loadUpdatedSlot_active_1
        & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_1[31:4])
          ? slot_addrs_1
          : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
            & loadUpdatedSlot_active_2
            & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_2[31:4])
              ? slot_addrs_2
              : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                & loadUpdatedSlot_active_3
                & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_3[31:4])
                  ? slot_addrs_3
                  : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                    & loadUpdatedSlot_active_4
                    & (~readFired_valid | readFired_bits_lineAddr != slot_addrs_4[31:4])
                      ? slot_addrs_4
                      : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                        & loadUpdatedSlot_active_5
                        & (~readFired_valid
                           | readFired_bits_lineAddr != slot_addrs_5[31:4])
                          ? slot_addrs_5
                          : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                            & loadUpdatedSlot_active_6
                            & (~readFired_valid
                               | readFired_bits_lineAddr != slot_addrs_6[31:4])
                              ? slot_addrs_6
                              : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                & loadUpdatedSlot_active_7
                                & (~readFired_valid
                                   | readFired_bits_lineAddr != slot_addrs_7[31:4])
                                  ? slot_addrs_7
                                  : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                    & loadUpdatedSlot_active_8
                                    & (~readFired_valid
                                       | readFired_bits_lineAddr != slot_addrs_8[31:4])
                                      ? slot_addrs_8
                                      : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                        & loadUpdatedSlot_active_9
                                        & (~readFired_valid
                                           | readFired_bits_lineAddr != slot_addrs_9[31:4])
                                          ? slot_addrs_9
                                          : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                            & loadUpdatedSlot_active_10
                                            & (~readFired_valid
                                               | readFired_bits_lineAddr != slot_addrs_10[31:4])
                                              ? slot_addrs_10
                                              : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                                & loadUpdatedSlot_active_11
                                                & (~readFired_valid
                                                   | readFired_bits_lineAddr != slot_addrs_11[31:4])
                                                  ? slot_addrs_11
                                                  : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                                    & loadUpdatedSlot_active_12
                                                    & (~readFired_valid
                                                       | readFired_bits_lineAddr != slot_addrs_12[31:4])
                                                      ? slot_addrs_12
                                                      : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                                        & loadUpdatedSlot_active_13
                                                        & (~readFired_valid
                                                           | readFired_bits_lineAddr != slot_addrs_13[31:4])
                                                          ? slot_addrs_13
                                                          : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                                            & loadUpdatedSlot_active_14
                                                            & (~readFired_valid
                                                               | readFired_bits_lineAddr != slot_addrs_14[31:4])
                                                              ? slot_addrs_14
                                                              : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
                                                                & loadUpdatedSlot_active_15
                                                                & (~readFired_valid
                                                                   | readFired_bits_lineAddr != slot_addrs_15[31:4])
                                                                  ? slot_addrs_15
                                                                  : 32'h0;
  wire [31:0]       targetLineAddr = {targetAddress_bits[31:4], 4'h0};
  wire              itcm = targetLineAddr < 32'h2000;
  wire              dtcm = (|(targetAddress_bits[31:16])) & targetLineAddr < 32'h18000;
  wire              peri = targetLineAddr > 32'h2FFFF & targetLineAddr < 32'h31000;
  wire              canScatter =
    slot_store
    & ({_scalarStoreComplete_T_63,
        _scalarStoreComplete_T_62,
        _writebackUpdatedSlot_result_baseAddr_T_11,
        _writebackUpdatedSlot_result_baseAddr_T_2,
        _scalarStoreComplete_T_59,
        _scalarStoreComplete_T_58,
        _writebackUpdatedSlot_result_baseAddr_T_10,
        _writebackUpdatedSlot_result_baseAddr_T_1} == 8'h0
       | slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max);
  wire              lineActive_0 =
    canScatter & slot_active_0 & slot_addrs_0[31:4] == targetAddress_bits[31:4];
  wire              lineActive_1 =
    canScatter & slot_active_1 & slot_addrs_1[31:4] == targetAddress_bits[31:4];
  wire              lineActive_2 =
    canScatter & slot_active_2 & slot_addrs_2[31:4] == targetAddress_bits[31:4];
  wire              lineActive_3 =
    canScatter & slot_active_3 & slot_addrs_3[31:4] == targetAddress_bits[31:4];
  wire              lineActive_4 =
    canScatter & slot_active_4 & slot_addrs_4[31:4] == targetAddress_bits[31:4];
  wire              lineActive_5 =
    canScatter & slot_active_5 & slot_addrs_5[31:4] == targetAddress_bits[31:4];
  wire              lineActive_6 =
    canScatter & slot_active_6 & slot_addrs_6[31:4] == targetAddress_bits[31:4];
  wire              lineActive_7 =
    canScatter & slot_active_7 & slot_addrs_7[31:4] == targetAddress_bits[31:4];
  wire              lineActive_8 =
    canScatter & slot_active_8 & slot_addrs_8[31:4] == targetAddress_bits[31:4];
  wire              lineActive_9 =
    canScatter & slot_active_9 & slot_addrs_9[31:4] == targetAddress_bits[31:4];
  wire              lineActive_10 =
    canScatter & slot_active_10 & slot_addrs_10[31:4] == targetAddress_bits[31:4];
  wire              lineActive_11 =
    canScatter & slot_active_11 & slot_addrs_11[31:4] == targetAddress_bits[31:4];
  wire              lineActive_12 =
    canScatter & slot_active_12 & slot_addrs_12[31:4] == targetAddress_bits[31:4];
  wire              lineActive_13 =
    canScatter & slot_active_13 & slot_addrs_13[31:4] == targetAddress_bits[31:4];
  wire              lineActive_14 =
    canScatter & slot_active_14 & slot_addrs_14[31:4] == targetAddress_bits[31:4];
  wire              lineActive_15 =
    canScatter & slot_active_15 & slot_addrs_15[31:4] == targetAddress_bits[31:4];
  wire [15:0]       valueSet_1 = lineActive_0 ? 16'h1 << slot_addrs_0[3:0] : 16'h0;
  wire [15:0]       validMatrix_1 = lineActive_1 ? 16'h1 << slot_addrs_1[3:0] : 16'h0;
  wire [15:0]       validMatrix_2 = lineActive_2 ? 16'h1 << slot_addrs_2[3:0] : 16'h0;
  wire [15:0]       validMatrix_3 = lineActive_3 ? 16'h1 << slot_addrs_3[3:0] : 16'h0;
  wire [15:0]       validMatrix_4 = lineActive_4 ? 16'h1 << slot_addrs_4[3:0] : 16'h0;
  wire [15:0]       validMatrix_5 = lineActive_5 ? 16'h1 << slot_addrs_5[3:0] : 16'h0;
  wire [15:0]       validMatrix_6 = lineActive_6 ? 16'h1 << slot_addrs_6[3:0] : 16'h0;
  wire [15:0]       validMatrix_7 = lineActive_7 ? 16'h1 << slot_addrs_7[3:0] : 16'h0;
  wire [15:0]       validMatrix_8 = lineActive_8 ? 16'h1 << slot_addrs_8[3:0] : 16'h0;
  wire [15:0]       validMatrix_9 = lineActive_9 ? 16'h1 << slot_addrs_9[3:0] : 16'h0;
  wire [15:0]       validMatrix_10 = lineActive_10 ? 16'h1 << slot_addrs_10[3:0] : 16'h0;
  wire [15:0]       validMatrix_11 = lineActive_11 ? 16'h1 << slot_addrs_11[3:0] : 16'h0;
  wire [15:0]       validMatrix_12 = lineActive_12 ? 16'h1 << slot_addrs_12[3:0] : 16'h0;
  wire [15:0]       validMatrix_13 = lineActive_13 ? 16'h1 << slot_addrs_13[3:0] : 16'h0;
  wire [15:0]       validMatrix_14 = lineActive_14 ? 16'h1 << slot_addrs_14[3:0] : 16'h0;
  wire [15:0]       valueSet_2 = valueSet_1 | validMatrix_1;
  wire [15:0]       valueSet_3 = valueSet_2 | validMatrix_2;
  wire [15:0]       valueSet_4 = valueSet_3 | validMatrix_3;
  wire [15:0]       valueSet_5 = valueSet_4 | validMatrix_4;
  wire [15:0]       valueSet_6 = valueSet_5 | validMatrix_5;
  wire [15:0]       valueSet_7 = valueSet_6 | validMatrix_6;
  wire [15:0]       valueSet_8 = valueSet_7 | validMatrix_7;
  wire [15:0]       valueSet_9 = valueSet_8 | validMatrix_8;
  wire [15:0]       valueSet_10 = valueSet_9 | validMatrix_9;
  wire [15:0]       valueSet_11 = valueSet_10 | validMatrix_10;
  wire [15:0]       valueSet_12 = valueSet_11 | validMatrix_11;
  wire [15:0]       valueSet_13 = valueSet_12 | validMatrix_12;
  wire [15:0]       valueSet_14 = valueSet_13 | validMatrix_13;
  wire [15:0]       selectionMatrix_1 = validMatrix_1 & ~valueSet_1;
  wire [15:0]       selectionMatrix_2 = validMatrix_2 & ~valueSet_2;
  wire [15:0]       selectionMatrix_3 = validMatrix_3 & ~valueSet_3;
  wire [15:0]       selectionMatrix_4 = validMatrix_4 & ~valueSet_4;
  wire [15:0]       selectionMatrix_5 = validMatrix_5 & ~valueSet_5;
  wire [15:0]       selectionMatrix_6 = validMatrix_6 & ~valueSet_6;
  wire [15:0]       selectionMatrix_7 = validMatrix_7 & ~valueSet_7;
  wire [15:0]       selectionMatrix_8 = validMatrix_8 & ~valueSet_8;
  wire [15:0]       selectionMatrix_9 = validMatrix_9 & ~valueSet_9;
  wire [15:0]       selectionMatrix_10 = validMatrix_10 & ~valueSet_10;
  wire [15:0]       selectionMatrix_11 = validMatrix_11 & ~valueSet_11;
  wire [15:0]       selectionMatrix_12 = validMatrix_12 & ~valueSet_12;
  wire [15:0]       selectionMatrix_13 = validMatrix_13 & ~valueSet_13;
  wire [15:0]       selectionMatrix_14 = validMatrix_14 & ~valueSet_14;
  wire [15:0]       selectionMatrix_15 =
    (lineActive_15 ? 16'h1 << slot_addrs_15[3:0] : 16'h0)
    & ~(valueSet_14 | validMatrix_14);
  wire [15:0]       _resultMask_T_14 =
    valueSet_1 | selectionMatrix_1 | selectionMatrix_2 | selectionMatrix_3
    | selectionMatrix_4 | selectionMatrix_5 | selectionMatrix_6 | selectionMatrix_7
    | selectionMatrix_8 | selectionMatrix_9 | selectionMatrix_10 | selectionMatrix_11
    | selectionMatrix_12 | selectionMatrix_13 | selectionMatrix_14 | selectionMatrix_15;
  wire [7:0]        wdata_0 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h0
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h0
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h0
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h0
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h0
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h0
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h0
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h0
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h0
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h0
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h0
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h0
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h0
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h0
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h0
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h0
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_1 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h1
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h1
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h1
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h1
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h1
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h1
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h1
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h1
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h1
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h1
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h1
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h1
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h1
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h1
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h1
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h1
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_2 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h2
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h2
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h2
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h2
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h2
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h2
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h2
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h2
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h2
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h2
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h2
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h2
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h2
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h2
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h2
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h2
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_3 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h3
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h3
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h3
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h3
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h3
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h3
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h3
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h3
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h3
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h3
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h3
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h3
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h3
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h3
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h3
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h3
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_4 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h4
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h4
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h4
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h4
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h4
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h4
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h4
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h4
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h4
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h4
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h4
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h4
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h4
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h4
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h4
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h4
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_5 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h5
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h5
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h5
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h5
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h5
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h5
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h5
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h5
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h5
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h5
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h5
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h5
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h5
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h5
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h5
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h5
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_6 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h6
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h6
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h6
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h6
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h6
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h6
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h6
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h6
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h6
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h6
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h6
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h6
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h6
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h6
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h6
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h6
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_7 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h7
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h7
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h7
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h7
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h7
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h7
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h7
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h7
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h7
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h7
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h7
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h7
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h7
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h7
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h7
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h7
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_8 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h8
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h8
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h8
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h8
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h8
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h8
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h8
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h8
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h8
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h8
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h8
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h8
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h8
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h8
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h8
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h8
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_9 =
    lineActive_0 & slot_addrs_0[3:0] == 4'h9
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'h9
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'h9
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'h9
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'h9
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'h9
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'h9
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'h9
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'h9
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'h9
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'h9
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'h9
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'h9
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'h9
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'h9
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'h9
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_10 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hA
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hA
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hA
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hA
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hA
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hA
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hA
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hA
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hA
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hA
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hA
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hA
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hA
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hA
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hA
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hA
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_11 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hB
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hB
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hB
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hB
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hB
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hB
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hB
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hB
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hB
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hB
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hB
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hB
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hB
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hB
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hB
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hB
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_12 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hC
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hC
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hC
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hC
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hC
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hC
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hC
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hC
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hC
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hC
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hC
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hC
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hC
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hC
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hC
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hC
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_13 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hD
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hD
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hD
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hD
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hD
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hD
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hD
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hD
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hD
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hD
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hD
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hD
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hD
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hD
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hD
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hD
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_14 =
    lineActive_0 & slot_addrs_0[3:0] == 4'hE
      ? slot_data_0
      : lineActive_1 & slot_addrs_1[3:0] == 4'hE
          ? slot_data_1
          : lineActive_2 & slot_addrs_2[3:0] == 4'hE
              ? slot_data_2
              : lineActive_3 & slot_addrs_3[3:0] == 4'hE
                  ? slot_data_3
                  : lineActive_4 & slot_addrs_4[3:0] == 4'hE
                      ? slot_data_4
                      : lineActive_5 & slot_addrs_5[3:0] == 4'hE
                          ? slot_data_5
                          : lineActive_6 & slot_addrs_6[3:0] == 4'hE
                              ? slot_data_6
                              : lineActive_7 & slot_addrs_7[3:0] == 4'hE
                                  ? slot_data_7
                                  : lineActive_8 & slot_addrs_8[3:0] == 4'hE
                                      ? slot_data_8
                                      : lineActive_9 & slot_addrs_9[3:0] == 4'hE
                                          ? slot_data_9
                                          : lineActive_10 & slot_addrs_10[3:0] == 4'hE
                                              ? slot_data_10
                                              : lineActive_11 & slot_addrs_11[3:0] == 4'hE
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & slot_addrs_12[3:0] == 4'hE
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & slot_addrs_13[3:0] == 4'hE
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & slot_addrs_14[3:0] == 4'hE
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & slot_addrs_15[3:0] == 4'hE
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire [7:0]        wdata_15 =
    lineActive_0 & (&(slot_addrs_0[3:0]))
      ? slot_data_0
      : lineActive_1 & (&(slot_addrs_1[3:0]))
          ? slot_data_1
          : lineActive_2 & (&(slot_addrs_2[3:0]))
              ? slot_data_2
              : lineActive_3 & (&(slot_addrs_3[3:0]))
                  ? slot_data_3
                  : lineActive_4 & (&(slot_addrs_4[3:0]))
                      ? slot_data_4
                      : lineActive_5 & (&(slot_addrs_5[3:0]))
                          ? slot_data_5
                          : lineActive_6 & (&(slot_addrs_6[3:0]))
                              ? slot_data_6
                              : lineActive_7 & (&(slot_addrs_7[3:0]))
                                  ? slot_data_7
                                  : lineActive_8 & (&(slot_addrs_8[3:0]))
                                      ? slot_data_8
                                      : lineActive_9 & (&(slot_addrs_9[3:0]))
                                          ? slot_data_9
                                          : lineActive_10 & (&(slot_addrs_10[3:0]))
                                              ? slot_data_10
                                              : lineActive_11 & (&(slot_addrs_11[3:0]))
                                                  ? slot_data_11
                                                  : lineActive_12
                                                    & (&(slot_addrs_12[3:0]))
                                                      ? slot_data_12
                                                      : lineActive_13
                                                        & (&(slot_addrs_13[3:0]))
                                                          ? slot_data_13
                                                          : lineActive_14
                                                            & (&(slot_addrs_14[3:0]))
                                                              ? slot_data_14
                                                              : lineActive_15
                                                                & (&(slot_addrs_15[3:0]))
                                                                  ? slot_data_15
                                                                  : 8'h0;
  wire              wordAligned = targetAddress_bits[1:0] == 2'h0;
  wire              _alignedAddress_T_1 = slot_op == 5'h3;
  wire              _alignedAddress_T_2 = slot_op == 5'h5;
  wire [2:0]        _size_T_3 = {_alignedAddress_T_2, _alignedAddress_T_1, ~(|slot_op)};
  wire              _alignedAddress_T_5 = slot_op == 5'h1;
  wire              _alignedAddress_T_6 = slot_op == 5'h4;
  wire              _alignedAddress_T_7 = slot_op == 5'h6;
  wire [2:0]        _size_T_8 =
    {_alignedAddress_T_7, _alignedAddress_T_6, _alignedAddress_T_5};
  wire              _alignedAddress_T_11 = slot_op == 5'h2;
  wire              _alignedAddress_T_12 = slot_op == 5'h7;
  wire              _alignedAddress_T_13 = slot_op == 5'hC;
  wire [2:0]        _size_T_14 =
    {_alignedAddress_T_13, _alignedAddress_T_12, _alignedAddress_T_11};
  wire [7:0]        _size_T_25 =
    {_scalarStoreComplete_T_63,
     _scalarStoreComplete_T_62,
     _writebackUpdatedSlot_result_baseAddr_T_11,
     _writebackUpdatedSlot_result_baseAddr_T_2,
     _scalarStoreComplete_T_59,
     _scalarStoreComplete_T_58,
     _writebackUpdatedSlot_result_baseAddr_T_10,
     _writebackUpdatedSlot_result_baseAddr_T_1};
  wire [2:0]        _alignedAddress_T_3 =
    {_alignedAddress_T_2, _alignedAddress_T_1, ~(|slot_op)};
  wire              _alignedAddress_T_10 =
    (|{_alignedAddress_T_7, _alignedAddress_T_6, _alignedAddress_T_5})
    & ~(targetAddress_bits[0]);
  wire              _alignedAddress_T_16 =
    (|{_alignedAddress_T_13, _alignedAddress_T_12, _alignedAddress_T_11}) & wordAligned;
  wire              _ibusFault_valid_T_3 =
    loadUpdatedSlot_active_0 | loadUpdatedSlot_active_1;
  wire              io_ibus_valid_0 =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
    & (_ibusFault_valid_T_3 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
       | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5 | loadUpdatedSlot_active_6
       | loadUpdatedSlot_active_7 | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
       | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11 | loadUpdatedSlot_active_12
       | loadUpdatedSlot_active_13 | loadUpdatedSlot_active_14
       | loadUpdatedSlot_active_15) & itcm & ~slot_store & ~faultReg_valid;
  wire              _io_active_T = slot_active_0 | slot_active_1;
  wire              io_dbus_valid_0 =
    dtcm
    & (slot_store
         ? slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
           & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
              | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
              | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
              | slot_active_14 | slot_active_15)
         : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
           & (_ibusFault_valid_T_3 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
              | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5
              | loadUpdatedSlot_active_6 | loadUpdatedSlot_active_7
              | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
              | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11
              | loadUpdatedSlot_active_12 | loadUpdatedSlot_active_13
              | loadUpdatedSlot_active_14 | loadUpdatedSlot_active_15)) & ~faultReg_valid;
  wire              io_ebus_dbus_valid_0 =
    (~(itcm | dtcm | peri) | peri)
    & (slot_store
         ? slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
           & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
              | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
              | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
              | slot_active_14 | slot_active_15)
         : slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
           & (_ibusFault_valid_T_3 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
              | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5
              | loadUpdatedSlot_active_6 | loadUpdatedSlot_active_7
              | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
              | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11
              | loadUpdatedSlot_active_12 | loadUpdatedSlot_active_13
              | loadUpdatedSlot_active_14 | loadUpdatedSlot_active_15)) & ~faultReg_valid;
  wire              ibusFired = io_ibus_valid_0 & io_ibus_ready;
  wire              ebusFired = io_ebus_dbus_valid_0 & io_ebus_dbus_ready;
  wire              slotFired = ebusFired | io_dbus_valid_0 | ibusFired;
  wire              transactionUpdatedSlot_active_0 =
    slot_store ? slot_active_0 & ~(slotFired & (|valueSet_1)) : loadUpdatedSlot_active_0;
  wire              transactionUpdatedSlot_active_1 =
    slot_store
      ? slot_active_1 & ~(slotFired & (|selectionMatrix_1))
      : loadUpdatedSlot_active_1;
  wire              transactionUpdatedSlot_active_2 =
    slot_store
      ? slot_active_2 & ~(slotFired & (|selectionMatrix_2))
      : loadUpdatedSlot_active_2;
  wire              transactionUpdatedSlot_active_3 =
    slot_store
      ? slot_active_3 & ~(slotFired & (|selectionMatrix_3))
      : loadUpdatedSlot_active_3;
  wire              transactionUpdatedSlot_active_4 =
    slot_store
      ? slot_active_4 & ~(slotFired & (|selectionMatrix_4))
      : loadUpdatedSlot_active_4;
  wire              transactionUpdatedSlot_active_5 =
    slot_store
      ? slot_active_5 & ~(slotFired & (|selectionMatrix_5))
      : loadUpdatedSlot_active_5;
  wire              transactionUpdatedSlot_active_6 =
    slot_store
      ? slot_active_6 & ~(slotFired & (|selectionMatrix_6))
      : loadUpdatedSlot_active_6;
  wire              transactionUpdatedSlot_active_7 =
    slot_store
      ? slot_active_7 & ~(slotFired & (|selectionMatrix_7))
      : loadUpdatedSlot_active_7;
  wire              transactionUpdatedSlot_active_8 =
    slot_store
      ? slot_active_8 & ~(slotFired & (|selectionMatrix_8))
      : loadUpdatedSlot_active_8;
  wire              transactionUpdatedSlot_active_9 =
    slot_store
      ? slot_active_9 & ~(slotFired & (|selectionMatrix_9))
      : loadUpdatedSlot_active_9;
  wire              transactionUpdatedSlot_active_10 =
    slot_store
      ? slot_active_10 & ~(slotFired & (|selectionMatrix_10))
      : loadUpdatedSlot_active_10;
  wire              transactionUpdatedSlot_active_11 =
    slot_store
      ? slot_active_11 & ~(slotFired & (|selectionMatrix_11))
      : loadUpdatedSlot_active_11;
  wire              transactionUpdatedSlot_active_12 =
    slot_store
      ? slot_active_12 & ~(slotFired & (|selectionMatrix_12))
      : loadUpdatedSlot_active_12;
  wire              transactionUpdatedSlot_active_13 =
    slot_store
      ? slot_active_13 & ~(slotFired & (|selectionMatrix_13))
      : loadUpdatedSlot_active_13;
  wire              transactionUpdatedSlot_active_14 =
    slot_store
      ? slot_active_14 & ~(slotFired & (|selectionMatrix_14))
      : loadUpdatedSlot_active_14;
  wire              transactionUpdatedSlot_active_15 =
    slot_store
      ? slot_active_15 & ~(slotFired & (|selectionMatrix_15))
      : loadUpdatedSlot_active_15;
  wire              lsu2RvvFire = io_lsu2rvv_0_ready & io_lsu2rvv_0_valid_0;
  wire              io_storeComplete_valid_0 =
    (slotFired & slot_store
     & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
        | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
        | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
        | slot_active_15 | slot_pendingWriteback
        | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
        | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
        | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max)
     & ~(transactionUpdatedSlot_active_0 | transactionUpdatedSlot_active_1
         | transactionUpdatedSlot_active_2 | transactionUpdatedSlot_active_3
         | transactionUpdatedSlot_active_4 | transactionUpdatedSlot_active_5
         | transactionUpdatedSlot_active_6 | transactionUpdatedSlot_active_7
         | transactionUpdatedSlot_active_8 | transactionUpdatedSlot_active_9
         | transactionUpdatedSlot_active_10 | transactionUpdatedSlot_active_11
         | transactionUpdatedSlot_active_12 | transactionUpdatedSlot_active_13
         | transactionUpdatedSlot_active_14 | transactionUpdatedSlot_active_15
         | slot_pendingWriteback
         | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
         | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
         | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max)
     & {_scalarStoreComplete_T_63,
        _scalarStoreComplete_T_62,
        _writebackUpdatedSlot_result_baseAddr_T_11,
        _writebackUpdatedSlot_result_baseAddr_T_2,
        _scalarStoreComplete_T_59,
        _scalarStoreComplete_T_58,
        _writebackUpdatedSlot_result_baseAddr_T_10,
        _writebackUpdatedSlot_result_baseAddr_T_1} == 8'h0 | lsu2RvvFire
     & io_lsu2rvv_0_bits_last_0) & ~io_ebus_fault_valid;
  wire [4:0]        currentOp = faultReg_valid ? faultReg_bits_op : slot_op;
  wire              io_rd_valid_0 =
    (faultReg_valid
     & (|{faultReg_bits_op == 5'h2,
          faultReg_bits_op == 5'h4,
          faultReg_bits_op == 5'h1,
          faultReg_bits_op == 5'h3,
          faultReg_bits_op == 5'h0})
     | slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
     & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
         | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
         | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
         | slot_active_15) & slot_pendingWriteback)
    & (|{currentOp == 5'h2,
         currentOp == 5'h4,
         currentOp == 5'h1,
         currentOp == 5'h3,
         currentOp == 5'h0});
  wire [31:0]       io_rd_bits_data_halfSigned =
    {{16{slot_data_1[7]}}, slot_data_1, slot_data_0};
  wire [31:0]       io_rd_bits_data_byteSigned = {{24{slot_data_0[7]}}, slot_data_0};
  wire [31:0]       _GEN_0 = {24'h0, slot_data_0};
  wire [31:0]       _GEN_1 = {16'h0, slot_data_1, slot_data_0};
  wire [4:0]        io_rd_bits_addr_0 = faultReg_valid ? faultReg_bits_rd : slot_rd;
  wire              io_rd_flt_valid_0 =
    (faultReg_valid & ~(faultReg_valid ? faultReg_bits_store : slot_store)
     | slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
     & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
         | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
         | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
         | slot_active_15) & slot_pendingWriteback) & currentOp == 5'hC;
  wire              _io_lsu2rvv_0_valid_T_21 = currentOp == 5'hD;
  wire              _io_lsu2rvv_0_valid_T_22 = currentOp == 5'hE;
  wire              _io_lsu2rvv_0_valid_T_23 = currentOp == 5'hF;
  wire              _io_lsu2rvv_0_valid_T_24 = currentOp == 5'h10;
  wire              _io_lsu2rvv_0_bits_last_T_22 = currentOp == 5'h11;
  wire              _io_lsu2rvv_0_bits_last_T_23 = currentOp == 5'h12;
  wire              _io_lsu2rvv_0_bits_last_T_24 = currentOp == 5'h13;
  wire              _io_lsu2rvv_0_bits_last_T_25 = currentOp == 5'h14;
  wire              vectorFault =
    faultReg_valid
    & (|{_io_lsu2rvv_0_bits_last_T_25,
         _io_lsu2rvv_0_bits_last_T_24,
         _io_lsu2rvv_0_bits_last_T_23,
         _io_lsu2rvv_0_bits_last_T_22,
         _io_lsu2rvv_0_valid_T_24,
         _io_lsu2rvv_0_valid_T_23,
         _io_lsu2rvv_0_valid_T_22,
         _io_lsu2rvv_0_valid_T_21});
  assign io_lsu2rvv_0_valid_0 =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
    & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
        | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
        | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
        | slot_active_15) & slot_pendingWriteback
    & (|{_io_lsu2rvv_0_bits_last_T_25,
         _io_lsu2rvv_0_bits_last_T_24,
         _io_lsu2rvv_0_bits_last_T_23,
         _io_lsu2rvv_0_bits_last_T_22,
         _io_lsu2rvv_0_valid_T_24,
         _io_lsu2rvv_0_valid_T_23,
         _io_lsu2rvv_0_valid_T_22,
         _io_lsu2rvv_0_valid_T_21}) | vectorFault;
  assign io_lsu2rvv_0_bits_last_0 =
    (slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
     & ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
         | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
         | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
         | slot_active_15) & slot_pendingWriteback | vectorFault)
    & (|{_io_lsu2rvv_0_bits_last_T_25,
         _io_lsu2rvv_0_bits_last_T_24,
         _io_lsu2rvv_0_bits_last_T_23,
         _io_lsu2rvv_0_bits_last_T_22});
  wire              writebackFired = io_rd_valid_0 | io_rd_flt_valid_0 | lsu2RvvFire;
  wire              vectorUpdate = io_rvv2lsu_0_ready_0 & io_rvv2lsu_0_valid;
  wire [2:0]        _nextSlot_max_subvector_T_23 =
    {1'h0, _nextSlot_max_subvector_T_3, 1'h0} | {_nextSlot_max_subvector_T_7, 2'h0};
  wire [1:0]        _GEN_2 =
    _nextSlot_max_subvector_T_23[1:0] | {_nextSlot_max_subvector_T_11, 1'h0};
  wire [2:0]        _nextSlot_result_indexParitions_T_20 =
    {1'h0, _nextSlot_result_indexParitions_T_2, 1'h0}
    | {_nextSlot_result_indexParitions_T_5, 2'h0};
  wire [1:0]        _GEN_3 =
    _nextSlot_result_indexParitions_T_20[1:0]
    | {_nextSlot_result_indexParitions_T_8, 1'h0};
  wire [1:0]        _nextSlot_T_18 = {_nextSlot_T_17, _nextSlot_T_16};
  wire [31:0]       _GEN_4 = {_opQueue_io_dataOut_0_data[30:0], 1'h0};
  wire [31:0]       _nextSlot_T_273 = _opQueue_io_dataOut_0_data * 32'h3;
  wire [31:0]       _GEN_5 = {_opQueue_io_dataOut_0_data[29:0], 2'h0};
  wire [31:0]       _nextSlot_T_152 = _opQueue_io_dataOut_0_data * 32'h5;
  wire [31:0]       _nextSlot_T_164 = _opQueue_io_dataOut_0_data * 32'h6;
  wire [31:0]       _nextSlot_T_176 = _opQueue_io_dataOut_0_data * 32'h7;
  wire [2:0]        _nextSlot_unitStride_T_21 =
    {1'h0, {1'h0, _nextSlot_unitStride_T_16} | {_nextSlot_unitStride_T_7, 1'h0}}
    | {_nextSlot_unitStride_T_8, 2'h0};
  wire [2:0]        _nextSlot_unitStride_T_38 =
    {1'h0, {1'h0, _nextSlot_unitStride_T_33} | {_nextSlot_unitStride_T_24, 1'h0}}
    | {_nextSlot_unitStride_T_25, 2'h0};
  wire [2:0]        nextSlot_unitStride =
    (|{_nextSlot_unitStride_T_3,
       _nextSlot_unitStride_T_2,
       _nextSlot_unitStride_T_1,
       _nextSlot_unitStride_T})
      ? {_nextSlot_unitStride_T_21[2:1],
         _nextSlot_unitStride_T_21[0]
           | ~(_nextSlot_unitStride_T_16 | _nextSlot_unitStride_T_7
               | _nextSlot_unitStride_T_8)}
      : {_nextSlot_unitStride_T_38[2:1],
         _nextSlot_unitStride_T_38[0]
           | ~(_nextSlot_unitStride_T_33 | _nextSlot_unitStride_T_24
               | _nextSlot_unitStride_T_25)};
  wire [5:0]        _GEN_6 = {3'h0, nextSlot_unitStride};
  wire [6:0]        _nextSlot_result_vectorLoop_T_39 =
    7'h1
    << (_opQueue_io_dataOut_0_emul_data[2] ? 2'h0 : _opQueue_io_dataOut_0_emul_data[1:0]);
  wire [31:0]       _GEN_7 = {slot_elemStride[27:0], 4'h0};
  wire              _GEN_8 =
    _writebackUpdatedSlot_result_baseAddr_T_17
    | _writebackUpdatedSlot_result_baseAddr_T_21
    | _writebackUpdatedSlot_result_baseAddr_T_25;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_423 = slot_elemStride * 32'h9;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_427 = slot_elemStride * 32'hA;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_431 = slot_elemStride * 32'hB;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_435 = slot_elemStride * 32'hC;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_439 = slot_elemStride * 32'hD;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_443 = slot_elemStride * 32'hE;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_447 = slot_elemStride * 32'hF;
  wire [31:0]       _vectorUpdatedSlot_segmentBaseAddr_T_2 =
    slot_baseAddr + slot_segmentStride * {28'h0, slot_vectorLoop_segment_curr};
  wire [63:0]       _vectorUpdatedSlot_indices_T_29 =
    _vectorUpdatedSlot_indices_T_3 ? io_rvv2lsu_0_bits_idx_bits_data[127:64] : 64'h0;
  wire [127:0]      vectorUpdatedSlot_indices =
    {64'h0,
     _vectorUpdatedSlot_indices_T_29[63:32],
     _vectorUpdatedSlot_indices_T_29[31:0]
       | (_vectorUpdatedSlot_indices_T_8 ? io_rvv2lsu_0_bits_idx_bits_data[63:32] : 32'h0)
       | (_vectorUpdatedSlot_indices_T_13
            ? io_rvv2lsu_0_bits_idx_bits_data[95:64]
            : 32'h0)
       | (_vectorUpdatedSlot_indices_T_18
            ? io_rvv2lsu_0_bits_idx_bits_data[127:96]
            : 32'h0)}
    | (_vectorUpdatedSlot_indices_T_3 | _vectorUpdatedSlot_indices_T_8
       | _vectorUpdatedSlot_indices_T_13 | _vectorUpdatedSlot_indices_T_18
         ? 128'h0
         : io_rvv2lsu_0_bits_idx_bits_data);
  wire [31:0]       _GEN_9 = {slot_elemStride[30:0], 1'h0};
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_639 = slot_elemStride * 32'h3;
  wire [31:0]       _GEN_10 = {slot_elemStride[29:0], 2'h0};
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_518 = slot_elemStride * 32'h5;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_530 = slot_elemStride * 32'h6;
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_542 = slot_elemStride * 32'h7;
  wire [31:0]       _GEN_11 = {slot_elemStride[28:0], 3'h0};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_0 =
    {16'h0, vectorUpdatedSlot_indices[15:0]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_1 =
    {16'h0, vectorUpdatedSlot_indices[31:16]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_2 =
    {16'h0, vectorUpdatedSlot_indices[47:32]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_3 =
    {16'h0, vectorUpdatedSlot_indices[63:48]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_4 =
    {16'h0, vectorUpdatedSlot_indices[79:64]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_5 =
    {16'h0, vectorUpdatedSlot_indices[95:80]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_6 =
    {16'h0, vectorUpdatedSlot_indices[111:96]};
  wire [31:0]       vectorUpdatedSlot_updateAddrs_indices16_7 =
    {16'h0, vectorUpdatedSlot_indices[127:112]};
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_881 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[7:0]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_0
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[31:0]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_897 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[15:8]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_1
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[63:32]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_913 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[23:16]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_2
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[95:64]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_929 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[31:24]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_3
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[127:96]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_840 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[39:32]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_4
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[31:0]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_848 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[47:40]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_5
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[63:32]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_856 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[55:48]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_6
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[95:64]
            : 32'h0));
  wire [31:0]       _vectorUpdatedSlot_updateAddrs_T_864 =
    _vectorUpdatedSlot_segmentBaseAddr_T_2
    + ((_writebackUpdatedSlot_result_baseAddr_T_17
          ? {24'h0, vectorUpdatedSlot_indices[63:56]}
          : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_21
            ? vectorUpdatedSlot_updateAddrs_indices16_7
            : 32'h0)
       | (_writebackUpdatedSlot_result_baseAddr_T_25
            ? vectorUpdatedSlot_indices[127:96]
            : 32'h0));
  wire              vectorUpdatedSlot_updateAddrs_defaultSel_3 =
    {_writebackUpdatedSlot_result_baseAddr_T_2,
     _writebackUpdatedSlot_result_baseAddr_T_1,
     _writebackUpdatedSlot_result_baseAddr_T_11,
     _writebackUpdatedSlot_result_baseAddr_T_10,
     _scalarStoreComplete_T_63,
     _scalarStoreComplete_T_62,
     _scalarStoreComplete_T_59,
     _scalarStoreComplete_T_58} == 8'h0;
  wire              _flushCmd_T_6 =
    _ops_T & (|{_ops_T_3, _ops_T_2, flushCmd_result_fencei});
  wire              _flushCmd_T_7 = flushCmd_valid & io_flush_ready;
  wire [15:0]       nextSlot_active =
    {15'h0, |_nextSlot_active_T_3} | ((|_nextSlot_active_T_8) ? 16'h3 : 16'h0)
    | ((|_nextSlot_active_T_13) ? 16'hF : 16'h0);
  wire [3:0][127:0] _GEN_12 =
    {{128'h0}, {io_ebus_dbus_rdata}, {io_dbus_rdata}, {io_ibus_rdata}};
  wire [127:0]      readData = _GEN_12[readFired_bits_bus];
  wire              vectorUpdatedSlot_shouldUpdate =
    (|{_writebackUpdatedSlot_result_baseAddr_T_11,
       _writebackUpdatedSlot_result_baseAddr_T_2,
       _writebackUpdatedSlot_result_baseAddr_T_10,
       _writebackUpdatedSlot_result_baseAddr_T_1,
       slot_vectorLoop_subvector_max}) | io_rvv2lsu_0_bits_idx_valid;
  wire              _vectorUpdatedSlot_newActiveBytes_T_11 =
    vectorUpdatedSlot_shouldUpdate
    & (|{_scalarStoreComplete_T_63,
         _scalarStoreComplete_T_62,
         _writebackUpdatedSlot_result_baseAddr_T_11,
         _writebackUpdatedSlot_result_baseAddr_T_2,
         _scalarStoreComplete_T_59,
         _scalarStoreComplete_T_58,
         _writebackUpdatedSlot_result_baseAddr_T_10,
         _writebackUpdatedSlot_result_baseAddr_T_1}) & io_rvv2lsu_0_bits_mask_valid;
  wire              vectorUpdatedSlot_newActiveBytes_0 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[0];
  wire              vectorUpdatedSlot_newActiveBytes_1 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[1];
  wire              vectorUpdatedSlot_newActiveBytes_2 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[2];
  wire              vectorUpdatedSlot_newActiveBytes_3 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[3];
  wire              vectorUpdatedSlot_newActiveBytes_4 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[4];
  wire              vectorUpdatedSlot_newActiveBytes_5 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[5];
  wire              vectorUpdatedSlot_newActiveBytes_6 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[6];
  wire              vectorUpdatedSlot_newActiveBytes_7 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[7];
  wire              vectorUpdatedSlot_newActiveBytes_8 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[8];
  wire              vectorUpdatedSlot_newActiveBytes_9 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[9];
  wire              vectorUpdatedSlot_newActiveBytes_10 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[10];
  wire              vectorUpdatedSlot_newActiveBytes_11 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[11];
  wire              vectorUpdatedSlot_newActiveBytes_12 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[12];
  wire              vectorUpdatedSlot_newActiveBytes_13 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[13];
  wire              vectorUpdatedSlot_newActiveBytes_14 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[14];
  wire              vectorUpdatedSlot_newActiveBytes_15 =
    _vectorUpdatedSlot_newActiveBytes_T_11 & io_rvv2lsu_0_bits_mask_bits[15];
  wire              _vectorUpdatedSlot_T_43 =
    vectorUpdatedSlot_shouldUpdate
    & (|{_scalarStoreComplete_T_63,
         _scalarStoreComplete_T_62,
         _writebackUpdatedSlot_result_baseAddr_T_11,
         _writebackUpdatedSlot_result_baseAddr_T_2,
         _scalarStoreComplete_T_59,
         _scalarStoreComplete_T_58,
         _writebackUpdatedSlot_result_baseAddr_T_10,
         _writebackUpdatedSlot_result_baseAddr_T_1}) & io_rvv2lsu_0_bits_vregfile_valid;
  wire [15:0][7:0]  _GEN_13 =
    {{readData[127:120]},
     {readData[119:112]},
     {readData[111:104]},
     {readData[103:96]},
     {readData[95:88]},
     {readData[87:80]},
     {readData[79:72]},
     {readData[71:64]},
     {readData[63:56]},
     {readData[55:48]},
     {readData[47:40]},
     {readData[39:32]},
     {readData[31:24]},
     {readData[23:16]},
     {readData[15:8]},
     {readData[7:0]}};
  wire              _readFired_T_1 = io_dbus_valid_0 & ~slot_store;
  wire              _readFired_T_3 = ebusFired & ~slot_store;
  wire              ibusFault_valid =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
    & (_ibusFault_valid_T_3 | loadUpdatedSlot_active_2 | loadUpdatedSlot_active_3
       | loadUpdatedSlot_active_4 | loadUpdatedSlot_active_5 | loadUpdatedSlot_active_6
       | loadUpdatedSlot_active_7 | loadUpdatedSlot_active_8 | loadUpdatedSlot_active_9
       | loadUpdatedSlot_active_10 | loadUpdatedSlot_active_11 | loadUpdatedSlot_active_12
       | loadUpdatedSlot_active_13 | loadUpdatedSlot_active_14
       | loadUpdatedSlot_active_15) & itcm & slot_store;
  wire              _io_active_T_18 =
    slot_vectorLoop_segment_curr == slot_vectorLoop_segment_max;
  wire              _io_active_T_21 =
    slot_vectorLoop_lmul_curr == slot_vectorLoop_lmul_max;
  wire [3:0]        _writebackUpdatedSlot_vectorLoopNext_result_rd_T_2 =
    slot_vectorLoop_lmul_curr + 4'h1;
  wire [3:0]        writebackUpdatedSlot_vectorLoopNext_result_lmul_y =
    _io_active_T_21 ? 4'h0 : _writebackUpdatedSlot_vectorLoopNext_result_rd_T_2;
  wire [3:0]        writebackUpdatedSlot_vectorLoopNext_lmul_curr =
    _io_active_T_18
      ? writebackUpdatedSlot_vectorLoopNext_result_lmul_y
      : slot_vectorLoop_lmul_curr;
  wire              writebackUpdatedSlot_finished =
    writebackUpdatedSlot_vectorLoopNext_lmul_curr == slot_vectorLoop_lmul_max;
  wire              _slotNext_T_27 =
    ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
      | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
      | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14 | slot_active_15
      | slot_pendingWriteback
      | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
      | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
      | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max) & (|_opQueue_io_nEnqueued);
  wire              _slotNext_T_46 =
    slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
    & (_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
       | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
       | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
       | slot_active_15);
  wire              _GEN_14 = vectorUpdate | _slotNext_T_46 | ~writebackFired;
  wire [4:0]        writebackUpdatedSlot_vectorLoopNext_rd =
    _io_active_T_18
      ? slot_vectorLoop_rdStart
        + {1'h0,
           _io_active_T_21 ? 4'h0 : _writebackUpdatedSlot_vectorLoopNext_result_rd_T_2}
      : slot_vectorLoop_rd + {1'h0, slot_vectorLoop_lmul_max};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      flushCmd_valid <= 1'h0;
      flushCmd_bits_fencei <= 1'h0;
      flushCmd_bits_pcNext <= 32'h0;
      readFired_valid <= 1'h0;
      readFired_bits_bus <= 2'h0;
      readFired_bits_lineAddr <= 28'h0;
      slot_op <= 5'h0;
      slot_rd <= 5'h0;
      slot_store <= 1'h0;
      slot_pc <= 32'h0;
      slot_baseAddr <= 32'h0;
      slot_active_0 <= 1'h0;
      slot_active_1 <= 1'h0;
      slot_active_2 <= 1'h0;
      slot_active_3 <= 1'h0;
      slot_active_4 <= 1'h0;
      slot_active_5 <= 1'h0;
      slot_active_6 <= 1'h0;
      slot_active_7 <= 1'h0;
      slot_active_8 <= 1'h0;
      slot_active_9 <= 1'h0;
      slot_active_10 <= 1'h0;
      slot_active_11 <= 1'h0;
      slot_active_12 <= 1'h0;
      slot_active_13 <= 1'h0;
      slot_active_14 <= 1'h0;
      slot_active_15 <= 1'h0;
      slot_addrs_0 <= 32'h0;
      slot_addrs_1 <= 32'h0;
      slot_addrs_2 <= 32'h0;
      slot_addrs_3 <= 32'h0;
      slot_addrs_4 <= 32'h0;
      slot_addrs_5 <= 32'h0;
      slot_addrs_6 <= 32'h0;
      slot_addrs_7 <= 32'h0;
      slot_addrs_8 <= 32'h0;
      slot_addrs_9 <= 32'h0;
      slot_addrs_10 <= 32'h0;
      slot_addrs_11 <= 32'h0;
      slot_addrs_12 <= 32'h0;
      slot_addrs_13 <= 32'h0;
      slot_addrs_14 <= 32'h0;
      slot_addrs_15 <= 32'h0;
      slot_data_0 <= 8'h0;
      slot_data_1 <= 8'h0;
      slot_data_2 <= 8'h0;
      slot_data_3 <= 8'h0;
      slot_data_4 <= 8'h0;
      slot_data_5 <= 8'h0;
      slot_data_6 <= 8'h0;
      slot_data_7 <= 8'h0;
      slot_data_8 <= 8'h0;
      slot_data_9 <= 8'h0;
      slot_data_10 <= 8'h0;
      slot_data_11 <= 8'h0;
      slot_data_12 <= 8'h0;
      slot_data_13 <= 8'h0;
      slot_data_14 <= 8'h0;
      slot_data_15 <= 8'h0;
      slot_pendingWriteback <= 1'h0;
      slot_elemStride <= 32'h0;
      slot_segmentStride <= 32'h0;
      slot_elemWidth <= 3'h0;
      slot_sew <= 3'h0;
      slot_indexParitions <= 3'h0;
      slot_vectorLoop_subvector_curr <= 3'h0;
      slot_vectorLoop_subvector_max <= 3'h0;
      slot_vectorLoop_segment_curr <= 4'h0;
      slot_vectorLoop_segment_max <= 4'h0;
      slot_vectorLoop_lmul_curr <= 4'h0;
      slot_vectorLoop_lmul_max <= 4'h0;
      slot_vectorLoop_rdStart <= 5'h0;
      slot_vectorLoop_rd <= 5'h0;
      faultReg_valid <= 1'h0;
      faultReg_bits_info_write <= 1'h0;
      faultReg_bits_info_addr <= 32'h0;
      faultReg_bits_info_epc <= 32'h0;
      faultReg_bits_rd <= 5'h0;
      faultReg_bits_op <= 5'h0;
      faultReg_bits_store <= 1'h0;
    end
    else begin
      flushCmd_valid <= _flushCmd_T_6 | ~_flushCmd_T_7 & flushCmd_valid;
      flushCmd_bits_fencei <=
        _flushCmd_T_6 ? flushCmd_result_fencei : ~_flushCmd_T_7 & flushCmd_bits_fencei;
      if (_flushCmd_T_6)
        flushCmd_bits_pcNext <= io_req_0_bits_pc + 32'h4;
      else if (_flushCmd_T_7)
        flushCmd_bits_pcNext <= 32'h0;
      readFired_valid <=
        ibusFired | io_dbus_valid_0 & ~slot_store | ebusFired & ~slot_store;
      if (ibusFired)
        readFired_bits_bus <= 2'h0;
      else if (_readFired_T_1)
        readFired_bits_bus <= 2'h1;
      else if (_readFired_T_3)
        readFired_bits_bus <= 2'h2;
      if (ibusFired | _readFired_T_1 | _readFired_T_3)
        readFired_bits_lineAddr <= targetAddress_bits[31:4];
      if (faultReg_valid) begin
        slot_op <= 5'h0;
        slot_rd <= 5'h0;
        slot_pc <= 32'h0;
        slot_baseAddr <= 32'h0;
        slot_addrs_0 <= 32'h0;
        slot_addrs_1 <= 32'h0;
        slot_addrs_2 <= 32'h0;
        slot_addrs_3 <= 32'h0;
        slot_addrs_4 <= 32'h0;
        slot_addrs_5 <= 32'h0;
        slot_addrs_6 <= 32'h0;
        slot_addrs_7 <= 32'h0;
        slot_addrs_8 <= 32'h0;
        slot_addrs_9 <= 32'h0;
        slot_addrs_10 <= 32'h0;
        slot_addrs_11 <= 32'h0;
        slot_addrs_12 <= 32'h0;
        slot_addrs_13 <= 32'h0;
        slot_addrs_14 <= 32'h0;
        slot_addrs_15 <= 32'h0;
        slot_data_0 <= 8'h0;
        slot_data_1 <= 8'h0;
        slot_data_2 <= 8'h0;
        slot_data_3 <= 8'h0;
        slot_elemStride <= 32'h0;
        slot_segmentStride <= 32'h0;
        slot_elemWidth <= 3'h0;
        slot_sew <= 3'h0;
        slot_indexParitions <= 3'h0;
        slot_vectorLoop_subvector_max <= 3'h0;
        slot_vectorLoop_segment_max <= 4'h0;
        slot_vectorLoop_lmul_max <= 4'h0;
        slot_vectorLoop_rdStart <= 5'h0;
        slot_vectorLoop_rd <= 5'h0;
      end
      else if (_slotNext_T_27) begin
        slot_op <= _opQueue_io_dataOut_0_op;
        slot_rd <= _opQueue_io_dataOut_0_rd;
        slot_pc <= _opQueue_io_dataOut_0_pc;
        slot_baseAddr <= _opQueue_io_dataOut_0_addr;
        slot_addrs_0 <=
          ~(|_nextSlot_T_18) | _nextSlot_unitStride_T_33 | _nextSlot_unitStride_T_24
          | _nextSlot_unitStride_T_25
            ? _opQueue_io_dataOut_0_addr
            : 32'h0;
        slot_addrs_1 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data
                 : 32'h0)
              | (_nextSlot_unitStride_T_24 ? _opQueue_io_dataOut_0_addr + 32'h1 : 32'h0)
              | (_nextSlot_unitStride_T_25 ? _opQueue_io_dataOut_0_addr + 32'h1 : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h1;
        slot_addrs_2 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33 ? _opQueue_io_dataOut_0_addr + _GEN_4 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data
                   : 32'h0)
              | (_nextSlot_unitStride_T_25 ? _opQueue_io_dataOut_0_addr + 32'h2 : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h2;
        slot_addrs_3 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25 ? _opQueue_io_dataOut_0_addr + 32'h3 : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h3;
        slot_addrs_4 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33 ? _opQueue_io_dataOut_0_addr + _GEN_5 : 32'h0)
              | (_nextSlot_unitStride_T_24 ? _opQueue_io_dataOut_0_addr + _GEN_4 : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h4;
        slot_addrs_5 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _nextSlot_T_152
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _GEN_4 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data + 32'h1
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h5;
        slot_addrs_6 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _nextSlot_T_164
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data + 32'h2
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h6;
        slot_addrs_7 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _nextSlot_T_176
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data + 32'h3
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h7;
        slot_addrs_8 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + {_opQueue_io_dataOut_0_data[28:0], 3'h0}
                 : 32'h0)
              | (_nextSlot_unitStride_T_24 ? _opQueue_io_dataOut_0_addr + _GEN_5 : 32'h0)
              | (_nextSlot_unitStride_T_25 ? _opQueue_io_dataOut_0_addr + _GEN_4 : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h8;
        slot_addrs_9 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'h9
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _GEN_5 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _GEN_4 + 32'h1
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'h9;
        slot_addrs_10 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hA
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_152
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _GEN_4 + 32'h2
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hA;
        slot_addrs_11 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hB
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_152 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _GEN_4 + 32'h3
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hB;
        slot_addrs_12 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hC
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_164
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hC;
        slot_addrs_13 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hD
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_164 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273 + 32'h1
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hD;
        slot_addrs_14 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hE
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_176
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273 + 32'h2
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hE;
        slot_addrs_15 <=
          (|_nextSlot_T_18)
            ? (_nextSlot_unitStride_T_33
                 ? _opQueue_io_dataOut_0_addr + _opQueue_io_dataOut_0_data * 32'hF
                 : 32'h0)
              | (_nextSlot_unitStride_T_24
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_176 + 32'h1
                   : 32'h0)
              | (_nextSlot_unitStride_T_25
                   ? _opQueue_io_dataOut_0_addr + _nextSlot_T_273 + 32'h3
                   : 32'h0)
            : _opQueue_io_dataOut_0_addr + 32'hF;
        slot_data_0 <= _opQueue_io_dataOut_0_data[7:0];
        slot_data_1 <= _opQueue_io_dataOut_0_data[15:8];
        slot_data_2 <= _opQueue_io_dataOut_0_data[23:16];
        slot_data_3 <= _opQueue_io_dataOut_0_data[31:24];
        slot_elemStride <=
          (|{_nextSlot_result_elemStride_T_1, _nextSlot_result_elemStride_T})
            ? {26'h0, _GEN_6 + {3'h0, _opQueue_io_dataOut_0_nfields} * _GEN_6}
            : _opQueue_io_dataOut_0_data;
        slot_segmentStride <= {29'h0, nextSlot_unitStride};
        slot_elemWidth <= _opQueue_io_dataOut_0_elemWidth;
        slot_sew <= _opQueue_io_dataOut_0_sew;
        slot_indexParitions <=
          {_nextSlot_result_indexParitions_T_20[2],
           _GEN_3[1],
           _GEN_3[0]
             | ~(_nextSlot_result_indexParitions_T_2 | _nextSlot_result_indexParitions_T_5
                 | _nextSlot_result_indexParitions_T_8)};
        slot_vectorLoop_subvector_max <=
          (|{_nextSlot_unitStride_T_3,
             _nextSlot_unitStride_T_2,
             _nextSlot_unitStride_T_1,
             _nextSlot_unitStride_T})
            ? {_nextSlot_max_subvector_T_23[2],
               _GEN_2[1],
               _GEN_2[0]
                 | ~(_nextSlot_max_subvector_T_3 | _nextSlot_max_subvector_T_7
                     | _nextSlot_max_subvector_T_11)}
            : {2'h0,
               |{_nextSlot_unitStride_T_3,
                 _nextSlot_unitStride_T_2,
                 _nextSlot_T_17,
                 _nextSlot_result_elemStride_T_1,
                 _nextSlot_unitStride_T_1,
                 _nextSlot_unitStride_T,
                 _nextSlot_T_16,
                 _nextSlot_result_elemStride_T}};
        slot_vectorLoop_segment_max <=
          {1'h0,
           (|{_nextSlot_unitStride_T_3,
              _nextSlot_unitStride_T_2,
              _nextSlot_T_17,
              _nextSlot_result_elemStride_T_1,
              _nextSlot_unitStride_T_1,
              _nextSlot_unitStride_T,
              _nextSlot_T_16,
              _nextSlot_result_elemStride_T})
           & (|{_nextSlot_unitStride_T_3,
                _nextSlot_unitStride_T_2,
                _nextSlot_T_17,
                _nextSlot_result_elemStride_T_1,
                _nextSlot_unitStride_T_1,
                _nextSlot_unitStride_T,
                _nextSlot_T_16,
                _nextSlot_result_elemStride_T})
             ? _opQueue_io_dataOut_0_nfields
             : 3'h0};
        slot_vectorLoop_lmul_max <=
          (|{_nextSlot_unitStride_T_3,
             _nextSlot_unitStride_T_2,
             _nextSlot_T_17,
             _nextSlot_result_elemStride_T_1,
             _nextSlot_unitStride_T_1,
             _nextSlot_unitStride_T,
             _nextSlot_T_16,
             _nextSlot_result_elemStride_T})
            ? _nextSlot_result_vectorLoop_T_39[3:0]
            : 4'h0;
        slot_vectorLoop_rdStart <= _opQueue_io_dataOut_0_rd;
        slot_vectorLoop_rd <= _opQueue_io_dataOut_0_rd;
      end
      else begin
        if (_GEN_14) begin
        end
        else
          slot_rd <=
            writebackUpdatedSlot_finished
              ? slot_vectorLoop_rd
              : writebackUpdatedSlot_vectorLoopNext_rd;
        if (vectorUpdate | _slotNext_T_46
            | ~(writebackFired
                & (slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
                   | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
                   | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max)
                & _io_active_T_18)) begin
        end
        else if (|{_writebackUpdatedSlot_result_baseAddr_T_2,
                   _writebackUpdatedSlot_result_baseAddr_T_1})
          slot_baseAddr <=
            slot_baseAddr + {24'h0, slot_vectorLoop_segment_max, 4'h0} + 32'h10;
        else if (|{_writebackUpdatedSlot_result_baseAddr_T_11,
                   _writebackUpdatedSlot_result_baseAddr_T_10})
          slot_baseAddr <=
            (_writebackUpdatedSlot_result_baseAddr_T_17 ? slot_baseAddr + _GEN_7 : 32'h0)
            | (_writebackUpdatedSlot_result_baseAddr_T_21
                 ? slot_baseAddr + _GEN_11
                 : 32'h0)
            | (_writebackUpdatedSlot_result_baseAddr_T_25
                 ? slot_baseAddr + _GEN_10
                 : 32'h0)
            | (_writebackUpdatedSlot_result_baseAddr_T_17
               | _writebackUpdatedSlot_result_baseAddr_T_21
               | _writebackUpdatedSlot_result_baseAddr_T_25
                 ? 32'h0
                 : slot_baseAddr + _GEN_7);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_0)
          slot_addrs_0 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2) & _GEN_8
             | (|_vectorUpdatedSlot_updateAddrs_T_384) & _GEN_8
               ? _vectorUpdatedSlot_segmentBaseAddr_T_2
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
               & (_vectorUpdatedSlot_updateAddrs_T_770
                  | _vectorUpdatedSlot_updateAddrs_T_803
                  | _vectorUpdatedSlot_updateAddrs_T_868)
                 ? _vectorUpdatedSlot_updateAddrs_T_881
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_0 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_1)
          slot_addrs_1 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_897
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_881 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_881 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_1 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_2)
          slot_addrs_2 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_913
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_897
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_881 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_2 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_3)
          slot_addrs_3 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_639
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_929
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_897 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_881 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_3 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_4)
          slot_addrs_4 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_840
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_913
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_897
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_4 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_5)
          slot_addrs_5 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_518
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_518
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h1
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_848
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_913 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_897 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_5 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_6)
          slot_addrs_6 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_530
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h2
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_530
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h2
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_856
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_929
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_897 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_6 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_7)
          slot_addrs_7 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_542
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h3
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_542
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + slot_elemStride + 32'h3
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_updateAddrs_T_864
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_929 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_897 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_7 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_8)
          slot_addrs_8 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_11
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_11
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[71:64]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_0
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[31:0]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_840
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_913
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_8 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_9)
          slot_addrs_9 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_423
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h1
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_423
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_10 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[79:72]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_1
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[63:32]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_840 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_913 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_9 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_10)
          slot_addrs_10 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_427
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_518
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h2
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_427
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_518
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[87:80]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_2
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[95:64]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_848
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_913 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_10 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_11)
          slot_addrs_11 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_431
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_518 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h3
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_431
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_518 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2 + _GEN_9 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[95:88]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_3
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[127:96]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_848 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_913 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_11 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_12)
          slot_addrs_12 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_435
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_530
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_435
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_530
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[103:96]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_4
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[31:0]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_856
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_929
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_12 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_13)
          slot_addrs_13 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_439
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_530 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h1
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_439
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_530 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[111:104]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_5
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[63:32]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_856 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_929 + 32'h1
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_13 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_14)
          slot_addrs_14 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_443
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_542
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h2
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_443
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_542
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[119:112]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_6
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[95:64]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_864
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_929 + 32'h2
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_14 : 32'h0);
        if (vectorUpdate & vectorUpdatedSlot_newActiveBytes_15)
          slot_addrs_15 <=
            ((|_vectorUpdatedSlot_updateAddrs_T_2)
               ? (_writebackUpdatedSlot_result_baseAddr_T_17
                    ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                      + _vectorUpdatedSlot_updateAddrs_T_447
                    : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_21
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_542 + 32'h1
                      : 32'h0)
                 | (_writebackUpdatedSlot_result_baseAddr_T_25
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h3
                      : 32'h0)
               : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_384)
                 ? (_writebackUpdatedSlot_result_baseAddr_T_17
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + _vectorUpdatedSlot_updateAddrs_T_447
                      : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_21
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_542 + 32'h1
                        : 32'h0)
                   | (_writebackUpdatedSlot_result_baseAddr_T_25
                        ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                          + _vectorUpdatedSlot_updateAddrs_T_639 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | ((|_vectorUpdatedSlot_updateAddrs_T_768)
                 ? (_vectorUpdatedSlot_updateAddrs_T_770
                      ? _vectorUpdatedSlot_segmentBaseAddr_T_2
                        + ((_writebackUpdatedSlot_result_baseAddr_T_17
                              ? {24'h0, vectorUpdatedSlot_indices[127:120]}
                              : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_21
                                ? vectorUpdatedSlot_updateAddrs_indices16_7
                                : 32'h0)
                           | (_writebackUpdatedSlot_result_baseAddr_T_25
                                ? vectorUpdatedSlot_indices[127:96]
                                : 32'h0))
                      : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_803
                        ? _vectorUpdatedSlot_updateAddrs_T_864 + 32'h1
                        : 32'h0)
                   | (_vectorUpdatedSlot_updateAddrs_T_868
                        ? _vectorUpdatedSlot_updateAddrs_T_929 + 32'h3
                        : 32'h0)
                 : 32'h0)
            | (vectorUpdatedSlot_updateAddrs_defaultSel_3 ? slot_addrs_15 : 32'h0);
        if (vectorUpdate) begin
          if (_vectorUpdatedSlot_T_43) begin
            slot_data_0 <= io_rvv2lsu_0_bits_vregfile_bits_data[7:0];
            slot_data_1 <= io_rvv2lsu_0_bits_vregfile_bits_data[15:8];
            slot_data_2 <= io_rvv2lsu_0_bits_vregfile_bits_data[23:16];
            slot_data_3 <= io_rvv2lsu_0_bits_vregfile_bits_data[31:24];
          end
        end
        else begin
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_0)) begin
          end
          else
            slot_data_0 <= _GEN_13[slot_addrs_0[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_1)) begin
          end
          else
            slot_data_1 <= _GEN_13[slot_addrs_1[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_2)) begin
          end
          else
            slot_data_2 <= _GEN_13[slot_addrs_2[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_3)) begin
          end
          else
            slot_data_3 <= _GEN_13[slot_addrs_3[3:0]];
        end
        if (vectorUpdate | _slotNext_T_46 | ~writebackFired
            | writebackUpdatedSlot_finished) begin
        end
        else
          slot_vectorLoop_rd <= writebackUpdatedSlot_vectorLoopNext_rd;
      end
      slot_store <=
        ~faultReg_valid & (_slotNext_T_27 ? _opQueue_io_dataOut_0_store : slot_store);
      slot_active_0 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[0]
             : vectorUpdate
                 ? slot_active_0 | vectorUpdatedSlot_newActiveBytes_0
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_0 : slot_active_0);
      slot_active_1 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[1]
             : vectorUpdate
                 ? slot_active_1 | vectorUpdatedSlot_newActiveBytes_1
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_1 : slot_active_1);
      slot_active_2 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[2]
             : vectorUpdate
                 ? slot_active_2 | vectorUpdatedSlot_newActiveBytes_2
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_2 : slot_active_2);
      slot_active_3 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[3]
             : vectorUpdate
                 ? slot_active_3 | vectorUpdatedSlot_newActiveBytes_3
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_3 : slot_active_3);
      slot_active_4 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[4]
             : vectorUpdate
                 ? slot_active_4 | vectorUpdatedSlot_newActiveBytes_4
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_4 : slot_active_4);
      slot_active_5 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[5]
             : vectorUpdate
                 ? slot_active_5 | vectorUpdatedSlot_newActiveBytes_5
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_5 : slot_active_5);
      slot_active_6 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[6]
             : vectorUpdate
                 ? slot_active_6 | vectorUpdatedSlot_newActiveBytes_6
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_6 : slot_active_6);
      slot_active_7 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[7]
             : vectorUpdate
                 ? slot_active_7 | vectorUpdatedSlot_newActiveBytes_7
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_7 : slot_active_7);
      slot_active_8 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[8]
             : vectorUpdate
                 ? slot_active_8 | vectorUpdatedSlot_newActiveBytes_8
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_8 : slot_active_8);
      slot_active_9 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[9]
             : vectorUpdate
                 ? slot_active_9 | vectorUpdatedSlot_newActiveBytes_9
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_9 : slot_active_9);
      slot_active_10 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[10]
             : vectorUpdate
                 ? slot_active_10 | vectorUpdatedSlot_newActiveBytes_10
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_10 : slot_active_10);
      slot_active_11 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[11]
             : vectorUpdate
                 ? slot_active_11 | vectorUpdatedSlot_newActiveBytes_11
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_11 : slot_active_11);
      slot_active_12 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[12]
             : vectorUpdate
                 ? slot_active_12 | vectorUpdatedSlot_newActiveBytes_12
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_12 : slot_active_12);
      slot_active_13 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[13]
             : vectorUpdate
                 ? slot_active_13 | vectorUpdatedSlot_newActiveBytes_13
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_13 : slot_active_13);
      slot_active_14 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[14]
             : vectorUpdate
                 ? slot_active_14 | vectorUpdatedSlot_newActiveBytes_14
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_14 : slot_active_14);
      slot_active_15 <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? nextSlot_active[15]
             : vectorUpdate
                 ? slot_active_15 | vectorUpdatedSlot_newActiveBytes_15
                 : _slotNext_T_46 ? transactionUpdatedSlot_active_15 : slot_active_15);
      if (faultReg_valid | _slotNext_T_27) begin
        slot_data_4 <= 8'h0;
        slot_data_5 <= 8'h0;
        slot_data_6 <= 8'h0;
        slot_data_7 <= 8'h0;
        slot_data_8 <= 8'h0;
        slot_data_9 <= 8'h0;
        slot_data_10 <= 8'h0;
        slot_data_11 <= 8'h0;
        slot_data_12 <= 8'h0;
        slot_data_13 <= 8'h0;
        slot_data_14 <= 8'h0;
        slot_data_15 <= 8'h0;
        slot_vectorLoop_subvector_curr <= 3'h0;
        slot_vectorLoop_segment_curr <= 4'h0;
        slot_vectorLoop_lmul_curr <= 4'h0;
      end
      else begin
        if (vectorUpdate) begin
          if (_vectorUpdatedSlot_T_43) begin
            slot_data_4 <= io_rvv2lsu_0_bits_vregfile_bits_data[39:32];
            slot_data_5 <= io_rvv2lsu_0_bits_vregfile_bits_data[47:40];
            slot_data_6 <= io_rvv2lsu_0_bits_vregfile_bits_data[55:48];
            slot_data_7 <= io_rvv2lsu_0_bits_vregfile_bits_data[63:56];
            slot_data_8 <= io_rvv2lsu_0_bits_vregfile_bits_data[71:64];
            slot_data_9 <= io_rvv2lsu_0_bits_vregfile_bits_data[79:72];
            slot_data_10 <= io_rvv2lsu_0_bits_vregfile_bits_data[87:80];
            slot_data_11 <= io_rvv2lsu_0_bits_vregfile_bits_data[95:88];
            slot_data_12 <= io_rvv2lsu_0_bits_vregfile_bits_data[103:96];
            slot_data_13 <= io_rvv2lsu_0_bits_vregfile_bits_data[111:104];
            slot_data_14 <= io_rvv2lsu_0_bits_vregfile_bits_data[119:112];
            slot_data_15 <= io_rvv2lsu_0_bits_vregfile_bits_data[127:120];
          end
          slot_vectorLoop_subvector_curr <=
            slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
              ? 3'h0
              : slot_vectorLoop_subvector_curr + 3'h1;
        end
        else begin
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_4)) begin
          end
          else
            slot_data_4 <= _GEN_13[slot_addrs_4[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_5)) begin
          end
          else
            slot_data_5 <= _GEN_13[slot_addrs_5[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_6)) begin
          end
          else
            slot_data_6 <= _GEN_13[slot_addrs_6[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_7)) begin
          end
          else
            slot_data_7 <= _GEN_13[slot_addrs_7[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_8)) begin
          end
          else
            slot_data_8 <= _GEN_13[slot_addrs_8[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_9)) begin
          end
          else
            slot_data_9 <= _GEN_13[slot_addrs_9[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_10)) begin
          end
          else
            slot_data_10 <= _GEN_13[slot_addrs_10[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_11)) begin
          end
          else
            slot_data_11 <= _GEN_13[slot_addrs_11[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_12)) begin
          end
          else
            slot_data_12 <= _GEN_13[slot_addrs_12[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_13)) begin
          end
          else
            slot_data_13 <= _GEN_13[slot_addrs_13[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_14)) begin
          end
          else
            slot_data_14 <= _GEN_13[slot_addrs_14[3:0]];
          if (~_slotNext_T_46 | slot_store
              | ~(readFired_valid & loadUpdatedSlot_lineActive_15)) begin
          end
          else
            slot_data_15 <= _GEN_13[slot_addrs_15[3:0]];
          if (_slotNext_T_46 | ~writebackFired) begin
          end
          else
            slot_vectorLoop_subvector_curr <=
              writebackUpdatedSlot_finished ? slot_vectorLoop_subvector_max : 3'h0;
        end
        if (_GEN_14) begin
        end
        else begin
          slot_vectorLoop_segment_curr <=
            writebackUpdatedSlot_finished
              ? slot_vectorLoop_segment_max
              : _io_active_T_18 ? 4'h0 : slot_vectorLoop_segment_curr + 4'h1;
          if (writebackUpdatedSlot_finished)
            slot_vectorLoop_lmul_curr <= slot_vectorLoop_lmul_max;
          else if (_io_active_T_18)
            slot_vectorLoop_lmul_curr <=
              writebackUpdatedSlot_vectorLoopNext_result_lmul_y;
        end
      end
      slot_pendingWriteback <=
        ~faultReg_valid
        & (_slotNext_T_27
             ? (|{~_opQueue_io_dataOut_0_store,
                  _nextSlot_unitStride_T_3,
                  _nextSlot_unitStride_T_2,
                  _nextSlot_T_17,
                  _nextSlot_result_elemStride_T_1,
                  _nextSlot_unitStride_T_1,
                  _nextSlot_unitStride_T,
                  _nextSlot_T_16,
                  _nextSlot_result_elemStride_T})
             : _GEN_14
                 ? slot_pendingWriteback
                 : writebackUpdatedSlot_vectorLoopNext_lmul_curr != slot_vectorLoop_lmul_max);
      faultReg_valid <= io_ebus_fault_valid ? io_ebus_fault_valid : ibusFault_valid;
      faultReg_bits_info_write <=
        io_ebus_fault_valid ? io_ebus_fault_bits_write : ibusFault_valid;
      faultReg_bits_info_addr <=
        io_ebus_fault_valid
          ? io_ebus_fault_bits_addr
          : ibusFault_valid ? targetLineAddr : 32'h0;
      faultReg_bits_info_epc <=
        io_ebus_fault_valid ? io_ebus_fault_bits_epc : ibusFault_valid ? slot_pc : 32'h0;
      faultReg_bits_rd <= slot_rd;
      faultReg_bits_op <= slot_op;
      faultReg_bits_store <= slot_store;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:30];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [4:0] i = 5'h0; i < 5'h1F; i += 5'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        flushCmd_valid = _RANDOM[5'h0][0];
        flushCmd_bits_fencei = _RANDOM[5'h0][2];
        flushCmd_bits_pcNext = {_RANDOM[5'h0][31:3], _RANDOM[5'h1][2:0]};
        readFired_valid = _RANDOM[5'h1][3];
        readFired_bits_bus = _RANDOM[5'h1][5:4];
        readFired_bits_lineAddr = {_RANDOM[5'h1][31:6], _RANDOM[5'h2][1:0]};
        slot_op = _RANDOM[5'h2][6:2];
        slot_rd = _RANDOM[5'h2][11:7];
        slot_store = _RANDOM[5'h2][12];
        slot_pc = {_RANDOM[5'h2][31:13], _RANDOM[5'h3][12:0]};
        slot_baseAddr = {_RANDOM[5'h3][31:13], _RANDOM[5'h4][12:0]};
        slot_active_0 = _RANDOM[5'h4][13];
        slot_active_1 = _RANDOM[5'h4][14];
        slot_active_2 = _RANDOM[5'h4][15];
        slot_active_3 = _RANDOM[5'h4][16];
        slot_active_4 = _RANDOM[5'h4][17];
        slot_active_5 = _RANDOM[5'h4][18];
        slot_active_6 = _RANDOM[5'h4][19];
        slot_active_7 = _RANDOM[5'h4][20];
        slot_active_8 = _RANDOM[5'h4][21];
        slot_active_9 = _RANDOM[5'h4][22];
        slot_active_10 = _RANDOM[5'h4][23];
        slot_active_11 = _RANDOM[5'h4][24];
        slot_active_12 = _RANDOM[5'h4][25];
        slot_active_13 = _RANDOM[5'h4][26];
        slot_active_14 = _RANDOM[5'h4][27];
        slot_active_15 = _RANDOM[5'h4][28];
        slot_addrs_0 = {_RANDOM[5'h4][31:29], _RANDOM[5'h5][28:0]};
        slot_addrs_1 = {_RANDOM[5'h5][31:29], _RANDOM[5'h6][28:0]};
        slot_addrs_2 = {_RANDOM[5'h6][31:29], _RANDOM[5'h7][28:0]};
        slot_addrs_3 = {_RANDOM[5'h7][31:29], _RANDOM[5'h8][28:0]};
        slot_addrs_4 = {_RANDOM[5'h8][31:29], _RANDOM[5'h9][28:0]};
        slot_addrs_5 = {_RANDOM[5'h9][31:29], _RANDOM[5'hA][28:0]};
        slot_addrs_6 = {_RANDOM[5'hA][31:29], _RANDOM[5'hB][28:0]};
        slot_addrs_7 = {_RANDOM[5'hB][31:29], _RANDOM[5'hC][28:0]};
        slot_addrs_8 = {_RANDOM[5'hC][31:29], _RANDOM[5'hD][28:0]};
        slot_addrs_9 = {_RANDOM[5'hD][31:29], _RANDOM[5'hE][28:0]};
        slot_addrs_10 = {_RANDOM[5'hE][31:29], _RANDOM[5'hF][28:0]};
        slot_addrs_11 = {_RANDOM[5'hF][31:29], _RANDOM[5'h10][28:0]};
        slot_addrs_12 = {_RANDOM[5'h10][31:29], _RANDOM[5'h11][28:0]};
        slot_addrs_13 = {_RANDOM[5'h11][31:29], _RANDOM[5'h12][28:0]};
        slot_addrs_14 = {_RANDOM[5'h12][31:29], _RANDOM[5'h13][28:0]};
        slot_addrs_15 = {_RANDOM[5'h13][31:29], _RANDOM[5'h14][28:0]};
        slot_data_0 = {_RANDOM[5'h14][31:29], _RANDOM[5'h15][4:0]};
        slot_data_1 = _RANDOM[5'h15][12:5];
        slot_data_2 = _RANDOM[5'h15][20:13];
        slot_data_3 = _RANDOM[5'h15][28:21];
        slot_data_4 = {_RANDOM[5'h15][31:29], _RANDOM[5'h16][4:0]};
        slot_data_5 = _RANDOM[5'h16][12:5];
        slot_data_6 = _RANDOM[5'h16][20:13];
        slot_data_7 = _RANDOM[5'h16][28:21];
        slot_data_8 = {_RANDOM[5'h16][31:29], _RANDOM[5'h17][4:0]};
        slot_data_9 = _RANDOM[5'h17][12:5];
        slot_data_10 = _RANDOM[5'h17][20:13];
        slot_data_11 = _RANDOM[5'h17][28:21];
        slot_data_12 = {_RANDOM[5'h17][31:29], _RANDOM[5'h18][4:0]};
        slot_data_13 = _RANDOM[5'h18][12:5];
        slot_data_14 = _RANDOM[5'h18][20:13];
        slot_data_15 = _RANDOM[5'h18][28:21];
        slot_pendingWriteback = _RANDOM[5'h18][29];
        slot_elemStride = {_RANDOM[5'h18][31:30], _RANDOM[5'h19][29:0]};
        slot_segmentStride = {_RANDOM[5'h19][31:30], _RANDOM[5'h1A][29:0]};
        slot_elemWidth = {_RANDOM[5'h1A][31:30], _RANDOM[5'h1B][0]};
        slot_sew = _RANDOM[5'h1B][3:1];
        slot_indexParitions = _RANDOM[5'h1B][6:4];
        slot_vectorLoop_subvector_curr = _RANDOM[5'h1B][9:7];
        slot_vectorLoop_subvector_max = _RANDOM[5'h1B][12:10];
        slot_vectorLoop_segment_curr = _RANDOM[5'h1B][16:13];
        slot_vectorLoop_segment_max = _RANDOM[5'h1B][20:17];
        slot_vectorLoop_lmul_curr = _RANDOM[5'h1B][24:21];
        slot_vectorLoop_lmul_max = _RANDOM[5'h1B][28:25];
        slot_vectorLoop_rdStart = {_RANDOM[5'h1B][31:29], _RANDOM[5'h1C][1:0]};
        slot_vectorLoop_rd = _RANDOM[5'h1C][6:2];
        faultReg_valid = _RANDOM[5'h1C][7];
        faultReg_bits_info_write = _RANDOM[5'h1C][8];
        faultReg_bits_info_addr = {_RANDOM[5'h1C][31:9], _RANDOM[5'h1D][8:0]};
        faultReg_bits_info_epc = {_RANDOM[5'h1D][31:9], _RANDOM[5'h1E][8:0]};
        faultReg_bits_rd = _RANDOM[5'h1E][13:9];
        faultReg_bits_op = _RANDOM[5'h1E][18:14];
        faultReg_bits_store = _RANDOM[5'h1E][19];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        flushCmd_valid = 1'h0;
        flushCmd_bits_fencei = 1'h0;
        flushCmd_bits_pcNext = 32'h0;
        readFired_valid = 1'h0;
        readFired_bits_bus = 2'h0;
        readFired_bits_lineAddr = 28'h0;
        slot_op = 5'h0;
        slot_rd = 5'h0;
        slot_store = 1'h0;
        slot_pc = 32'h0;
        slot_baseAddr = 32'h0;
        slot_active_0 = 1'h0;
        slot_active_1 = 1'h0;
        slot_active_2 = 1'h0;
        slot_active_3 = 1'h0;
        slot_active_4 = 1'h0;
        slot_active_5 = 1'h0;
        slot_active_6 = 1'h0;
        slot_active_7 = 1'h0;
        slot_active_8 = 1'h0;
        slot_active_9 = 1'h0;
        slot_active_10 = 1'h0;
        slot_active_11 = 1'h0;
        slot_active_12 = 1'h0;
        slot_active_13 = 1'h0;
        slot_active_14 = 1'h0;
        slot_active_15 = 1'h0;
        slot_addrs_0 = 32'h0;
        slot_addrs_1 = 32'h0;
        slot_addrs_2 = 32'h0;
        slot_addrs_3 = 32'h0;
        slot_addrs_4 = 32'h0;
        slot_addrs_5 = 32'h0;
        slot_addrs_6 = 32'h0;
        slot_addrs_7 = 32'h0;
        slot_addrs_8 = 32'h0;
        slot_addrs_9 = 32'h0;
        slot_addrs_10 = 32'h0;
        slot_addrs_11 = 32'h0;
        slot_addrs_12 = 32'h0;
        slot_addrs_13 = 32'h0;
        slot_addrs_14 = 32'h0;
        slot_addrs_15 = 32'h0;
        slot_data_0 = 8'h0;
        slot_data_1 = 8'h0;
        slot_data_2 = 8'h0;
        slot_data_3 = 8'h0;
        slot_data_4 = 8'h0;
        slot_data_5 = 8'h0;
        slot_data_6 = 8'h0;
        slot_data_7 = 8'h0;
        slot_data_8 = 8'h0;
        slot_data_9 = 8'h0;
        slot_data_10 = 8'h0;
        slot_data_11 = 8'h0;
        slot_data_12 = 8'h0;
        slot_data_13 = 8'h0;
        slot_data_14 = 8'h0;
        slot_data_15 = 8'h0;
        slot_pendingWriteback = 1'h0;
        slot_elemStride = 32'h0;
        slot_segmentStride = 32'h0;
        slot_elemWidth = 3'h0;
        slot_sew = 3'h0;
        slot_indexParitions = 3'h0;
        slot_vectorLoop_subvector_curr = 3'h0;
        slot_vectorLoop_subvector_max = 3'h0;
        slot_vectorLoop_segment_curr = 4'h0;
        slot_vectorLoop_segment_max = 4'h0;
        slot_vectorLoop_lmul_curr = 4'h0;
        slot_vectorLoop_lmul_max = 4'h0;
        slot_vectorLoop_rdStart = 5'h0;
        slot_vectorLoop_rd = 5'h0;
        faultReg_valid = 1'h0;
        faultReg_bits_info_write = 1'h0;
        faultReg_bits_info_addr = 32'h0;
        faultReg_bits_info_epc = 32'h0;
        faultReg_bits_rd = 5'h0;
        faultReg_bits_op = 5'h0;
        faultReg_bits_store = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CircularBufferMulti_1 opQueue (
    .clock                  (clock),
    .reset                  (reset),
    .io_enqValid            (opQueue_io_enqValid),
    .io_enqData_0_store     (_alignedOps_aligner_out_0_bits[118]),
    .io_enqData_0_rd        (_alignedOps_aligner_out_0_bits[117:113]),
    .io_enqData_0_op        (_alignedOps_aligner_out_0_bits[112:108]),
    .io_enqData_0_pc        (_alignedOps_aligner_out_0_bits[107:76]),
    .io_enqData_0_addr      (_alignedOps_aligner_out_0_bits[75:44]),
    .io_enqData_0_data      (_alignedOps_aligner_out_0_bits[43:12]),
    .io_enqData_0_elemWidth (_alignedOps_aligner_out_0_bits[11:9]),
    .io_enqData_0_sew       (_alignedOps_aligner_out_0_bits[8:6]),
    .io_enqData_0_emul_data (_alignedOps_aligner_out_0_bits[5:3]),
    .io_enqData_0_nfields   (_alignedOps_aligner_out_0_bits[2:0]),
    .io_enqData_1_store     (_alignedOps_aligner_out_1_bits[118]),
    .io_enqData_1_rd        (_alignedOps_aligner_out_1_bits[117:113]),
    .io_enqData_1_op        (_alignedOps_aligner_out_1_bits[112:108]),
    .io_enqData_1_pc        (_alignedOps_aligner_out_1_bits[107:76]),
    .io_enqData_1_addr      (_alignedOps_aligner_out_1_bits[75:44]),
    .io_enqData_1_data      (_alignedOps_aligner_out_1_bits[43:12]),
    .io_enqData_1_elemWidth (_alignedOps_aligner_out_1_bits[11:9]),
    .io_enqData_1_sew       (_alignedOps_aligner_out_1_bits[8:6]),
    .io_enqData_1_emul_data (_alignedOps_aligner_out_1_bits[5:3]),
    .io_enqData_1_nfields   (_alignedOps_aligner_out_1_bits[2:0]),
    .io_enqData_2_store     (_alignedOps_aligner_out_2_bits[118]),
    .io_enqData_2_rd        (_alignedOps_aligner_out_2_bits[117:113]),
    .io_enqData_2_op        (_alignedOps_aligner_out_2_bits[112:108]),
    .io_enqData_2_pc        (_alignedOps_aligner_out_2_bits[107:76]),
    .io_enqData_2_addr      (_alignedOps_aligner_out_2_bits[75:44]),
    .io_enqData_2_data      (_alignedOps_aligner_out_2_bits[43:12]),
    .io_enqData_2_elemWidth (_alignedOps_aligner_out_2_bits[11:9]),
    .io_enqData_2_sew       (_alignedOps_aligner_out_2_bits[8:6]),
    .io_enqData_2_emul_data (_alignedOps_aligner_out_2_bits[5:3]),
    .io_enqData_2_nfields   (_alignedOps_aligner_out_2_bits[2:0]),
    .io_enqData_3_store     (_alignedOps_aligner_out_3_bits[118]),
    .io_enqData_3_rd        (_alignedOps_aligner_out_3_bits[117:113]),
    .io_enqData_3_op        (_alignedOps_aligner_out_3_bits[112:108]),
    .io_enqData_3_pc        (_alignedOps_aligner_out_3_bits[107:76]),
    .io_enqData_3_addr      (_alignedOps_aligner_out_3_bits[75:44]),
    .io_enqData_3_data      (_alignedOps_aligner_out_3_bits[43:12]),
    .io_enqData_3_elemWidth (_alignedOps_aligner_out_3_bits[11:9]),
    .io_enqData_3_sew       (_alignedOps_aligner_out_3_bits[8:6]),
    .io_enqData_3_emul_data (_alignedOps_aligner_out_3_bits[5:3]),
    .io_enqData_3_nfields   (_alignedOps_aligner_out_3_bits[2:0]),
    .io_nEnqueued           (_opQueue_io_nEnqueued),
    .io_nSpace              (_opQueue_io_nSpace),
    .io_dataOut_0_store     (_opQueue_io_dataOut_0_store),
    .io_dataOut_0_rd        (_opQueue_io_dataOut_0_rd),
    .io_dataOut_0_op        (_opQueue_io_dataOut_0_op),
    .io_dataOut_0_pc        (_opQueue_io_dataOut_0_pc),
    .io_dataOut_0_addr      (_opQueue_io_dataOut_0_addr),
    .io_dataOut_0_data      (_opQueue_io_dataOut_0_data),
    .io_dataOut_0_elemWidth (_opQueue_io_dataOut_0_elemWidth),
    .io_dataOut_0_sew       (_opQueue_io_dataOut_0_sew),
    .io_dataOut_0_emul_data (_opQueue_io_dataOut_0_emul_data),
    .io_dataOut_0_nfields   (_opQueue_io_dataOut_0_nfields),
    .io_dataOut_1_store     (/* unused */),
    .io_dataOut_1_rd        (/* unused */),
    .io_dataOut_1_op        (/* unused */),
    .io_dataOut_1_pc        (/* unused */),
    .io_dataOut_1_addr      (/* unused */),
    .io_dataOut_1_data      (/* unused */),
    .io_dataOut_1_elemWidth (/* unused */),
    .io_dataOut_1_sew       (/* unused */),
    .io_dataOut_1_emul_data (/* unused */),
    .io_dataOut_1_nfields   (/* unused */),
    .io_dataOut_2_store     (/* unused */),
    .io_dataOut_2_rd        (/* unused */),
    .io_dataOut_2_op        (/* unused */),
    .io_dataOut_2_pc        (/* unused */),
    .io_dataOut_2_addr      (/* unused */),
    .io_dataOut_2_data      (/* unused */),
    .io_dataOut_2_elemWidth (/* unused */),
    .io_dataOut_2_sew       (/* unused */),
    .io_dataOut_2_emul_data (/* unused */),
    .io_dataOut_2_nfields   (/* unused */),
    .io_dataOut_3_store     (/* unused */),
    .io_dataOut_3_rd        (/* unused */),
    .io_dataOut_3_op        (/* unused */),
    .io_dataOut_3_pc        (/* unused */),
    .io_dataOut_3_addr      (/* unused */),
    .io_dataOut_3_data      (/* unused */),
    .io_dataOut_3_elemWidth (/* unused */),
    .io_dataOut_3_sew       (/* unused */),
    .io_dataOut_3_emul_data (/* unused */),
    .io_dataOut_3_nfields   (/* unused */),
    .io_deqReady
      ({2'h0,
        ~(_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
          | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
          | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
          | slot_active_15 | slot_pendingWriteback
          | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
          | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
          | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max)
          & (|_opQueue_io_nEnqueued)}),
    .io_flush               (1'h0)
  );
  Aligner_119_4 alignedOps_aligner (
    .in_0_valid  (_ops_T & {_ops_T_3, _ops_T_2, flushCmd_result_fencei} == 3'h0),
    .in_0_bits
      ({io_req_0_bits_store,
        io_req_0_bits_addr,
        io_req_0_bits_op,
        io_req_0_bits_pc,
        io_busPort_addr_0,
        io_req_0_bits_op == 5'hC ? io_busPort_flt_data_0 : io_busPort_data_0,
        io_req_0_bits_elemWidth,
        io_rvvState_bits_sew,
        _ops_result_nfields_T & (|{_ops_result_nfields_T_8, _ops_result_nfields_T_7})
          ? 3'h0
          : _ops_result_nfields_T_6
            & (|{_ops_result_nfields_T_8, _ops_result_nfields_T_7})
              ? {1'h0,
                 {1'h0, _ops_result_emul_data_T_30} | {_ops_result_emul_data_T_14, 1'h0}
                   | {2{&io_req_0_bits_nfields}}}
              : (|{io_req_0_bits_op == 5'h12,
                   _ops_result_nfields_T_8,
                   io_req_0_bits_op == 5'hE,
                   _ops_result_nfields_T_7})
                  ? (_ops_emul_data_T_2 ? _ops_emul_data_T_138 : 3'h0)
                    | (_ops_emul_data_T_11 ? _ops_emul_data_T_147 : 3'h0)
                    | (_ops_emul_data_T_20 ? _ops_emul_data_T_156 : 3'h0)
                    | (_ops_emul_data_T_25 ? _ops_emul_data_T_161 : 3'h0)
                    | (_ops_emul_data_T_2 | _ops_emul_data_T_11 | _ops_emul_data_T_20
                       | _ops_emul_data_T_25
                         ? 3'h0
                         : io_rvvState_bits_lmul)
                  : io_rvvState_bits_lmul,
        _ops_result_nfields_T_5 | _ops_result_nfields_T_11
          ? 3'h0
          : io_req_0_bits_nfields}),
    .in_1_valid
      (io_req_1_ready_0 & io_req_1_valid
       & {io_req_1_bits_op == 5'hA,
          io_req_1_bits_op == 5'h9,
          io_req_1_bits_op == 5'h8} == 3'h0),
    .in_1_bits
      ({io_req_1_bits_store,
        io_req_1_bits_addr,
        io_req_1_bits_op,
        io_req_1_bits_pc,
        io_busPort_addr_1,
        io_req_1_bits_op == 5'hC ? 32'h0 : io_busPort_data_1,
        io_req_1_bits_elemWidth,
        io_rvvState_bits_sew,
        _ops_result_nfields_T_22 & (|{_ops_result_nfields_T_30, _ops_result_nfields_T_29})
          ? 3'h0
          : _ops_result_nfields_T_28
            & (|{_ops_result_nfields_T_30, _ops_result_nfields_T_29})
              ? {1'h0,
                 {1'h0, _ops_result_emul_data_T_73} | {_ops_result_emul_data_T_57, 1'h0}
                   | {2{&io_req_1_bits_nfields}}}
              : (|{io_req_1_bits_op == 5'h12,
                   _ops_result_nfields_T_30,
                   io_req_1_bits_op == 5'hE,
                   _ops_result_nfields_T_29})
                  ? (_ops_emul_data_T_47 ? _ops_emul_data_T_138 : 3'h0)
                    | (_ops_emul_data_T_56 ? _ops_emul_data_T_147 : 3'h0)
                    | (_ops_emul_data_T_65 ? _ops_emul_data_T_156 : 3'h0)
                    | (_ops_emul_data_T_70 ? _ops_emul_data_T_161 : 3'h0)
                    | (_ops_emul_data_T_47 | _ops_emul_data_T_56 | _ops_emul_data_T_65
                       | _ops_emul_data_T_70
                         ? 3'h0
                         : io_rvvState_bits_lmul)
                  : io_rvvState_bits_lmul,
        _ops_result_nfields_T_27 | _ops_result_nfields_T_33
          ? 3'h0
          : io_req_1_bits_nfields}),
    .in_2_valid
      (io_req_2_ready_0 & io_req_2_valid
       & {io_req_2_bits_op == 5'hA,
          io_req_2_bits_op == 5'h9,
          io_req_2_bits_op == 5'h8} == 3'h0),
    .in_2_bits
      ({io_req_2_bits_store,
        io_req_2_bits_addr,
        io_req_2_bits_op,
        io_req_2_bits_pc,
        io_busPort_addr_2,
        io_req_2_bits_op == 5'hC ? 32'h0 : io_busPort_data_2,
        io_req_2_bits_elemWidth,
        io_rvvState_bits_sew,
        _ops_result_nfields_T_44 & (|{_ops_result_nfields_T_52, _ops_result_nfields_T_51})
          ? 3'h0
          : _ops_result_nfields_T_50
            & (|{_ops_result_nfields_T_52, _ops_result_nfields_T_51})
              ? {1'h0,
                 {1'h0, _ops_result_emul_data_T_116} | {_ops_result_emul_data_T_100, 1'h0}
                   | {2{&io_req_2_bits_nfields}}}
              : (|{io_req_2_bits_op == 5'h12,
                   _ops_result_nfields_T_52,
                   io_req_2_bits_op == 5'hE,
                   _ops_result_nfields_T_51})
                  ? (_ops_emul_data_T_92 ? _ops_emul_data_T_138 : 3'h0)
                    | (_ops_emul_data_T_101 ? _ops_emul_data_T_147 : 3'h0)
                    | (_ops_emul_data_T_110 ? _ops_emul_data_T_156 : 3'h0)
                    | (_ops_emul_data_T_115 ? _ops_emul_data_T_161 : 3'h0)
                    | (_ops_emul_data_T_92 | _ops_emul_data_T_101 | _ops_emul_data_T_110
                       | _ops_emul_data_T_115
                         ? 3'h0
                         : io_rvvState_bits_lmul)
                  : io_rvvState_bits_lmul,
        _ops_result_nfields_T_49 | _ops_result_nfields_T_55
          ? 3'h0
          : io_req_2_bits_nfields}),
    .in_3_valid
      (io_req_3_ready_0 & io_req_3_valid
       & {io_req_3_bits_op == 5'hA,
          io_req_3_bits_op == 5'h9,
          io_req_3_bits_op == 5'h8} == 3'h0),
    .in_3_bits
      ({io_req_3_bits_store,
        io_req_3_bits_addr,
        io_req_3_bits_op,
        io_req_3_bits_pc,
        io_busPort_addr_3,
        io_req_3_bits_op == 5'hC ? 32'h0 : io_busPort_data_3,
        io_req_3_bits_elemWidth,
        io_rvvState_bits_sew,
        _ops_result_nfields_T_66 & (|{_ops_result_nfields_T_74, _ops_result_nfields_T_73})
          ? 3'h0
          : _ops_result_nfields_T_72
            & (|{_ops_result_nfields_T_74, _ops_result_nfields_T_73})
              ? {1'h0,
                 {1'h0, _ops_result_emul_data_T_159} | {_ops_result_emul_data_T_143, 1'h0}
                   | {2{&io_req_3_bits_nfields}}}
              : (|{io_req_3_bits_op == 5'h12,
                   _ops_result_nfields_T_74,
                   io_req_3_bits_op == 5'hE,
                   _ops_result_nfields_T_73})
                  ? (_ops_emul_data_T_137 ? _ops_emul_data_T_138 : 3'h0)
                    | (_ops_emul_data_T_146 ? _ops_emul_data_T_147 : 3'h0)
                    | (_ops_emul_data_T_155 ? _ops_emul_data_T_156 : 3'h0)
                    | (_ops_emul_data_T_160 ? _ops_emul_data_T_161 : 3'h0)
                    | (_ops_emul_data_T_137 | _ops_emul_data_T_146 | _ops_emul_data_T_155
                       | _ops_emul_data_T_160
                         ? 3'h0
                         : io_rvvState_bits_lmul)
                  : io_rvvState_bits_lmul,
        _ops_result_nfields_T_71 | _ops_result_nfields_T_77
          ? 3'h0
          : io_req_3_bits_nfields}),
    .out_0_valid (_alignedOps_aligner_out_0_valid),
    .out_0_bits  (_alignedOps_aligner_out_0_bits),
    .out_1_valid (_alignedOps_aligner_out_1_valid),
    .out_1_bits  (_alignedOps_aligner_out_1_bits),
    .out_2_valid (_alignedOps_aligner_out_2_valid),
    .out_2_bits  (_alignedOps_aligner_out_2_bits),
    .out_3_valid (_alignedOps_aligner_out_3_valid),
    .out_3_bits  (_alignedOps_aligner_out_3_bits)
  );
  assign io_req_0_ready = io_req_0_ready_0;
  assign io_req_1_ready = io_req_1_ready_0;
  assign io_req_2_ready = io_req_2_ready_0;
  assign io_req_3_ready = io_req_3_ready_0;
  assign io_rd_valid = io_rd_valid_0;
  assign io_rd_bits_addr = io_rd_bits_addr_0;
  assign io_rd_bits_data =
    slot_op == 5'hC | slot_op == 5'h2
      ? {slot_data_3, slot_data_2, slot_data_1, slot_data_0}
      : slot_op == 5'h4
          ? _GEN_1
          : slot_op == 5'h1
              ? io_rd_bits_data_halfSigned
              : slot_op == 5'h3
                  ? _GEN_0
                  : (|slot_op) ? 32'h0 : io_rd_bits_data_byteSigned;
  assign io_rd_flt_valid = io_rd_flt_valid_0;
  assign io_rd_flt_bits_addr = io_rd_bits_addr_0;
  assign io_rd_flt_bits_data =
    slot_op == 5'hC | slot_op == 5'h2
      ? {slot_data_3, slot_data_2, slot_data_1, slot_data_0}
      : slot_op == 5'h4
          ? _GEN_1
          : slot_op == 5'h1
              ? io_rd_bits_data_halfSigned
              : slot_op == 5'h3
                  ? _GEN_0
                  : (|slot_op) ? 32'h0 : io_rd_bits_data_byteSigned;
  assign io_ibus_valid = io_ibus_valid_0;
  assign io_ibus_addr = targetLineAddr;
  assign io_dbus_valid = io_dbus_valid_0;
  assign io_dbus_write = slot_store;
  assign io_dbus_addr = targetLineAddr;
  assign io_dbus_wdata =
    {wdata_15,
     wdata_14,
     wdata_13,
     wdata_12,
     wdata_11,
     wdata_10,
     wdata_9,
     wdata_8,
     wdata_7,
     wdata_6,
     wdata_5,
     wdata_4,
     wdata_3,
     wdata_2,
     wdata_1,
     wdata_0};
  assign io_dbus_wmask = _resultMask_T_14;
  assign io_flush_valid = flushCmd_valid;
  assign io_flush_fencei = flushCmd_bits_fencei;
  assign io_flush_pcNext = flushCmd_bits_pcNext;
  assign io_fault_valid = faultReg_valid;
  assign io_fault_bits_write = faultReg_bits_info_write;
  assign io_fault_bits_addr = faultReg_bits_info_addr;
  assign io_fault_bits_epc = faultReg_bits_info_epc;
  assign io_ebus_dbus_valid = io_ebus_dbus_valid_0;
  assign io_ebus_dbus_write = slot_store;
  assign io_ebus_dbus_pc = slot_pc;
  assign io_ebus_dbus_addr =
    ((|_alignedAddress_T_3) ? targetAddress_bits : 32'h0)
    | (_alignedAddress_T_10 ? {targetAddress_bits[31:1], 1'h0} : 32'h0)
    | (_alignedAddress_T_16 ? {targetAddress_bits[31:2], 2'h0} : 32'h0)
    | ((|_alignedAddress_T_3) | _alignedAddress_T_10 | _alignedAddress_T_16
         ? 32'h0
         : {targetAddress_bits[31:4], 4'h0});
  assign io_ebus_dbus_size =
    {4'h0, |_size_T_3} | ((|_size_T_8) ? (targetAddress_bits[0] ? 5'h10 : 5'h2) : 5'h0)
    | ((|_size_T_14) ? (wordAligned ? 5'h4 : 5'h10) : 5'h0) | {|_size_T_25, 4'h0}
    | {{_alignedAddress_T_2,
        _alignedAddress_T_1,
        ~(|slot_op),
        _alignedAddress_T_7,
        _alignedAddress_T_6,
        _alignedAddress_T_5,
        _alignedAddress_T_13,
        _alignedAddress_T_12,
        _alignedAddress_T_11,
        _scalarStoreComplete_T_63,
        _scalarStoreComplete_T_62,
        _writebackUpdatedSlot_result_baseAddr_T_11,
        _writebackUpdatedSlot_result_baseAddr_T_2,
        _scalarStoreComplete_T_59,
        _scalarStoreComplete_T_58,
        _writebackUpdatedSlot_result_baseAddr_T_10,
        _writebackUpdatedSlot_result_baseAddr_T_1} == 17'h0,
       4'h0};
  assign io_ebus_dbus_wdata =
    {wdata_15,
     wdata_14,
     wdata_13,
     wdata_12,
     wdata_11,
     wdata_10,
     wdata_9,
     wdata_8,
     wdata_7,
     wdata_6,
     wdata_5,
     wdata_4,
     wdata_3,
     wdata_2,
     wdata_1,
     wdata_0};
  assign io_ebus_dbus_wmask = _resultMask_T_14;
  assign io_rvv2lsu_0_ready = io_rvv2lsu_0_ready_0;
  assign io_lsu2rvv_0_valid = io_lsu2rvv_0_valid_0;
  assign io_lsu2rvv_0_bits_addr = io_rd_bits_addr_0;
  assign io_lsu2rvv_0_bits_data =
    {slot_data_15,
     slot_data_14,
     slot_data_13,
     slot_data_12,
     slot_data_11,
     slot_data_10,
     slot_data_9,
     slot_data_8,
     slot_data_7,
     slot_data_6,
     slot_data_5,
     slot_data_4,
     slot_data_3,
     slot_data_2,
     slot_data_1,
     slot_data_0};
  assign io_lsu2rvv_0_bits_last = io_lsu2rvv_0_bits_last_0;
  assign io_queueCapacity = _opQueue_io_nSpace;
  assign io_active =
    |{_io_active_T | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
        | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9 | slot_active_10
        | slot_active_11 | slot_active_12 | slot_active_13 | slot_active_14
        | slot_active_15 | slot_pendingWriteback
        | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max
        | slot_vectorLoop_segment_curr != slot_vectorLoop_segment_max
        | slot_vectorLoop_lmul_curr != slot_vectorLoop_lmul_max,
      _opQueue_io_nEnqueued};
  assign io_storeComplete_valid = io_storeComplete_valid_0;
  assign io_storeComplete_bits = io_storeComplete_valid_0 ? slot_pc : 32'h0;
endmodule

module FaultManager(
  input         io_in_fault_0_csr,
                io_in_fault_0_jal,
                io_in_fault_0_jalr,
                io_in_fault_0_bxx,
                io_in_fault_0_undef,
                io_in_fault_0_rvv,
                io_in_fault_1_jal,
                io_in_fault_1_jalr,
                io_in_fault_1_bxx,
                io_in_fault_2_jal,
                io_in_fault_2_jalr,
                io_in_fault_2_bxx,
                io_in_fault_3_jal,
                io_in_fault_3_jalr,
                io_in_fault_3_bxx,
  input  [31:0] io_in_pc_0_pc,
                io_in_pc_1_pc,
                io_in_pc_2_pc,
                io_in_pc_3_pc,
  input         io_in_memory_fault_valid,
                io_in_memory_fault_bits_write,
  input  [31:0] io_in_memory_fault_bits_addr,
                io_in_memory_fault_bits_epc,
  input         io_in_rvv_fault_valid,
  input  [31:0] io_in_rvv_fault_bits_mepc,
                io_in_rvv_fault_bits_mtval,
                io_in_undef_0_inst,
                io_in_undef_1_inst,
                io_in_undef_2_inst,
                io_in_undef_3_inst,
                io_in_jal_0_target,
                io_in_jal_1_target,
                io_in_jal_2_target,
                io_in_jal_3_target,
                io_in_jalr_0_target,
                io_in_jalr_1_target,
                io_in_jalr_2_target,
                io_in_jalr_3_target,
  input         io_in_fetchFault_valid,
  input  [31:0] io_in_fetchFault_bits,
  output        io_out_valid,
  output [31:0] io_out_bits_mepc,
                io_out_bits_mtval,
                io_out_bits_mcause,
  output        io_out_bits_decode
);

  wire             faults_0 =
    io_in_fault_0_csr | io_in_fault_0_jal | io_in_fault_0_jalr | io_in_fault_0_bxx
    | io_in_fault_0_undef | io_in_fault_0_rvv;
  wire             faults_1 = io_in_fault_1_jal | io_in_fault_1_jalr | io_in_fault_1_bxx;
  wire             faults_2 = io_in_fault_2_jal | io_in_fault_2_jalr | io_in_fault_2_bxx;
  wire             fault =
    faults_0 | faults_1 | faults_2 | io_in_fault_3_jal | io_in_fault_3_jalr
    | io_in_fault_3_bxx;
  wire [1:0]       first_fault = faults_0 ? 2'h0 : faults_1 ? 2'h1 : {1'h1, ~faults_2};
  wire [1:0]       undef_fault_idx = io_in_fault_0_undef ? 2'h0 : 2'h3;
  wire [1:0]       jal_fault_idx =
    io_in_fault_0_jal ? 2'h0 : io_in_fault_1_jal ? 2'h1 : {1'h1, ~io_in_fault_2_jal};
  wire [1:0]       jalr_fault_idx =
    io_in_fault_0_jalr ? 2'h0 : io_in_fault_1_jalr ? 2'h1 : {1'h1, ~io_in_fault_2_jalr};
  wire [1:0]       rvv_dispatch_fault_idx = io_in_fault_0_rvv ? 2'h0 : 2'h3;
  wire             load_fault = io_in_memory_fault_valid & ~io_in_memory_fault_bits_write;
  wire             store_fault = io_in_memory_fault_valid & io_in_memory_fault_bits_write;
  wire [3:0][31:0] _GEN =
    {{io_in_pc_3_pc}, {io_in_pc_2_pc}, {io_in_pc_1_pc}, {io_in_pc_0_pc}};
  wire             _GEN_0 = load_fault | store_fault;
  wire             first_fault_is_csr =
    io_in_fault_0_csr & (io_in_fault_0_csr ? 2'h0 : 2'h3) == first_fault;
  wire             first_fault_is_jal =
    (io_in_fault_0_jal | io_in_fault_1_jal | io_in_fault_2_jal | io_in_fault_3_jal)
    & jal_fault_idx == first_fault;
  wire             first_fault_is_jalr =
    (io_in_fault_0_jalr | io_in_fault_1_jalr | io_in_fault_2_jalr | io_in_fault_3_jalr)
    & jalr_fault_idx == first_fault;
  wire             first_fault_is_bxx =
    (io_in_fault_0_bxx | io_in_fault_1_bxx | io_in_fault_2_bxx | io_in_fault_3_bxx)
    & (io_in_fault_0_bxx
         ? 2'h0
         : io_in_fault_1_bxx ? 2'h1 : {1'h1, ~io_in_fault_2_bxx}) == first_fault;
  wire             first_fault_is_undef =
    io_in_fault_0_undef & undef_fault_idx == first_fault;
  wire             first_fault_is_rvv_dispatch =
    io_in_fault_0_rvv & rvv_dispatch_fault_idx == first_fault;
  wire [3:0][31:0] _GEN_1 =
    {{io_in_jalr_3_target},
     {io_in_jalr_2_target},
     {io_in_jalr_1_target},
     {io_in_jalr_0_target}};
  wire [3:0][31:0] _GEN_2 =
    {{io_in_undef_3_inst},
     {io_in_undef_2_inst},
     {io_in_undef_1_inst},
     {io_in_undef_0_inst}};
  wire [3:0][31:0] _GEN_3 =
    {{io_in_jal_3_target},
     {io_in_jal_2_target},
     {io_in_jal_1_target},
     {io_in_jal_0_target}};
  assign io_out_valid =
    fault | io_in_fetchFault_valid | load_fault | store_fault | io_in_rvv_fault_valid;
  assign io_out_bits_mepc =
    _GEN_0
      ? io_in_memory_fault_bits_epc
      : io_in_rvv_fault_valid
          ? io_in_rvv_fault_bits_mepc
          : fault
              ? _GEN[first_fault]
              : io_in_fetchFault_valid ? io_in_fetchFault_bits : 32'h0;
  assign io_out_bits_mtval =
    _GEN_0
      ? io_in_memory_fault_bits_addr
      : io_in_rvv_fault_valid
          ? io_in_rvv_fault_bits_mtval
          : first_fault_is_csr
              ? 32'h0
              : first_fault_is_jal
                  ? _GEN_3[jal_fault_idx]
                  : first_fault_is_jalr
                      ? _GEN_1[jalr_fault_idx] & 32'hFFFFFFFE
                      : first_fault_is_bxx
                          ? 32'h0
                          : first_fault_is_undef
                              ? _GEN_2[undef_fault_idx]
                              : first_fault_is_rvv_dispatch
                                  ? _GEN_2[rvv_dispatch_fault_idx]
                                  : 32'h0;
  assign io_out_bits_mcause =
    load_fault
      ? 32'h5
      : store_fault
          ? 32'h7
          : io_in_rvv_fault_valid | first_fault_is_csr
              ? 32'h2
              : first_fault_is_jal | first_fault_is_jalr | first_fault_is_bxx
                  ? 32'h0
                  : first_fault_is_undef | first_fault_is_rvv_dispatch
                      ? 32'h2
                      : {31'h0, io_in_fetchFault_valid};
  assign io_out_bits_decode =
    first_fault_is_csr | first_fault_is_jal | first_fault_is_jalr | first_fault_is_bxx
    | first_fault_is_undef | first_fault_is_rvv_dispatch;
endmodule

module CircularBufferMulti_2(
  input         clock,
                reset,
  input  [3:0]  io_enqValid,
  input  [31:0] io_enqData_0_addr,
  input  [6:0]  io_enqData_0_idx,
  input         io_enqData_0_trap,
                io_enqData_0_isControlFlow,
                io_enqData_0_isBranch,
                io_enqData_0_isVector,
                io_enqData_0_linkOk,
                io_enqData_0_isEcall,
                io_enqData_0_isMpause,
  input  [31:0] io_enqData_1_addr,
  input  [6:0]  io_enqData_1_idx,
  input         io_enqData_1_trap,
                io_enqData_1_isControlFlow,
                io_enqData_1_isBranch,
                io_enqData_1_isVector,
                io_enqData_1_linkOk,
                io_enqData_1_isEcall,
                io_enqData_1_isMpause,
  input  [31:0] io_enqData_2_addr,
  input  [6:0]  io_enqData_2_idx,
  input         io_enqData_2_trap,
                io_enqData_2_isControlFlow,
                io_enqData_2_isBranch,
                io_enqData_2_isVector,
                io_enqData_2_linkOk,
                io_enqData_2_isEcall,
                io_enqData_2_isMpause,
  input  [31:0] io_enqData_3_addr,
  input  [6:0]  io_enqData_3_idx,
  input         io_enqData_3_trap,
                io_enqData_3_isControlFlow,
                io_enqData_3_isBranch,
                io_enqData_3_isVector,
                io_enqData_3_linkOk,
                io_enqData_3_isEcall,
                io_enqData_3_isMpause,
  input  [31:0] io_enqData_4_addr,
  input  [6:0]  io_enqData_4_idx,
  input         io_enqData_4_trap,
                io_enqData_4_isControlFlow,
                io_enqData_4_isBranch,
                io_enqData_4_isVector,
                io_enqData_4_linkOk,
                io_enqData_4_isEcall,
                io_enqData_4_isMpause,
  input  [31:0] io_enqData_5_addr,
  input  [6:0]  io_enqData_5_idx,
  input         io_enqData_5_trap,
                io_enqData_5_isControlFlow,
                io_enqData_5_isBranch,
                io_enqData_5_isVector,
                io_enqData_5_linkOk,
                io_enqData_5_isEcall,
                io_enqData_5_isMpause,
  input  [31:0] io_enqData_6_addr,
  input  [6:0]  io_enqData_6_idx,
  input         io_enqData_6_trap,
                io_enqData_6_isControlFlow,
                io_enqData_6_isBranch,
                io_enqData_6_isVector,
                io_enqData_6_linkOk,
                io_enqData_6_isEcall,
                io_enqData_6_isMpause,
  input  [31:0] io_enqData_7_addr,
  input  [6:0]  io_enqData_7_idx,
  input         io_enqData_7_trap,
                io_enqData_7_isControlFlow,
                io_enqData_7_isBranch,
                io_enqData_7_isVector,
                io_enqData_7_linkOk,
                io_enqData_7_isEcall,
                io_enqData_7_isMpause,
  output [3:0]  io_nEnqueued,
                io_nSpace,
  output [31:0] io_dataOut_0_addr,
  output [6:0]  io_dataOut_0_idx,
  output        io_dataOut_0_trap,
                io_dataOut_0_isControlFlow,
                io_dataOut_0_isBranch,
                io_dataOut_0_isVector,
                io_dataOut_0_linkOk,
                io_dataOut_0_isEcall,
                io_dataOut_0_isMpause,
  output [31:0] io_dataOut_1_addr,
  output [6:0]  io_dataOut_1_idx,
  output        io_dataOut_1_trap,
                io_dataOut_1_isControlFlow,
                io_dataOut_1_isBranch,
                io_dataOut_1_isVector,
                io_dataOut_1_linkOk,
                io_dataOut_1_isEcall,
                io_dataOut_1_isMpause,
  output [31:0] io_dataOut_2_addr,
  output [6:0]  io_dataOut_2_idx,
  output        io_dataOut_2_trap,
                io_dataOut_2_isControlFlow,
                io_dataOut_2_isBranch,
                io_dataOut_2_isVector,
                io_dataOut_2_linkOk,
                io_dataOut_2_isEcall,
                io_dataOut_2_isMpause,
  output [31:0] io_dataOut_3_addr,
  output [6:0]  io_dataOut_3_idx,
  output        io_dataOut_3_trap,
                io_dataOut_3_isControlFlow,
                io_dataOut_3_isBranch,
                io_dataOut_3_isVector,
                io_dataOut_3_linkOk,
                io_dataOut_3_isEcall,
                io_dataOut_3_isMpause,
  output [31:0] io_dataOut_4_addr,
  output [6:0]  io_dataOut_4_idx,
  output        io_dataOut_4_trap,
                io_dataOut_4_isControlFlow,
                io_dataOut_4_isBranch,
                io_dataOut_4_isVector,
                io_dataOut_4_linkOk,
                io_dataOut_4_isEcall,
                io_dataOut_4_isMpause,
  output [31:0] io_dataOut_5_addr,
  output [6:0]  io_dataOut_5_idx,
  output        io_dataOut_5_trap,
                io_dataOut_5_isControlFlow,
                io_dataOut_5_isBranch,
                io_dataOut_5_isVector,
                io_dataOut_5_linkOk,
                io_dataOut_5_isEcall,
                io_dataOut_5_isMpause,
  output [31:0] io_dataOut_6_addr,
  output [6:0]  io_dataOut_6_idx,
  output        io_dataOut_6_trap,
                io_dataOut_6_isControlFlow,
                io_dataOut_6_isBranch,
                io_dataOut_6_isVector,
                io_dataOut_6_linkOk,
                io_dataOut_6_isEcall,
                io_dataOut_6_isMpause,
  output [31:0] io_dataOut_7_addr,
  output [6:0]  io_dataOut_7_idx,
  output        io_dataOut_7_trap,
                io_dataOut_7_isControlFlow,
                io_dataOut_7_isBranch,
                io_dataOut_7_isVector,
                io_dataOut_7_linkOk,
                io_dataOut_7_isEcall,
                io_dataOut_7_isMpause,
  input  [3:0]  io_deqReady,
  input         io_flush
);

  reg  [31:0]  buffer_0_addr;
  reg  [6:0]   buffer_0_idx;
  reg          buffer_0_trap;
  reg          buffer_0_isControlFlow;
  reg          buffer_0_isBranch;
  reg          buffer_0_isVector;
  reg          buffer_0_linkOk;
  reg          buffer_0_isEcall;
  reg          buffer_0_isMpause;
  reg  [31:0]  buffer_1_addr;
  reg  [6:0]   buffer_1_idx;
  reg          buffer_1_trap;
  reg          buffer_1_isControlFlow;
  reg          buffer_1_isBranch;
  reg          buffer_1_isVector;
  reg          buffer_1_linkOk;
  reg          buffer_1_isEcall;
  reg          buffer_1_isMpause;
  reg  [31:0]  buffer_2_addr;
  reg  [6:0]   buffer_2_idx;
  reg          buffer_2_trap;
  reg          buffer_2_isControlFlow;
  reg          buffer_2_isBranch;
  reg          buffer_2_isVector;
  reg          buffer_2_linkOk;
  reg          buffer_2_isEcall;
  reg          buffer_2_isMpause;
  reg  [31:0]  buffer_3_addr;
  reg  [6:0]   buffer_3_idx;
  reg          buffer_3_trap;
  reg          buffer_3_isControlFlow;
  reg          buffer_3_isBranch;
  reg          buffer_3_isVector;
  reg          buffer_3_linkOk;
  reg          buffer_3_isEcall;
  reg          buffer_3_isMpause;
  reg  [31:0]  buffer_4_addr;
  reg  [6:0]   buffer_4_idx;
  reg          buffer_4_trap;
  reg          buffer_4_isControlFlow;
  reg          buffer_4_isBranch;
  reg          buffer_4_isVector;
  reg          buffer_4_linkOk;
  reg          buffer_4_isEcall;
  reg          buffer_4_isMpause;
  reg  [31:0]  buffer_5_addr;
  reg  [6:0]   buffer_5_idx;
  reg          buffer_5_trap;
  reg          buffer_5_isControlFlow;
  reg          buffer_5_isBranch;
  reg          buffer_5_isVector;
  reg          buffer_5_linkOk;
  reg          buffer_5_isEcall;
  reg          buffer_5_isMpause;
  reg  [31:0]  buffer_6_addr;
  reg  [6:0]   buffer_6_idx;
  reg          buffer_6_trap;
  reg          buffer_6_isControlFlow;
  reg          buffer_6_isBranch;
  reg          buffer_6_isVector;
  reg          buffer_6_linkOk;
  reg          buffer_6_isEcall;
  reg          buffer_6_isMpause;
  reg  [31:0]  buffer_7_addr;
  reg  [6:0]   buffer_7_idx;
  reg          buffer_7_trap;
  reg          buffer_7_isControlFlow;
  reg          buffer_7_isBranch;
  reg          buffer_7_isVector;
  reg          buffer_7_linkOk;
  reg          buffer_7_isEcall;
  reg          buffer_7_isMpause;
  reg  [2:0]   enqPtr;
  reg  [2:0]   deqPtr;
  reg  [3:0]   nEnqueued;
  wire [8:0]   _outputBufferView_rotated_T_9 = {6'h0, deqPtr} * 9'h2E;
  wire [367:0] _outputBufferView_rotated_T_22 =
    _outputBufferView_rotated_T_9[0]
      ? {buffer_0_isMpause,
         buffer_7_addr,
         buffer_7_idx,
         buffer_7_trap,
         buffer_7_isControlFlow,
         buffer_7_isBranch,
         buffer_7_isVector,
         buffer_7_linkOk,
         buffer_7_isEcall,
         buffer_7_isMpause,
         buffer_6_addr,
         buffer_6_idx,
         buffer_6_trap,
         buffer_6_isControlFlow,
         buffer_6_isBranch,
         buffer_6_isVector,
         buffer_6_linkOk,
         buffer_6_isEcall,
         buffer_6_isMpause,
         buffer_5_addr,
         buffer_5_idx,
         buffer_5_trap,
         buffer_5_isControlFlow,
         buffer_5_isBranch,
         buffer_5_isVector,
         buffer_5_linkOk,
         buffer_5_isEcall,
         buffer_5_isMpause,
         buffer_4_addr,
         buffer_4_idx,
         buffer_4_trap,
         buffer_4_isControlFlow,
         buffer_4_isBranch,
         buffer_4_isVector,
         buffer_4_linkOk,
         buffer_4_isEcall,
         buffer_4_isMpause,
         buffer_3_addr,
         buffer_3_idx,
         buffer_3_trap,
         buffer_3_isControlFlow,
         buffer_3_isBranch,
         buffer_3_isVector,
         buffer_3_linkOk,
         buffer_3_isEcall,
         buffer_3_isMpause,
         buffer_2_addr,
         buffer_2_idx,
         buffer_2_trap,
         buffer_2_isControlFlow,
         buffer_2_isBranch,
         buffer_2_isVector,
         buffer_2_linkOk,
         buffer_2_isEcall,
         buffer_2_isMpause,
         buffer_1_addr,
         buffer_1_idx,
         buffer_1_trap,
         buffer_1_isControlFlow,
         buffer_1_isBranch,
         buffer_1_isVector,
         buffer_1_linkOk,
         buffer_1_isEcall,
         buffer_1_isMpause,
         buffer_0_addr,
         buffer_0_idx,
         buffer_0_trap,
         buffer_0_isControlFlow,
         buffer_0_isBranch,
         buffer_0_isVector,
         buffer_0_linkOk,
         buffer_0_isEcall}
      : {buffer_7_addr,
         buffer_7_idx,
         buffer_7_trap,
         buffer_7_isControlFlow,
         buffer_7_isBranch,
         buffer_7_isVector,
         buffer_7_linkOk,
         buffer_7_isEcall,
         buffer_7_isMpause,
         buffer_6_addr,
         buffer_6_idx,
         buffer_6_trap,
         buffer_6_isControlFlow,
         buffer_6_isBranch,
         buffer_6_isVector,
         buffer_6_linkOk,
         buffer_6_isEcall,
         buffer_6_isMpause,
         buffer_5_addr,
         buffer_5_idx,
         buffer_5_trap,
         buffer_5_isControlFlow,
         buffer_5_isBranch,
         buffer_5_isVector,
         buffer_5_linkOk,
         buffer_5_isEcall,
         buffer_5_isMpause,
         buffer_4_addr,
         buffer_4_idx,
         buffer_4_trap,
         buffer_4_isControlFlow,
         buffer_4_isBranch,
         buffer_4_isVector,
         buffer_4_linkOk,
         buffer_4_isEcall,
         buffer_4_isMpause,
         buffer_3_addr,
         buffer_3_idx,
         buffer_3_trap,
         buffer_3_isControlFlow,
         buffer_3_isBranch,
         buffer_3_isVector,
         buffer_3_linkOk,
         buffer_3_isEcall,
         buffer_3_isMpause,
         buffer_2_addr,
         buffer_2_idx,
         buffer_2_trap,
         buffer_2_isControlFlow,
         buffer_2_isBranch,
         buffer_2_isVector,
         buffer_2_linkOk,
         buffer_2_isEcall,
         buffer_2_isMpause,
         buffer_1_addr,
         buffer_1_idx,
         buffer_1_trap,
         buffer_1_isControlFlow,
         buffer_1_isBranch,
         buffer_1_isVector,
         buffer_1_linkOk,
         buffer_1_isEcall,
         buffer_1_isMpause,
         buffer_0_addr,
         buffer_0_idx,
         buffer_0_trap,
         buffer_0_isControlFlow,
         buffer_0_isBranch,
         buffer_0_isVector,
         buffer_0_linkOk,
         buffer_0_isEcall,
         buffer_0_isMpause};
  wire [367:0] _outputBufferView_rotated_T_26 =
    _outputBufferView_rotated_T_9[1]
      ? {_outputBufferView_rotated_T_22[1:0], _outputBufferView_rotated_T_22[367:2]}
      : _outputBufferView_rotated_T_22;
  wire [367:0] _outputBufferView_rotated_T_30 =
    _outputBufferView_rotated_T_9[2]
      ? {_outputBufferView_rotated_T_26[3:0], _outputBufferView_rotated_T_26[367:4]}
      : _outputBufferView_rotated_T_26;
  wire [367:0] _outputBufferView_rotated_T_34 =
    _outputBufferView_rotated_T_9[3]
      ? {_outputBufferView_rotated_T_30[7:0], _outputBufferView_rotated_T_30[367:8]}
      : _outputBufferView_rotated_T_30;
  wire [367:0] _outputBufferView_rotated_T_38 =
    _outputBufferView_rotated_T_9[4]
      ? {_outputBufferView_rotated_T_34[15:0], _outputBufferView_rotated_T_34[367:16]}
      : _outputBufferView_rotated_T_34;
  wire [367:0] _outputBufferView_rotated_T_42 =
    _outputBufferView_rotated_T_9[5]
      ? {_outputBufferView_rotated_T_38[31:0], _outputBufferView_rotated_T_38[367:32]}
      : _outputBufferView_rotated_T_38;
  wire [367:0] _outputBufferView_rotated_T_46 =
    _outputBufferView_rotated_T_9[6]
      ? {_outputBufferView_rotated_T_42[63:0], _outputBufferView_rotated_T_42[367:64]}
      : _outputBufferView_rotated_T_42;
  wire [367:0] _outputBufferView_rotated_T_50 =
    _outputBufferView_rotated_T_9[7]
      ? {_outputBufferView_rotated_T_46[127:0], _outputBufferView_rotated_T_46[367:128]}
      : _outputBufferView_rotated_T_46;
  wire [367:0] outputBufferView_rotated =
    _outputBufferView_rotated_T_9[8]
      ? {_outputBufferView_rotated_T_50[255:0], _outputBufferView_rotated_T_50[367:256]}
      : _outputBufferView_rotated_T_50;
  wire         expandedInput_2_ret_valid = io_enqValid > 4'h2;
  wire         expandedInput_4_ret_valid = io_enqValid > 4'h4;
  wire         expandedInput_5_ret_valid = io_enqValid > 4'h5;
  wire         expandedInput_6_ret_valid = io_enqValid > 4'h6;
  wire [8:0]   _rotatedInput_rotated_T_17 = {6'h0, enqPtr} * 9'h2F;
  wire [375:0] _rotatedInput_rotated_T_30 =
    _rotatedInput_rotated_T_17[0]
      ? {io_enqData_7_addr,
         io_enqData_7_idx,
         io_enqData_7_trap,
         io_enqData_7_isControlFlow,
         io_enqData_7_isBranch,
         io_enqData_7_isVector,
         io_enqData_7_linkOk,
         io_enqData_7_isEcall,
         io_enqData_7_isMpause,
         expandedInput_6_ret_valid,
         io_enqData_6_addr,
         io_enqData_6_idx,
         io_enqData_6_trap,
         io_enqData_6_isControlFlow,
         io_enqData_6_isBranch,
         io_enqData_6_isVector,
         io_enqData_6_linkOk,
         io_enqData_6_isEcall,
         io_enqData_6_isMpause,
         expandedInput_5_ret_valid,
         io_enqData_5_addr,
         io_enqData_5_idx,
         io_enqData_5_trap,
         io_enqData_5_isControlFlow,
         io_enqData_5_isBranch,
         io_enqData_5_isVector,
         io_enqData_5_linkOk,
         io_enqData_5_isEcall,
         io_enqData_5_isMpause,
         expandedInput_4_ret_valid,
         io_enqData_4_addr,
         io_enqData_4_idx,
         io_enqData_4_trap,
         io_enqData_4_isControlFlow,
         io_enqData_4_isBranch,
         io_enqData_4_isVector,
         io_enqData_4_linkOk,
         io_enqData_4_isEcall,
         io_enqData_4_isMpause,
         |(io_enqValid[3:2]),
         io_enqData_3_addr,
         io_enqData_3_idx,
         io_enqData_3_trap,
         io_enqData_3_isControlFlow,
         io_enqData_3_isBranch,
         io_enqData_3_isVector,
         io_enqData_3_linkOk,
         io_enqData_3_isEcall,
         io_enqData_3_isMpause,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_idx,
         io_enqData_2_trap,
         io_enqData_2_isControlFlow,
         io_enqData_2_isBranch,
         io_enqData_2_isVector,
         io_enqData_2_linkOk,
         io_enqData_2_isEcall,
         io_enqData_2_isMpause,
         |(io_enqValid[3:1]),
         io_enqData_1_addr,
         io_enqData_1_idx,
         io_enqData_1_trap,
         io_enqData_1_isControlFlow,
         io_enqData_1_isBranch,
         io_enqData_1_isVector,
         io_enqData_1_linkOk,
         io_enqData_1_isEcall,
         io_enqData_1_isMpause,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_idx,
         io_enqData_0_trap,
         io_enqData_0_isControlFlow,
         io_enqData_0_isBranch,
         io_enqData_0_isVector,
         io_enqData_0_linkOk,
         io_enqData_0_isEcall,
         io_enqData_0_isMpause,
         io_enqValid[3]}
      : {io_enqValid[3],
         io_enqData_7_addr,
         io_enqData_7_idx,
         io_enqData_7_trap,
         io_enqData_7_isControlFlow,
         io_enqData_7_isBranch,
         io_enqData_7_isVector,
         io_enqData_7_linkOk,
         io_enqData_7_isEcall,
         io_enqData_7_isMpause,
         expandedInput_6_ret_valid,
         io_enqData_6_addr,
         io_enqData_6_idx,
         io_enqData_6_trap,
         io_enqData_6_isControlFlow,
         io_enqData_6_isBranch,
         io_enqData_6_isVector,
         io_enqData_6_linkOk,
         io_enqData_6_isEcall,
         io_enqData_6_isMpause,
         expandedInput_5_ret_valid,
         io_enqData_5_addr,
         io_enqData_5_idx,
         io_enqData_5_trap,
         io_enqData_5_isControlFlow,
         io_enqData_5_isBranch,
         io_enqData_5_isVector,
         io_enqData_5_linkOk,
         io_enqData_5_isEcall,
         io_enqData_5_isMpause,
         expandedInput_4_ret_valid,
         io_enqData_4_addr,
         io_enqData_4_idx,
         io_enqData_4_trap,
         io_enqData_4_isControlFlow,
         io_enqData_4_isBranch,
         io_enqData_4_isVector,
         io_enqData_4_linkOk,
         io_enqData_4_isEcall,
         io_enqData_4_isMpause,
         |(io_enqValid[3:2]),
         io_enqData_3_addr,
         io_enqData_3_idx,
         io_enqData_3_trap,
         io_enqData_3_isControlFlow,
         io_enqData_3_isBranch,
         io_enqData_3_isVector,
         io_enqData_3_linkOk,
         io_enqData_3_isEcall,
         io_enqData_3_isMpause,
         expandedInput_2_ret_valid,
         io_enqData_2_addr,
         io_enqData_2_idx,
         io_enqData_2_trap,
         io_enqData_2_isControlFlow,
         io_enqData_2_isBranch,
         io_enqData_2_isVector,
         io_enqData_2_linkOk,
         io_enqData_2_isEcall,
         io_enqData_2_isMpause,
         |(io_enqValid[3:1]),
         io_enqData_1_addr,
         io_enqData_1_idx,
         io_enqData_1_trap,
         io_enqData_1_isControlFlow,
         io_enqData_1_isBranch,
         io_enqData_1_isVector,
         io_enqData_1_linkOk,
         io_enqData_1_isEcall,
         io_enqData_1_isMpause,
         |io_enqValid,
         io_enqData_0_addr,
         io_enqData_0_idx,
         io_enqData_0_trap,
         io_enqData_0_isControlFlow,
         io_enqData_0_isBranch,
         io_enqData_0_isVector,
         io_enqData_0_linkOk,
         io_enqData_0_isEcall,
         io_enqData_0_isMpause};
  wire [375:0] _rotatedInput_rotated_T_34 =
    _rotatedInput_rotated_T_17[1]
      ? {_rotatedInput_rotated_T_30[373:0], _rotatedInput_rotated_T_30[375:374]}
      : _rotatedInput_rotated_T_30;
  wire [375:0] _rotatedInput_rotated_T_38 =
    _rotatedInput_rotated_T_17[2]
      ? {_rotatedInput_rotated_T_34[371:0], _rotatedInput_rotated_T_34[375:372]}
      : _rotatedInput_rotated_T_34;
  wire [375:0] _rotatedInput_rotated_T_42 =
    _rotatedInput_rotated_T_17[3]
      ? {_rotatedInput_rotated_T_38[367:0], _rotatedInput_rotated_T_38[375:368]}
      : _rotatedInput_rotated_T_38;
  wire [375:0] _rotatedInput_rotated_T_46 =
    _rotatedInput_rotated_T_17[4]
      ? {_rotatedInput_rotated_T_42[359:0], _rotatedInput_rotated_T_42[375:360]}
      : _rotatedInput_rotated_T_42;
  wire [375:0] _rotatedInput_rotated_T_50 =
    _rotatedInput_rotated_T_17[5]
      ? {_rotatedInput_rotated_T_46[343:0], _rotatedInput_rotated_T_46[375:344]}
      : _rotatedInput_rotated_T_46;
  wire [375:0] _rotatedInput_rotated_T_54 =
    _rotatedInput_rotated_T_17[6]
      ? {_rotatedInput_rotated_T_50[311:0], _rotatedInput_rotated_T_50[375:312]}
      : _rotatedInput_rotated_T_50;
  wire [375:0] _rotatedInput_rotated_T_58 =
    _rotatedInput_rotated_T_17[7]
      ? {_rotatedInput_rotated_T_54[247:0], _rotatedInput_rotated_T_54[375:248]}
      : _rotatedInput_rotated_T_54;
  wire [375:0] rotatedInput_rotated =
    _rotatedInput_rotated_T_17[8]
      ? {_rotatedInput_rotated_T_58[119:0], _rotatedInput_rotated_T_58[375:120]}
      : _rotatedInput_rotated_T_58;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      buffer_0_addr <= 32'h0;
      buffer_0_idx <= 7'h0;
      buffer_0_trap <= 1'h0;
      buffer_0_isControlFlow <= 1'h0;
      buffer_0_isBranch <= 1'h0;
      buffer_0_isVector <= 1'h0;
      buffer_0_linkOk <= 1'h0;
      buffer_0_isEcall <= 1'h0;
      buffer_0_isMpause <= 1'h0;
      buffer_1_addr <= 32'h0;
      buffer_1_idx <= 7'h0;
      buffer_1_trap <= 1'h0;
      buffer_1_isControlFlow <= 1'h0;
      buffer_1_isBranch <= 1'h0;
      buffer_1_isVector <= 1'h0;
      buffer_1_linkOk <= 1'h0;
      buffer_1_isEcall <= 1'h0;
      buffer_1_isMpause <= 1'h0;
      buffer_2_addr <= 32'h0;
      buffer_2_idx <= 7'h0;
      buffer_2_trap <= 1'h0;
      buffer_2_isControlFlow <= 1'h0;
      buffer_2_isBranch <= 1'h0;
      buffer_2_isVector <= 1'h0;
      buffer_2_linkOk <= 1'h0;
      buffer_2_isEcall <= 1'h0;
      buffer_2_isMpause <= 1'h0;
      buffer_3_addr <= 32'h0;
      buffer_3_idx <= 7'h0;
      buffer_3_trap <= 1'h0;
      buffer_3_isControlFlow <= 1'h0;
      buffer_3_isBranch <= 1'h0;
      buffer_3_isVector <= 1'h0;
      buffer_3_linkOk <= 1'h0;
      buffer_3_isEcall <= 1'h0;
      buffer_3_isMpause <= 1'h0;
      buffer_4_addr <= 32'h0;
      buffer_4_idx <= 7'h0;
      buffer_4_trap <= 1'h0;
      buffer_4_isControlFlow <= 1'h0;
      buffer_4_isBranch <= 1'h0;
      buffer_4_isVector <= 1'h0;
      buffer_4_linkOk <= 1'h0;
      buffer_4_isEcall <= 1'h0;
      buffer_4_isMpause <= 1'h0;
      buffer_5_addr <= 32'h0;
      buffer_5_idx <= 7'h0;
      buffer_5_trap <= 1'h0;
      buffer_5_isControlFlow <= 1'h0;
      buffer_5_isBranch <= 1'h0;
      buffer_5_isVector <= 1'h0;
      buffer_5_linkOk <= 1'h0;
      buffer_5_isEcall <= 1'h0;
      buffer_5_isMpause <= 1'h0;
      buffer_6_addr <= 32'h0;
      buffer_6_idx <= 7'h0;
      buffer_6_trap <= 1'h0;
      buffer_6_isControlFlow <= 1'h0;
      buffer_6_isBranch <= 1'h0;
      buffer_6_isVector <= 1'h0;
      buffer_6_linkOk <= 1'h0;
      buffer_6_isEcall <= 1'h0;
      buffer_6_isMpause <= 1'h0;
      buffer_7_addr <= 32'h0;
      buffer_7_idx <= 7'h0;
      buffer_7_trap <= 1'h0;
      buffer_7_isControlFlow <= 1'h0;
      buffer_7_isBranch <= 1'h0;
      buffer_7_isVector <= 1'h0;
      buffer_7_linkOk <= 1'h0;
      buffer_7_isEcall <= 1'h0;
      buffer_7_isMpause <= 1'h0;
      enqPtr <= 3'h0;
      deqPtr <= 3'h0;
      nEnqueued <= 4'h0;
    end
    else begin
      if (rotatedInput_rotated[46]) begin
        buffer_0_addr <= rotatedInput_rotated[45:14];
        buffer_0_idx <= rotatedInput_rotated[13:7];
        buffer_0_trap <= rotatedInput_rotated[6];
        buffer_0_isControlFlow <= rotatedInput_rotated[5];
        buffer_0_isBranch <= rotatedInput_rotated[4];
        buffer_0_isVector <= rotatedInput_rotated[3];
        buffer_0_linkOk <= rotatedInput_rotated[2];
        buffer_0_isEcall <= rotatedInput_rotated[1];
        buffer_0_isMpause <= rotatedInput_rotated[0];
      end
      if (rotatedInput_rotated[93]) begin
        buffer_1_addr <= rotatedInput_rotated[92:61];
        buffer_1_idx <= rotatedInput_rotated[60:54];
        buffer_1_trap <= rotatedInput_rotated[53];
        buffer_1_isControlFlow <= rotatedInput_rotated[52];
        buffer_1_isBranch <= rotatedInput_rotated[51];
        buffer_1_isVector <= rotatedInput_rotated[50];
        buffer_1_linkOk <= rotatedInput_rotated[49];
        buffer_1_isEcall <= rotatedInput_rotated[48];
        buffer_1_isMpause <= rotatedInput_rotated[47];
      end
      if (rotatedInput_rotated[140]) begin
        buffer_2_addr <= rotatedInput_rotated[139:108];
        buffer_2_idx <= rotatedInput_rotated[107:101];
        buffer_2_trap <= rotatedInput_rotated[100];
        buffer_2_isControlFlow <= rotatedInput_rotated[99];
        buffer_2_isBranch <= rotatedInput_rotated[98];
        buffer_2_isVector <= rotatedInput_rotated[97];
        buffer_2_linkOk <= rotatedInput_rotated[96];
        buffer_2_isEcall <= rotatedInput_rotated[95];
        buffer_2_isMpause <= rotatedInput_rotated[94];
      end
      if (rotatedInput_rotated[187]) begin
        buffer_3_addr <= rotatedInput_rotated[186:155];
        buffer_3_idx <= rotatedInput_rotated[154:148];
        buffer_3_trap <= rotatedInput_rotated[147];
        buffer_3_isControlFlow <= rotatedInput_rotated[146];
        buffer_3_isBranch <= rotatedInput_rotated[145];
        buffer_3_isVector <= rotatedInput_rotated[144];
        buffer_3_linkOk <= rotatedInput_rotated[143];
        buffer_3_isEcall <= rotatedInput_rotated[142];
        buffer_3_isMpause <= rotatedInput_rotated[141];
      end
      if (rotatedInput_rotated[234]) begin
        buffer_4_addr <= rotatedInput_rotated[233:202];
        buffer_4_idx <= rotatedInput_rotated[201:195];
        buffer_4_trap <= rotatedInput_rotated[194];
        buffer_4_isControlFlow <= rotatedInput_rotated[193];
        buffer_4_isBranch <= rotatedInput_rotated[192];
        buffer_4_isVector <= rotatedInput_rotated[191];
        buffer_4_linkOk <= rotatedInput_rotated[190];
        buffer_4_isEcall <= rotatedInput_rotated[189];
        buffer_4_isMpause <= rotatedInput_rotated[188];
      end
      if (rotatedInput_rotated[281]) begin
        buffer_5_addr <= rotatedInput_rotated[280:249];
        buffer_5_idx <= rotatedInput_rotated[248:242];
        buffer_5_trap <= rotatedInput_rotated[241];
        buffer_5_isControlFlow <= rotatedInput_rotated[240];
        buffer_5_isBranch <= rotatedInput_rotated[239];
        buffer_5_isVector <= rotatedInput_rotated[238];
        buffer_5_linkOk <= rotatedInput_rotated[237];
        buffer_5_isEcall <= rotatedInput_rotated[236];
        buffer_5_isMpause <= rotatedInput_rotated[235];
      end
      if (rotatedInput_rotated[328]) begin
        buffer_6_addr <= rotatedInput_rotated[327:296];
        buffer_6_idx <= rotatedInput_rotated[295:289];
        buffer_6_trap <= rotatedInput_rotated[288];
        buffer_6_isControlFlow <= rotatedInput_rotated[287];
        buffer_6_isBranch <= rotatedInput_rotated[286];
        buffer_6_isVector <= rotatedInput_rotated[285];
        buffer_6_linkOk <= rotatedInput_rotated[284];
        buffer_6_isEcall <= rotatedInput_rotated[283];
        buffer_6_isMpause <= rotatedInput_rotated[282];
      end
      if (rotatedInput_rotated[375]) begin
        buffer_7_addr <= rotatedInput_rotated[374:343];
        buffer_7_idx <= rotatedInput_rotated[342:336];
        buffer_7_trap <= rotatedInput_rotated[335];
        buffer_7_isControlFlow <= rotatedInput_rotated[334];
        buffer_7_isBranch <= rotatedInput_rotated[333];
        buffer_7_isVector <= rotatedInput_rotated[332];
        buffer_7_linkOk <= rotatedInput_rotated[331];
        buffer_7_isEcall <= rotatedInput_rotated[330];
        buffer_7_isMpause <= rotatedInput_rotated[329];
      end
      enqPtr <= io_flush ? 3'h0 : enqPtr + io_enqValid[2:0];
      deqPtr <= io_flush ? 3'h0 : deqPtr + io_deqReady[2:0];
      nEnqueued <= io_flush ? 4'h0 : nEnqueued + io_enqValid - io_deqReady;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:11];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'hC; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        buffer_0_addr = _RANDOM[4'h0];
        buffer_0_idx = _RANDOM[4'h1][6:0];
        buffer_0_trap = _RANDOM[4'h1][7];
        buffer_0_isControlFlow = _RANDOM[4'h1][8];
        buffer_0_isBranch = _RANDOM[4'h1][9];
        buffer_0_isVector = _RANDOM[4'h1][10];
        buffer_0_linkOk = _RANDOM[4'h1][11];
        buffer_0_isEcall = _RANDOM[4'h1][12];
        buffer_0_isMpause = _RANDOM[4'h1][13];
        buffer_1_addr = {_RANDOM[4'h1][31:14], _RANDOM[4'h2][13:0]};
        buffer_1_idx = _RANDOM[4'h2][20:14];
        buffer_1_trap = _RANDOM[4'h2][21];
        buffer_1_isControlFlow = _RANDOM[4'h2][22];
        buffer_1_isBranch = _RANDOM[4'h2][23];
        buffer_1_isVector = _RANDOM[4'h2][24];
        buffer_1_linkOk = _RANDOM[4'h2][25];
        buffer_1_isEcall = _RANDOM[4'h2][26];
        buffer_1_isMpause = _RANDOM[4'h2][27];
        buffer_2_addr = {_RANDOM[4'h2][31:28], _RANDOM[4'h3][27:0]};
        buffer_2_idx = {_RANDOM[4'h3][31:28], _RANDOM[4'h4][2:0]};
        buffer_2_trap = _RANDOM[4'h4][3];
        buffer_2_isControlFlow = _RANDOM[4'h4][4];
        buffer_2_isBranch = _RANDOM[4'h4][5];
        buffer_2_isVector = _RANDOM[4'h4][6];
        buffer_2_linkOk = _RANDOM[4'h4][7];
        buffer_2_isEcall = _RANDOM[4'h4][8];
        buffer_2_isMpause = _RANDOM[4'h4][9];
        buffer_3_addr = {_RANDOM[4'h4][31:10], _RANDOM[4'h5][9:0]};
        buffer_3_idx = _RANDOM[4'h5][16:10];
        buffer_3_trap = _RANDOM[4'h5][17];
        buffer_3_isControlFlow = _RANDOM[4'h5][18];
        buffer_3_isBranch = _RANDOM[4'h5][19];
        buffer_3_isVector = _RANDOM[4'h5][20];
        buffer_3_linkOk = _RANDOM[4'h5][21];
        buffer_3_isEcall = _RANDOM[4'h5][22];
        buffer_3_isMpause = _RANDOM[4'h5][23];
        buffer_4_addr = {_RANDOM[4'h5][31:24], _RANDOM[4'h6][23:0]};
        buffer_4_idx = _RANDOM[4'h6][30:24];
        buffer_4_trap = _RANDOM[4'h6][31];
        buffer_4_isControlFlow = _RANDOM[4'h7][0];
        buffer_4_isBranch = _RANDOM[4'h7][1];
        buffer_4_isVector = _RANDOM[4'h7][2];
        buffer_4_linkOk = _RANDOM[4'h7][3];
        buffer_4_isEcall = _RANDOM[4'h7][4];
        buffer_4_isMpause = _RANDOM[4'h7][5];
        buffer_5_addr = {_RANDOM[4'h7][31:6], _RANDOM[4'h8][5:0]};
        buffer_5_idx = _RANDOM[4'h8][12:6];
        buffer_5_trap = _RANDOM[4'h8][13];
        buffer_5_isControlFlow = _RANDOM[4'h8][14];
        buffer_5_isBranch = _RANDOM[4'h8][15];
        buffer_5_isVector = _RANDOM[4'h8][16];
        buffer_5_linkOk = _RANDOM[4'h8][17];
        buffer_5_isEcall = _RANDOM[4'h8][18];
        buffer_5_isMpause = _RANDOM[4'h8][19];
        buffer_6_addr = {_RANDOM[4'h8][31:20], _RANDOM[4'h9][19:0]};
        buffer_6_idx = _RANDOM[4'h9][26:20];
        buffer_6_trap = _RANDOM[4'h9][27];
        buffer_6_isControlFlow = _RANDOM[4'h9][28];
        buffer_6_isBranch = _RANDOM[4'h9][29];
        buffer_6_isVector = _RANDOM[4'h9][30];
        buffer_6_linkOk = _RANDOM[4'h9][31];
        buffer_6_isEcall = _RANDOM[4'hA][0];
        buffer_6_isMpause = _RANDOM[4'hA][1];
        buffer_7_addr = {_RANDOM[4'hA][31:2], _RANDOM[4'hB][1:0]};
        buffer_7_idx = _RANDOM[4'hB][8:2];
        buffer_7_trap = _RANDOM[4'hB][9];
        buffer_7_isControlFlow = _RANDOM[4'hB][10];
        buffer_7_isBranch = _RANDOM[4'hB][11];
        buffer_7_isVector = _RANDOM[4'hB][12];
        buffer_7_linkOk = _RANDOM[4'hB][13];
        buffer_7_isEcall = _RANDOM[4'hB][14];
        buffer_7_isMpause = _RANDOM[4'hB][15];
        enqPtr = _RANDOM[4'hB][18:16];
        deqPtr = _RANDOM[4'hB][21:19];
        nEnqueued = _RANDOM[4'hB][25:22];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        buffer_0_addr = 32'h0;
        buffer_0_idx = 7'h0;
        buffer_0_trap = 1'h0;
        buffer_0_isControlFlow = 1'h0;
        buffer_0_isBranch = 1'h0;
        buffer_0_isVector = 1'h0;
        buffer_0_linkOk = 1'h0;
        buffer_0_isEcall = 1'h0;
        buffer_0_isMpause = 1'h0;
        buffer_1_addr = 32'h0;
        buffer_1_idx = 7'h0;
        buffer_1_trap = 1'h0;
        buffer_1_isControlFlow = 1'h0;
        buffer_1_isBranch = 1'h0;
        buffer_1_isVector = 1'h0;
        buffer_1_linkOk = 1'h0;
        buffer_1_isEcall = 1'h0;
        buffer_1_isMpause = 1'h0;
        buffer_2_addr = 32'h0;
        buffer_2_idx = 7'h0;
        buffer_2_trap = 1'h0;
        buffer_2_isControlFlow = 1'h0;
        buffer_2_isBranch = 1'h0;
        buffer_2_isVector = 1'h0;
        buffer_2_linkOk = 1'h0;
        buffer_2_isEcall = 1'h0;
        buffer_2_isMpause = 1'h0;
        buffer_3_addr = 32'h0;
        buffer_3_idx = 7'h0;
        buffer_3_trap = 1'h0;
        buffer_3_isControlFlow = 1'h0;
        buffer_3_isBranch = 1'h0;
        buffer_3_isVector = 1'h0;
        buffer_3_linkOk = 1'h0;
        buffer_3_isEcall = 1'h0;
        buffer_3_isMpause = 1'h0;
        buffer_4_addr = 32'h0;
        buffer_4_idx = 7'h0;
        buffer_4_trap = 1'h0;
        buffer_4_isControlFlow = 1'h0;
        buffer_4_isBranch = 1'h0;
        buffer_4_isVector = 1'h0;
        buffer_4_linkOk = 1'h0;
        buffer_4_isEcall = 1'h0;
        buffer_4_isMpause = 1'h0;
        buffer_5_addr = 32'h0;
        buffer_5_idx = 7'h0;
        buffer_5_trap = 1'h0;
        buffer_5_isControlFlow = 1'h0;
        buffer_5_isBranch = 1'h0;
        buffer_5_isVector = 1'h0;
        buffer_5_linkOk = 1'h0;
        buffer_5_isEcall = 1'h0;
        buffer_5_isMpause = 1'h0;
        buffer_6_addr = 32'h0;
        buffer_6_idx = 7'h0;
        buffer_6_trap = 1'h0;
        buffer_6_isControlFlow = 1'h0;
        buffer_6_isBranch = 1'h0;
        buffer_6_isVector = 1'h0;
        buffer_6_linkOk = 1'h0;
        buffer_6_isEcall = 1'h0;
        buffer_6_isMpause = 1'h0;
        buffer_7_addr = 32'h0;
        buffer_7_idx = 7'h0;
        buffer_7_trap = 1'h0;
        buffer_7_isControlFlow = 1'h0;
        buffer_7_isBranch = 1'h0;
        buffer_7_isVector = 1'h0;
        buffer_7_linkOk = 1'h0;
        buffer_7_isEcall = 1'h0;
        buffer_7_isMpause = 1'h0;
        enqPtr = 3'h0;
        deqPtr = 3'h0;
        nEnqueued = 4'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_nEnqueued = nEnqueued;
  assign io_nSpace = 4'h8 - nEnqueued;
  assign io_dataOut_0_addr = outputBufferView_rotated[45:14];
  assign io_dataOut_0_idx = outputBufferView_rotated[13:7];
  assign io_dataOut_0_trap = outputBufferView_rotated[6];
  assign io_dataOut_0_isControlFlow = outputBufferView_rotated[5];
  assign io_dataOut_0_isBranch = outputBufferView_rotated[4];
  assign io_dataOut_0_isVector = outputBufferView_rotated[3];
  assign io_dataOut_0_linkOk = outputBufferView_rotated[2];
  assign io_dataOut_0_isEcall = outputBufferView_rotated[1];
  assign io_dataOut_0_isMpause = outputBufferView_rotated[0];
  assign io_dataOut_1_addr = outputBufferView_rotated[91:60];
  assign io_dataOut_1_idx = outputBufferView_rotated[59:53];
  assign io_dataOut_1_trap = outputBufferView_rotated[52];
  assign io_dataOut_1_isControlFlow = outputBufferView_rotated[51];
  assign io_dataOut_1_isBranch = outputBufferView_rotated[50];
  assign io_dataOut_1_isVector = outputBufferView_rotated[49];
  assign io_dataOut_1_linkOk = outputBufferView_rotated[48];
  assign io_dataOut_1_isEcall = outputBufferView_rotated[47];
  assign io_dataOut_1_isMpause = outputBufferView_rotated[46];
  assign io_dataOut_2_addr = outputBufferView_rotated[137:106];
  assign io_dataOut_2_idx = outputBufferView_rotated[105:99];
  assign io_dataOut_2_trap = outputBufferView_rotated[98];
  assign io_dataOut_2_isControlFlow = outputBufferView_rotated[97];
  assign io_dataOut_2_isBranch = outputBufferView_rotated[96];
  assign io_dataOut_2_isVector = outputBufferView_rotated[95];
  assign io_dataOut_2_linkOk = outputBufferView_rotated[94];
  assign io_dataOut_2_isEcall = outputBufferView_rotated[93];
  assign io_dataOut_2_isMpause = outputBufferView_rotated[92];
  assign io_dataOut_3_addr = outputBufferView_rotated[183:152];
  assign io_dataOut_3_idx = outputBufferView_rotated[151:145];
  assign io_dataOut_3_trap = outputBufferView_rotated[144];
  assign io_dataOut_3_isControlFlow = outputBufferView_rotated[143];
  assign io_dataOut_3_isBranch = outputBufferView_rotated[142];
  assign io_dataOut_3_isVector = outputBufferView_rotated[141];
  assign io_dataOut_3_linkOk = outputBufferView_rotated[140];
  assign io_dataOut_3_isEcall = outputBufferView_rotated[139];
  assign io_dataOut_3_isMpause = outputBufferView_rotated[138];
  assign io_dataOut_4_addr = outputBufferView_rotated[229:198];
  assign io_dataOut_4_idx = outputBufferView_rotated[197:191];
  assign io_dataOut_4_trap = outputBufferView_rotated[190];
  assign io_dataOut_4_isControlFlow = outputBufferView_rotated[189];
  assign io_dataOut_4_isBranch = outputBufferView_rotated[188];
  assign io_dataOut_4_isVector = outputBufferView_rotated[187];
  assign io_dataOut_4_linkOk = outputBufferView_rotated[186];
  assign io_dataOut_4_isEcall = outputBufferView_rotated[185];
  assign io_dataOut_4_isMpause = outputBufferView_rotated[184];
  assign io_dataOut_5_addr = outputBufferView_rotated[275:244];
  assign io_dataOut_5_idx = outputBufferView_rotated[243:237];
  assign io_dataOut_5_trap = outputBufferView_rotated[236];
  assign io_dataOut_5_isControlFlow = outputBufferView_rotated[235];
  assign io_dataOut_5_isBranch = outputBufferView_rotated[234];
  assign io_dataOut_5_isVector = outputBufferView_rotated[233];
  assign io_dataOut_5_linkOk = outputBufferView_rotated[232];
  assign io_dataOut_5_isEcall = outputBufferView_rotated[231];
  assign io_dataOut_5_isMpause = outputBufferView_rotated[230];
  assign io_dataOut_6_addr = outputBufferView_rotated[321:290];
  assign io_dataOut_6_idx = outputBufferView_rotated[289:283];
  assign io_dataOut_6_trap = outputBufferView_rotated[282];
  assign io_dataOut_6_isControlFlow = outputBufferView_rotated[281];
  assign io_dataOut_6_isBranch = outputBufferView_rotated[280];
  assign io_dataOut_6_isVector = outputBufferView_rotated[279];
  assign io_dataOut_6_linkOk = outputBufferView_rotated[278];
  assign io_dataOut_6_isEcall = outputBufferView_rotated[277];
  assign io_dataOut_6_isMpause = outputBufferView_rotated[276];
  assign io_dataOut_7_addr = outputBufferView_rotated[367:336];
  assign io_dataOut_7_idx = outputBufferView_rotated[335:329];
  assign io_dataOut_7_trap = outputBufferView_rotated[328];
  assign io_dataOut_7_isControlFlow = outputBufferView_rotated[327];
  assign io_dataOut_7_isBranch = outputBufferView_rotated[326];
  assign io_dataOut_7_isVector = outputBufferView_rotated[325];
  assign io_dataOut_7_linkOk = outputBufferView_rotated[324];
  assign io_dataOut_7_isEcall = outputBufferView_rotated[323];
  assign io_dataOut_7_isMpause = outputBufferView_rotated[322];
endmodule

module RetirementBuffer(
  input         clock,
                reset,
                io_inst_0_ready,
                io_inst_0_valid,
  input  [31:0] io_inst_0_bits_addr,
                io_inst_0_bits_inst,
  input         io_inst_1_ready,
                io_inst_1_valid,
  input  [31:0] io_inst_1_bits_addr,
                io_inst_1_bits_inst,
  input         io_inst_2_ready,
                io_inst_2_valid,
  input  [31:0] io_inst_2_bits_addr,
                io_inst_2_bits_inst,
  input         io_inst_3_ready,
                io_inst_3_valid,
  input  [31:0] io_inst_3_bits_addr,
                io_inst_3_bits_inst,
                io_targets_0,
                io_targets_1,
                io_targets_2,
                io_targets_3,
                io_jalrTargets_0,
                io_jalrTargets_1,
                io_jalrTargets_2,
                io_jalrTargets_3,
  input         io_jump_0,
                io_jump_1,
                io_jump_2,
                io_jump_3,
                io_branch_0,
                io_branch_1,
                io_branch_2,
                io_branch_3,
                io_storeComplete_valid,
  input  [31:0] io_storeComplete_bits,
  input         io_writeAddrScalar_0_valid,
  input  [4:0]  io_writeAddrScalar_0_addr,
  input         io_writeAddrScalar_1_valid,
  input  [4:0]  io_writeAddrScalar_1_addr,
  input         io_writeAddrScalar_2_valid,
  input  [4:0]  io_writeAddrScalar_2_addr,
  input         io_writeAddrScalar_3_valid,
  input  [4:0]  io_writeAddrScalar_3_addr,
  input         io_writeDataScalar_0_valid,
  input  [4:0]  io_writeDataScalar_0_bits_addr,
  input         io_writeDataScalar_1_valid,
  input  [4:0]  io_writeDataScalar_1_bits_addr,
  input         io_writeDataScalar_2_valid,
  input  [4:0]  io_writeDataScalar_2_bits_addr,
  input         io_writeDataScalar_3_valid,
  input  [4:0]  io_writeDataScalar_3_bits_addr,
  input         io_writeDataScalar_4_valid,
  input  [4:0]  io_writeDataScalar_4_bits_addr,
  input         io_writeDataScalar_5_valid,
  input  [4:0]  io_writeDataScalar_5_bits_addr,
  input         io_writeAddrFloat_valid,
  input  [4:0]  io_writeAddrFloat_addr,
  input         io_writeDataFloat_0_valid,
  input  [4:0]  io_writeDataFloat_0_bits_addr,
  input         io_writeDataFloat_1_valid,
  input  [4:0]  io_writeDataFloat_1_bits_addr,
  input         io_writeAddrVector_0_valid,
  input  [4:0]  io_writeAddrVector_0_addr,
  input         io_writeAddrVector_1_valid,
  input  [4:0]  io_writeAddrVector_1_addr,
  input         io_writeAddrVector_2_valid,
  input  [4:0]  io_writeAddrVector_2_addr,
  input         io_writeAddrVector_3_valid,
  input  [4:0]  io_writeAddrVector_3_addr,
  input         io_writeDataVector_0_valid,
  input  [4:0]  io_writeDataVector_0_bits_addr,
  input  [31:0] io_writeDataVector_0_bits_uop_pc,
  input         io_writeDataVector_0_bits_last_uop_valid,
                io_writeDataVector_1_valid,
  input  [4:0]  io_writeDataVector_1_bits_addr,
  input  [31:0] io_writeDataVector_1_bits_uop_pc,
  input         io_writeDataVector_1_bits_last_uop_valid,
                io_writeDataVector_2_valid,
  input  [4:0]  io_writeDataVector_2_bits_addr,
  input  [31:0] io_writeDataVector_2_bits_uop_pc,
  input         io_writeDataVector_2_bits_last_uop_valid,
                io_writeDataVector_3_valid,
  input  [4:0]  io_writeDataVector_3_bits_addr,
  input  [31:0] io_writeDataVector_3_bits_uop_pc,
  input         io_writeDataVector_3_bits_last_uop_valid,
                io_fault_valid,
  input  [31:0] io_fault_bits_mepc,
                io_fault_bits_mcause,
  input         io_fault_bits_decode,
  output [31:0] io_nSpace,
  output [3:0]  io_nRetired,
  output        io_empty,
                io_trapPending,
                io_debug_inst_0_valid,
  output [31:0] io_debug_inst_0_bits_pc,
  output [6:0]  io_debug_inst_0_bits_idx,
  output        io_debug_inst_0_bits_trap,
                io_debug_inst_1_valid,
  output [31:0] io_debug_inst_1_bits_pc,
  output [6:0]  io_debug_inst_1_bits_idx,
  output        io_debug_inst_1_bits_trap,
                io_debug_inst_2_valid,
  output [31:0] io_debug_inst_2_bits_pc,
  output [6:0]  io_debug_inst_2_bits_idx,
  output        io_debug_inst_2_bits_trap,
                io_debug_inst_3_valid,
  output [31:0] io_debug_inst_3_bits_pc,
  output [6:0]  io_debug_inst_3_bits_idx,
  output        io_debug_inst_3_bits_trap,
                io_debug_inst_4_valid,
  output [31:0] io_debug_inst_4_bits_pc,
  output [6:0]  io_debug_inst_4_bits_idx,
  output        io_debug_inst_4_bits_trap,
                io_debug_inst_5_valid,
  output [31:0] io_debug_inst_5_bits_pc,
  output [6:0]  io_debug_inst_5_bits_idx,
  output        io_debug_inst_5_bits_trap,
                io_debug_inst_6_valid,
  output [31:0] io_debug_inst_6_bits_pc,
  output [6:0]  io_debug_inst_6_bits_idx,
  output        io_debug_inst_6_bits_trap,
                io_debug_inst_7_valid,
  output [31:0] io_debug_inst_7_bits_pc,
  output [6:0]  io_debug_inst_7_bits_idx,
  output        io_debug_inst_7_bits_trap
);

  wire [3:0]  _instBuffer_io_nEnqueued;
  wire [3:0]  _instBuffer_io_nSpace;
  wire [31:0] _instBuffer_io_dataOut_0_addr;
  wire [6:0]  _instBuffer_io_dataOut_0_idx;
  wire        _instBuffer_io_dataOut_0_trap;
  wire        _instBuffer_io_dataOut_0_isControlFlow;
  wire        _instBuffer_io_dataOut_0_isBranch;
  wire        _instBuffer_io_dataOut_0_isVector;
  wire        _instBuffer_io_dataOut_0_isEcall;
  wire        _instBuffer_io_dataOut_0_isMpause;
  wire [31:0] _instBuffer_io_dataOut_1_addr;
  wire [6:0]  _instBuffer_io_dataOut_1_idx;
  wire        _instBuffer_io_dataOut_1_trap;
  wire        _instBuffer_io_dataOut_1_isControlFlow;
  wire        _instBuffer_io_dataOut_1_isBranch;
  wire        _instBuffer_io_dataOut_1_isVector;
  wire        _instBuffer_io_dataOut_1_linkOk;
  wire        _instBuffer_io_dataOut_1_isEcall;
  wire        _instBuffer_io_dataOut_1_isMpause;
  wire [31:0] _instBuffer_io_dataOut_2_addr;
  wire [6:0]  _instBuffer_io_dataOut_2_idx;
  wire        _instBuffer_io_dataOut_2_trap;
  wire        _instBuffer_io_dataOut_2_isControlFlow;
  wire        _instBuffer_io_dataOut_2_isBranch;
  wire        _instBuffer_io_dataOut_2_isVector;
  wire        _instBuffer_io_dataOut_2_linkOk;
  wire        _instBuffer_io_dataOut_2_isEcall;
  wire        _instBuffer_io_dataOut_2_isMpause;
  wire [31:0] _instBuffer_io_dataOut_3_addr;
  wire [6:0]  _instBuffer_io_dataOut_3_idx;
  wire        _instBuffer_io_dataOut_3_trap;
  wire        _instBuffer_io_dataOut_3_isControlFlow;
  wire        _instBuffer_io_dataOut_3_isBranch;
  wire        _instBuffer_io_dataOut_3_isVector;
  wire        _instBuffer_io_dataOut_3_linkOk;
  wire        _instBuffer_io_dataOut_3_isEcall;
  wire        _instBuffer_io_dataOut_3_isMpause;
  wire [31:0] _instBuffer_io_dataOut_4_addr;
  wire [6:0]  _instBuffer_io_dataOut_4_idx;
  wire        _instBuffer_io_dataOut_4_trap;
  wire        _instBuffer_io_dataOut_4_isControlFlow;
  wire        _instBuffer_io_dataOut_4_isBranch;
  wire        _instBuffer_io_dataOut_4_isVector;
  wire        _instBuffer_io_dataOut_4_linkOk;
  wire        _instBuffer_io_dataOut_4_isEcall;
  wire        _instBuffer_io_dataOut_4_isMpause;
  wire [31:0] _instBuffer_io_dataOut_5_addr;
  wire [6:0]  _instBuffer_io_dataOut_5_idx;
  wire        _instBuffer_io_dataOut_5_trap;
  wire        _instBuffer_io_dataOut_5_isControlFlow;
  wire        _instBuffer_io_dataOut_5_isBranch;
  wire        _instBuffer_io_dataOut_5_isVector;
  wire        _instBuffer_io_dataOut_5_linkOk;
  wire        _instBuffer_io_dataOut_5_isEcall;
  wire        _instBuffer_io_dataOut_5_isMpause;
  wire [31:0] _instBuffer_io_dataOut_6_addr;
  wire [6:0]  _instBuffer_io_dataOut_6_idx;
  wire        _instBuffer_io_dataOut_6_trap;
  wire        _instBuffer_io_dataOut_6_isControlFlow;
  wire        _instBuffer_io_dataOut_6_isBranch;
  wire        _instBuffer_io_dataOut_6_isVector;
  wire        _instBuffer_io_dataOut_6_linkOk;
  wire        _instBuffer_io_dataOut_6_isEcall;
  wire        _instBuffer_io_dataOut_6_isMpause;
  wire [31:0] _instBuffer_io_dataOut_7_addr;
  wire [6:0]  _instBuffer_io_dataOut_7_idx;
  wire        _instBuffer_io_dataOut_7_trap;
  wire        _instBuffer_io_dataOut_7_isControlFlow;
  wire        _instBuffer_io_dataOut_7_isBranch;
  wire        _instBuffer_io_dataOut_7_isVector;
  wire        _instBuffer_io_dataOut_7_linkOk;
  wire        _instBuffer_io_dataOut_7_isEcall;
  wire        _instBuffer_io_dataOut_7_isMpause;
  reg         storeComplete_pipe_v;
  reg  [31:0] storeComplete_pipe_b;
  wire        instFires_0 = io_inst_0_ready & io_inst_0_valid;
  wire        instFires_1 = io_inst_1_ready & io_inst_1_valid;
  wire        instFires_2 = io_inst_2_ready & io_inst_2_valid;
  wire        instFires_3 = io_inst_3_ready & io_inst_3_valid;
  wire        decodeFaultValid = io_fault_valid & io_fault_bits_decode;
  wire        noFire0Fault =
    io_fault_valid & ~instFires_0 & io_fault_bits_mcause != 32'h7
    & io_fault_bits_mcause != 32'h5;
  reg  [31:0] regLastTarget;
  reg  [31:0] regLastAddr;
  reg         regLastIsBranch;
  wire        _lane0LinkOk_T_35 = io_inst_0_bits_addr == regLastTarget;
  wire [31:0] _faultLinkOk_T_36 = regLastAddr + 32'h4;
  wire        insts_instr_vectorStore =
    io_inst_0_bits_inst[6:0] == 7'h27
    & (~(|(io_inst_0_bits_inst[14:12])) | io_inst_0_bits_inst[14:12] == 3'h5
       | io_inst_0_bits_inst[14:12] == 3'h6 | (&(io_inst_0_bits_inst[14:12])));
  wire [6:0]  _GEN = {2'h0, io_writeAddrScalar_0_addr};
  wire        insts_vectorStore =
    io_inst_0_bits_inst[6:0] == 7'h27
    & (~(|(io_inst_0_bits_inst[14:12])) | io_inst_0_bits_inst[14:12] == 3'h5
       | io_inst_0_bits_inst[14:12] == 3'h6 | (&(io_inst_0_bits_inst[14:12])));
  wire        insts_vectorStore_1 =
    io_inst_1_bits_inst[6:0] == 7'h27
    & (io_inst_1_bits_inst[14:12] == 3'h0 | io_inst_1_bits_inst[14:12] == 3'h5
       | io_inst_1_bits_inst[14:12] == 3'h6 | (&(io_inst_1_bits_inst[14:12])));
  wire        insts_vectorStore_2 =
    io_inst_2_bits_inst[6:0] == 7'h27
    & (io_inst_2_bits_inst[14:12] == 3'h0 | io_inst_2_bits_inst[14:12] == 3'h5
       | io_inst_2_bits_inst[14:12] == 3'h6 | (&(io_inst_2_bits_inst[14:12])));
  wire        insts_vectorStore_3 =
    io_inst_3_bits_inst[6:0] == 7'h27
    & (io_inst_3_bits_inst[14:12] == 3'h0 | io_inst_3_bits_inst[14:12] == 3'h5
       | io_inst_3_bits_inst[14:12] == 3'h6 | (&(io_inst_3_bits_inst[14:12])));
  reg         resultBuffer_0_valid;
  reg         resultBuffer_0_bits_trap;
  reg         resultBuffer_0_bits_cfDone;
  reg         resultBuffer_1_valid;
  reg         resultBuffer_1_bits_trap;
  reg         resultBuffer_1_bits_cfDone;
  reg         resultBuffer_2_valid;
  reg         resultBuffer_2_bits_trap;
  reg         resultBuffer_2_bits_cfDone;
  reg         resultBuffer_3_valid;
  reg         resultBuffer_3_bits_trap;
  reg         resultBuffer_3_bits_cfDone;
  reg         resultBuffer_4_valid;
  reg         resultBuffer_4_bits_trap;
  reg         resultBuffer_4_bits_cfDone;
  reg         resultBuffer_5_valid;
  reg         resultBuffer_5_bits_trap;
  reg         resultBuffer_5_bits_cfDone;
  reg         resultBuffer_6_valid;
  reg         resultBuffer_6_bits_trap;
  reg         resultBuffer_6_bits_cfDone;
  reg         resultBuffer_7_valid;
  reg         resultBuffer_7_bits_trap;
  reg         resultBuffer_7_bits_cfDone;
  wire [6:0]  _GEN_0 = {2'h0, io_writeDataScalar_0_bits_addr};
  wire [6:0]  _GEN_1 = {2'h0, io_writeDataScalar_1_bits_addr};
  wire [6:0]  _GEN_2 = {2'h0, io_writeDataScalar_2_bits_addr};
  wire [6:0]  _GEN_3 = {2'h0, io_writeDataScalar_3_bits_addr};
  wire [6:0]  _GEN_4 = {2'h0, io_writeDataScalar_4_bits_addr};
  wire [6:0]  _GEN_5 = {2'h0, io_writeDataScalar_5_bits_addr};
  wire [6:0]  _floatWriteIdxMap_T_28 = {2'h0, io_writeDataFloat_0_bits_addr} + 7'h20;
  wire [6:0]  _floatWriteIdxMap_T_30 = {2'h0, io_writeDataFloat_1_bits_addr} + 7'h20;
  wire [7:0]  _vectorWriteIdxMap_T_199 = {3'h0, io_writeDataVector_0_bits_addr} + 8'h40;
  wire [7:0]  _GEN_6 = {1'h0, _instBuffer_io_dataOut_0_idx};
  wire [7:0]  _vectorWriteIdxMap_T_206 = {3'h0, io_writeDataVector_1_bits_addr} + 8'h40;
  wire [7:0]  _vectorWriteIdxMap_T_213 = {3'h0, io_writeDataVector_2_bits_addr} + 8'h40;
  wire [7:0]  _vectorWriteIdxMap_T_220 = {3'h0, io_writeDataVector_3_bits_addr} + 8'h40;
  wire        nextAddrValid =
    (|(_instBuffer_io_nEnqueued[3:1])) | noFire0Fault | io_inst_0_valid;
  wire        _faultLinkOk_T_35 = io_fault_bits_mepc == regLastTarget;
  wire        newCfDone =
    (|_instBuffer_io_nEnqueued)
    & (~_instBuffer_io_dataOut_0_isControlFlow | nextAddrValid);
  wire        hi =
    resultBuffer_0_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_0_addr == io_fault_bits_mepc | (|_instBuffer_io_nEnqueued)
    & _instBuffer_io_dataOut_0_trap | _instBuffer_io_dataOut_0_isControlFlow & newCfDone
    & (~(nextAddrValid
         & (((|(_instBuffer_io_nEnqueued[3:1]))
               ? _instBuffer_io_dataOut_1_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_0_isBranch
            & ((|(_instBuffer_io_nEnqueued[3:1]))
                 ? _instBuffer_io_dataOut_1_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_1_addr) == _instBuffer_io_dataOut_0_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_0_isMpause;
  wire        currentDataDone =
    resultBuffer_0_valid | (|_instBuffer_io_nEnqueued) & ~resultBuffer_0_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_0_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_0_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_0_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_0_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_0_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_0_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_0_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_0_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_0_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_0_addr
          | ~_instBuffer_io_dataOut_0_isVector & _vectorWriteIdxMap_T_199 == _GEN_6)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_0_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_0_addr
          | ~_instBuffer_io_dataOut_0_isVector & _vectorWriteIdxMap_T_206 == _GEN_6)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_0_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_0_addr
          | ~_instBuffer_io_dataOut_0_isVector & _vectorWriteIdxMap_T_213 == _GEN_6)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_0_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_0_addr
          | ~_instBuffer_io_dataOut_0_isVector & _vectorWriteIdxMap_T_220 == _GEN_6)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_0_idx)
       | _instBuffer_io_dataOut_0_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_0_addr | hi);
  wire        currentCfDone =
    resultBuffer_0_valid & resultBuffer_0_bits_cfDone | newCfDone;
  wire [7:0]  _GEN_7 = {1'h0, _instBuffer_io_dataOut_1_idx};
  wire        nextValid_1 = _instBuffer_io_nEnqueued > 4'h2;
  wire        nextAddrValid_1 = nextValid_1 | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_1 =
    (|(_instBuffer_io_nEnqueued[3:1]))
    & (~_instBuffer_io_dataOut_1_isControlFlow | nextAddrValid_1);
  wire        currentTrap_1 =
    resultBuffer_1_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_1_addr == io_fault_bits_mepc
    | (|(_instBuffer_io_nEnqueued[3:1])) & _instBuffer_io_dataOut_1_trap
    | _instBuffer_io_dataOut_1_isControlFlow & newCfDone_1
    & (~(nextAddrValid_1
         & ((nextValid_1
               ? _instBuffer_io_dataOut_2_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_1_isBranch
            & (nextValid_1
                 ? _instBuffer_io_dataOut_2_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_2_addr) == _instBuffer_io_dataOut_1_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_1_isMpause;
  wire        currentDataDone_1 =
    resultBuffer_1_valid | (|(_instBuffer_io_nEnqueued[3:1])) & ~resultBuffer_1_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_1_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_1_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_1_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_1_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_1_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_1_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_1_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_1_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_1_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_1_addr
          | ~_instBuffer_io_dataOut_1_isVector & _vectorWriteIdxMap_T_199 == _GEN_7)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_1_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_1_addr
          | ~_instBuffer_io_dataOut_1_isVector & _vectorWriteIdxMap_T_206 == _GEN_7)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_1_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_1_addr
          | ~_instBuffer_io_dataOut_1_isVector & _vectorWriteIdxMap_T_213 == _GEN_7)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_1_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_1_addr
          | ~_instBuffer_io_dataOut_1_isVector & _vectorWriteIdxMap_T_220 == _GEN_7)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_1_idx)
       | _instBuffer_io_dataOut_1_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_1_addr | currentTrap_1);
  wire        currentCfDone_1 =
    resultBuffer_1_valid & resultBuffer_1_bits_cfDone | newCfDone_1;
  wire [7:0]  _GEN_8 = {1'h0, _instBuffer_io_dataOut_2_idx};
  wire        validBufferEntry_2 = _instBuffer_io_nEnqueued > 4'h2;
  wire        nextAddrValid_2 =
    (|(_instBuffer_io_nEnqueued[3:2])) | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_2 =
    validBufferEntry_2 & (~_instBuffer_io_dataOut_2_isControlFlow | nextAddrValid_2);
  wire        currentTrap_2 =
    resultBuffer_2_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_2_addr == io_fault_bits_mepc | validBufferEntry_2
    & _instBuffer_io_dataOut_2_trap | _instBuffer_io_dataOut_2_isControlFlow & newCfDone_2
    & (~(nextAddrValid_2
         & (((|(_instBuffer_io_nEnqueued[3:2]))
               ? _instBuffer_io_dataOut_3_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_2_isBranch
            & ((|(_instBuffer_io_nEnqueued[3:2]))
                 ? _instBuffer_io_dataOut_3_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_3_addr) == _instBuffer_io_dataOut_2_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_2_isMpause;
  wire        currentDataDone_2 =
    resultBuffer_2_valid | validBufferEntry_2 & ~resultBuffer_2_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_2_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_2_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_2_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_2_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_2_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_2_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_2_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_2_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_2_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_2_addr
          | ~_instBuffer_io_dataOut_2_isVector & _vectorWriteIdxMap_T_199 == _GEN_8)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_2_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_2_addr
          | ~_instBuffer_io_dataOut_2_isVector & _vectorWriteIdxMap_T_206 == _GEN_8)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_2_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_2_addr
          | ~_instBuffer_io_dataOut_2_isVector & _vectorWriteIdxMap_T_213 == _GEN_8)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_2_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_2_addr
          | ~_instBuffer_io_dataOut_2_isVector & _vectorWriteIdxMap_T_220 == _GEN_8)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_2_idx)
       | _instBuffer_io_dataOut_2_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_2_addr | currentTrap_2);
  wire        currentCfDone_2 =
    resultBuffer_2_valid & resultBuffer_2_bits_cfDone | newCfDone_2;
  wire [7:0]  _GEN_9 = {1'h0, _instBuffer_io_dataOut_3_idx};
  wire        nextValid_3 = _instBuffer_io_nEnqueued > 4'h4;
  wire        nextAddrValid_3 = nextValid_3 | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_3 =
    (|(_instBuffer_io_nEnqueued[3:2]))
    & (~_instBuffer_io_dataOut_3_isControlFlow | nextAddrValid_3);
  wire        currentTrap_3 =
    resultBuffer_3_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_3_addr == io_fault_bits_mepc
    | (|(_instBuffer_io_nEnqueued[3:2])) & _instBuffer_io_dataOut_3_trap
    | _instBuffer_io_dataOut_3_isControlFlow & newCfDone_3
    & (~(nextAddrValid_3
         & ((nextValid_3
               ? _instBuffer_io_dataOut_4_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_3_isBranch
            & (nextValid_3
                 ? _instBuffer_io_dataOut_4_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_4_addr) == _instBuffer_io_dataOut_3_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_3_isMpause;
  wire        currentDataDone_3 =
    resultBuffer_3_valid | (|(_instBuffer_io_nEnqueued[3:2])) & ~resultBuffer_3_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_3_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_3_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_3_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_3_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_3_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_3_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_3_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_3_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_3_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_3_addr
          | ~_instBuffer_io_dataOut_3_isVector & _vectorWriteIdxMap_T_199 == _GEN_9)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_3_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_3_addr
          | ~_instBuffer_io_dataOut_3_isVector & _vectorWriteIdxMap_T_206 == _GEN_9)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_3_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_3_addr
          | ~_instBuffer_io_dataOut_3_isVector & _vectorWriteIdxMap_T_213 == _GEN_9)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_3_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_3_addr
          | ~_instBuffer_io_dataOut_3_isVector & _vectorWriteIdxMap_T_220 == _GEN_9)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_3_idx)
       | _instBuffer_io_dataOut_3_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_3_addr | currentTrap_3);
  wire        currentCfDone_3 =
    resultBuffer_3_valid & resultBuffer_3_bits_cfDone | newCfDone_3;
  wire [7:0]  _GEN_10 = {1'h0, _instBuffer_io_dataOut_4_idx};
  wire        validBufferEntry_4 = _instBuffer_io_nEnqueued > 4'h4;
  wire        nextValid_4 = _instBuffer_io_nEnqueued > 4'h5;
  wire        nextAddrValid_4 = nextValid_4 | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_4 =
    validBufferEntry_4 & (~_instBuffer_io_dataOut_4_isControlFlow | nextAddrValid_4);
  wire        currentTrap_4 =
    resultBuffer_4_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_4_addr == io_fault_bits_mepc | validBufferEntry_4
    & _instBuffer_io_dataOut_4_trap | _instBuffer_io_dataOut_4_isControlFlow & newCfDone_4
    & (~(nextAddrValid_4
         & ((nextValid_4
               ? _instBuffer_io_dataOut_5_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_4_isBranch
            & (nextValid_4
                 ? _instBuffer_io_dataOut_5_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_5_addr) == _instBuffer_io_dataOut_4_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_4_isMpause;
  wire        currentDataDone_4 =
    resultBuffer_4_valid | validBufferEntry_4 & ~resultBuffer_4_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_4_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_4_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_4_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_4_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_4_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_4_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_4_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_4_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_4_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_4_addr
          | ~_instBuffer_io_dataOut_4_isVector & _vectorWriteIdxMap_T_199 == _GEN_10)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_4_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_4_addr
          | ~_instBuffer_io_dataOut_4_isVector & _vectorWriteIdxMap_T_206 == _GEN_10)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_4_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_4_addr
          | ~_instBuffer_io_dataOut_4_isVector & _vectorWriteIdxMap_T_213 == _GEN_10)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_4_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_4_addr
          | ~_instBuffer_io_dataOut_4_isVector & _vectorWriteIdxMap_T_220 == _GEN_10)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_4_idx)
       | _instBuffer_io_dataOut_4_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_4_addr | currentTrap_4);
  wire        currentCfDone_4 =
    resultBuffer_4_valid & resultBuffer_4_bits_cfDone | newCfDone_4;
  wire [7:0]  _GEN_11 = {1'h0, _instBuffer_io_dataOut_5_idx};
  wire        validBufferEntry_5 = _instBuffer_io_nEnqueued > 4'h5;
  wire        nextValid_5 = _instBuffer_io_nEnqueued > 4'h6;
  wire        nextAddrValid_5 = nextValid_5 | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_5 =
    validBufferEntry_5 & (~_instBuffer_io_dataOut_5_isControlFlow | nextAddrValid_5);
  wire        currentTrap_5 =
    resultBuffer_5_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_5_addr == io_fault_bits_mepc | validBufferEntry_5
    & _instBuffer_io_dataOut_5_trap | _instBuffer_io_dataOut_5_isControlFlow & newCfDone_5
    & (~(nextAddrValid_5
         & ((nextValid_5
               ? _instBuffer_io_dataOut_6_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_5_isBranch
            & (nextValid_5
                 ? _instBuffer_io_dataOut_6_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_6_addr) == _instBuffer_io_dataOut_5_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_5_isMpause;
  wire        currentDataDone_5 =
    resultBuffer_5_valid | validBufferEntry_5 & ~resultBuffer_5_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_5_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_5_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_5_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_5_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_5_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_5_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_5_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_5_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_5_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_5_addr
          | ~_instBuffer_io_dataOut_5_isVector & _vectorWriteIdxMap_T_199 == _GEN_11)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_5_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_5_addr
          | ~_instBuffer_io_dataOut_5_isVector & _vectorWriteIdxMap_T_206 == _GEN_11)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_5_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_5_addr
          | ~_instBuffer_io_dataOut_5_isVector & _vectorWriteIdxMap_T_213 == _GEN_11)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_5_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_5_addr
          | ~_instBuffer_io_dataOut_5_isVector & _vectorWriteIdxMap_T_220 == _GEN_11)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_5_idx)
       | _instBuffer_io_dataOut_5_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_5_addr | currentTrap_5);
  wire        currentCfDone_5 =
    resultBuffer_5_valid & resultBuffer_5_bits_cfDone | newCfDone_5;
  wire [7:0]  _GEN_12 = {1'h0, _instBuffer_io_dataOut_6_idx};
  wire        validBufferEntry_6 = _instBuffer_io_nEnqueued > 4'h6;
  wire        nextAddrValid_6 =
    _instBuffer_io_nEnqueued[3] | noFire0Fault | io_inst_0_valid;
  wire        newCfDone_6 =
    validBufferEntry_6 & (~_instBuffer_io_dataOut_6_isControlFlow | nextAddrValid_6);
  wire        currentTrap_6 =
    resultBuffer_6_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_6_addr == io_fault_bits_mepc | validBufferEntry_6
    & _instBuffer_io_dataOut_6_trap | _instBuffer_io_dataOut_6_isControlFlow & newCfDone_6
    & (~(nextAddrValid_6
         & ((_instBuffer_io_nEnqueued[3]
               ? _instBuffer_io_dataOut_7_linkOk
               : noFire0Fault
                   ? _faultLinkOk_T_35 | regLastIsBranch
                     & io_fault_bits_mepc == _faultLinkOk_T_36
                   : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                     & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_6_isBranch
            & (_instBuffer_io_nEnqueued[3]
                 ? _instBuffer_io_dataOut_7_addr
                 : noFire0Fault
                     ? io_fault_bits_mepc
                     : io_inst_0_valid
                         ? io_inst_0_bits_addr
                         : _instBuffer_io_dataOut_7_addr) == _instBuffer_io_dataOut_6_addr
            + 32'h4)) | noFire0Fault) & ~_instBuffer_io_dataOut_6_isMpause;
  wire        currentDataDone_6 =
    resultBuffer_6_valid | validBufferEntry_6 & ~resultBuffer_6_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_6_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_6_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_6_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_6_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_6_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_6_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_6_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_6_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_6_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_6_addr
          | ~_instBuffer_io_dataOut_6_isVector & _vectorWriteIdxMap_T_199 == _GEN_12)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_6_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_6_addr
          | ~_instBuffer_io_dataOut_6_isVector & _vectorWriteIdxMap_T_206 == _GEN_12)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_6_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_6_addr
          | ~_instBuffer_io_dataOut_6_isVector & _vectorWriteIdxMap_T_213 == _GEN_12)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_6_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_6_addr
          | ~_instBuffer_io_dataOut_6_isVector & _vectorWriteIdxMap_T_220 == _GEN_12)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_6_idx)
       | _instBuffer_io_dataOut_6_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_6_addr | currentTrap_6);
  wire        currentCfDone_6 =
    resultBuffer_6_valid & resultBuffer_6_bits_cfDone | newCfDone_6;
  wire [7:0]  _GEN_13 = {1'h0, _instBuffer_io_dataOut_7_idx};
  wire        nextAddrValid_7 = noFire0Fault | io_inst_0_valid;
  wire        newCfDone_7 =
    _instBuffer_io_nEnqueued[3]
    & (~_instBuffer_io_dataOut_7_isControlFlow | nextAddrValid_7);
  wire        currentTrap_7 =
    resultBuffer_7_bits_trap | io_fault_valid
    & _instBuffer_io_dataOut_7_addr == io_fault_bits_mepc | _instBuffer_io_nEnqueued[3]
    & _instBuffer_io_dataOut_7_trap | _instBuffer_io_dataOut_7_isControlFlow & newCfDone_7
    & (~(nextAddrValid_7
         & ((noFire0Fault
               ? _faultLinkOk_T_35 | regLastIsBranch
                 & io_fault_bits_mepc == _faultLinkOk_T_36
               : ~io_inst_0_valid | _lane0LinkOk_T_35 | regLastIsBranch
                 & io_inst_0_bits_addr == _faultLinkOk_T_36)
            | _instBuffer_io_dataOut_7_isBranch
            & (noFire0Fault
                 ? io_fault_bits_mepc
                 : io_inst_0_valid
                     ? io_inst_0_bits_addr
                     : 32'h0) == _instBuffer_io_dataOut_7_addr + 32'h4)) | noFire0Fault)
    & ~_instBuffer_io_dataOut_7_isMpause;
  wire        currentDataDone_7 =
    resultBuffer_7_valid | _instBuffer_io_nEnqueued[3] & ~resultBuffer_7_valid
    & (io_writeDataScalar_0_valid & _GEN_0 == _instBuffer_io_dataOut_7_idx
       | io_writeDataScalar_1_valid & _GEN_1 == _instBuffer_io_dataOut_7_idx
       | io_writeDataScalar_2_valid & _GEN_2 == _instBuffer_io_dataOut_7_idx
       | io_writeDataScalar_3_valid & _GEN_3 == _instBuffer_io_dataOut_7_idx
       | io_writeDataScalar_4_valid & _GEN_4 == _instBuffer_io_dataOut_7_idx
       | io_writeDataScalar_5_valid & _GEN_5 == _instBuffer_io_dataOut_7_idx
       | io_writeDataFloat_0_valid
       & _floatWriteIdxMap_T_28 == _instBuffer_io_dataOut_7_idx
       | io_writeDataFloat_1_valid
       & _floatWriteIdxMap_T_30 == _instBuffer_io_dataOut_7_idx
       | io_writeDataVector_0_valid
       & (_instBuffer_io_dataOut_7_isVector
          & io_writeDataVector_0_bits_uop_pc == _instBuffer_io_dataOut_7_addr
          | ~_instBuffer_io_dataOut_7_isVector & _vectorWriteIdxMap_T_199 == _GEN_13)
       & io_writeDataVector_0_bits_last_uop_valid | io_writeDataVector_1_valid
       & (_instBuffer_io_dataOut_7_isVector
          & io_writeDataVector_1_bits_uop_pc == _instBuffer_io_dataOut_7_addr
          | ~_instBuffer_io_dataOut_7_isVector & _vectorWriteIdxMap_T_206 == _GEN_13)
       & io_writeDataVector_1_bits_last_uop_valid | io_writeDataVector_2_valid
       & (_instBuffer_io_dataOut_7_isVector
          & io_writeDataVector_2_bits_uop_pc == _instBuffer_io_dataOut_7_addr
          | ~_instBuffer_io_dataOut_7_isVector & _vectorWriteIdxMap_T_213 == _GEN_13)
       & io_writeDataVector_2_bits_last_uop_valid | io_writeDataVector_3_valid
       & (_instBuffer_io_dataOut_7_isVector
          & io_writeDataVector_3_bits_uop_pc == _instBuffer_io_dataOut_7_addr
          | ~_instBuffer_io_dataOut_7_isVector & _vectorWriteIdxMap_T_220 == _GEN_13)
       & io_writeDataVector_3_bits_last_uop_valid | (&_instBuffer_io_dataOut_7_idx)
       | _instBuffer_io_dataOut_7_idx == 7'h7E & storeComplete_pipe_v
       & storeComplete_pipe_b == _instBuffer_io_dataOut_7_addr | currentTrap_7);
  wire        currentCfDone_7 =
    resultBuffer_7_valid & resultBuffer_7_bits_cfDone | newCfDone_7;
  wire        trapDetected_0 = currentDataDone & hi;
  wire        trapDetected_1 = currentDataDone_1 & currentTrap_1;
  wire        trapDetected_2 = currentDataDone_2 & currentTrap_2;
  wire        trapDetected_3 = currentDataDone_3 & currentTrap_3;
  wire        trapDetected_4 = currentDataDone_4 & currentTrap_4;
  wire        trapDetected_5 = currentDataDone_5 & currentTrap_5;
  wire        trapDetected_6 = currentDataDone_6 & currentTrap_6;
  wire        hasTrap =
    trapDetected_0 | trapDetected_1 | trapDetected_2 | trapDetected_3 | trapDetected_4
    | trapDetected_5 | trapDetected_6 | currentDataDone_7 & currentTrap_7;
  wire [7:0]  _countValid_T_9 =
    ~{currentDataDone_7 & currentCfDone_7,
      currentDataDone_6 & currentCfDone_6,
      currentDataDone_5 & currentCfDone_5,
      currentDataDone_4 & currentCfDone_4,
      currentDataDone_3 & currentCfDone_3,
      currentDataDone_2 & currentCfDone_2,
      currentDataDone_1 & currentCfDone_1,
      currentDataDone & currentCfDone};
  wire [3:0]  countValid =
    _countValid_T_9[0]
      ? 4'h0
      : _countValid_T_9[1]
          ? 4'h1
          : _countValid_T_9[2]
              ? 4'h2
              : _countValid_T_9[3]
                  ? 4'h3
                  : _countValid_T_9[4]
                      ? 4'h4
                      : _countValid_T_9[5]
                          ? 4'h5
                          : _countValid_T_9[6] ? 4'h6 : _countValid_T_9[7] ? 4'h7 : 4'h8;
  wire [3:0]  _GEN_14 =
    {1'h0,
     (trapDetected_0
        ? 3'h0
        : trapDetected_1
            ? 3'h1
            : trapDetected_2
                ? 3'h2
                : trapDetected_3
                    ? 3'h3
                    : trapDetected_4
                        ? 3'h4
                        : trapDetected_5 ? 3'h5 : {2'h3, ~trapDetected_6}) + 3'h1};
  wire        trapReadyToRetire = hasTrap & _GEN_14 <= countValid;
  wire [3:0]  deqReady = trapReadyToRetire ? _GEN_14 : countValid;
  reg         io_trapPending_REG;
  wire        valid_2 = deqReady > 4'h2;
  wire        valid_4 = deqReady > 4'h4;
  wire        valid_5 = deqReady > 4'h5;
  wire        valid_6 = deqReady > 4'h6;
  wire [23:0] shifted =
    {currentDataDone_7,
     currentTrap_7,
     currentCfDone_7,
     currentDataDone_6,
     currentTrap_6,
     currentCfDone_6,
     currentDataDone_5,
     currentTrap_5,
     currentCfDone_5,
     currentDataDone_4,
     currentTrap_4,
     currentCfDone_4,
     currentDataDone_3,
     currentTrap_3,
     currentCfDone_3,
     currentDataDone_2,
     currentTrap_2,
     currentCfDone_2,
     currentDataDone_1,
     currentTrap_1,
     currentCfDone_1,
     currentDataDone,
     hi,
     currentCfDone} >> {2'h0, deqReady} * 6'h3;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      storeComplete_pipe_v <= 1'h0;
      regLastTarget <= 32'h0;
      regLastAddr <= 32'h0;
      regLastIsBranch <= 1'h0;
      resultBuffer_0_valid <= 1'h0;
      resultBuffer_0_bits_trap <= 1'h0;
      resultBuffer_0_bits_cfDone <= 1'h0;
      resultBuffer_1_valid <= 1'h0;
      resultBuffer_1_bits_trap <= 1'h0;
      resultBuffer_1_bits_cfDone <= 1'h0;
      resultBuffer_2_valid <= 1'h0;
      resultBuffer_2_bits_trap <= 1'h0;
      resultBuffer_2_bits_cfDone <= 1'h0;
      resultBuffer_3_valid <= 1'h0;
      resultBuffer_3_bits_trap <= 1'h0;
      resultBuffer_3_bits_cfDone <= 1'h0;
      resultBuffer_4_valid <= 1'h0;
      resultBuffer_4_bits_trap <= 1'h0;
      resultBuffer_4_bits_cfDone <= 1'h0;
      resultBuffer_5_valid <= 1'h0;
      resultBuffer_5_bits_trap <= 1'h0;
      resultBuffer_5_bits_cfDone <= 1'h0;
      resultBuffer_6_valid <= 1'h0;
      resultBuffer_6_bits_trap <= 1'h0;
      resultBuffer_6_bits_cfDone <= 1'h0;
      resultBuffer_7_valid <= 1'h0;
      resultBuffer_7_bits_trap <= 1'h0;
      resultBuffer_7_bits_cfDone <= 1'h0;
      io_trapPending_REG <= 1'h0;
    end
    else begin
      storeComplete_pipe_v <= io_storeComplete_valid;
      if (instFires_0 | instFires_1 | instFires_2 | instFires_3) begin
        regLastTarget <=
          instFires_3
            ? (io_inst_3_bits_inst[6:0] == 7'h67 ? io_jalrTargets_3 : io_targets_3)
            : instFires_2
                ? (io_inst_2_bits_inst[6:0] == 7'h67 ? io_jalrTargets_2 : io_targets_2)
                : instFires_1
                    ? (io_inst_1_bits_inst[6:0] == 7'h67
                         ? io_jalrTargets_1
                         : io_targets_1)
                    : io_inst_0_bits_inst[6:0] == 7'h67 ? io_jalrTargets_0 : io_targets_0;
        regLastAddr <=
          instFires_3
            ? io_inst_3_bits_addr
            : instFires_2
                ? io_inst_2_bits_addr
                : instFires_1 ? io_inst_1_bits_addr : io_inst_0_bits_addr;
        regLastIsBranch <=
          instFires_3
            ? io_branch_3
            : instFires_2 ? io_branch_2 : instFires_1 ? io_branch_1 : io_branch_0;
      end
      resultBuffer_0_valid <= ~trapReadyToRetire & shifted[2];
      resultBuffer_0_bits_trap <= ~trapReadyToRetire & shifted[1];
      resultBuffer_0_bits_cfDone <= ~trapReadyToRetire & shifted[0];
      resultBuffer_1_valid <= ~trapReadyToRetire & shifted[5];
      resultBuffer_1_bits_trap <= ~trapReadyToRetire & shifted[4];
      resultBuffer_1_bits_cfDone <= ~trapReadyToRetire & shifted[3];
      resultBuffer_2_valid <= ~trapReadyToRetire & shifted[8];
      resultBuffer_2_bits_trap <= ~trapReadyToRetire & shifted[7];
      resultBuffer_2_bits_cfDone <= ~trapReadyToRetire & shifted[6];
      resultBuffer_3_valid <= ~trapReadyToRetire & shifted[11];
      resultBuffer_3_bits_trap <= ~trapReadyToRetire & shifted[10];
      resultBuffer_3_bits_cfDone <= ~trapReadyToRetire & shifted[9];
      resultBuffer_4_valid <= ~trapReadyToRetire & shifted[14];
      resultBuffer_4_bits_trap <= ~trapReadyToRetire & shifted[13];
      resultBuffer_4_bits_cfDone <= ~trapReadyToRetire & shifted[12];
      resultBuffer_5_valid <= ~trapReadyToRetire & shifted[17];
      resultBuffer_5_bits_trap <= ~trapReadyToRetire & shifted[16];
      resultBuffer_5_bits_cfDone <= ~trapReadyToRetire & shifted[15];
      resultBuffer_6_valid <= ~trapReadyToRetire & shifted[20];
      resultBuffer_6_bits_trap <= ~trapReadyToRetire & shifted[19];
      resultBuffer_6_bits_cfDone <= ~trapReadyToRetire & shifted[18];
      resultBuffer_7_valid <= ~trapReadyToRetire & shifted[23];
      resultBuffer_7_bits_trap <= ~trapReadyToRetire & shifted[22];
      resultBuffer_7_bits_cfDone <= ~trapReadyToRetire & shifted[21];
      io_trapPending_REG <= hasTrap & ~trapReadyToRetire;
    end
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_storeComplete_valid)
      storeComplete_pipe_b <= io_storeComplete_bits;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        storeComplete_pipe_v = _RANDOM[3'h0][0];
        storeComplete_pipe_b = {_RANDOM[3'h0][31:1], _RANDOM[3'h1][0]};
        regLastTarget = {_RANDOM[3'h1][31:1], _RANDOM[3'h2][0]};
        regLastAddr = {_RANDOM[3'h2][31:1], _RANDOM[3'h3][0]};
        regLastIsBranch = _RANDOM[3'h3][1];
        resultBuffer_0_valid = _RANDOM[3'h3][2];
        resultBuffer_0_bits_trap = _RANDOM[3'h3][3];
        resultBuffer_0_bits_cfDone = _RANDOM[3'h3][4];
        resultBuffer_1_valid = _RANDOM[3'h3][5];
        resultBuffer_1_bits_trap = _RANDOM[3'h3][6];
        resultBuffer_1_bits_cfDone = _RANDOM[3'h3][7];
        resultBuffer_2_valid = _RANDOM[3'h3][8];
        resultBuffer_2_bits_trap = _RANDOM[3'h3][9];
        resultBuffer_2_bits_cfDone = _RANDOM[3'h3][10];
        resultBuffer_3_valid = _RANDOM[3'h3][11];
        resultBuffer_3_bits_trap = _RANDOM[3'h3][12];
        resultBuffer_3_bits_cfDone = _RANDOM[3'h3][13];
        resultBuffer_4_valid = _RANDOM[3'h3][14];
        resultBuffer_4_bits_trap = _RANDOM[3'h3][15];
        resultBuffer_4_bits_cfDone = _RANDOM[3'h3][16];
        resultBuffer_5_valid = _RANDOM[3'h3][17];
        resultBuffer_5_bits_trap = _RANDOM[3'h3][18];
        resultBuffer_5_bits_cfDone = _RANDOM[3'h3][19];
        resultBuffer_6_valid = _RANDOM[3'h3][20];
        resultBuffer_6_bits_trap = _RANDOM[3'h3][21];
        resultBuffer_6_bits_cfDone = _RANDOM[3'h3][22];
        resultBuffer_7_valid = _RANDOM[3'h3][23];
        resultBuffer_7_bits_trap = _RANDOM[3'h3][24];
        resultBuffer_7_bits_cfDone = _RANDOM[3'h3][25];
        io_trapPending_REG = _RANDOM[3'h4][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        storeComplete_pipe_v = 1'h0;
        regLastTarget = 32'h0;
        regLastAddr = 32'h0;
        regLastIsBranch = 1'h0;
        resultBuffer_0_valid = 1'h0;
        resultBuffer_0_bits_trap = 1'h0;
        resultBuffer_0_bits_cfDone = 1'h0;
        resultBuffer_1_valid = 1'h0;
        resultBuffer_1_bits_trap = 1'h0;
        resultBuffer_1_bits_cfDone = 1'h0;
        resultBuffer_2_valid = 1'h0;
        resultBuffer_2_bits_trap = 1'h0;
        resultBuffer_2_bits_cfDone = 1'h0;
        resultBuffer_3_valid = 1'h0;
        resultBuffer_3_bits_trap = 1'h0;
        resultBuffer_3_bits_cfDone = 1'h0;
        resultBuffer_4_valid = 1'h0;
        resultBuffer_4_bits_trap = 1'h0;
        resultBuffer_4_bits_cfDone = 1'h0;
        resultBuffer_5_valid = 1'h0;
        resultBuffer_5_bits_trap = 1'h0;
        resultBuffer_5_bits_cfDone = 1'h0;
        resultBuffer_6_valid = 1'h0;
        resultBuffer_6_bits_trap = 1'h0;
        resultBuffer_6_bits_cfDone = 1'h0;
        resultBuffer_7_valid = 1'h0;
        resultBuffer_7_bits_trap = 1'h0;
        resultBuffer_7_bits_cfDone = 1'h0;
        io_trapPending_REG = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CircularBufferMulti_2 instBuffer (
    .clock                      (clock),
    .reset                      (reset),
    .io_enqValid
      ({1'h0,
        {1'h0, {1'h0, instFires_0} + {1'h0, instFires_1}}
          + {1'h0, {1'h0, instFires_2} + {1'h0, instFires_3}}}
       + {3'h0, decodeFaultValid | noFire0Fault}),
    .io_enqData_0_addr          (noFire0Fault ? io_fault_bits_mepc : io_inst_0_bits_addr),
    .io_enqData_0_idx
      (io_writeAddrFloat_valid
         ? {2'h0, io_writeAddrFloat_addr} + 7'h20
         : io_writeAddrVector_0_valid
             ? {2'h0, io_writeAddrVector_0_addr} - 7'h40
             : noFire0Fault
                 ? (io_writeAddrScalar_0_valid & (|io_writeAddrScalar_0_addr)
                      ? _GEN
                      : {6'h3F,
                         ~(io_inst_0_bits_inst[6:0] == 7'h23
                           | io_inst_0_bits_inst[6:0] == 7'h27
                           & (io_inst_0_bits_inst[14:12] == 3'h1
                              | io_inst_0_bits_inst[14:12] == 3'h2
                              | io_inst_0_bits_inst[14:12] == 3'h3
                              | io_inst_0_bits_inst[14:12] == 3'h4)
                           | insts_instr_vectorStore)})
                 : io_writeAddrScalar_0_valid & (|io_writeAddrScalar_0_addr)
                     ? _GEN
                     : {6'h3F,
                        ~(io_inst_0_bits_inst[6:0] == 7'h23
                          | io_inst_0_bits_inst[6:0] == 7'h27
                          & (io_inst_0_bits_inst[14:12] == 3'h1
                             | io_inst_0_bits_inst[14:12] == 3'h2
                             | io_inst_0_bits_inst[14:12] == 3'h3
                             | io_inst_0_bits_inst[14:12] == 3'h4) | insts_vectorStore)}),
    .io_enqData_0_trap
      (noFire0Fault | decodeFaultValid & io_fault_bits_mepc == io_inst_0_bits_addr),
    .io_enqData_0_isControlFlow (io_jump_0 | io_branch_0),
    .io_enqData_0_isBranch      (io_branch_0),
    .io_enqData_0_isVector
      (noFire0Fault
         ? io_writeAddrVector_0_valid | insts_instr_vectorStore
         : io_writeAddrVector_0_valid | insts_vectorStore),
    .io_enqData_0_linkOk
      (noFire0Fault
         ? io_fault_bits_mepc == regLastTarget | regLastIsBranch
           & io_fault_bits_mepc == _faultLinkOk_T_36
         : _lane0LinkOk_T_35 | regLastIsBranch
           & io_inst_0_bits_addr == _faultLinkOk_T_36),
    .io_enqData_0_isEcall       (io_inst_0_bits_inst == 32'h73),
    .io_enqData_0_isMpause      (io_inst_0_bits_inst == 32'h8000073),
    .io_enqData_1_addr          (io_inst_1_bits_addr),
    .io_enqData_1_idx
      (io_writeAddrVector_1_valid
         ? {2'h0, io_writeAddrVector_1_addr} - 7'h40
         : io_writeAddrScalar_1_valid & (|io_writeAddrScalar_1_addr)
             ? {2'h0, io_writeAddrScalar_1_addr}
             : {6'h3F,
                ~(io_inst_1_bits_inst[6:0] == 7'h23 | io_inst_1_bits_inst[6:0] == 7'h27
                  & (io_inst_1_bits_inst[14:12] == 3'h1
                     | io_inst_1_bits_inst[14:12] == 3'h2
                     | io_inst_1_bits_inst[14:12] == 3'h3
                     | io_inst_1_bits_inst[14:12] == 3'h4) | insts_vectorStore_1)}),
    .io_enqData_1_trap
      (decodeFaultValid & io_fault_bits_mepc == io_inst_1_bits_addr),
    .io_enqData_1_isControlFlow (io_jump_1 | io_branch_1),
    .io_enqData_1_isBranch      (io_branch_1),
    .io_enqData_1_isVector      (io_writeAddrVector_1_valid | insts_vectorStore_1),
    .io_enqData_1_linkOk
      (io_inst_1_bits_addr == (io_inst_0_bits_inst[6:0] == 7'h67
                                 ? io_jalrTargets_0
                                 : io_targets_0) | io_branch_0
       & io_inst_1_bits_addr == io_inst_0_bits_addr + 32'h4),
    .io_enqData_1_isEcall       (io_inst_1_bits_inst == 32'h73),
    .io_enqData_1_isMpause      (io_inst_1_bits_inst == 32'h8000073),
    .io_enqData_2_addr          (io_inst_2_bits_addr),
    .io_enqData_2_idx
      (io_writeAddrVector_2_valid
         ? {2'h0, io_writeAddrVector_2_addr} - 7'h40
         : io_writeAddrScalar_2_valid & (|io_writeAddrScalar_2_addr)
             ? {2'h0, io_writeAddrScalar_2_addr}
             : {6'h3F,
                ~(io_inst_2_bits_inst[6:0] == 7'h23 | io_inst_2_bits_inst[6:0] == 7'h27
                  & (io_inst_2_bits_inst[14:12] == 3'h1
                     | io_inst_2_bits_inst[14:12] == 3'h2
                     | io_inst_2_bits_inst[14:12] == 3'h3
                     | io_inst_2_bits_inst[14:12] == 3'h4) | insts_vectorStore_2)}),
    .io_enqData_2_trap
      (decodeFaultValid & io_fault_bits_mepc == io_inst_2_bits_addr),
    .io_enqData_2_isControlFlow (io_jump_2 | io_branch_2),
    .io_enqData_2_isBranch      (io_branch_2),
    .io_enqData_2_isVector      (io_writeAddrVector_2_valid | insts_vectorStore_2),
    .io_enqData_2_linkOk
      (io_inst_2_bits_addr == (io_inst_1_bits_inst[6:0] == 7'h67
                                 ? io_jalrTargets_1
                                 : io_targets_1) | io_branch_1
       & io_inst_2_bits_addr == io_inst_1_bits_addr + 32'h4),
    .io_enqData_2_isEcall       (io_inst_2_bits_inst == 32'h73),
    .io_enqData_2_isMpause      (io_inst_2_bits_inst == 32'h8000073),
    .io_enqData_3_addr          (io_inst_3_bits_addr),
    .io_enqData_3_idx
      (io_writeAddrVector_3_valid
         ? {2'h0, io_writeAddrVector_3_addr} - 7'h40
         : io_writeAddrScalar_3_valid & (|io_writeAddrScalar_3_addr)
             ? {2'h0, io_writeAddrScalar_3_addr}
             : {6'h3F,
                ~(io_inst_3_bits_inst[6:0] == 7'h23 | io_inst_3_bits_inst[6:0] == 7'h27
                  & (io_inst_3_bits_inst[14:12] == 3'h1
                     | io_inst_3_bits_inst[14:12] == 3'h2
                     | io_inst_3_bits_inst[14:12] == 3'h3
                     | io_inst_3_bits_inst[14:12] == 3'h4) | insts_vectorStore_3)}),
    .io_enqData_3_trap
      (decodeFaultValid & io_fault_bits_mepc == io_inst_3_bits_addr),
    .io_enqData_3_isControlFlow (io_jump_3 | io_branch_3),
    .io_enqData_3_isBranch      (io_branch_3),
    .io_enqData_3_isVector      (io_writeAddrVector_3_valid | insts_vectorStore_3),
    .io_enqData_3_linkOk
      (io_inst_3_bits_addr == (io_inst_2_bits_inst[6:0] == 7'h67
                                 ? io_jalrTargets_2
                                 : io_targets_2) | io_branch_2
       & io_inst_3_bits_addr == io_inst_2_bits_addr + 32'h4),
    .io_enqData_3_isEcall       (io_inst_3_bits_inst == 32'h73),
    .io_enqData_3_isMpause      (io_inst_3_bits_inst == 32'h8000073),
    .io_enqData_4_addr          (32'h0),
    .io_enqData_4_idx           (7'h0),
    .io_enqData_4_trap          (1'h0),
    .io_enqData_4_isControlFlow (1'h0),
    .io_enqData_4_isBranch      (1'h0),
    .io_enqData_4_isVector      (1'h0),
    .io_enqData_4_linkOk        (1'h0),
    .io_enqData_4_isEcall       (1'h0),
    .io_enqData_4_isMpause      (1'h0),
    .io_enqData_5_addr          (32'h0),
    .io_enqData_5_idx           (7'h0),
    .io_enqData_5_trap          (1'h0),
    .io_enqData_5_isControlFlow (1'h0),
    .io_enqData_5_isBranch      (1'h0),
    .io_enqData_5_isVector      (1'h0),
    .io_enqData_5_linkOk        (1'h0),
    .io_enqData_5_isEcall       (1'h0),
    .io_enqData_5_isMpause      (1'h0),
    .io_enqData_6_addr          (32'h0),
    .io_enqData_6_idx           (7'h0),
    .io_enqData_6_trap          (1'h0),
    .io_enqData_6_isControlFlow (1'h0),
    .io_enqData_6_isBranch      (1'h0),
    .io_enqData_6_isVector      (1'h0),
    .io_enqData_6_linkOk        (1'h0),
    .io_enqData_6_isEcall       (1'h0),
    .io_enqData_6_isMpause      (1'h0),
    .io_enqData_7_addr          (32'h0),
    .io_enqData_7_idx           (7'h0),
    .io_enqData_7_trap          (1'h0),
    .io_enqData_7_isControlFlow (1'h0),
    .io_enqData_7_isBranch      (1'h0),
    .io_enqData_7_isVector      (1'h0),
    .io_enqData_7_linkOk        (1'h0),
    .io_enqData_7_isEcall       (1'h0),
    .io_enqData_7_isMpause      (1'h0),
    .io_nEnqueued               (_instBuffer_io_nEnqueued),
    .io_nSpace                  (_instBuffer_io_nSpace),
    .io_dataOut_0_addr          (_instBuffer_io_dataOut_0_addr),
    .io_dataOut_0_idx           (_instBuffer_io_dataOut_0_idx),
    .io_dataOut_0_trap          (_instBuffer_io_dataOut_0_trap),
    .io_dataOut_0_isControlFlow (_instBuffer_io_dataOut_0_isControlFlow),
    .io_dataOut_0_isBranch      (_instBuffer_io_dataOut_0_isBranch),
    .io_dataOut_0_isVector      (_instBuffer_io_dataOut_0_isVector),
    .io_dataOut_0_linkOk        (/* unused */),
    .io_dataOut_0_isEcall       (_instBuffer_io_dataOut_0_isEcall),
    .io_dataOut_0_isMpause      (_instBuffer_io_dataOut_0_isMpause),
    .io_dataOut_1_addr          (_instBuffer_io_dataOut_1_addr),
    .io_dataOut_1_idx           (_instBuffer_io_dataOut_1_idx),
    .io_dataOut_1_trap          (_instBuffer_io_dataOut_1_trap),
    .io_dataOut_1_isControlFlow (_instBuffer_io_dataOut_1_isControlFlow),
    .io_dataOut_1_isBranch      (_instBuffer_io_dataOut_1_isBranch),
    .io_dataOut_1_isVector      (_instBuffer_io_dataOut_1_isVector),
    .io_dataOut_1_linkOk        (_instBuffer_io_dataOut_1_linkOk),
    .io_dataOut_1_isEcall       (_instBuffer_io_dataOut_1_isEcall),
    .io_dataOut_1_isMpause      (_instBuffer_io_dataOut_1_isMpause),
    .io_dataOut_2_addr          (_instBuffer_io_dataOut_2_addr),
    .io_dataOut_2_idx           (_instBuffer_io_dataOut_2_idx),
    .io_dataOut_2_trap          (_instBuffer_io_dataOut_2_trap),
    .io_dataOut_2_isControlFlow (_instBuffer_io_dataOut_2_isControlFlow),
    .io_dataOut_2_isBranch      (_instBuffer_io_dataOut_2_isBranch),
    .io_dataOut_2_isVector      (_instBuffer_io_dataOut_2_isVector),
    .io_dataOut_2_linkOk        (_instBuffer_io_dataOut_2_linkOk),
    .io_dataOut_2_isEcall       (_instBuffer_io_dataOut_2_isEcall),
    .io_dataOut_2_isMpause      (_instBuffer_io_dataOut_2_isMpause),
    .io_dataOut_3_addr          (_instBuffer_io_dataOut_3_addr),
    .io_dataOut_3_idx           (_instBuffer_io_dataOut_3_idx),
    .io_dataOut_3_trap          (_instBuffer_io_dataOut_3_trap),
    .io_dataOut_3_isControlFlow (_instBuffer_io_dataOut_3_isControlFlow),
    .io_dataOut_3_isBranch      (_instBuffer_io_dataOut_3_isBranch),
    .io_dataOut_3_isVector      (_instBuffer_io_dataOut_3_isVector),
    .io_dataOut_3_linkOk        (_instBuffer_io_dataOut_3_linkOk),
    .io_dataOut_3_isEcall       (_instBuffer_io_dataOut_3_isEcall),
    .io_dataOut_3_isMpause      (_instBuffer_io_dataOut_3_isMpause),
    .io_dataOut_4_addr          (_instBuffer_io_dataOut_4_addr),
    .io_dataOut_4_idx           (_instBuffer_io_dataOut_4_idx),
    .io_dataOut_4_trap          (_instBuffer_io_dataOut_4_trap),
    .io_dataOut_4_isControlFlow (_instBuffer_io_dataOut_4_isControlFlow),
    .io_dataOut_4_isBranch      (_instBuffer_io_dataOut_4_isBranch),
    .io_dataOut_4_isVector      (_instBuffer_io_dataOut_4_isVector),
    .io_dataOut_4_linkOk        (_instBuffer_io_dataOut_4_linkOk),
    .io_dataOut_4_isEcall       (_instBuffer_io_dataOut_4_isEcall),
    .io_dataOut_4_isMpause      (_instBuffer_io_dataOut_4_isMpause),
    .io_dataOut_5_addr          (_instBuffer_io_dataOut_5_addr),
    .io_dataOut_5_idx           (_instBuffer_io_dataOut_5_idx),
    .io_dataOut_5_trap          (_instBuffer_io_dataOut_5_trap),
    .io_dataOut_5_isControlFlow (_instBuffer_io_dataOut_5_isControlFlow),
    .io_dataOut_5_isBranch      (_instBuffer_io_dataOut_5_isBranch),
    .io_dataOut_5_isVector      (_instBuffer_io_dataOut_5_isVector),
    .io_dataOut_5_linkOk        (_instBuffer_io_dataOut_5_linkOk),
    .io_dataOut_5_isEcall       (_instBuffer_io_dataOut_5_isEcall),
    .io_dataOut_5_isMpause      (_instBuffer_io_dataOut_5_isMpause),
    .io_dataOut_6_addr          (_instBuffer_io_dataOut_6_addr),
    .io_dataOut_6_idx           (_instBuffer_io_dataOut_6_idx),
    .io_dataOut_6_trap          (_instBuffer_io_dataOut_6_trap),
    .io_dataOut_6_isControlFlow (_instBuffer_io_dataOut_6_isControlFlow),
    .io_dataOut_6_isBranch      (_instBuffer_io_dataOut_6_isBranch),
    .io_dataOut_6_isVector      (_instBuffer_io_dataOut_6_isVector),
    .io_dataOut_6_linkOk        (_instBuffer_io_dataOut_6_linkOk),
    .io_dataOut_6_isEcall       (_instBuffer_io_dataOut_6_isEcall),
    .io_dataOut_6_isMpause      (_instBuffer_io_dataOut_6_isMpause),
    .io_dataOut_7_addr          (_instBuffer_io_dataOut_7_addr),
    .io_dataOut_7_idx           (_instBuffer_io_dataOut_7_idx),
    .io_dataOut_7_trap          (_instBuffer_io_dataOut_7_trap),
    .io_dataOut_7_isControlFlow (_instBuffer_io_dataOut_7_isControlFlow),
    .io_dataOut_7_isBranch      (_instBuffer_io_dataOut_7_isBranch),
    .io_dataOut_7_isVector      (_instBuffer_io_dataOut_7_isVector),
    .io_dataOut_7_linkOk        (_instBuffer_io_dataOut_7_linkOk),
    .io_dataOut_7_isEcall       (_instBuffer_io_dataOut_7_isEcall),
    .io_dataOut_7_isMpause      (_instBuffer_io_dataOut_7_isMpause),
    .io_deqReady                (deqReady),
    .io_flush                   (trapReadyToRetire)
  );
  assign io_nSpace = {28'h0, _instBuffer_io_nSpace};
  assign io_nRetired =
    deqReady
    - ({1'h0,
        {1'h0,
         {1'h0, (|deqReady) & _instBuffer_io_dataOut_0_isEcall}
           + {1'h0, (|(deqReady[3:1])) & _instBuffer_io_dataOut_1_isEcall}}
          + {1'h0,
             {1'h0, deqReady > 4'h2 & _instBuffer_io_dataOut_2_isEcall}
               + {1'h0, (|(deqReady[3:2])) & _instBuffer_io_dataOut_3_isEcall}}}
       + {1'h0,
          {1'h0,
           {1'h0, deqReady > 4'h4 & _instBuffer_io_dataOut_4_isEcall}
             + {1'h0, deqReady > 4'h5 & _instBuffer_io_dataOut_5_isEcall}}
            + {1'h0,
               {1'h0, deqReady > 4'h6 & _instBuffer_io_dataOut_6_isEcall}
                 + {1'h0, deqReady[3] & _instBuffer_io_dataOut_7_isEcall}}});
  assign io_empty = _instBuffer_io_nEnqueued == 4'h0;
  assign io_trapPending = io_trapPending_REG;
  assign io_debug_inst_0_valid = |deqReady;
  assign io_debug_inst_0_bits_pc = (|deqReady) ? _instBuffer_io_dataOut_0_addr : 32'h0;
  assign io_debug_inst_0_bits_idx =
    (|deqReady)
      ? (hi & ~(hi & _instBuffer_io_dataOut_0_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_0_idx)
      : 7'h0;
  assign io_debug_inst_0_bits_trap = (|deqReady) & hi;
  assign io_debug_inst_1_valid = |(deqReady[3:1]);
  assign io_debug_inst_1_bits_pc =
    (|(deqReady[3:1])) ? _instBuffer_io_dataOut_1_addr : 32'h0;
  assign io_debug_inst_1_bits_idx =
    (|(deqReady[3:1]))
      ? (currentTrap_1
         & ~(currentTrap_1 & _instBuffer_io_dataOut_1_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_1_idx)
      : 7'h0;
  assign io_debug_inst_1_bits_trap = (|(deqReady[3:1])) & currentTrap_1;
  assign io_debug_inst_2_valid = valid_2;
  assign io_debug_inst_2_bits_pc = valid_2 ? _instBuffer_io_dataOut_2_addr : 32'h0;
  assign io_debug_inst_2_bits_idx =
    valid_2
      ? (currentTrap_2
         & ~(currentTrap_2 & _instBuffer_io_dataOut_2_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_2_idx)
      : 7'h0;
  assign io_debug_inst_2_bits_trap = valid_2 & currentTrap_2;
  assign io_debug_inst_3_valid = |(deqReady[3:2]);
  assign io_debug_inst_3_bits_pc =
    (|(deqReady[3:2])) ? _instBuffer_io_dataOut_3_addr : 32'h0;
  assign io_debug_inst_3_bits_idx =
    (|(deqReady[3:2]))
      ? (currentTrap_3
         & ~(currentTrap_3 & _instBuffer_io_dataOut_3_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_3_idx)
      : 7'h0;
  assign io_debug_inst_3_bits_trap = (|(deqReady[3:2])) & currentTrap_3;
  assign io_debug_inst_4_valid = valid_4;
  assign io_debug_inst_4_bits_pc = valid_4 ? _instBuffer_io_dataOut_4_addr : 32'h0;
  assign io_debug_inst_4_bits_idx =
    valid_4
      ? (currentTrap_4
         & ~(currentTrap_4 & _instBuffer_io_dataOut_4_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_4_idx)
      : 7'h0;
  assign io_debug_inst_4_bits_trap = valid_4 & currentTrap_4;
  assign io_debug_inst_5_valid = valid_5;
  assign io_debug_inst_5_bits_pc = valid_5 ? _instBuffer_io_dataOut_5_addr : 32'h0;
  assign io_debug_inst_5_bits_idx =
    valid_5
      ? (currentTrap_5
         & ~(currentTrap_5 & _instBuffer_io_dataOut_5_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_5_idx)
      : 7'h0;
  assign io_debug_inst_5_bits_trap = valid_5 & currentTrap_5;
  assign io_debug_inst_6_valid = valid_6;
  assign io_debug_inst_6_bits_pc = valid_6 ? _instBuffer_io_dataOut_6_addr : 32'h0;
  assign io_debug_inst_6_bits_idx =
    valid_6
      ? (currentTrap_6
         & ~(currentTrap_6 & _instBuffer_io_dataOut_6_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_6_idx)
      : 7'h0;
  assign io_debug_inst_6_bits_trap = valid_6 & currentTrap_6;
  assign io_debug_inst_7_valid = deqReady[3];
  assign io_debug_inst_7_bits_pc = deqReady[3] ? _instBuffer_io_dataOut_7_addr : 32'h0;
  assign io_debug_inst_7_bits_idx =
    deqReady[3]
      ? (currentTrap_7
         & ~(currentTrap_7 & _instBuffer_io_dataOut_7_isControlFlow & noFire0Fault)
           ? 7'h7F
           : _instBuffer_io_dataOut_7_idx)
      : 7'h0;
  assign io_debug_inst_7_bits_trap = deqReady[3] & currentTrap_7;
endmodule

module Alu(
  input         clock,
                reset,
                io_req_valid,
  input  [4:0]  io_req_bits_addr,
                io_req_bits_op,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  reg               valid;
  reg  [4:0]        addr;
  reg  [4:0]        op;
  wire              r2IsGreater = $signed(io_rs1_data) < $signed(io_rs2_data);
  wire              r2IsGreaterU = io_rs1_data < io_rs2_data;
  wire [31:0]       _io_rd_bits_data_T_19 = io_rs1_data ^ io_rs2_data;
  wire [62:0]       _io_rd_bits_data_T_7 = {31'h0, io_rs1_data} << io_rs2_data[4:0];
  wire [31:0]       _GEN = {27'h0, io_rs2_data[4:0]};
  wire [31:0]       _io_rd_bits_data_T_29 =
    {16'h0, io_rs1_data[31:16]} | {io_rs1_data[15:0], 16'h0};
  wire [31:0]       _io_rd_bits_data_T_39 =
    {8'h0, _io_rd_bits_data_T_29[31:8] & 24'hFF00FF}
    | {_io_rd_bits_data_T_29[23:0] & 24'hFF00FF, 8'h0};
  wire [31:0]       _io_rd_bits_data_T_49 =
    {4'h0, _io_rd_bits_data_T_39[31:4] & 28'hF0F0F0F}
    | {_io_rd_bits_data_T_39[27:0] & 28'hF0F0F0F, 4'h0};
  wire [31:0]       _io_rd_bits_data_T_59 =
    {2'h0, _io_rd_bits_data_T_49[31:2] & 30'h33333333}
    | {_io_rd_bits_data_T_49[29:0] & 30'h33333333, 2'h0};
  wire [31:0]       _io_rd_bits_data_T_69 =
    {1'h0, _io_rd_bits_data_T_59[31:1] & 31'h55555555}
    | {_io_rd_bits_data_T_59[30:0] & 31'h55555555, 1'h0};
  wire [31:0]       _io_rd_bits_data_T_312 =
    io_rs2_data[0] ? {io_rs1_data[30:0], io_rs1_data[31]} : io_rs1_data;
  wire [31:0]       _io_rd_bits_data_T_316 =
    io_rs2_data[1]
      ? {_io_rd_bits_data_T_312[29:0], _io_rd_bits_data_T_312[31:30]}
      : _io_rd_bits_data_T_312;
  wire [31:0]       _io_rd_bits_data_T_320 =
    io_rs2_data[2]
      ? {_io_rd_bits_data_T_316[27:0], _io_rd_bits_data_T_316[31:28]}
      : _io_rd_bits_data_T_316;
  wire [31:0]       _io_rd_bits_data_T_324 =
    io_rs2_data[3]
      ? {_io_rd_bits_data_T_320[23:0], _io_rd_bits_data_T_320[31:24]}
      : _io_rd_bits_data_T_320;
  wire [31:0]       _io_rd_bits_data_T_337 =
    io_rs2_data[0] ? {io_rs1_data[0], io_rs1_data[31:1]} : io_rs1_data;
  wire [31:0]       _io_rd_bits_data_T_341 =
    io_rs2_data[1]
      ? {_io_rd_bits_data_T_337[1:0], _io_rd_bits_data_T_337[31:2]}
      : _io_rd_bits_data_T_337;
  wire [31:0]       _io_rd_bits_data_T_345 =
    io_rs2_data[2]
      ? {_io_rd_bits_data_T_341[3:0], _io_rd_bits_data_T_341[31:4]}
      : _io_rd_bits_data_T_341;
  wire [31:0]       _io_rd_bits_data_T_349 =
    io_rs2_data[3]
      ? {_io_rd_bits_data_T_345[7:0], _io_rd_bits_data_T_345[31:8]}
      : _io_rd_bits_data_T_345;
  wire [31:0][31:0] _GEN_0 =
    {{32'h0},
     {32'h0},
     {32'h0},
     {32'h0},
     {{16'h0, io_rs1_data[15:0]}},
     {{io_rs1_data[7:0], io_rs1_data[15:8], io_rs1_data[23:16], io_rs1_data[31:24]}},
     {{io_rs1_data[31:24] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[23:16] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[15:8] == 8'h0 ? 8'h0 : 8'hFF,
       io_rs1_data[7:0] == 8'h0 ? 8'h0 : 8'hFF}},
     {io_rs2_data[4]
        ? {_io_rd_bits_data_T_349[15:0], _io_rd_bits_data_T_349[31:16]}
        : _io_rd_bits_data_T_349},
     {io_rs2_data[4]
        ? {_io_rd_bits_data_T_324[15:0], _io_rd_bits_data_T_324[31:16]}
        : _io_rd_bits_data_T_324},
     {{{16{io_rs1_data[15]}}, io_rs1_data[15:0]}},
     {{{24{io_rs1_data[7]}}, io_rs1_data[7:0]}},
     {r2IsGreaterU ? io_rs1_data : io_rs2_data},
     {r2IsGreater ? io_rs1_data : io_rs2_data},
     {r2IsGreaterU ? io_rs2_data : io_rs1_data},
     {r2IsGreater ? io_rs2_data : io_rs1_data},
     {{26'h0,
       {1'h0,
        {1'h0,
         {1'h0,
          {1'h0, {1'h0, io_rs1_data[0]} + {1'h0, io_rs1_data[1]}}
            + {1'h0, {1'h0, io_rs1_data[2]} + {1'h0, io_rs1_data[3]}}}
           + {1'h0,
              {1'h0, {1'h0, io_rs1_data[4]} + {1'h0, io_rs1_data[5]}}
                + {1'h0, {1'h0, io_rs1_data[6]} + {1'h0, io_rs1_data[7]}}}}
          + {1'h0,
             {1'h0,
              {1'h0, {1'h0, io_rs1_data[8]} + {1'h0, io_rs1_data[9]}}
                + {1'h0, {1'h0, io_rs1_data[10]} + {1'h0, io_rs1_data[11]}}}
               + {1'h0,
                  {1'h0, {1'h0, io_rs1_data[12]} + {1'h0, io_rs1_data[13]}}
                    + {1'h0, {1'h0, io_rs1_data[14]} + {1'h0, io_rs1_data[15]}}}}}
         + {1'h0,
            {1'h0,
             {1'h0,
              {1'h0, {1'h0, io_rs1_data[16]} + {1'h0, io_rs1_data[17]}}
                + {1'h0, {1'h0, io_rs1_data[18]} + {1'h0, io_rs1_data[19]}}}
               + {1'h0,
                  {1'h0, {1'h0, io_rs1_data[20]} + {1'h0, io_rs1_data[21]}}
                    + {1'h0, {1'h0, io_rs1_data[22]} + {1'h0, io_rs1_data[23]}}}}
              + {1'h0,
                 {1'h0,
                  {1'h0, {1'h0, io_rs1_data[24]} + {1'h0, io_rs1_data[25]}}
                    + {1'h0, {1'h0, io_rs1_data[26]} + {1'h0, io_rs1_data[27]}}}
                   + {1'h0,
                      {1'h0, {1'h0, io_rs1_data[28]} + {1'h0, io_rs1_data[29]}}
                        + {1'h0, {1'h0, io_rs1_data[30]} + {1'h0, io_rs1_data[31]}}}}}}},
     {{26'h0,
       io_rs1_data[0]
         ? 6'h0
         : io_rs1_data[1]
             ? 6'h1
             : io_rs1_data[2]
                 ? 6'h2
                 : io_rs1_data[3]
                     ? 6'h3
                     : io_rs1_data[4]
                         ? 6'h4
                         : io_rs1_data[5]
                             ? 6'h5
                             : io_rs1_data[6]
                                 ? 6'h6
                                 : io_rs1_data[7]
                                     ? 6'h7
                                     : io_rs1_data[8]
                                         ? 6'h8
                                         : io_rs1_data[9]
                                             ? 6'h9
                                             : io_rs1_data[10]
                                                 ? 6'hA
                                                 : io_rs1_data[11]
                                                     ? 6'hB
                                                     : io_rs1_data[12]
                                                         ? 6'hC
                                                         : io_rs1_data[13]
                                                             ? 6'hD
                                                             : io_rs1_data[14]
                                                                 ? 6'hE
                                                                 : io_rs1_data[15]
                                                                     ? 6'hF
                                                                     : io_rs1_data[16]
                                                                         ? 6'h10
                                                                         : io_rs1_data[17]
                                                                             ? 6'h11
                                                                             : io_rs1_data[18]
                                                                                 ? 6'h12
                                                                                 : io_rs1_data[19]
                                                                                     ? 6'h13
                                                                                     : io_rs1_data[20]
                                                                                         ? 6'h14
                                                                                         : io_rs1_data[21]
                                                                                             ? 6'h15
                                                                                             : io_rs1_data[22]
                                                                                                 ? 6'h16
                                                                                                 : io_rs1_data[23]
                                                                                                     ? 6'h17
                                                                                                     : io_rs1_data[24]
                                                                                                         ? 6'h18
                                                                                                         : io_rs1_data[25]
                                                                                                             ? 6'h19
                                                                                                             : io_rs1_data[26]
                                                                                                                 ? 6'h1A
                                                                                                                 : io_rs1_data[27]
                                                                                                                     ? 6'h1B
                                                                                                                     : io_rs1_data[28]
                                                                                                                         ? 6'h1C
                                                                                                                         : io_rs1_data[29]
                                                                                                                             ? 6'h1D
                                                                                                                             : io_rs1_data[30]
                                                                                                                                 ? 6'h1E
                                                                                                                                 : io_rs1_data[31]
                                                                                                                                     ? 6'h1F
                                                                                                                                     : 6'h20}},
     {{26'h0,
       _io_rd_bits_data_T_69[0]
         ? 6'h0
         : _io_rd_bits_data_T_69[1]
             ? 6'h1
             : _io_rd_bits_data_T_69[2]
                 ? 6'h2
                 : _io_rd_bits_data_T_69[3]
                     ? 6'h3
                     : _io_rd_bits_data_T_69[4]
                         ? 6'h4
                         : _io_rd_bits_data_T_69[5]
                             ? 6'h5
                             : _io_rd_bits_data_T_69[6]
                                 ? 6'h6
                                 : _io_rd_bits_data_T_69[7]
                                     ? 6'h7
                                     : _io_rd_bits_data_T_69[8]
                                         ? 6'h8
                                         : _io_rd_bits_data_T_69[9]
                                             ? 6'h9
                                             : _io_rd_bits_data_T_69[10]
                                                 ? 6'hA
                                                 : _io_rd_bits_data_T_69[11]
                                                     ? 6'hB
                                                     : _io_rd_bits_data_T_69[12]
                                                         ? 6'hC
                                                         : _io_rd_bits_data_T_69[13]
                                                             ? 6'hD
                                                             : _io_rd_bits_data_T_69[14]
                                                                 ? 6'hE
                                                                 : _io_rd_bits_data_T_69[15]
                                                                     ? 6'hF
                                                                     : _io_rd_bits_data_T_69[16]
                                                                         ? 6'h10
                                                                         : _io_rd_bits_data_T_69[17]
                                                                             ? 6'h11
                                                                             : _io_rd_bits_data_T_69[18]
                                                                                 ? 6'h12
                                                                                 : _io_rd_bits_data_T_69[19]
                                                                                     ? 6'h13
                                                                                     : _io_rd_bits_data_T_69[20]
                                                                                         ? 6'h14
                                                                                         : _io_rd_bits_data_T_69[21]
                                                                                             ? 6'h15
                                                                                             : _io_rd_bits_data_T_69[22]
                                                                                                 ? 6'h16
                                                                                                 : _io_rd_bits_data_T_69[23]
                                                                                                     ? 6'h17
                                                                                                     : _io_rd_bits_data_T_69[24]
                                                                                                         ? 6'h18
                                                                                                         : _io_rd_bits_data_T_69[25]
                                                                                                             ? 6'h19
                                                                                                             : _io_rd_bits_data_T_69[26]
                                                                                                                 ? 6'h1A
                                                                                                                 : _io_rd_bits_data_T_69[27]
                                                                                                                     ? 6'h1B
                                                                                                                     : _io_rd_bits_data_T_69[28]
                                                                                                                         ? 6'h1C
                                                                                                                         : _io_rd_bits_data_T_69[29]
                                                                                                                             ? 6'h1D
                                                                                                                             : _io_rd_bits_data_T_69[30]
                                                                                                                                 ? 6'h1E
                                                                                                                                 : _io_rd_bits_data_T_69[31]
                                                                                                                                     ? 6'h1F
                                                                                                                                     : 6'h20}},
     {~_io_rd_bits_data_T_19},
     {io_rs1_data | ~io_rs2_data},
     {io_rs1_data & ~io_rs2_data},
     {io_rs2_data},
     {$signed($signed(io_rs1_data) >>> _GEN)},
     {io_rs1_data >> _GEN},
     {_io_rd_bits_data_T_7[31:0]},
     {io_rs1_data & io_rs2_data},
     {io_rs1_data | io_rs2_data},
     {_io_rd_bits_data_T_19},
     {{31'h0, r2IsGreaterU}},
     {{31'h0, r2IsGreater}},
     {io_rs1_data - io_rs2_data},
     {io_rs1_data + io_rs2_data}};
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      valid <= 1'h0;
      addr <= 5'h0;
      op <= 5'h0;
    end
    else begin
      valid <= io_req_valid;
      if (io_req_valid) begin
        addr <= io_req_bits_addr;
        op <= io_req_bits_op;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        valid = _RANDOM[/*Zero width*/ 1'b0][0];
        addr = _RANDOM[/*Zero width*/ 1'b0][5:1];
        op = _RANDOM[/*Zero width*/ 1'b0][10:6];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        valid = 1'h0;
        addr = 5'h0;
        op = 5'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_rd_valid = valid;
  assign io_rd_bits_addr = addr;
  assign io_rd_bits_data = _GEN_0[op];
endmodule

module Bru(
  input         clock,
                reset,
                io_req_valid,
                io_req_bits_fwd,
  input  [3:0]  io_req_bits_op,
  input  [31:0] io_req_bits_pc,
                io_req_bits_target,
  input  [4:0]  io_req_bits_link,
  output        io_csr_in_mode_valid,
  output [1:0]  io_csr_in_mode_bits,
  output        io_csr_in_mcause_valid,
  output [31:0] io_csr_in_mcause_bits,
  output        io_csr_in_mepc_valid,
  output [31:0] io_csr_in_mepc_bits,
  output        io_csr_in_mtval_valid,
  output [31:0] io_csr_in_mtval_bits,
  output        io_csr_in_halt,
                io_csr_in_fault,
                io_csr_in_wfi,
  input  [1:0]  io_csr_out_mode,
  input  [31:0] io_csr_out_mepc,
                io_csr_out_mtvec,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  output        io_taken_valid,
  output [31:0] io_taken_value,
  input  [31:0] io_target_data,
  output        io_interlock,
  input         io_fault_manager_valid,
  input  [31:0] io_fault_manager_bits_mepc,
                io_fault_manager_bits_mtval,
                io_fault_manager_bits_mcause
);

  wire        io_csr_in_fault_0;
  reg         stateReg_valid;
  reg         stateReg_bits_fwd;
  reg  [3:0]  stateReg_bits_op;
  reg  [31:0] stateReg_bits_target;
  reg         stateReg_bits_linkValid;
  reg  [4:0]  stateReg_bits_linkAddr;
  reg  [31:0] stateReg_bits_linkData;
  reg  [31:0] stateReg_bits_pcEx;
  wire        _io_csr_in_fault_T = io_csr_out_mode == 2'h0;
  wire        _io_csr_in_mcause_bits_T_4 = io_csr_out_mode == 2'h1;
  wire        _ignore_T_2 = stateReg_bits_op == 4'h8;
  wire        _ignore_T_3 = stateReg_bits_op == 4'h9;
  wire        _ignore_T_4 = stateReg_bits_op == 4'hA;
  wire        _ignore_T_5 = stateReg_bits_op == 4'hB;
  wire        _ignore_T_7 = stateReg_bits_op == 4'hD;
  wire        usageFault =
    stateReg_valid
    & (_io_csr_in_mcause_bits_T_4 ? (|{_ignore_T_5, _ignore_T_4}) : _ignore_T_2);
  assign io_csr_in_fault_0 = usageFault & _io_csr_in_fault_T;
  wire        _ignore_T_6 = stateReg_bits_op == 4'hC;
  wire [31:0] nextState_linkData = io_req_bits_pc + 32'h4;
  wire        _nextState_target_T = io_req_bits_op == 4'h1;
  wire [31:0] mtvec = {io_csr_out_mtvec[31:2], 2'h0};
  wire        _pipeline0Target_call_T = io_req_bits_op == 4'hB;
  wire        stateRegValid = io_req_valid | io_fault_manager_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      stateReg_valid <= 1'h0;
      stateReg_bits_fwd <= 1'h0;
      stateReg_bits_op <= 4'h0;
      stateReg_bits_target <= 32'h0;
      stateReg_bits_linkValid <= 1'h0;
      stateReg_bits_linkAddr <= 5'h0;
      stateReg_bits_linkData <= 32'h0;
      stateReg_bits_pcEx <= 32'h0;
    end
    else begin
      stateReg_valid <= stateRegValid;
      if (stateRegValid) begin
        stateReg_bits_fwd <= io_req_valid & io_req_bits_fwd;
        stateReg_bits_op <= io_fault_manager_valid ? 4'hD : io_req_bits_op;
        stateReg_bits_target <=
          io_fault_manager_valid
            ? mtvec
            : io_req_bits_fwd
                ? nextState_linkData
                : _nextState_target_T
                    ? io_target_data & 32'hFFFFFFFE
                    : io_req_bits_op == 4'h9
                        ? mtvec
                        : (|{_pipeline0Target_call_T & _io_csr_in_fault_T,
                             _pipeline0Target_call_T & _io_csr_in_mcause_bits_T_4,
                             io_req_bits_op == 4'hA,
                             io_req_bits_op == 4'h8})
                            ? io_csr_out_mepc
                            : io_req_bits_op == 4'hC
                                ? nextState_linkData
                                : io_req_bits_target;
        stateReg_bits_linkValid <=
          io_req_valid & (|io_req_bits_link)
          & (|{_nextState_target_T, io_req_bits_op == 4'h0});
        stateReg_bits_linkAddr <= io_req_bits_link;
        stateReg_bits_linkData <= nextState_linkData;
        stateReg_bits_pcEx <= io_req_bits_pc;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:4];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h5; i += 3'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        stateReg_valid = _RANDOM[3'h0][0];
        stateReg_bits_fwd = _RANDOM[3'h0][1];
        stateReg_bits_op = _RANDOM[3'h0][5:2];
        stateReg_bits_target = {_RANDOM[3'h0][31:6], _RANDOM[3'h1][5:0]};
        stateReg_bits_linkValid = _RANDOM[3'h2][6];
        stateReg_bits_linkAddr = _RANDOM[3'h2][11:7];
        stateReg_bits_linkData = {_RANDOM[3'h2][31:12], _RANDOM[3'h3][11:0]};
        stateReg_bits_pcEx = {_RANDOM[3'h3][31:12], _RANDOM[3'h4][11:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        stateReg_valid = 1'h0;
        stateReg_bits_fwd = 1'h0;
        stateReg_bits_op = 4'h0;
        stateReg_bits_target = 32'h0;
        stateReg_bits_linkValid = 1'h0;
        stateReg_bits_linkAddr = 5'h0;
        stateReg_bits_linkData = 32'h0;
        stateReg_bits_pcEx = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_csr_in_mode_valid =
    stateReg_valid
    & (_io_csr_in_mcause_bits_T_4
         ? (|{_ignore_T_7, _ignore_T_5, _ignore_T_4, _ignore_T_3, _ignore_T_2})
         : _ignore_T_5);
  assign io_csr_in_mode_bits = {1'h0, ~(_ignore_T_5 & _io_csr_in_fault_T)};
  assign io_csr_in_mcause_valid =
    stateReg_valid & (usageFault | _ignore_T_3 | _io_csr_in_mcause_bits_T_4 & _ignore_T_2)
    | io_fault_manager_valid;
  assign io_csr_in_mcause_bits =
    io_fault_manager_valid
      ? io_fault_manager_bits_mcause
      : {27'h0,
         _ignore_T_3 & _io_csr_in_fault_T
           ? 5'hB
           : _ignore_T_3 & _io_csr_in_mcause_bits_T_4
               ? 5'h8
               : _ignore_T_2 ? 5'h3 : usageFault ? 5'h19 : 5'h0};
  assign io_csr_in_mepc_valid = stateReg_valid & _ignore_T_3 | io_fault_manager_valid;
  assign io_csr_in_mepc_bits =
    io_fault_manager_valid ? io_fault_manager_bits_mepc : stateReg_bits_pcEx;
  assign io_csr_in_mtval_valid = usageFault | io_fault_manager_valid;
  assign io_csr_in_mtval_bits =
    io_fault_manager_valid ? io_fault_manager_bits_mtval : stateReg_bits_pcEx;
  assign io_csr_in_halt =
    stateReg_valid & _ignore_T_4 & _io_csr_in_fault_T | io_csr_in_fault_0;
  assign io_csr_in_fault = io_csr_in_fault_0;
  assign io_csr_in_wfi = stateReg_valid & _ignore_T_6;
  assign io_rd_valid = stateReg_valid & stateReg_bits_linkValid;
  assign io_rd_bits_addr = stateReg_bits_linkAddr;
  assign io_rd_bits_data = stateReg_bits_linkData;
  assign io_taken_valid =
    stateReg_valid
    & (stateReg_bits_op == 4'hD
       | (stateReg_bits_op == 4'h7
            ? io_rs1_data >= io_rs2_data != stateReg_bits_fwd
            : stateReg_bits_op == 4'h6
                ? io_rs1_data < io_rs2_data != stateReg_bits_fwd
                : stateReg_bits_op == 4'h5
                    ? $signed(io_rs1_data) >= $signed(io_rs2_data) != stateReg_bits_fwd
                    : stateReg_bits_op == 4'h4
                        ? $signed(io_rs1_data) < $signed(io_rs2_data) != stateReg_bits_fwd
                        : stateReg_bits_op == 4'h3
                            ? io_rs1_data != io_rs2_data != stateReg_bits_fwd
                            : stateReg_bits_op == 4'h2
                                ? io_rs1_data == io_rs2_data != stateReg_bits_fwd
                                : stateReg_bits_op == 4'h1 | ~(|stateReg_bits_op)
                                    ? ~stateReg_bits_fwd
                                    : stateReg_bits_op == 4'hC
                                      | (stateReg_bits_op == 4'hB
                                           ? _io_csr_in_fault_T
                                           : stateReg_bits_op == 4'hA
                                               ? _io_csr_in_mcause_bits_T_4
                                               : stateReg_bits_op == 4'h9
                                                 | stateReg_bits_op == 4'h8
                                                 & _io_csr_in_mcause_bits_T_4)));
  assign io_taken_value = stateReg_bits_target;
  assign io_interlock =
    stateReg_valid & (|{_ignore_T_7, _ignore_T_5, _ignore_T_4, _ignore_T_3, _ignore_T_2});
endmodule

module Bru_1(
  input         clock,
                reset,
                io_req_valid,
                io_req_bits_fwd,
  input  [3:0]  io_req_bits_op,
  input  [31:0] io_req_bits_pc,
                io_req_bits_target,
  input  [4:0]  io_req_bits_link,
  input         io_rs1_valid,
  input  [31:0] io_rs1_data,
  input         io_rs2_valid,
  input  [31:0] io_rs2_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data,
  output        io_taken_valid,
  output [31:0] io_taken_value,
  input  [31:0] io_target_data
);

  reg         stateReg_valid;
  reg         stateReg_bits_fwd;
  reg  [3:0]  stateReg_bits_op;
  reg  [31:0] stateReg_bits_target;
  reg         stateReg_bits_linkValid;
  reg  [4:0]  stateReg_bits_linkAddr;
  reg  [31:0] stateReg_bits_linkData;
  wire        _ignore_T_2 = stateReg_bits_op == 4'h8;
  wire        _ignore_T_3 = stateReg_bits_op == 4'h9;
  wire        _ignore_T_4 = stateReg_bits_op == 4'hA;
  wire        _ignore_T_5 = stateReg_bits_op == 4'hB;
  wire        _ignore_T_6 = stateReg_bits_op == 4'hC;
  wire [31:0] nextState_linkData = io_req_bits_pc + 32'h4;
  wire        _nextState_target_T = io_req_bits_op == 4'h1;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      stateReg_valid <= 1'h0;
      stateReg_bits_fwd <= 1'h0;
      stateReg_bits_op <= 4'h0;
      stateReg_bits_target <= 32'h0;
      stateReg_bits_linkValid <= 1'h0;
      stateReg_bits_linkAddr <= 5'h0;
      stateReg_bits_linkData <= 32'h0;
    end
    else begin
      stateReg_valid <= io_req_valid;
      if (io_req_valid) begin
        stateReg_bits_fwd <= io_req_valid & io_req_bits_fwd;
        stateReg_bits_op <= io_req_bits_op;
        stateReg_bits_target <=
          io_req_bits_fwd
            ? nextState_linkData
            : _nextState_target_T ? io_target_data & 32'hFFFFFFFE : io_req_bits_target;
        stateReg_bits_linkValid <=
          io_req_valid & (|io_req_bits_link)
          & (|{_nextState_target_T, io_req_bits_op == 4'h0});
        stateReg_bits_linkAddr <= io_req_bits_link;
        stateReg_bits_linkData <= nextState_linkData;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        stateReg_valid = _RANDOM[2'h0][0];
        stateReg_bits_fwd = _RANDOM[2'h0][1];
        stateReg_bits_op = _RANDOM[2'h0][5:2];
        stateReg_bits_target = {_RANDOM[2'h0][31:6], _RANDOM[2'h1][5:0]};
        stateReg_bits_linkValid = _RANDOM[2'h2][6];
        stateReg_bits_linkAddr = _RANDOM[2'h2][11:7];
        stateReg_bits_linkData = {_RANDOM[2'h2][31:12], _RANDOM[2'h3][11:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        stateReg_valid = 1'h0;
        stateReg_bits_fwd = 1'h0;
        stateReg_bits_op = 4'h0;
        stateReg_bits_target = 32'h0;
        stateReg_bits_linkValid = 1'h0;
        stateReg_bits_linkAddr = 5'h0;
        stateReg_bits_linkData = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_rd_valid = stateReg_valid & stateReg_bits_linkValid;
  assign io_rd_bits_addr = stateReg_bits_linkAddr;
  assign io_rd_bits_data = stateReg_bits_linkData;
  assign io_taken_valid =
    stateReg_valid
    & (stateReg_bits_op == 4'hD
       | (stateReg_bits_op == 4'h7
            ? io_rs1_data >= io_rs2_data != stateReg_bits_fwd
            : stateReg_bits_op == 4'h6
                ? io_rs1_data < io_rs2_data != stateReg_bits_fwd
                : stateReg_bits_op == 4'h5
                    ? $signed(io_rs1_data) >= $signed(io_rs2_data) != stateReg_bits_fwd
                    : stateReg_bits_op == 4'h4
                        ? $signed(io_rs1_data) < $signed(io_rs2_data) != stateReg_bits_fwd
                        : stateReg_bits_op == 4'h3
                            ? io_rs1_data != io_rs2_data != stateReg_bits_fwd
                            : stateReg_bits_op == 4'h2
                                ? io_rs1_data == io_rs2_data != stateReg_bits_fwd
                                : (stateReg_bits_op == 4'h1 | ~(|stateReg_bits_op))
                                  & ~stateReg_bits_fwd));
  assign io_taken_value = stateReg_bits_target;
endmodule

module Arbiter4_MluCmd(
  input        io_in_0_valid,
  input  [4:0] io_in_0_bits_addr,
  input  [2:0] io_in_0_bits_op,
  output       io_in_1_ready,
  input        io_in_1_valid,
  input  [4:0] io_in_1_bits_addr,
  input  [2:0] io_in_1_bits_op,
  output       io_in_2_ready,
  input        io_in_2_valid,
  input  [4:0] io_in_2_bits_addr,
  input  [2:0] io_in_2_bits_op,
  output       io_in_3_ready,
  input        io_in_3_valid,
  input  [4:0] io_in_3_bits_addr,
  input  [2:0] io_in_3_bits_op,
  output       io_out_valid,
  output [4:0] io_out_bits_addr,
  output [2:0] io_out_bits_op,
  output [1:0] io_chosen
);

  wire _grant_T = io_in_0_valid | io_in_1_valid;
  wire _io_out_valid_T = _grant_T | io_in_2_valid;
  assign io_in_1_ready = ~io_in_0_valid;
  assign io_in_2_ready = ~_grant_T;
  assign io_in_3_ready = ~_io_out_valid_T;
  assign io_out_valid = _io_out_valid_T | io_in_3_valid;
  assign io_out_bits_addr =
    io_in_0_valid
      ? io_in_0_bits_addr
      : io_in_1_valid
          ? io_in_1_bits_addr
          : io_in_2_valid ? io_in_2_bits_addr : io_in_3_bits_addr;
  assign io_out_bits_op =
    io_in_0_valid
      ? io_in_0_bits_op
      : io_in_1_valid
          ? io_in_1_bits_op
          : io_in_2_valid ? io_in_2_bits_op : io_in_3_bits_op;
  assign io_chosen = io_in_0_valid ? 2'h0 : io_in_1_valid ? 2'h1 : {1'h1, ~io_in_2_valid};
endmodule

module Queue1_MluStage1(
  input        clock,
               reset,
               io_enq_valid,
  input  [4:0] io_enq_bits_rd,
  input  [2:0] io_enq_bits_op,
  input  [3:0] io_enq_bits_sel,
  output       io_deq_valid,
  output [4:0] io_deq_bits_rd,
  output [2:0] io_deq_bits_op,
  output [3:0] io_deq_bits_sel
);

  reg [11:0] ram;
  reg        full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(io_enq_valid == full))
      full <= io_enq_valid;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_enq_valid)
      ram <= {io_enq_bits_rd, io_enq_bits_op, io_enq_bits_sel};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        full = _RANDOM[/*Zero width*/ 1'b0][0];
        ram = _RANDOM[/*Zero width*/ 1'b0][12:1];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_rd = ram[11:7];
  assign io_deq_bits_op = ram[6:4];
  assign io_deq_bits_sel = ram[3:0];
endmodule

module Queue1_MluStage2(
  input         clock,
                reset,
                io_enq_valid,
  input  [4:0]  io_enq_bits_rd,
  input  [2:0]  io_enq_bits_op,
  input  [65:0] io_enq_bits_prod,
  output        io_deq_valid,
  output [4:0]  io_deq_bits_rd,
  output [2:0]  io_deq_bits_op,
  output [65:0] io_deq_bits_prod
);

  reg [73:0] ram;
  reg        full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(io_enq_valid == full))
      full <= io_enq_valid;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (io_enq_valid)
      ram <= {io_enq_bits_rd, io_enq_bits_op, io_enq_bits_prod};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2][10:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_rd = ram[73:69];
  assign io_deq_bits_op = ram[68:66];
  assign io_deq_bits_prod = ram[65:0];
endmodule

module Mlu(
  input         clock,
                reset,
                io_req_0_valid,
  input  [4:0]  io_req_0_bits_addr,
  input  [2:0]  io_req_0_bits_op,
  output        io_req_1_ready,
  input         io_req_1_valid,
  input  [4:0]  io_req_1_bits_addr,
  input  [2:0]  io_req_1_bits_op,
  output        io_req_2_ready,
  input         io_req_2_valid,
  input  [4:0]  io_req_2_bits_addr,
  input  [2:0]  io_req_2_bits_op,
  output        io_req_3_ready,
  input         io_req_3_valid,
  input  [4:0]  io_req_3_bits_addr,
  input  [2:0]  io_req_3_bits_op,
  input         io_rs1_0_valid,
  input  [31:0] io_rs1_0_data,
  input         io_rs1_1_valid,
  input  [31:0] io_rs1_1_data,
  input         io_rs1_2_valid,
  input  [31:0] io_rs1_2_data,
  input         io_rs1_3_valid,
  input  [31:0] io_rs1_3_data,
  input         io_rs2_0_valid,
  input  [31:0] io_rs2_0_data,
  input         io_rs2_1_valid,
  input  [31:0] io_rs2_1_data,
  input         io_rs2_2_valid,
  input  [31:0] io_rs2_2_data,
  input         io_rs2_3_valid,
  input  [31:0] io_rs2_3_data,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  wire [2:0]  _stage3Input_q_io_deq_bits_op;
  wire [65:0] _stage3Input_q_io_deq_bits_prod;
  wire        _stage2Input_q_io_deq_valid;
  wire [4:0]  _stage2Input_q_io_deq_bits_rd;
  wire [2:0]  _stage2Input_q_io_deq_bits_op;
  wire [3:0]  _stage2Input_q_io_deq_bits_sel;
  wire        _arb_io_out_valid;
  wire [4:0]  _arb_io_out_bits_addr;
  wire [2:0]  _arb_io_out_bits_op;
  wire [1:0]  _arb_io_chosen;
  wire [31:0] rs1 =
    (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[0]
       ? io_rs1_0_data
       : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[1]
         ? io_rs1_1_data
         : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[2]
         ? io_rs1_2_data
         : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[3]
         ? io_rs1_3_data
         : 32'h0);
  wire [31:0] rs2 =
    (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[0]
       ? io_rs2_0_data
       : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[1]
         ? io_rs2_1_data
         : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[2]
         ? io_rs2_2_data
         : 32'h0)
    | (_stage2Input_q_io_deq_valid & _stage2Input_q_io_deq_bits_sel[3]
         ? io_rs2_3_data
         : 32'h0);
  wire        rs2signed = _stage2Input_q_io_deq_bits_op == 3'h1;
  Arbiter4_MluCmd arb (
    .io_in_0_valid     (io_req_0_valid),
    .io_in_0_bits_addr (io_req_0_bits_addr),
    .io_in_0_bits_op   (io_req_0_bits_op),
    .io_in_1_ready     (io_req_1_ready),
    .io_in_1_valid     (io_req_1_valid),
    .io_in_1_bits_addr (io_req_1_bits_addr),
    .io_in_1_bits_op   (io_req_1_bits_op),
    .io_in_2_ready     (io_req_2_ready),
    .io_in_2_valid     (io_req_2_valid),
    .io_in_2_bits_addr (io_req_2_bits_addr),
    .io_in_2_bits_op   (io_req_2_bits_op),
    .io_in_3_ready     (io_req_3_ready),
    .io_in_3_valid     (io_req_3_valid),
    .io_in_3_bits_addr (io_req_3_bits_addr),
    .io_in_3_bits_op   (io_req_3_bits_op),
    .io_out_valid      (_arb_io_out_valid),
    .io_out_bits_addr  (_arb_io_out_bits_addr),
    .io_out_bits_op    (_arb_io_out_bits_op),
    .io_chosen         (_arb_io_chosen)
  );
  Queue1_MluStage1 stage2Input_q (
    .clock           (clock),
    .reset           (reset),
    .io_enq_valid    (_arb_io_out_valid),
    .io_enq_bits_rd  (_arb_io_out_bits_addr),
    .io_enq_bits_op  (_arb_io_out_bits_op),
    .io_enq_bits_sel (4'h1 << _arb_io_chosen),
    .io_deq_valid    (_stage2Input_q_io_deq_valid),
    .io_deq_bits_rd  (_stage2Input_q_io_deq_bits_rd),
    .io_deq_bits_op  (_stage2Input_q_io_deq_bits_op),
    .io_deq_bits_sel (_stage2Input_q_io_deq_bits_sel)
  );
  Queue1_MluStage2 stage3Input_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_valid     (_stage2Input_q_io_deq_valid),
    .io_enq_bits_rd   (_stage2Input_q_io_deq_bits_rd),
    .io_enq_bits_op   (_stage2Input_q_io_deq_bits_op),
    .io_enq_bits_prod
      ({{34{(_stage2Input_q_io_deq_bits_op == 3'h2 | rs2signed) & rs1[31]}}, rs1}
       * {{34{rs2signed & rs2[31]}}, rs2}),
    .io_deq_valid     (io_rd_valid),
    .io_deq_bits_rd   (io_rd_bits_addr),
    .io_deq_bits_op   (_stage3Input_q_io_deq_bits_op),
    .io_deq_bits_prod (_stage3Input_q_io_deq_bits_prod)
  );
  assign io_rd_bits_data =
    _stage3Input_q_io_deq_bits_op == 3'h0
      ? _stage3Input_q_io_deq_bits_prod[31:0]
      : _stage3Input_q_io_deq_bits_prod[63:32];
endmodule

module Dvu(
  input         clock,
                reset,
  output        io_req_ready,
  input         io_req_valid,
  input  [4:0]  io_req_bits_addr,
  input  [1:0]  io_req_bits_op,
  input  [31:0] io_rs1_data,
                io_rs2_data,
  input         io_rd_ready,
  output        io_rd_valid,
  output [4:0]  io_rd_bits_addr,
  output [31:0] io_rd_bits_data
);

  reg         active;
  reg         compute;
  reg  [4:0]  addr1;
  reg         signed1;
  reg         divide1;
  reg  [4:0]  addr2;
  reg         signed2d;
  reg         signed2r;
  reg         divide2;
  reg  [5:0]  count;
  reg  [31:0] divide;
  reg  [31:0] remain;
  reg  [31:0] denom;
  wire        io_req_ready_0 = ~active & ~compute & ~(count[5]);
  wire        _divide1_T_1 = io_req_bits_op == 2'h0;
  wire [31:0] inp = signed1 & io_rs1_data[31] ? ~io_rs1_data + 32'h1 : io_rs1_data;
  wire [15:0] _clz_T_12 = {8'h0, inp[15:8]} | {inp[7:0], 8'h0};
  wire [15:0] _clz_T_22 =
    {4'h0, _clz_T_12[15:4] & 12'hF0F} | {_clz_T_12[11:0] & 12'hF0F, 4'h0};
  wire [15:0] _clz_T_32 =
    {2'h0, _clz_T_22[15:2] & 14'h3333} | {_clz_T_22[13:0] & 14'h3333, 2'h0};
  wire [14:0] _clz_T_42 =
    _clz_T_32[15:1] & 15'h5555 | {1'h0, _clz_T_32[12:0] & 13'h1555, 1'h0};
  wire [7:0]  _clz_T_53 = {4'h0, inp[23:20]} | {inp[19:16], 4'h0};
  wire [7:0]  _clz_T_63 = {2'h0, _clz_T_53[7:2] & 6'h33} | {_clz_T_53[5:0] & 6'h33, 2'h0};
  wire [7:0]  _clz_T_73 = {1'h0, _clz_T_63[7:1] & 7'h55} | {_clz_T_63[6:0] & 7'h55, 1'h0};
  wire [4:0]  clz =
    ~(|io_rs2_data) | inp[31] | inp[30]
      ? 5'h0
      : inp[29]
          ? 5'h1
          : inp[28]
              ? 5'h2
              : inp[27]
                  ? 5'h3
                  : inp[26]
                      ? 5'h4
                      : inp[25]
                          ? 5'h5
                          : inp[24]
                              ? 5'h6
                              : _clz_T_73[0]
                                  ? 5'h7
                                  : _clz_T_73[1]
                                      ? 5'h8
                                      : _clz_T_73[2]
                                          ? 5'h9
                                          : _clz_T_73[3]
                                              ? 5'hA
                                              : _clz_T_73[4]
                                                  ? 5'hB
                                                  : _clz_T_73[5]
                                                      ? 5'hC
                                                      : _clz_T_73[6]
                                                          ? 5'hD
                                                          : _clz_T_73[7]
                                                              ? 5'hE
                                                              : _clz_T_42[0]
                                                                  ? 5'hF
                                                                  : _clz_T_42[1]
                                                                      ? 5'h10
                                                                      : _clz_T_42[2]
                                                                          ? 5'h11
                                                                          : _clz_T_42[3]
                                                                              ? 5'h12
                                                                              : _clz_T_42[4]
                                                                                  ? 5'h13
                                                                                  : _clz_T_42[5]
                                                                                      ? 5'h14
                                                                                      : _clz_T_42[6]
                                                                                          ? 5'h15
                                                                                          : _clz_T_42[7]
                                                                                              ? 5'h16
                                                                                              : _clz_T_42[8]
                                                                                                  ? 5'h17
                                                                                                  : _clz_T_42[9]
                                                                                                      ? 5'h18
                                                                                                      : _clz_T_42[10]
                                                                                                          ? 5'h19
                                                                                                          : _clz_T_42[11]
                                                                                                              ? 5'h1A
                                                                                                              : _clz_T_42[12]
                                                                                                                  ? 5'h1B
                                                                                                                  : _clz_T_42[13]
                                                                                                                      ? 5'h1C
                                                                                                                      : _clz_T_42[14]
                                                                                                                          ? 5'h1D
                                                                                                                          : 5'h1E;
  wire [62:0] _divide_T = {31'h0, inp} << clz;
  wire [32:0] subtract = {1'h0, remain[30:0], divide[31]} - {1'h0, denom};
  wire        _divide1_T = io_req_valid & io_req_ready_0;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      active <= 1'h0;
      compute <= 1'h0;
      addr1 <= 5'h0;
      signed1 <= 1'h0;
      divide1 <= 1'h0;
      addr2 <= 5'h0;
      signed2d <= 1'h0;
      signed2r <= 1'h0;
      divide2 <= 1'h0;
      count <= 6'h0;
      divide <= 32'h0;
      remain <= 32'h0;
      denom <= 32'h0;
    end
    else begin
      active <= _divide1_T | count != 6'h1E & active;
      compute <= active;
      if (_divide1_T) begin
        addr1 <= io_req_bits_addr;
        signed1 <= |{io_req_bits_op == 2'h2, _divide1_T_1};
        divide1 <= |{io_req_bits_op == 2'h1, _divide1_T_1};
      end
      if (active & ~compute) begin
        addr2 <= addr1;
        signed2d <= signed1 & io_rs1_data[31] != io_rs2_data[31] & (|io_rs2_data);
        signed2r <= signed1 & io_rs1_data[31];
        divide2 <= divide1;
        count <= {1'h0, clz};
        divide <= _divide_T[31:0];
        remain <= 32'h0;
        denom <= signed1 & io_rs2_data[31] ? ~io_rs2_data + 32'h1 : io_rs2_data;
      end
      else if (compute & ~(count[5])) begin
        count <= count + 6'h1;
        divide <= subtract[32] ? {divide[30:0], 1'h0} : {divide[30:0], 1'h1};
        remain <= subtract[32] ? {remain[30:0], divide[31]} : subtract[31:0];
      end
      else if (count[5] & io_rd_ready)
        count <= 6'h0;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        active = _RANDOM[2'h0][0];
        compute = _RANDOM[2'h0][1];
        addr1 = _RANDOM[2'h0][6:2];
        signed1 = _RANDOM[2'h0][7];
        divide1 = _RANDOM[2'h0][8];
        addr2 = _RANDOM[2'h0][13:9];
        signed2d = _RANDOM[2'h0][14];
        signed2r = _RANDOM[2'h0][15];
        divide2 = _RANDOM[2'h0][16];
        count = _RANDOM[2'h0][22:17];
        divide = {_RANDOM[2'h0][31:23], _RANDOM[2'h1][22:0]};
        remain = {_RANDOM[2'h1][31:23], _RANDOM[2'h2][22:0]};
        denom = {_RANDOM[2'h2][31:23], _RANDOM[2'h3][22:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        active = 1'h0;
        compute = 1'h0;
        addr1 = 5'h0;
        signed1 = 1'h0;
        divide1 = 1'h0;
        addr2 = 5'h0;
        signed2d = 1'h0;
        signed2r = 1'h0;
        divide2 = 1'h0;
        count = 6'h0;
        divide = 32'h0;
        remain = 32'h0;
        denom = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_req_ready = io_req_ready_0;
  assign io_rd_valid = count[5];
  assign io_rd_bits_addr = addr2;
  assign io_rd_bits_data =
    divide2 ? (signed2d ? ~divide + 32'h1 : divide) : signed2r ? ~remain + 32'h1 : remain;
endmodule

module Queue1_FloatInstruction(
  input         clock,
                reset,
                io_enq_valid,
  input  [2:0]  io_enq_bits_opcode,
  input  [4:0]  io_enq_bits_funct5,
                io_enq_bits_rs3,
                io_enq_bits_rs2,
                io_enq_bits_rs1,
  input  [2:0]  io_enq_bits_rm,
  input  [31:0] io_enq_bits_inst,
                io_enq_bits_pc,
  input         io_enq_bits_scalar_rd,
                io_enq_bits_scalar_rs1,
                io_enq_bits_float_rs1,
  input  [4:0]  io_enq_bits_rd,
  input         io_enq_bits_uses_rs3,
                io_enq_bits_uses_rs2,
                io_deq_ready,
  output        io_deq_valid,
  output [2:0]  io_deq_bits_opcode,
  output [4:0]  io_deq_bits_funct5,
                io_deq_bits_rs3,
                io_deq_bits_rs2,
                io_deq_bits_rs1,
  output [2:0]  io_deq_bits_rm,
  output        io_deq_bits_scalar_rd,
  output [4:0]  io_deq_bits_rd,
  output        io_count
);

  reg  [99:0] ram;
  wire        io_enq_ready;
  reg         full;
  wire        do_enq = io_enq_ready & io_enq_valid;
  assign io_enq_ready = ~full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(do_enq == (io_deq_ready & full)))
      full <= do_enq;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (do_enq)
      ram <=
        {io_enq_bits_opcode,
         io_enq_bits_funct5,
         io_enq_bits_rs3,
         io_enq_bits_rs2,
         io_enq_bits_rs1,
         io_enq_bits_rm,
         io_enq_bits_inst,
         io_enq_bits_pc,
         io_enq_bits_scalar_rd,
         io_enq_bits_scalar_rs1,
         io_enq_bits_float_rs1,
         io_enq_bits_rd,
         io_enq_bits_uses_rs3,
         io_enq_bits_uses_rs2};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:3];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [2:0] i = 3'h0; i < 3'h4; i += 3'h1) begin
          _RANDOM[i[1:0]] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2], _RANDOM[2'h3][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_deq_valid = full;
  assign io_deq_bits_opcode = ram[99:97];
  assign io_deq_bits_funct5 = ram[96:92];
  assign io_deq_bits_rs3 = ram[91:87];
  assign io_deq_bits_rs2 = ram[86:82];
  assign io_deq_bits_rs1 = ram[81:77];
  assign io_deq_bits_rm = ram[76:74];
  assign io_deq_bits_scalar_rd = ram[9];
  assign io_deq_bits_rd = ram[6:2];
  assign io_count = full;
endmodule


// Include rmemory initializers in init blocks unless synthesis is set
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_MEM_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_MEM_INIT
`endif // not def RANDOMIZE
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

// VCS coverage exclude_module
module ram_2x37(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [36:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [36:0] W0_data
);

  reg [36:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [63:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h40; j += 7'h20) begin
            _RANDOM_MEM[j[5:0] +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[36:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 37'bx;
endmodule

module Queue2_RegfileWriteDataIO(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [4:0]  io_enq_bits_addr,
  input  [31:0] io_enq_bits_data,
  input         io_deq_ready,
  output        io_deq_valid,
  output [4:0]  io_deq_bits_addr,
  output [31:0] io_deq_bits_data
);

  wire [36:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  wire        do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x37 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_addr, io_enq_bits_data})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_addr = _ram_ext_R0_data[36:32];
  assign io_deq_bits_data = _ram_ext_R0_data[31:0];
endmodule

module FloatCore(
  input         clock,
                reset,
  output        io_inst_ready,
  input         io_inst_valid,
  input  [2:0]  io_inst_bits_opcode,
  input  [4:0]  io_inst_bits_funct5,
                io_inst_bits_rs3,
                io_inst_bits_rs2,
                io_inst_bits_rs1,
  input  [2:0]  io_inst_bits_rm,
  input  [31:0] io_inst_bits_inst,
                io_inst_bits_pc,
  input         io_inst_bits_scalar_rd,
                io_inst_bits_scalar_rs1,
                io_inst_bits_float_rs1,
  input  [4:0]  io_inst_bits_rd,
  input         io_inst_bits_uses_rs3,
                io_inst_bits_uses_rs2,
  output        io_read_ports_0_valid,
  output [4:0]  io_read_ports_0_addr,
  input  [22:0] io_read_ports_0_data_mantissa,
  input  [7:0]  io_read_ports_0_data_exponent,
  input         io_read_ports_0_data_sign,
  output        io_read_ports_1_valid,
  output [4:0]  io_read_ports_1_addr,
  input  [22:0] io_read_ports_1_data_mantissa,
  input  [7:0]  io_read_ports_1_data_exponent,
  input         io_read_ports_1_data_sign,
  output        io_read_ports_2_valid,
  output [4:0]  io_read_ports_2_addr,
  input  [22:0] io_read_ports_2_data_mantissa,
  input  [7:0]  io_read_ports_2_data_exponent,
  input         io_read_ports_2_data_sign,
  output        io_write_ports_0_valid,
  output [4:0]  io_write_ports_0_addr,
  output [22:0] io_write_ports_0_data_mantissa,
  output [7:0]  io_write_ports_0_data_exponent,
  output        io_write_ports_0_data_sign,
                io_write_ports_1_valid,
  output [4:0]  io_write_ports_1_addr,
  output [22:0] io_write_ports_1_data_mantissa,
  output [7:0]  io_write_ports_1_data_exponent,
  output        io_write_ports_1_data_sign,
  input  [31:0] io_rs1_data,
  input         io_scalar_rd_ready,
  output        io_scalar_rd_valid,
  output [4:0]  io_scalar_rd_bits_addr,
  output [31:0] io_scalar_rd_bits_data,
  output        io_csr_in_fflags_valid,
  output [4:0]  io_csr_in_fflags_bits,
  input  [2:0]  io_csr_out_frm,
  input         io_lsu_rd_valid,
  input  [4:0]  io_lsu_rd_bits_addr,
  input  [31:0] io_lsu_rd_bits_data
);

  wire            instQueue_io_deq_ready;
  wire            _floatCoreWrapper_io_out_ready_i_T_4;
  wire            _floatCoreWrapper_io_in_valid_i_T_4;
  wire            _scalar_rd_pipe_q_io_enq_ready;
  wire            _floatCoreWrapper_in_ready_o;
  wire            _floatCoreWrapper_out_valid_o;
  wire [31:0]     _floatCoreWrapper_result_o;
  wire            _floatCoreWrapper_status_o_0;
  wire            _floatCoreWrapper_status_o_1;
  wire            _floatCoreWrapper_status_o_2;
  wire            _floatCoreWrapper_status_o_3;
  wire            _floatCoreWrapper_status_o_4;
  wire            _instQueue_io_deq_valid;
  wire [2:0]      _instQueue_io_deq_bits_opcode;
  wire [4:0]      _instQueue_io_deq_bits_funct5;
  wire [4:0]      _instQueue_io_deq_bits_rs3;
  wire [4:0]      _instQueue_io_deq_bits_rs2;
  wire [4:0]      _instQueue_io_deq_bits_rs1;
  wire [2:0]      _instQueue_io_deq_bits_rm;
  wire            _instQueue_io_deq_bits_scalar_rd;
  wire [4:0]      _instQueue_io_deq_bits_rd;
  wire            _instQueue_io_count;
  wire            _opfp_mod_T_6 = _instQueue_io_deq_bits_funct5 == 5'h4;
  wire            _opfp_mod_T_8 = _instQueue_io_deq_bits_funct5 == 5'h18;
  wire            _fmv_x_w_T_2 = _instQueue_io_deq_bits_funct5 == 5'h1C;
  wire            _opfp_mod_T_10 = _instQueue_io_deq_bits_funct5 == 5'h1A;
  wire [3:0]      opfp_operation =
    _opfp_mod_T_10
      ? 4'hC
      : _fmv_x_w_T_2
          ? 4'h9
          : _instQueue_io_deq_bits_funct5 == 5'h14
              ? 4'h8
              : _opfp_mod_T_8
                  ? 4'hB
                  : {1'h0,
                     _instQueue_io_deq_bits_funct5 == 5'h5
                       ? 3'h7
                       : _opfp_mod_T_6
                           ? 3'h6
                           : _instQueue_io_deq_bits_funct5 == 5'hB
                               ? 3'h5
                               : _instQueue_io_deq_bits_funct5 == 5'h3
                                   ? 3'h4
                                   : {2'h1, _instQueue_io_deq_bits_funct5 == 5'h2}};
  wire [7:0][3:0] _GEN =
    {{4'h2}, {4'h1}, {4'h1}, {4'h0}, {4'h0}, {opfp_operation}, {4'hF}, {4'h2}};
  wire [3:0]      op_i = _GEN[_instQueue_io_deq_bits_opcode];
  wire            _read_port_2_valid_T = op_i == 4'h0;
  wire            _read_port_2_valid_T_1 = op_i == 4'h1;
  wire            _fmv_w_x_T = _instQueue_io_deq_bits_opcode == 3'h2;
  wire            _floatCoreWrapper_io_operands_i_0_T_1 = opfp_operation == 4'hC;
  wire            _fmv_w_x_T_4 = _instQueue_io_deq_bits_rm == 3'h0;
  wire            fmv_x_w =
    _instQueue_io_deq_valid & _fmv_w_x_T & _fmv_x_w_T_2 & _fmv_w_x_T_4;
  wire            fmv_w_x =
    _instQueue_io_deq_valid & _fmv_w_x_T & _instQueue_io_deq_bits_funct5 == 5'h1E
    & _fmv_w_x_T_4;
  wire            fmv = fmv_x_w | fmv_w_x;
  wire            _op2_addr_T = op_i == 4'h2;
  wire            inst_rm_valid =
    _instQueue_io_deq_bits_rm == 3'h0 | _instQueue_io_deq_bits_rm == 3'h1
    | _instQueue_io_deq_bits_rm == 3'h2 | _instQueue_io_deq_bits_rm == 3'h3
    | _instQueue_io_deq_bits_rm == 3'h4 | (&_instQueue_io_deq_bits_rm);
  wire            csr_rm_valid =
    io_csr_out_frm == 3'h0 | io_csr_out_frm == 3'h1 | io_csr_out_frm == 3'h2
    | io_csr_out_frm == 3'h3 | io_csr_out_frm == 3'h4 | (&io_csr_out_frm);
  reg             fpuActive;
  wire            _io_csr_in_fflags_valid_T =
    instQueue_io_deq_ready & _instQueue_io_deq_valid;
  wire            _instQueue_io_deq_ready_T =
    _floatCoreWrapper_io_in_valid_i_T_4 & _floatCoreWrapper_in_ready_o;
  assign _floatCoreWrapper_io_in_valid_i_T_4 =
    _instQueue_io_deq_valid & ~fmv & ~fpuActive & inst_rm_valid
    & (~(&_instQueue_io_deq_bits_rm) | ~(~csr_rm_valid | csr_rm_valid & (&io_csr_out_frm))
       & csr_rm_valid);
  wire [31:0]     _io_write_ports_0_data_T =
    fmv_w_x ? io_rs1_data : _floatCoreWrapper_result_o;
  assign _floatCoreWrapper_io_out_ready_i_T_4 =
    _instQueue_io_deq_valid & _instQueue_io_deq_bits_scalar_rd
    & _scalar_rd_pipe_q_io_enq_ready | _instQueue_io_deq_valid
    & ~_instQueue_io_deq_bits_scalar_rd;
  assign instQueue_io_deq_ready =
    (_instQueue_io_deq_ready_T | fpuActive) & _floatCoreWrapper_io_out_ready_i_T_4
    & _floatCoreWrapper_out_valid_o | fmv;
  always @(posedge clock or posedge reset) begin
    if (reset)
      fpuActive <= 1'h0;
    else
      fpuActive <= ~_io_csr_in_fflags_valid_T & (_instQueue_io_deq_ready_T | fpuActive);
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        fpuActive = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        fpuActive = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue1_FloatInstruction instQueue (
    .clock                  (clock),
    .reset                  (reset),
    .io_enq_valid           (io_inst_valid),
    .io_enq_bits_opcode     (io_inst_bits_opcode),
    .io_enq_bits_funct5     (io_inst_bits_funct5),
    .io_enq_bits_rs3        (io_inst_bits_rs3),
    .io_enq_bits_rs2        (io_inst_bits_rs2),
    .io_enq_bits_rs1        (io_inst_bits_rs1),
    .io_enq_bits_rm         (io_inst_bits_rm),
    .io_enq_bits_inst       (io_inst_bits_inst),
    .io_enq_bits_pc         (io_inst_bits_pc),
    .io_enq_bits_scalar_rd  (io_inst_bits_scalar_rd),
    .io_enq_bits_scalar_rs1 (io_inst_bits_scalar_rs1),
    .io_enq_bits_float_rs1  (io_inst_bits_float_rs1),
    .io_enq_bits_rd         (io_inst_bits_rd),
    .io_enq_bits_uses_rs3   (io_inst_bits_uses_rs3),
    .io_enq_bits_uses_rs2   (io_inst_bits_uses_rs2),
    .io_deq_ready           (instQueue_io_deq_ready),
    .io_deq_valid           (_instQueue_io_deq_valid),
    .io_deq_bits_opcode     (_instQueue_io_deq_bits_opcode),
    .io_deq_bits_funct5     (_instQueue_io_deq_bits_funct5),
    .io_deq_bits_rs3        (_instQueue_io_deq_bits_rs3),
    .io_deq_bits_rs2        (_instQueue_io_deq_bits_rs2),
    .io_deq_bits_rs1        (_instQueue_io_deq_bits_rs1),
    .io_deq_bits_rm         (_instQueue_io_deq_bits_rm),
    .io_deq_bits_scalar_rd  (_instQueue_io_deq_bits_scalar_rd),
    .io_deq_bits_rd         (_instQueue_io_deq_bits_rd),
    .io_count               (_instQueue_io_count)
  );
  FloatCoreWrapper floatCoreWrapper (
    .clk_i         (clock),
    .rst_ni        (~reset),
    .in_valid_i    (_floatCoreWrapper_io_in_valid_i_T_4),
    .in_ready_o    (_floatCoreWrapper_in_ready_o),
    .operands_i_0
      (_fmv_w_x_T & _floatCoreWrapper_io_operands_i_0_T_1
         ? io_rs1_data
         : {io_read_ports_0_data_sign,
            io_read_ports_0_data_exponent,
            io_read_ports_0_data_mantissa}),
    .operands_i_1
      ({io_read_ports_1_data_sign,
        io_read_ports_1_data_exponent,
        io_read_ports_1_data_mantissa}),
    .operands_i_2
      ({io_read_ports_2_data_sign,
        io_read_ports_2_data_exponent,
        io_read_ports_2_data_mantissa}),
    .op_i          (op_i),
    .op_mod_i
      (_instQueue_io_deq_bits_opcode != 3'h6
       & (_instQueue_io_deq_bits_opcode == 3'h5 | _instQueue_io_deq_bits_opcode == 3'h4
          | _instQueue_io_deq_bits_opcode != 3'h3 & _instQueue_io_deq_bits_opcode == 3'h2
          & (_opfp_mod_T_10 | _opfp_mod_T_8
               ? _instQueue_io_deq_bits_rs2[0]
               : _opfp_mod_T_6 | _instQueue_io_deq_bits_funct5 == 5'h1))),
    .rnd_mode_i
      (inst_rm_valid & (&_instQueue_io_deq_bits_rm)
         ? io_csr_out_frm
         : _instQueue_io_deq_bits_rm),
    .flush_i       (1'h0),
    .out_valid_o   (_floatCoreWrapper_out_valid_o),
    .out_ready_i   (_floatCoreWrapper_io_out_ready_i_T_4),
    .result_o      (_floatCoreWrapper_result_o),
    .status_o_0    (_floatCoreWrapper_status_o_0),
    .status_o_1    (_floatCoreWrapper_status_o_1),
    .status_o_2    (_floatCoreWrapper_status_o_2),
    .status_o_3    (_floatCoreWrapper_status_o_3),
    .status_o_4    (_floatCoreWrapper_status_o_4),
    .busy_o        (/* unused */),
    .early_valid_o (/* unused */)
  );
  Queue2_RegfileWriteDataIO scalar_rd_pipe_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_scalar_rd_pipe_q_io_enq_ready),
    .io_enq_valid
      ((_instQueue_io_deq_ready_T | fpuActive) & _floatCoreWrapper_out_valid_o
       & _floatCoreWrapper_io_out_ready_i_T_4 & _instQueue_io_deq_bits_scalar_rd
       | fmv_x_w),
    .io_enq_bits_addr (_instQueue_io_deq_bits_rd),
    .io_enq_bits_data
      (fmv_x_w
         ? {io_read_ports_0_data_sign,
            io_read_ports_0_data_exponent,
            io_read_ports_0_data_mantissa}
         : _floatCoreWrapper_result_o),
    .io_deq_ready     (io_scalar_rd_ready),
    .io_deq_valid     (io_scalar_rd_valid),
    .io_deq_bits_addr (io_scalar_rd_bits_addr),
    .io_deq_bits_data (io_scalar_rd_bits_data)
  );
  assign io_inst_ready = ~_instQueue_io_count;
  assign io_read_ports_0_valid = op_i != 4'h2 & _instQueue_io_deq_valid;
  assign io_read_ports_0_addr = _instQueue_io_deq_bits_rs1;
  assign io_read_ports_1_valid =
    ((|{_read_port_2_valid_T_1, _read_port_2_valid_T}) | _fmv_w_x_T
     & {_floatCoreWrapper_io_operands_i_0_T_1,
        opfp_operation == 4'hB,
        opfp_operation == 4'h9,
        opfp_operation == 4'h5} == 4'h0) & _instQueue_io_deq_valid;
  assign io_read_ports_1_addr =
    _op2_addr_T ? _instQueue_io_deq_bits_rs1 : _instQueue_io_deq_bits_rs2;
  assign io_read_ports_2_valid =
    ((|{_read_port_2_valid_T_1, _read_port_2_valid_T}) | _fmv_w_x_T
     & opfp_operation == 4'h2) & _instQueue_io_deq_valid;
  assign io_read_ports_2_addr =
    _op2_addr_T ? _instQueue_io_deq_bits_rs2 : _instQueue_io_deq_bits_rs3;
  assign io_write_ports_0_valid =
    (_floatCoreWrapper_out_valid_o & _io_csr_in_fflags_valid_T
     & ~_instQueue_io_deq_bits_scalar_rd | fmv_w_x)
    & ~(_instQueue_io_deq_valid & _instQueue_io_deq_bits_opcode == 3'h1);
  assign io_write_ports_0_addr = _instQueue_io_deq_bits_rd;
  assign io_write_ports_0_data_mantissa = _io_write_ports_0_data_T[22:0];
  assign io_write_ports_0_data_exponent = _io_write_ports_0_data_T[30:23];
  assign io_write_ports_0_data_sign = _io_write_ports_0_data_T[31];
  assign io_write_ports_1_valid = io_lsu_rd_valid;
  assign io_write_ports_1_addr = io_lsu_rd_bits_addr;
  assign io_write_ports_1_data_mantissa = io_lsu_rd_bits_data[22:0];
  assign io_write_ports_1_data_exponent = io_lsu_rd_bits_data[30:23];
  assign io_write_ports_1_data_sign = io_lsu_rd_bits_data[31];
  assign io_csr_in_fflags_valid =
    _floatCoreWrapper_out_valid_o & _io_csr_in_fflags_valid_T & ~fmv;
  assign io_csr_in_fflags_bits =
    {_floatCoreWrapper_status_o_4,
     _floatCoreWrapper_status_o_3,
     _floatCoreWrapper_status_o_2,
     _floatCoreWrapper_status_o_1,
     _floatCoreWrapper_status_o_0};
endmodule

module FRegfile(
  input         clock,
                reset,
                io_read_ports_0_valid,
  input  [4:0]  io_read_ports_0_addr,
  output [22:0] io_read_ports_0_data_mantissa,
  output [7:0]  io_read_ports_0_data_exponent,
  output        io_read_ports_0_data_sign,
  input         io_read_ports_1_valid,
  input  [4:0]  io_read_ports_1_addr,
  output [22:0] io_read_ports_1_data_mantissa,
  output [7:0]  io_read_ports_1_data_exponent,
  output        io_read_ports_1_data_sign,
  input         io_read_ports_2_valid,
  input  [4:0]  io_read_ports_2_addr,
  output [22:0] io_read_ports_2_data_mantissa,
  output [7:0]  io_read_ports_2_data_exponent,
  output        io_read_ports_2_data_sign,
  input         io_write_ports_0_valid,
  input  [4:0]  io_write_ports_0_addr,
  input  [22:0] io_write_ports_0_data_mantissa,
  input  [7:0]  io_write_ports_0_data_exponent,
  input         io_write_ports_0_data_sign,
                io_write_ports_1_valid,
  input  [4:0]  io_write_ports_1_addr,
  input  [22:0] io_write_ports_1_data_mantissa,
  input  [7:0]  io_write_ports_1_data_exponent,
  input         io_write_ports_1_data_sign,
  input  [31:0] io_scoreboard_set,
  output [31:0] io_scoreboard,
                io_busPort_data_0,
  input  [4:0]  io_busPortAddr
);

  reg  [22:0]       fregfile_0_mantissa;
  reg  [7:0]        fregfile_0_exponent;
  reg               fregfile_0_sign;
  reg  [22:0]       fregfile_1_mantissa;
  reg  [7:0]        fregfile_1_exponent;
  reg               fregfile_1_sign;
  reg  [22:0]       fregfile_2_mantissa;
  reg  [7:0]        fregfile_2_exponent;
  reg               fregfile_2_sign;
  reg  [22:0]       fregfile_3_mantissa;
  reg  [7:0]        fregfile_3_exponent;
  reg               fregfile_3_sign;
  reg  [22:0]       fregfile_4_mantissa;
  reg  [7:0]        fregfile_4_exponent;
  reg               fregfile_4_sign;
  reg  [22:0]       fregfile_5_mantissa;
  reg  [7:0]        fregfile_5_exponent;
  reg               fregfile_5_sign;
  reg  [22:0]       fregfile_6_mantissa;
  reg  [7:0]        fregfile_6_exponent;
  reg               fregfile_6_sign;
  reg  [22:0]       fregfile_7_mantissa;
  reg  [7:0]        fregfile_7_exponent;
  reg               fregfile_7_sign;
  reg  [22:0]       fregfile_8_mantissa;
  reg  [7:0]        fregfile_8_exponent;
  reg               fregfile_8_sign;
  reg  [22:0]       fregfile_9_mantissa;
  reg  [7:0]        fregfile_9_exponent;
  reg               fregfile_9_sign;
  reg  [22:0]       fregfile_10_mantissa;
  reg  [7:0]        fregfile_10_exponent;
  reg               fregfile_10_sign;
  reg  [22:0]       fregfile_11_mantissa;
  reg  [7:0]        fregfile_11_exponent;
  reg               fregfile_11_sign;
  reg  [22:0]       fregfile_12_mantissa;
  reg  [7:0]        fregfile_12_exponent;
  reg               fregfile_12_sign;
  reg  [22:0]       fregfile_13_mantissa;
  reg  [7:0]        fregfile_13_exponent;
  reg               fregfile_13_sign;
  reg  [22:0]       fregfile_14_mantissa;
  reg  [7:0]        fregfile_14_exponent;
  reg               fregfile_14_sign;
  reg  [22:0]       fregfile_15_mantissa;
  reg  [7:0]        fregfile_15_exponent;
  reg               fregfile_15_sign;
  reg  [22:0]       fregfile_16_mantissa;
  reg  [7:0]        fregfile_16_exponent;
  reg               fregfile_16_sign;
  reg  [22:0]       fregfile_17_mantissa;
  reg  [7:0]        fregfile_17_exponent;
  reg               fregfile_17_sign;
  reg  [22:0]       fregfile_18_mantissa;
  reg  [7:0]        fregfile_18_exponent;
  reg               fregfile_18_sign;
  reg  [22:0]       fregfile_19_mantissa;
  reg  [7:0]        fregfile_19_exponent;
  reg               fregfile_19_sign;
  reg  [22:0]       fregfile_20_mantissa;
  reg  [7:0]        fregfile_20_exponent;
  reg               fregfile_20_sign;
  reg  [22:0]       fregfile_21_mantissa;
  reg  [7:0]        fregfile_21_exponent;
  reg               fregfile_21_sign;
  reg  [22:0]       fregfile_22_mantissa;
  reg  [7:0]        fregfile_22_exponent;
  reg               fregfile_22_sign;
  reg  [22:0]       fregfile_23_mantissa;
  reg  [7:0]        fregfile_23_exponent;
  reg               fregfile_23_sign;
  reg  [22:0]       fregfile_24_mantissa;
  reg  [7:0]        fregfile_24_exponent;
  reg               fregfile_24_sign;
  reg  [22:0]       fregfile_25_mantissa;
  reg  [7:0]        fregfile_25_exponent;
  reg               fregfile_25_sign;
  reg  [22:0]       fregfile_26_mantissa;
  reg  [7:0]        fregfile_26_exponent;
  reg               fregfile_26_sign;
  reg  [22:0]       fregfile_27_mantissa;
  reg  [7:0]        fregfile_27_exponent;
  reg               fregfile_27_sign;
  reg  [22:0]       fregfile_28_mantissa;
  reg  [7:0]        fregfile_28_exponent;
  reg               fregfile_28_sign;
  reg  [22:0]       fregfile_29_mantissa;
  reg  [7:0]        fregfile_29_exponent;
  reg               fregfile_29_sign;
  reg  [22:0]       fregfile_30_mantissa;
  reg  [7:0]        fregfile_30_exponent;
  reg               fregfile_30_sign;
  reg  [22:0]       fregfile_31_mantissa;
  reg  [7:0]        fregfile_31_exponent;
  reg               fregfile_31_sign;
  reg  [31:0]       scoreboard;
  reg               scoreboard_error;
  wire [31:0][22:0] _GEN =
    {{fregfile_31_mantissa},
     {fregfile_30_mantissa},
     {fregfile_29_mantissa},
     {fregfile_28_mantissa},
     {fregfile_27_mantissa},
     {fregfile_26_mantissa},
     {fregfile_25_mantissa},
     {fregfile_24_mantissa},
     {fregfile_23_mantissa},
     {fregfile_22_mantissa},
     {fregfile_21_mantissa},
     {fregfile_20_mantissa},
     {fregfile_19_mantissa},
     {fregfile_18_mantissa},
     {fregfile_17_mantissa},
     {fregfile_16_mantissa},
     {fregfile_15_mantissa},
     {fregfile_14_mantissa},
     {fregfile_13_mantissa},
     {fregfile_12_mantissa},
     {fregfile_11_mantissa},
     {fregfile_10_mantissa},
     {fregfile_9_mantissa},
     {fregfile_8_mantissa},
     {fregfile_7_mantissa},
     {fregfile_6_mantissa},
     {fregfile_5_mantissa},
     {fregfile_4_mantissa},
     {fregfile_3_mantissa},
     {fregfile_2_mantissa},
     {fregfile_1_mantissa},
     {fregfile_0_mantissa}};
  wire [31:0][7:0]  _GEN_0 =
    {{fregfile_31_exponent},
     {fregfile_30_exponent},
     {fregfile_29_exponent},
     {fregfile_28_exponent},
     {fregfile_27_exponent},
     {fregfile_26_exponent},
     {fregfile_25_exponent},
     {fregfile_24_exponent},
     {fregfile_23_exponent},
     {fregfile_22_exponent},
     {fregfile_21_exponent},
     {fregfile_20_exponent},
     {fregfile_19_exponent},
     {fregfile_18_exponent},
     {fregfile_17_exponent},
     {fregfile_16_exponent},
     {fregfile_15_exponent},
     {fregfile_14_exponent},
     {fregfile_13_exponent},
     {fregfile_12_exponent},
     {fregfile_11_exponent},
     {fregfile_10_exponent},
     {fregfile_9_exponent},
     {fregfile_8_exponent},
     {fregfile_7_exponent},
     {fregfile_6_exponent},
     {fregfile_5_exponent},
     {fregfile_4_exponent},
     {fregfile_3_exponent},
     {fregfile_2_exponent},
     {fregfile_1_exponent},
     {fregfile_0_exponent}};
  wire [31:0]       _GEN_1 =
    {{fregfile_31_sign},
     {fregfile_30_sign},
     {fregfile_29_sign},
     {fregfile_28_sign},
     {fregfile_27_sign},
     {fregfile_26_sign},
     {fregfile_25_sign},
     {fregfile_24_sign},
     {fregfile_23_sign},
     {fregfile_22_sign},
     {fregfile_21_sign},
     {fregfile_20_sign},
     {fregfile_19_sign},
     {fregfile_18_sign},
     {fregfile_17_sign},
     {fregfile_16_sign},
     {fregfile_15_sign},
     {fregfile_14_sign},
     {fregfile_13_sign},
     {fregfile_12_sign},
     {fregfile_11_sign},
     {fregfile_10_sign},
     {fregfile_9_sign},
     {fregfile_8_sign},
     {fregfile_7_sign},
     {fregfile_6_sign},
     {fregfile_5_sign},
     {fregfile_4_sign},
     {fregfile_3_sign},
     {fregfile_2_sign},
     {fregfile_1_sign},
     {fregfile_0_sign}};
  wire [31:0]       scoreboard_clr =
    (io_write_ports_0_valid ? 32'h1 << io_write_ports_0_addr : 32'h0)
    | (io_write_ports_1_valid ? 32'h1 << io_write_ports_1_addr : 32'h0);
  wire              valid_0 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h0;
  wire              valid_0_1 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1;
  wire              valid_0_2 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h2;
  wire              valid_0_3 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h3;
  wire              valid_0_4 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h4;
  wire              valid_0_5 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h5;
  wire              valid_0_6 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h6;
  wire              valid_0_7 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h7;
  wire              valid_0_8 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h8;
  wire              valid_0_9 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h9;
  wire              valid_0_10 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hA;
  wire              valid_0_11 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hB;
  wire              valid_0_12 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hC;
  wire              valid_0_13 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hD;
  wire              valid_0_14 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hE;
  wire              valid_0_15 = io_write_ports_0_valid & io_write_ports_0_addr == 5'hF;
  wire              valid_0_16 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h10;
  wire              valid_0_17 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h11;
  wire              valid_0_18 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h12;
  wire              valid_0_19 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h13;
  wire              valid_0_20 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h14;
  wire              valid_0_21 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h15;
  wire              valid_0_22 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h16;
  wire              valid_0_23 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h17;
  wire              valid_0_24 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h18;
  wire              valid_0_25 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h19;
  wire              valid_0_26 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1A;
  wire              valid_0_27 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1B;
  wire              valid_0_28 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1C;
  wire              valid_0_29 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1D;
  wire              valid_0_30 = io_write_ports_0_valid & io_write_ports_0_addr == 5'h1E;
  wire              valid_0_31 = io_write_ports_0_valid & (&io_write_ports_0_addr);
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      fregfile_0_mantissa <= 23'h0;
      fregfile_0_exponent <= 8'h0;
      fregfile_0_sign <= 1'h0;
      fregfile_1_mantissa <= 23'h0;
      fregfile_1_exponent <= 8'h0;
      fregfile_1_sign <= 1'h0;
      fregfile_2_mantissa <= 23'h0;
      fregfile_2_exponent <= 8'h0;
      fregfile_2_sign <= 1'h0;
      fregfile_3_mantissa <= 23'h0;
      fregfile_3_exponent <= 8'h0;
      fregfile_3_sign <= 1'h0;
      fregfile_4_mantissa <= 23'h0;
      fregfile_4_exponent <= 8'h0;
      fregfile_4_sign <= 1'h0;
      fregfile_5_mantissa <= 23'h0;
      fregfile_5_exponent <= 8'h0;
      fregfile_5_sign <= 1'h0;
      fregfile_6_mantissa <= 23'h0;
      fregfile_6_exponent <= 8'h0;
      fregfile_6_sign <= 1'h0;
      fregfile_7_mantissa <= 23'h0;
      fregfile_7_exponent <= 8'h0;
      fregfile_7_sign <= 1'h0;
      fregfile_8_mantissa <= 23'h0;
      fregfile_8_exponent <= 8'h0;
      fregfile_8_sign <= 1'h0;
      fregfile_9_mantissa <= 23'h0;
      fregfile_9_exponent <= 8'h0;
      fregfile_9_sign <= 1'h0;
      fregfile_10_mantissa <= 23'h0;
      fregfile_10_exponent <= 8'h0;
      fregfile_10_sign <= 1'h0;
      fregfile_11_mantissa <= 23'h0;
      fregfile_11_exponent <= 8'h0;
      fregfile_11_sign <= 1'h0;
      fregfile_12_mantissa <= 23'h0;
      fregfile_12_exponent <= 8'h0;
      fregfile_12_sign <= 1'h0;
      fregfile_13_mantissa <= 23'h0;
      fregfile_13_exponent <= 8'h0;
      fregfile_13_sign <= 1'h0;
      fregfile_14_mantissa <= 23'h0;
      fregfile_14_exponent <= 8'h0;
      fregfile_14_sign <= 1'h0;
      fregfile_15_mantissa <= 23'h0;
      fregfile_15_exponent <= 8'h0;
      fregfile_15_sign <= 1'h0;
      fregfile_16_mantissa <= 23'h0;
      fregfile_16_exponent <= 8'h0;
      fregfile_16_sign <= 1'h0;
      fregfile_17_mantissa <= 23'h0;
      fregfile_17_exponent <= 8'h0;
      fregfile_17_sign <= 1'h0;
      fregfile_18_mantissa <= 23'h0;
      fregfile_18_exponent <= 8'h0;
      fregfile_18_sign <= 1'h0;
      fregfile_19_mantissa <= 23'h0;
      fregfile_19_exponent <= 8'h0;
      fregfile_19_sign <= 1'h0;
      fregfile_20_mantissa <= 23'h0;
      fregfile_20_exponent <= 8'h0;
      fregfile_20_sign <= 1'h0;
      fregfile_21_mantissa <= 23'h0;
      fregfile_21_exponent <= 8'h0;
      fregfile_21_sign <= 1'h0;
      fregfile_22_mantissa <= 23'h0;
      fregfile_22_exponent <= 8'h0;
      fregfile_22_sign <= 1'h0;
      fregfile_23_mantissa <= 23'h0;
      fregfile_23_exponent <= 8'h0;
      fregfile_23_sign <= 1'h0;
      fregfile_24_mantissa <= 23'h0;
      fregfile_24_exponent <= 8'h0;
      fregfile_24_sign <= 1'h0;
      fregfile_25_mantissa <= 23'h0;
      fregfile_25_exponent <= 8'h0;
      fregfile_25_sign <= 1'h0;
      fregfile_26_mantissa <= 23'h0;
      fregfile_26_exponent <= 8'h0;
      fregfile_26_sign <= 1'h0;
      fregfile_27_mantissa <= 23'h0;
      fregfile_27_exponent <= 8'h0;
      fregfile_27_sign <= 1'h0;
      fregfile_28_mantissa <= 23'h0;
      fregfile_28_exponent <= 8'h0;
      fregfile_28_sign <= 1'h0;
      fregfile_29_mantissa <= 23'h0;
      fregfile_29_exponent <= 8'h0;
      fregfile_29_sign <= 1'h0;
      fregfile_30_mantissa <= 23'h0;
      fregfile_30_exponent <= 8'h0;
      fregfile_30_sign <= 1'h0;
      fregfile_31_mantissa <= 23'h0;
      fregfile_31_exponent <= 8'h0;
      fregfile_31_sign <= 1'h0;
      scoreboard <= 32'h0;
      scoreboard_error <= 1'h0;
    end
    else begin
      if (valid_0 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h0) begin
        fregfile_0_mantissa <=
          valid_0 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_0_exponent <=
          valid_0 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_0_sign <=
          valid_0 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_1 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1) begin
        fregfile_1_mantissa <=
          valid_0_1 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_1_exponent <=
          valid_0_1 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_1_sign <=
          valid_0_1 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_2 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h2) begin
        fregfile_2_mantissa <=
          valid_0_2 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_2_exponent <=
          valid_0_2 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_2_sign <=
          valid_0_2 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_3 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h3) begin
        fregfile_3_mantissa <=
          valid_0_3 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_3_exponent <=
          valid_0_3 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_3_sign <=
          valid_0_3 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_4 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h4) begin
        fregfile_4_mantissa <=
          valid_0_4 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_4_exponent <=
          valid_0_4 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_4_sign <=
          valid_0_4 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_5 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h5) begin
        fregfile_5_mantissa <=
          valid_0_5 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_5_exponent <=
          valid_0_5 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_5_sign <=
          valid_0_5 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_6 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h6) begin
        fregfile_6_mantissa <=
          valid_0_6 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_6_exponent <=
          valid_0_6 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_6_sign <=
          valid_0_6 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_7 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h7) begin
        fregfile_7_mantissa <=
          valid_0_7 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_7_exponent <=
          valid_0_7 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_7_sign <=
          valid_0_7 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_8 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h8) begin
        fregfile_8_mantissa <=
          valid_0_8 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_8_exponent <=
          valid_0_8 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_8_sign <=
          valid_0_8 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_9 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h9) begin
        fregfile_9_mantissa <=
          valid_0_9 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_9_exponent <=
          valid_0_9 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_9_sign <=
          valid_0_9 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_10 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hA) begin
        fregfile_10_mantissa <=
          valid_0_10 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_10_exponent <=
          valid_0_10 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_10_sign <=
          valid_0_10 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_11 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hB) begin
        fregfile_11_mantissa <=
          valid_0_11 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_11_exponent <=
          valid_0_11 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_11_sign <=
          valid_0_11 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_12 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hC) begin
        fregfile_12_mantissa <=
          valid_0_12 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_12_exponent <=
          valid_0_12 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_12_sign <=
          valid_0_12 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_13 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hD) begin
        fregfile_13_mantissa <=
          valid_0_13 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_13_exponent <=
          valid_0_13 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_13_sign <=
          valid_0_13 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_14 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hE) begin
        fregfile_14_mantissa <=
          valid_0_14 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_14_exponent <=
          valid_0_14 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_14_sign <=
          valid_0_14 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_15 | io_write_ports_1_valid & io_write_ports_1_addr == 5'hF) begin
        fregfile_15_mantissa <=
          valid_0_15 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_15_exponent <=
          valid_0_15 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_15_sign <=
          valid_0_15 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_16 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h10) begin
        fregfile_16_mantissa <=
          valid_0_16 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_16_exponent <=
          valid_0_16 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_16_sign <=
          valid_0_16 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_17 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h11) begin
        fregfile_17_mantissa <=
          valid_0_17 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_17_exponent <=
          valid_0_17 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_17_sign <=
          valid_0_17 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_18 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h12) begin
        fregfile_18_mantissa <=
          valid_0_18 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_18_exponent <=
          valid_0_18 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_18_sign <=
          valid_0_18 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_19 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h13) begin
        fregfile_19_mantissa <=
          valid_0_19 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_19_exponent <=
          valid_0_19 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_19_sign <=
          valid_0_19 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_20 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h14) begin
        fregfile_20_mantissa <=
          valid_0_20 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_20_exponent <=
          valid_0_20 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_20_sign <=
          valid_0_20 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_21 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h15) begin
        fregfile_21_mantissa <=
          valid_0_21 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_21_exponent <=
          valid_0_21 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_21_sign <=
          valid_0_21 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_22 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h16) begin
        fregfile_22_mantissa <=
          valid_0_22 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_22_exponent <=
          valid_0_22 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_22_sign <=
          valid_0_22 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_23 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h17) begin
        fregfile_23_mantissa <=
          valid_0_23 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_23_exponent <=
          valid_0_23 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_23_sign <=
          valid_0_23 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_24 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h18) begin
        fregfile_24_mantissa <=
          valid_0_24 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_24_exponent <=
          valid_0_24 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_24_sign <=
          valid_0_24 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_25 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h19) begin
        fregfile_25_mantissa <=
          valid_0_25 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_25_exponent <=
          valid_0_25 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_25_sign <=
          valid_0_25 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_26 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1A) begin
        fregfile_26_mantissa <=
          valid_0_26 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_26_exponent <=
          valid_0_26 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_26_sign <=
          valid_0_26 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_27 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1B) begin
        fregfile_27_mantissa <=
          valid_0_27 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_27_exponent <=
          valid_0_27 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_27_sign <=
          valid_0_27 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_28 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1C) begin
        fregfile_28_mantissa <=
          valid_0_28 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_28_exponent <=
          valid_0_28 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_28_sign <=
          valid_0_28 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_29 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1D) begin
        fregfile_29_mantissa <=
          valid_0_29 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_29_exponent <=
          valid_0_29 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_29_sign <=
          valid_0_29 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_30 | io_write_ports_1_valid & io_write_ports_1_addr == 5'h1E) begin
        fregfile_30_mantissa <=
          valid_0_30 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_30_exponent <=
          valid_0_30 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_30_sign <=
          valid_0_30 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      if (valid_0_31 | io_write_ports_1_valid & (&io_write_ports_1_addr)) begin
        fregfile_31_mantissa <=
          valid_0_31 ? io_write_ports_0_data_mantissa : io_write_ports_1_data_mantissa;
        fregfile_31_exponent <=
          valid_0_31 ? io_write_ports_0_data_exponent : io_write_ports_1_data_exponent;
        fregfile_31_sign <=
          valid_0_31 ? io_write_ports_0_data_sign : io_write_ports_1_data_sign;
      end
      scoreboard <= scoreboard & ~scoreboard_clr | io_scoreboard_set;
      scoreboard_error <= (scoreboard & scoreboard_clr) != scoreboard_clr;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:33];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [5:0] i = 6'h0; i < 6'h22; i += 6'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        fregfile_0_mantissa = _RANDOM[6'h0][22:0];
        fregfile_0_exponent = _RANDOM[6'h0][30:23];
        fregfile_0_sign = _RANDOM[6'h0][31];
        fregfile_1_mantissa = _RANDOM[6'h1][22:0];
        fregfile_1_exponent = _RANDOM[6'h1][30:23];
        fregfile_1_sign = _RANDOM[6'h1][31];
        fregfile_2_mantissa = _RANDOM[6'h2][22:0];
        fregfile_2_exponent = _RANDOM[6'h2][30:23];
        fregfile_2_sign = _RANDOM[6'h2][31];
        fregfile_3_mantissa = _RANDOM[6'h3][22:0];
        fregfile_3_exponent = _RANDOM[6'h3][30:23];
        fregfile_3_sign = _RANDOM[6'h3][31];
        fregfile_4_mantissa = _RANDOM[6'h4][22:0];
        fregfile_4_exponent = _RANDOM[6'h4][30:23];
        fregfile_4_sign = _RANDOM[6'h4][31];
        fregfile_5_mantissa = _RANDOM[6'h5][22:0];
        fregfile_5_exponent = _RANDOM[6'h5][30:23];
        fregfile_5_sign = _RANDOM[6'h5][31];
        fregfile_6_mantissa = _RANDOM[6'h6][22:0];
        fregfile_6_exponent = _RANDOM[6'h6][30:23];
        fregfile_6_sign = _RANDOM[6'h6][31];
        fregfile_7_mantissa = _RANDOM[6'h7][22:0];
        fregfile_7_exponent = _RANDOM[6'h7][30:23];
        fregfile_7_sign = _RANDOM[6'h7][31];
        fregfile_8_mantissa = _RANDOM[6'h8][22:0];
        fregfile_8_exponent = _RANDOM[6'h8][30:23];
        fregfile_8_sign = _RANDOM[6'h8][31];
        fregfile_9_mantissa = _RANDOM[6'h9][22:0];
        fregfile_9_exponent = _RANDOM[6'h9][30:23];
        fregfile_9_sign = _RANDOM[6'h9][31];
        fregfile_10_mantissa = _RANDOM[6'hA][22:0];
        fregfile_10_exponent = _RANDOM[6'hA][30:23];
        fregfile_10_sign = _RANDOM[6'hA][31];
        fregfile_11_mantissa = _RANDOM[6'hB][22:0];
        fregfile_11_exponent = _RANDOM[6'hB][30:23];
        fregfile_11_sign = _RANDOM[6'hB][31];
        fregfile_12_mantissa = _RANDOM[6'hC][22:0];
        fregfile_12_exponent = _RANDOM[6'hC][30:23];
        fregfile_12_sign = _RANDOM[6'hC][31];
        fregfile_13_mantissa = _RANDOM[6'hD][22:0];
        fregfile_13_exponent = _RANDOM[6'hD][30:23];
        fregfile_13_sign = _RANDOM[6'hD][31];
        fregfile_14_mantissa = _RANDOM[6'hE][22:0];
        fregfile_14_exponent = _RANDOM[6'hE][30:23];
        fregfile_14_sign = _RANDOM[6'hE][31];
        fregfile_15_mantissa = _RANDOM[6'hF][22:0];
        fregfile_15_exponent = _RANDOM[6'hF][30:23];
        fregfile_15_sign = _RANDOM[6'hF][31];
        fregfile_16_mantissa = _RANDOM[6'h10][22:0];
        fregfile_16_exponent = _RANDOM[6'h10][30:23];
        fregfile_16_sign = _RANDOM[6'h10][31];
        fregfile_17_mantissa = _RANDOM[6'h11][22:0];
        fregfile_17_exponent = _RANDOM[6'h11][30:23];
        fregfile_17_sign = _RANDOM[6'h11][31];
        fregfile_18_mantissa = _RANDOM[6'h12][22:0];
        fregfile_18_exponent = _RANDOM[6'h12][30:23];
        fregfile_18_sign = _RANDOM[6'h12][31];
        fregfile_19_mantissa = _RANDOM[6'h13][22:0];
        fregfile_19_exponent = _RANDOM[6'h13][30:23];
        fregfile_19_sign = _RANDOM[6'h13][31];
        fregfile_20_mantissa = _RANDOM[6'h14][22:0];
        fregfile_20_exponent = _RANDOM[6'h14][30:23];
        fregfile_20_sign = _RANDOM[6'h14][31];
        fregfile_21_mantissa = _RANDOM[6'h15][22:0];
        fregfile_21_exponent = _RANDOM[6'h15][30:23];
        fregfile_21_sign = _RANDOM[6'h15][31];
        fregfile_22_mantissa = _RANDOM[6'h16][22:0];
        fregfile_22_exponent = _RANDOM[6'h16][30:23];
        fregfile_22_sign = _RANDOM[6'h16][31];
        fregfile_23_mantissa = _RANDOM[6'h17][22:0];
        fregfile_23_exponent = _RANDOM[6'h17][30:23];
        fregfile_23_sign = _RANDOM[6'h17][31];
        fregfile_24_mantissa = _RANDOM[6'h18][22:0];
        fregfile_24_exponent = _RANDOM[6'h18][30:23];
        fregfile_24_sign = _RANDOM[6'h18][31];
        fregfile_25_mantissa = _RANDOM[6'h19][22:0];
        fregfile_25_exponent = _RANDOM[6'h19][30:23];
        fregfile_25_sign = _RANDOM[6'h19][31];
        fregfile_26_mantissa = _RANDOM[6'h1A][22:0];
        fregfile_26_exponent = _RANDOM[6'h1A][30:23];
        fregfile_26_sign = _RANDOM[6'h1A][31];
        fregfile_27_mantissa = _RANDOM[6'h1B][22:0];
        fregfile_27_exponent = _RANDOM[6'h1B][30:23];
        fregfile_27_sign = _RANDOM[6'h1B][31];
        fregfile_28_mantissa = _RANDOM[6'h1C][22:0];
        fregfile_28_exponent = _RANDOM[6'h1C][30:23];
        fregfile_28_sign = _RANDOM[6'h1C][31];
        fregfile_29_mantissa = _RANDOM[6'h1D][22:0];
        fregfile_29_exponent = _RANDOM[6'h1D][30:23];
        fregfile_29_sign = _RANDOM[6'h1D][31];
        fregfile_30_mantissa = _RANDOM[6'h1E][22:0];
        fregfile_30_exponent = _RANDOM[6'h1E][30:23];
        fregfile_30_sign = _RANDOM[6'h1E][31];
        fregfile_31_mantissa = _RANDOM[6'h1F][22:0];
        fregfile_31_exponent = _RANDOM[6'h1F][30:23];
        fregfile_31_sign = _RANDOM[6'h1F][31];
        scoreboard = _RANDOM[6'h20];
        scoreboard_error = _RANDOM[6'h21][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        fregfile_0_mantissa = 23'h0;
        fregfile_0_exponent = 8'h0;
        fregfile_0_sign = 1'h0;
        fregfile_1_mantissa = 23'h0;
        fregfile_1_exponent = 8'h0;
        fregfile_1_sign = 1'h0;
        fregfile_2_mantissa = 23'h0;
        fregfile_2_exponent = 8'h0;
        fregfile_2_sign = 1'h0;
        fregfile_3_mantissa = 23'h0;
        fregfile_3_exponent = 8'h0;
        fregfile_3_sign = 1'h0;
        fregfile_4_mantissa = 23'h0;
        fregfile_4_exponent = 8'h0;
        fregfile_4_sign = 1'h0;
        fregfile_5_mantissa = 23'h0;
        fregfile_5_exponent = 8'h0;
        fregfile_5_sign = 1'h0;
        fregfile_6_mantissa = 23'h0;
        fregfile_6_exponent = 8'h0;
        fregfile_6_sign = 1'h0;
        fregfile_7_mantissa = 23'h0;
        fregfile_7_exponent = 8'h0;
        fregfile_7_sign = 1'h0;
        fregfile_8_mantissa = 23'h0;
        fregfile_8_exponent = 8'h0;
        fregfile_8_sign = 1'h0;
        fregfile_9_mantissa = 23'h0;
        fregfile_9_exponent = 8'h0;
        fregfile_9_sign = 1'h0;
        fregfile_10_mantissa = 23'h0;
        fregfile_10_exponent = 8'h0;
        fregfile_10_sign = 1'h0;
        fregfile_11_mantissa = 23'h0;
        fregfile_11_exponent = 8'h0;
        fregfile_11_sign = 1'h0;
        fregfile_12_mantissa = 23'h0;
        fregfile_12_exponent = 8'h0;
        fregfile_12_sign = 1'h0;
        fregfile_13_mantissa = 23'h0;
        fregfile_13_exponent = 8'h0;
        fregfile_13_sign = 1'h0;
        fregfile_14_mantissa = 23'h0;
        fregfile_14_exponent = 8'h0;
        fregfile_14_sign = 1'h0;
        fregfile_15_mantissa = 23'h0;
        fregfile_15_exponent = 8'h0;
        fregfile_15_sign = 1'h0;
        fregfile_16_mantissa = 23'h0;
        fregfile_16_exponent = 8'h0;
        fregfile_16_sign = 1'h0;
        fregfile_17_mantissa = 23'h0;
        fregfile_17_exponent = 8'h0;
        fregfile_17_sign = 1'h0;
        fregfile_18_mantissa = 23'h0;
        fregfile_18_exponent = 8'h0;
        fregfile_18_sign = 1'h0;
        fregfile_19_mantissa = 23'h0;
        fregfile_19_exponent = 8'h0;
        fregfile_19_sign = 1'h0;
        fregfile_20_mantissa = 23'h0;
        fregfile_20_exponent = 8'h0;
        fregfile_20_sign = 1'h0;
        fregfile_21_mantissa = 23'h0;
        fregfile_21_exponent = 8'h0;
        fregfile_21_sign = 1'h0;
        fregfile_22_mantissa = 23'h0;
        fregfile_22_exponent = 8'h0;
        fregfile_22_sign = 1'h0;
        fregfile_23_mantissa = 23'h0;
        fregfile_23_exponent = 8'h0;
        fregfile_23_sign = 1'h0;
        fregfile_24_mantissa = 23'h0;
        fregfile_24_exponent = 8'h0;
        fregfile_24_sign = 1'h0;
        fregfile_25_mantissa = 23'h0;
        fregfile_25_exponent = 8'h0;
        fregfile_25_sign = 1'h0;
        fregfile_26_mantissa = 23'h0;
        fregfile_26_exponent = 8'h0;
        fregfile_26_sign = 1'h0;
        fregfile_27_mantissa = 23'h0;
        fregfile_27_exponent = 8'h0;
        fregfile_27_sign = 1'h0;
        fregfile_28_mantissa = 23'h0;
        fregfile_28_exponent = 8'h0;
        fregfile_28_sign = 1'h0;
        fregfile_29_mantissa = 23'h0;
        fregfile_29_exponent = 8'h0;
        fregfile_29_sign = 1'h0;
        fregfile_30_mantissa = 23'h0;
        fregfile_30_exponent = 8'h0;
        fregfile_30_sign = 1'h0;
        fregfile_31_mantissa = 23'h0;
        fregfile_31_exponent = 8'h0;
        fregfile_31_sign = 1'h0;
        scoreboard = 32'h0;
        scoreboard_error = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_read_ports_0_data_mantissa =
    io_read_ports_0_valid ? _GEN[io_read_ports_0_addr] : 23'h0;
  assign io_read_ports_0_data_exponent =
    io_read_ports_0_valid ? _GEN_0[io_read_ports_0_addr] : 8'h0;
  assign io_read_ports_0_data_sign = io_read_ports_0_valid & _GEN_1[io_read_ports_0_addr];
  assign io_read_ports_1_data_mantissa =
    io_read_ports_1_valid ? _GEN[io_read_ports_1_addr] : 23'h0;
  assign io_read_ports_1_data_exponent =
    io_read_ports_1_valid ? _GEN_0[io_read_ports_1_addr] : 8'h0;
  assign io_read_ports_1_data_sign = io_read_ports_1_valid & _GEN_1[io_read_ports_1_addr];
  assign io_read_ports_2_data_mantissa =
    io_read_ports_2_valid ? _GEN[io_read_ports_2_addr] : 23'h0;
  assign io_read_ports_2_data_exponent =
    io_read_ports_2_valid ? _GEN_0[io_read_ports_2_addr] : 8'h0;
  assign io_read_ports_2_data_sign = io_read_ports_2_valid & _GEN_1[io_read_ports_2_addr];
  assign io_scoreboard = scoreboard;
  assign io_busPort_data_0 =
    {_GEN_1[io_busPortAddr], _GEN_0[io_busPortAddr], _GEN[io_busPortAddr]};
endmodule

module Arbiter4_RegfileWriteDataIO(
  input         io_in_0_valid,
  input  [4:0]  io_in_0_bits_addr,
  input  [31:0] io_in_0_bits_data,
  output        io_in_1_ready,
  input         io_in_1_valid,
  input  [4:0]  io_in_1_bits_addr,
  input  [31:0] io_in_1_bits_data,
  output        io_in_2_ready,
  input         io_in_2_valid,
  input  [4:0]  io_in_2_bits_addr,
  input  [31:0] io_in_2_bits_data,
  output        io_in_3_ready,
  input         io_in_3_valid,
  input  [4:0]  io_in_3_bits_addr,
  input  [31:0] io_in_3_bits_data,
  output        io_out_valid,
  output [4:0]  io_out_bits_addr,
  output [31:0] io_out_bits_data
);

  wire _grant_T = io_in_0_valid | io_in_1_valid;
  wire _io_out_valid_T = _grant_T | io_in_2_valid;
  assign io_in_1_ready = ~io_in_0_valid;
  assign io_in_2_ready = ~_grant_T;
  assign io_in_3_ready = ~_io_out_valid_T;
  assign io_out_valid = _io_out_valid_T | io_in_3_valid;
  assign io_out_bits_addr =
    io_in_0_valid
      ? io_in_0_bits_addr
      : io_in_1_valid
          ? io_in_1_bits_addr
          : io_in_2_valid ? io_in_2_bits_addr : io_in_3_bits_addr;
  assign io_out_bits_data =
    io_in_0_valid
      ? io_in_0_bits_data
      : io_in_1_valid
          ? io_in_1_bits_data
          : io_in_2_valid ? io_in_2_bits_data : io_in_3_bits_data;
endmodule

module SCore(
  input          clock,
                 reset,
  input  [31:0]  io_csr_in_value_0,
  output [31:0]  io_csr_out_value_0,
                 io_csr_out_value_1,
                 io_csr_out_value_2,
                 io_csr_out_value_3,
                 io_csr_out_value_4,
                 io_csr_out_value_5,
                 io_csr_out_value_6,
                 io_csr_out_value_7,
                 io_csr_out_value_8,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output         io_ibus_valid,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  input          io_rvvcore_inst_0_ready,
  output         io_rvvcore_inst_0_valid,
  output [31:0]  io_rvvcore_inst_0_bits_pc,
  output [1:0]   io_rvvcore_inst_0_bits_opcode,
  output [24:0]  io_rvvcore_inst_0_bits_bits,
  input          io_rvvcore_inst_1_ready,
  output         io_rvvcore_inst_1_valid,
  output [31:0]  io_rvvcore_inst_1_bits_pc,
  output [1:0]   io_rvvcore_inst_1_bits_opcode,
  output [24:0]  io_rvvcore_inst_1_bits_bits,
  input          io_rvvcore_inst_2_ready,
  output         io_rvvcore_inst_2_valid,
  output [31:0]  io_rvvcore_inst_2_bits_pc,
  output [1:0]   io_rvvcore_inst_2_bits_opcode,
  output [24:0]  io_rvvcore_inst_2_bits_bits,
  input          io_rvvcore_inst_3_ready,
  output         io_rvvcore_inst_3_valid,
  output [31:0]  io_rvvcore_inst_3_bits_pc,
  output [1:0]   io_rvvcore_inst_3_bits_opcode,
  output [24:0]  io_rvvcore_inst_3_bits_bits,
  output         io_rvvcore_rs_0_valid,
  output [31:0]  io_rvvcore_rs_0_data,
  output         io_rvvcore_rs_1_valid,
  output [31:0]  io_rvvcore_rs_1_data,
  output         io_rvvcore_rs_2_valid,
  output [31:0]  io_rvvcore_rs_2_data,
  output         io_rvvcore_rs_3_valid,
  output [31:0]  io_rvvcore_rs_3_data,
  output         io_rvvcore_rs_4_valid,
  output [31:0]  io_rvvcore_rs_4_data,
  output         io_rvvcore_rs_5_valid,
  output [31:0]  io_rvvcore_rs_5_data,
  output         io_rvvcore_rs_6_valid,
  output [31:0]  io_rvvcore_rs_6_data,
  output         io_rvvcore_rs_7_valid,
  output [31:0]  io_rvvcore_rs_7_data,
  input          io_rvvcore_rd_0_valid,
  input  [4:0]   io_rvvcore_rd_0_bits_addr,
  input  [31:0]  io_rvvcore_rd_0_bits_data,
  input          io_rvvcore_rd_1_valid,
  input  [4:0]   io_rvvcore_rd_1_bits_addr,
  input  [31:0]  io_rvvcore_rd_1_bits_data,
  input          io_rvvcore_rd_2_valid,
  input  [4:0]   io_rvvcore_rd_2_bits_addr,
  input  [31:0]  io_rvvcore_rd_2_bits_data,
  input          io_rvvcore_rd_3_valid,
  input  [4:0]   io_rvvcore_rd_3_bits_addr,
  input  [31:0]  io_rvvcore_rd_3_bits_data,
  output [31:0]  io_rvvcore_frs_0,
  output         io_rvvcore_rvv2lsu_0_ready,
  input          io_rvvcore_rvv2lsu_0_valid,
                 io_rvvcore_rvv2lsu_0_bits_idx_valid,
  input  [127:0] io_rvvcore_rvv2lsu_0_bits_idx_bits_data,
  input          io_rvvcore_rvv2lsu_0_bits_vregfile_valid,
  input  [127:0] io_rvvcore_rvv2lsu_0_bits_vregfile_bits_data,
  input          io_rvvcore_rvv2lsu_0_bits_mask_valid,
  input  [15:0]  io_rvvcore_rvv2lsu_0_bits_mask_bits,
  input          io_rvvcore_lsu2rvv_0_ready,
  output         io_rvvcore_lsu2rvv_0_valid,
  output [4:0]   io_rvvcore_lsu2rvv_0_bits_addr,
  output [127:0] io_rvvcore_lsu2rvv_0_bits_data,
  output         io_rvvcore_lsu2rvv_0_bits_last,
  input          io_rvvcore_configState_valid,
  input  [7:0]   io_rvvcore_configState_bits_vl,
  input  [6:0]   io_rvvcore_configState_bits_vstart,
  input          io_rvvcore_configState_bits_ma,
                 io_rvvcore_configState_bits_ta,
  input  [2:0]   io_rvvcore_configState_bits_sew,
                 io_rvvcore_configState_bits_lmul,
                 io_rvvcore_configState_bits_lmul_orig,
  input          io_rvvcore_configState_bits_vill,
  output         io_rvvcore_async_rd_ready,
  input          io_rvvcore_async_rd_valid,
  input  [4:0]   io_rvvcore_async_rd_bits_addr,
  input  [31:0]  io_rvvcore_async_rd_bits_data,
  input          io_rvvcore_trap_valid,
  input  [31:0]  io_rvvcore_trap_bits_pc,
  input  [1:0]   io_rvvcore_trap_bits_opcode,
  input  [24:0]  io_rvvcore_trap_bits_bits,
  input  [6:0]   io_rvvcore_csr_vstart,
  input  [1:0]   io_rvvcore_csr_vxrm,
  input          io_rvvcore_csr_vxsat,
  output [2:0]   io_rvvcore_csr_frm,
  output         io_rvvcore_csr_vstart_write_valid,
  output [6:0]   io_rvvcore_csr_vstart_write_bits,
  output         io_rvvcore_csr_vxrm_write_valid,
  output [1:0]   io_rvvcore_csr_vxrm_write_bits,
  output         io_rvvcore_csr_vxsat_write_valid,
                 io_rvvcore_csr_vxsat_write_bits,
  input          io_rvvcore_rvv_idle,
  input  [3:0]   io_rvvcore_queue_capacity,
  input          io_rvvcore_rd_rob2rt_o_0_w_valid,
  input  [4:0]   io_rvvcore_rd_rob2rt_o_0_w_index,
  input  [31:0]  io_rvvcore_rd_rob2rt_o_0_uop_pc,
  input          io_rvvcore_rd_rob2rt_o_0_last_uop_valid,
                 io_rvvcore_rd_rob2rt_o_1_w_valid,
  input  [4:0]   io_rvvcore_rd_rob2rt_o_1_w_index,
  input  [31:0]  io_rvvcore_rd_rob2rt_o_1_uop_pc,
  input          io_rvvcore_rd_rob2rt_o_1_last_uop_valid,
                 io_rvvcore_rd_rob2rt_o_2_w_valid,
  input  [4:0]   io_rvvcore_rd_rob2rt_o_2_w_index,
  input  [31:0]  io_rvvcore_rd_rob2rt_o_2_uop_pc,
  input          io_rvvcore_rd_rob2rt_o_2_last_uop_valid,
                 io_rvvcore_rd_rob2rt_o_3_w_valid,
  input  [4:0]   io_rvvcore_rd_rob2rt_o_3_w_index,
  input  [31:0]  io_rvvcore_rd_rob2rt_o_3_uop_pc,
  input          io_rvvcore_rd_rob2rt_o_3_last_uop_valid,
  output         io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_addr_2,
                 io_debug_addr_3,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_inst_2,
                 io_debug_inst_3,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_dispatch_2_instFire,
  output [31:0]  io_debug_dispatch_2_instAddr,
                 io_debug_dispatch_2_instInst,
  output         io_debug_dispatch_3_instFire,
  output [31:0]  io_debug_dispatch_3_instAddr,
                 io_debug_dispatch_3_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeAddr_2_valid,
  output [4:0]   io_debug_regfile_writeAddr_2_bits,
  output         io_debug_regfile_writeAddr_3_valid,
  output [4:0]   io_debug_regfile_writeAddr_3_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_regfile_writeData_4_valid,
  output [4:0]   io_debug_regfile_writeData_4_bits_addr,
  output [31:0]  io_debug_regfile_writeData_4_bits_data,
  output         io_debug_regfile_writeData_5_valid,
  output [4:0]   io_debug_regfile_writeData_5_bits_addr,
  output [31:0]  io_debug_regfile_writeData_5_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data,
  output         io_debug_rb_inst_0_valid,
  output [31:0]  io_debug_rb_inst_0_bits_pc,
  output [6:0]   io_debug_rb_inst_0_bits_idx,
  output         io_debug_rb_inst_0_bits_trap,
                 io_debug_rb_inst_1_valid,
  output [31:0]  io_debug_rb_inst_1_bits_pc,
  output [6:0]   io_debug_rb_inst_1_bits_idx,
  output         io_debug_rb_inst_1_bits_trap,
                 io_debug_rb_inst_2_valid,
  output [31:0]  io_debug_rb_inst_2_bits_pc,
  output [6:0]   io_debug_rb_inst_2_bits_idx,
  output         io_debug_rb_inst_2_bits_trap,
                 io_debug_rb_inst_3_valid,
  output [31:0]  io_debug_rb_inst_3_bits_pc,
  output [6:0]   io_debug_rb_inst_3_bits_idx,
  output         io_debug_rb_inst_3_bits_trap,
                 io_debug_rb_inst_4_valid,
  output [31:0]  io_debug_rb_inst_4_bits_pc,
  output [6:0]   io_debug_rb_inst_4_bits_idx,
  output         io_debug_rb_inst_4_bits_trap,
                 io_debug_rb_inst_5_valid,
  output [31:0]  io_debug_rb_inst_5_bits_pc,
  output [6:0]   io_debug_rb_inst_5_bits_idx,
  output         io_debug_rb_inst_5_bits_trap,
                 io_debug_rb_inst_6_valid,
  output [31:0]  io_debug_rb_inst_6_bits_pc,
  output [6:0]   io_debug_rb_inst_6_bits_idx,
  output         io_debug_rb_inst_6_bits_trap,
                 io_debug_rb_inst_7_valid,
  output [31:0]  io_debug_rb_inst_7_bits_pc,
  output [6:0]   io_debug_rb_inst_7_bits_idx,
  output         io_debug_rb_inst_7_bits_trap
);

  wire         _arb_io_in_1_ready;
  wire         _arb_io_in_3_ready;
  wire         _arb_io_out_valid;
  wire [4:0]   _arb_io_out_bits_addr;
  wire [31:0]  _arb_io_out_bits_data;
  wire [22:0]  _fRegfile_io_read_ports_0_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_0_data_exponent;
  wire         _fRegfile_io_read_ports_0_data_sign;
  wire [22:0]  _fRegfile_io_read_ports_1_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_1_data_exponent;
  wire         _fRegfile_io_read_ports_1_data_sign;
  wire [22:0]  _fRegfile_io_read_ports_2_data_mantissa;
  wire [7:0]   _fRegfile_io_read_ports_2_data_exponent;
  wire         _fRegfile_io_read_ports_2_data_sign;
  wire [31:0]  _fRegfile_io_scoreboard;
  wire [31:0]  _fRegfile_io_busPort_data_0;
  wire         _floatCore_io_inst_ready;
  wire         _floatCore_io_read_ports_0_valid;
  wire [4:0]   _floatCore_io_read_ports_0_addr;
  wire         _floatCore_io_read_ports_1_valid;
  wire [4:0]   _floatCore_io_read_ports_1_addr;
  wire         _floatCore_io_read_ports_2_valid;
  wire [4:0]   _floatCore_io_read_ports_2_addr;
  wire         _floatCore_io_write_ports_0_valid;
  wire [4:0]   _floatCore_io_write_ports_0_addr;
  wire [22:0]  _floatCore_io_write_ports_0_data_mantissa;
  wire [7:0]   _floatCore_io_write_ports_0_data_exponent;
  wire         _floatCore_io_write_ports_0_data_sign;
  wire         _floatCore_io_write_ports_1_valid;
  wire [4:0]   _floatCore_io_write_ports_1_addr;
  wire [22:0]  _floatCore_io_write_ports_1_data_mantissa;
  wire [7:0]   _floatCore_io_write_ports_1_data_exponent;
  wire         _floatCore_io_write_ports_1_data_sign;
  wire         _floatCore_io_scalar_rd_valid;
  wire [4:0]   _floatCore_io_scalar_rd_bits_addr;
  wire [31:0]  _floatCore_io_scalar_rd_bits_data;
  wire         _floatCore_io_csr_in_fflags_valid;
  wire [4:0]   _floatCore_io_csr_in_fflags_bits;
  wire         _dvu_io_req_ready;
  wire         _dvu_io_rd_valid;
  wire [4:0]   _dvu_io_rd_bits_addr;
  wire [31:0]  _dvu_io_rd_bits_data;
  wire         _mlu_io_req_1_ready;
  wire         _mlu_io_req_2_ready;
  wire         _mlu_io_req_3_ready;
  wire         _mlu_io_rd_valid;
  wire [4:0]   _mlu_io_rd_bits_addr;
  wire [31:0]  _mlu_io_rd_bits_data;
  wire         _bru_3_io_rd_valid;
  wire [4:0]   _bru_3_io_rd_bits_addr;
  wire [31:0]  _bru_3_io_rd_bits_data;
  wire         _bru_3_io_taken_valid;
  wire [31:0]  _bru_3_io_taken_value;
  wire         _bru_2_io_rd_valid;
  wire [4:0]   _bru_2_io_rd_bits_addr;
  wire [31:0]  _bru_2_io_rd_bits_data;
  wire         _bru_2_io_taken_valid;
  wire [31:0]  _bru_2_io_taken_value;
  wire         _bru_1_io_rd_valid;
  wire [4:0]   _bru_1_io_rd_bits_addr;
  wire [31:0]  _bru_1_io_rd_bits_data;
  wire         _bru_1_io_taken_valid;
  wire [31:0]  _bru_1_io_taken_value;
  wire         _bru_0_io_csr_in_mode_valid;
  wire [1:0]   _bru_0_io_csr_in_mode_bits;
  wire         _bru_0_io_csr_in_mcause_valid;
  wire [31:0]  _bru_0_io_csr_in_mcause_bits;
  wire         _bru_0_io_csr_in_mepc_valid;
  wire [31:0]  _bru_0_io_csr_in_mepc_bits;
  wire         _bru_0_io_csr_in_mtval_valid;
  wire [31:0]  _bru_0_io_csr_in_mtval_bits;
  wire         _bru_0_io_csr_in_halt;
  wire         _bru_0_io_csr_in_fault;
  wire         _bru_0_io_csr_in_wfi;
  wire         _bru_0_io_rd_valid;
  wire [4:0]   _bru_0_io_rd_bits_addr;
  wire [31:0]  _bru_0_io_rd_bits_data;
  wire         _bru_0_io_taken_valid;
  wire [31:0]  _bru_0_io_taken_value;
  wire         _bru_0_io_interlock;
  wire         _alu_3_io_rd_valid;
  wire [4:0]   _alu_3_io_rd_bits_addr;
  wire [31:0]  _alu_3_io_rd_bits_data;
  wire         _alu_2_io_rd_valid;
  wire [4:0]   _alu_2_io_rd_bits_addr;
  wire [31:0]  _alu_2_io_rd_bits_data;
  wire         _alu_1_io_rd_valid;
  wire [4:0]   _alu_1_io_rd_bits_addr;
  wire [31:0]  _alu_1_io_rd_bits_data;
  wire         _alu_0_io_rd_valid;
  wire [4:0]   _alu_0_io_rd_bits_addr;
  wire [31:0]  _alu_0_io_rd_bits_data;
  wire [31:0]  _retirement_buffer_io_nSpace;
  wire [3:0]   _retirement_buffer_io_nRetired;
  wire         _retirement_buffer_io_empty;
  wire         _retirement_buffer_io_trapPending;
  wire         _fault_manager_io_out_valid;
  wire [31:0]  _fault_manager_io_out_bits_mepc;
  wire [31:0]  _fault_manager_io_out_bits_mtval;
  wire [31:0]  _fault_manager_io_out_bits_mcause;
  wire         _fault_manager_io_out_bits_decode;
  wire         _lsu_io_req_0_ready;
  wire         _lsu_io_req_1_ready;
  wire         _lsu_io_req_2_ready;
  wire         _lsu_io_req_3_ready;
  wire         _lsu_io_rd_valid;
  wire [4:0]   _lsu_io_rd_bits_addr;
  wire [31:0]  _lsu_io_rd_bits_data;
  wire         _lsu_io_rd_flt_valid;
  wire [4:0]   _lsu_io_rd_flt_bits_addr;
  wire [31:0]  _lsu_io_rd_flt_bits_data;
  wire         _lsu_io_ibus_valid;
  wire [31:0]  _lsu_io_ibus_addr;
  wire         _lsu_io_dbus_valid;
  wire         _lsu_io_dbus_write;
  wire [31:0]  _lsu_io_dbus_addr;
  wire [127:0] _lsu_io_dbus_wdata;
  wire         _lsu_io_flush_valid;
  wire         _lsu_io_flush_fencei;
  wire [31:0]  _lsu_io_flush_pcNext;
  wire         _lsu_io_fault_valid;
  wire         _lsu_io_fault_bits_write;
  wire [31:0]  _lsu_io_fault_bits_addr;
  wire [31:0]  _lsu_io_fault_bits_epc;
  wire [2:0]   _lsu_io_queueCapacity;
  wire         _lsu_io_active;
  wire         _lsu_io_storeComplete_valid;
  wire [31:0]  _lsu_io_storeComplete_bits;
  wire         _dispatch_io_csrFault_0;
  wire         _dispatch_io_jalFault_0;
  wire         _dispatch_io_jalFault_1;
  wire         _dispatch_io_jalFault_2;
  wire         _dispatch_io_jalFault_3;
  wire         _dispatch_io_jalrFault_0;
  wire         _dispatch_io_jalrFault_1;
  wire         _dispatch_io_jalrFault_2;
  wire         _dispatch_io_jalrFault_3;
  wire         _dispatch_io_bxxFault_0;
  wire         _dispatch_io_bxxFault_1;
  wire         _dispatch_io_bxxFault_2;
  wire         _dispatch_io_bxxFault_3;
  wire         _dispatch_io_undefFault_0;
  wire         _dispatch_io_rvvFault_0;
  wire [31:0]  _dispatch_io_bruTarget_0;
  wire [31:0]  _dispatch_io_bruTarget_1;
  wire [31:0]  _dispatch_io_bruTarget_2;
  wire [31:0]  _dispatch_io_bruTarget_3;
  wire         _dispatch_io_inst_0_ready;
  wire         _dispatch_io_inst_1_ready;
  wire         _dispatch_io_inst_2_ready;
  wire         _dispatch_io_inst_3_ready;
  wire         _dispatch_io_rs1Read_0_valid;
  wire [4:0]   _dispatch_io_rs1Read_0_addr;
  wire         _dispatch_io_rs1Read_1_valid;
  wire [4:0]   _dispatch_io_rs1Read_1_addr;
  wire         _dispatch_io_rs1Read_2_valid;
  wire [4:0]   _dispatch_io_rs1Read_2_addr;
  wire         _dispatch_io_rs1Read_3_valid;
  wire [4:0]   _dispatch_io_rs1Read_3_addr;
  wire         _dispatch_io_rs1Set_0_valid;
  wire [31:0]  _dispatch_io_rs1Set_0_value;
  wire         _dispatch_io_rs1Set_1_valid;
  wire [31:0]  _dispatch_io_rs1Set_1_value;
  wire         _dispatch_io_rs1Set_2_valid;
  wire [31:0]  _dispatch_io_rs1Set_2_value;
  wire         _dispatch_io_rs1Set_3_valid;
  wire [31:0]  _dispatch_io_rs1Set_3_value;
  wire         _dispatch_io_rs2Read_0_valid;
  wire [4:0]   _dispatch_io_rs2Read_0_addr;
  wire         _dispatch_io_rs2Read_1_valid;
  wire [4:0]   _dispatch_io_rs2Read_1_addr;
  wire         _dispatch_io_rs2Read_2_valid;
  wire [4:0]   _dispatch_io_rs2Read_2_addr;
  wire         _dispatch_io_rs2Read_3_valid;
  wire [4:0]   _dispatch_io_rs2Read_3_addr;
  wire         _dispatch_io_rs2Set_0_valid;
  wire [31:0]  _dispatch_io_rs2Set_0_value;
  wire         _dispatch_io_rs2Set_1_valid;
  wire [31:0]  _dispatch_io_rs2Set_1_value;
  wire         _dispatch_io_rs2Set_2_valid;
  wire [31:0]  _dispatch_io_rs2Set_2_value;
  wire         _dispatch_io_rs2Set_3_valid;
  wire [31:0]  _dispatch_io_rs2Set_3_value;
  wire         _dispatch_io_rdMark_0_valid;
  wire [4:0]   _dispatch_io_rdMark_0_addr;
  wire         _dispatch_io_rdMark_1_valid;
  wire [4:0]   _dispatch_io_rdMark_1_addr;
  wire         _dispatch_io_rdMark_2_valid;
  wire [4:0]   _dispatch_io_rdMark_2_addr;
  wire         _dispatch_io_rdMark_3_valid;
  wire [4:0]   _dispatch_io_rdMark_3_addr;
  wire         _dispatch_io_busRead_0_bypass;
  wire         _dispatch_io_busRead_0_immen;
  wire [31:0]  _dispatch_io_busRead_0_immed;
  wire         _dispatch_io_busRead_1_bypass;
  wire [31:0]  _dispatch_io_busRead_1_immed;
  wire         _dispatch_io_busRead_2_bypass;
  wire [31:0]  _dispatch_io_busRead_2_immed;
  wire         _dispatch_io_busRead_3_bypass;
  wire [31:0]  _dispatch_io_busRead_3_immed;
  wire         _dispatch_io_rdMark_flt_valid;
  wire [4:0]   _dispatch_io_rdMark_flt_addr;
  wire         _dispatch_io_rvvRdMark_0_valid;
  wire [4:0]   _dispatch_io_rvvRdMark_0_addr;
  wire         _dispatch_io_rvvRdMark_1_valid;
  wire [4:0]   _dispatch_io_rvvRdMark_1_addr;
  wire         _dispatch_io_rvvRdMark_2_valid;
  wire [4:0]   _dispatch_io_rvvRdMark_2_addr;
  wire         _dispatch_io_rvvRdMark_3_valid;
  wire [4:0]   _dispatch_io_rvvRdMark_3_addr;
  wire         _dispatch_io_alu_0_valid;
  wire [4:0]   _dispatch_io_alu_0_bits_addr;
  wire [4:0]   _dispatch_io_alu_0_bits_op;
  wire         _dispatch_io_alu_1_valid;
  wire [4:0]   _dispatch_io_alu_1_bits_addr;
  wire [4:0]   _dispatch_io_alu_1_bits_op;
  wire         _dispatch_io_alu_2_valid;
  wire [4:0]   _dispatch_io_alu_2_bits_addr;
  wire [4:0]   _dispatch_io_alu_2_bits_op;
  wire         _dispatch_io_alu_3_valid;
  wire [4:0]   _dispatch_io_alu_3_bits_addr;
  wire [4:0]   _dispatch_io_alu_3_bits_op;
  wire         _dispatch_io_bru_0_valid;
  wire         _dispatch_io_bru_0_bits_fwd;
  wire [3:0]   _dispatch_io_bru_0_bits_op;
  wire [31:0]  _dispatch_io_bru_0_bits_pc;
  wire [31:0]  _dispatch_io_bru_0_bits_target;
  wire [4:0]   _dispatch_io_bru_0_bits_link;
  wire         _dispatch_io_bru_1_valid;
  wire         _dispatch_io_bru_1_bits_fwd;
  wire [3:0]   _dispatch_io_bru_1_bits_op;
  wire [31:0]  _dispatch_io_bru_1_bits_pc;
  wire [31:0]  _dispatch_io_bru_1_bits_target;
  wire [4:0]   _dispatch_io_bru_1_bits_link;
  wire         _dispatch_io_bru_2_valid;
  wire         _dispatch_io_bru_2_bits_fwd;
  wire [3:0]   _dispatch_io_bru_2_bits_op;
  wire [31:0]  _dispatch_io_bru_2_bits_pc;
  wire [31:0]  _dispatch_io_bru_2_bits_target;
  wire [4:0]   _dispatch_io_bru_2_bits_link;
  wire         _dispatch_io_bru_3_valid;
  wire         _dispatch_io_bru_3_bits_fwd;
  wire [3:0]   _dispatch_io_bru_3_bits_op;
  wire [31:0]  _dispatch_io_bru_3_bits_pc;
  wire [31:0]  _dispatch_io_bru_3_bits_target;
  wire [4:0]   _dispatch_io_bru_3_bits_link;
  wire         _dispatch_io_csr_valid;
  wire [4:0]   _dispatch_io_csr_bits_addr;
  wire [11:0]  _dispatch_io_csr_bits_index;
  wire [4:0]   _dispatch_io_csr_bits_rs1;
  wire [1:0]   _dispatch_io_csr_bits_op;
  wire         _dispatch_io_lsu_0_valid;
  wire         _dispatch_io_lsu_0_bits_store;
  wire [4:0]   _dispatch_io_lsu_0_bits_addr;
  wire [4:0]   _dispatch_io_lsu_0_bits_op;
  wire [31:0]  _dispatch_io_lsu_0_bits_pc;
  wire [2:0]   _dispatch_io_lsu_0_bits_elemWidth;
  wire [2:0]   _dispatch_io_lsu_0_bits_nfields;
  wire [4:0]   _dispatch_io_lsu_0_bits_umop;
  wire         _dispatch_io_lsu_1_valid;
  wire         _dispatch_io_lsu_1_bits_store;
  wire [4:0]   _dispatch_io_lsu_1_bits_addr;
  wire [4:0]   _dispatch_io_lsu_1_bits_op;
  wire [31:0]  _dispatch_io_lsu_1_bits_pc;
  wire [2:0]   _dispatch_io_lsu_1_bits_elemWidth;
  wire [2:0]   _dispatch_io_lsu_1_bits_nfields;
  wire [4:0]   _dispatch_io_lsu_1_bits_umop;
  wire         _dispatch_io_lsu_2_valid;
  wire         _dispatch_io_lsu_2_bits_store;
  wire [4:0]   _dispatch_io_lsu_2_bits_addr;
  wire [4:0]   _dispatch_io_lsu_2_bits_op;
  wire [31:0]  _dispatch_io_lsu_2_bits_pc;
  wire [2:0]   _dispatch_io_lsu_2_bits_elemWidth;
  wire [2:0]   _dispatch_io_lsu_2_bits_nfields;
  wire [4:0]   _dispatch_io_lsu_2_bits_umop;
  wire         _dispatch_io_lsu_3_valid;
  wire         _dispatch_io_lsu_3_bits_store;
  wire [4:0]   _dispatch_io_lsu_3_bits_addr;
  wire [4:0]   _dispatch_io_lsu_3_bits_op;
  wire [31:0]  _dispatch_io_lsu_3_bits_pc;
  wire [2:0]   _dispatch_io_lsu_3_bits_elemWidth;
  wire [2:0]   _dispatch_io_lsu_3_bits_nfields;
  wire [4:0]   _dispatch_io_lsu_3_bits_umop;
  wire         _dispatch_io_mlu_0_valid;
  wire [4:0]   _dispatch_io_mlu_0_bits_addr;
  wire [2:0]   _dispatch_io_mlu_0_bits_op;
  wire         _dispatch_io_mlu_1_valid;
  wire [4:0]   _dispatch_io_mlu_1_bits_addr;
  wire [2:0]   _dispatch_io_mlu_1_bits_op;
  wire         _dispatch_io_mlu_2_valid;
  wire [4:0]   _dispatch_io_mlu_2_bits_addr;
  wire [2:0]   _dispatch_io_mlu_2_bits_op;
  wire         _dispatch_io_mlu_3_valid;
  wire [4:0]   _dispatch_io_mlu_3_bits_addr;
  wire [2:0]   _dispatch_io_mlu_3_bits_op;
  wire         _dispatch_io_dvu_0_valid;
  wire [4:0]   _dispatch_io_dvu_0_bits_addr;
  wire [1:0]   _dispatch_io_dvu_0_bits_op;
  wire         _dispatch_io_float_valid;
  wire [2:0]   _dispatch_io_float_bits_opcode;
  wire [4:0]   _dispatch_io_float_bits_funct5;
  wire [4:0]   _dispatch_io_float_bits_rs3;
  wire [4:0]   _dispatch_io_float_bits_rs2;
  wire [4:0]   _dispatch_io_float_bits_rs1;
  wire [2:0]   _dispatch_io_float_bits_rm;
  wire [31:0]  _dispatch_io_float_bits_inst;
  wire [31:0]  _dispatch_io_float_bits_pc;
  wire         _dispatch_io_float_bits_scalar_rd;
  wire         _dispatch_io_float_bits_scalar_rs1;
  wire         _dispatch_io_float_bits_float_rs1;
  wire [4:0]   _dispatch_io_float_bits_rd;
  wire         _dispatch_io_float_bits_uses_rs3;
  wire         _dispatch_io_float_bits_uses_rs2;
  wire [4:0]   _dispatch_io_fbusPortAddr;
  wire         _dispatch_io_slog;
  wire         _dispatch_io_branch_0;
  wire         _dispatch_io_branch_1;
  wire         _dispatch_io_branch_2;
  wire         _dispatch_io_branch_3;
  wire         _dispatch_io_jump_0;
  wire         _dispatch_io_jump_1;
  wire         _dispatch_io_jump_2;
  wire         _dispatch_io_jump_3;
  wire [31:0]  _csr_io_csr_out_value_4;
  wire         _csr_io_rd_valid;
  wire [4:0]   _csr_io_rd_bits_addr;
  wire [31:0]  _csr_io_rd_bits_data;
  wire [1:0]   _csr_io_bru_out_mode;
  wire [31:0]  _csr_io_bru_out_mepc;
  wire [31:0]  _csr_io_bru_out_mtvec;
  wire [2:0]   _csr_io_float_out_frm;
  wire         _csr_io_halted;
  wire         _csr_io_wfi;
  wire         _fetch_io_ibus_valid;
  wire [31:0]  _fetch_io_ibus_addr;
  wire         _fetch_io_inst_lanes_0_valid;
  wire [31:0]  _fetch_io_inst_lanes_0_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_0_bits_inst;
  wire         _fetch_io_inst_lanes_0_bits_brchFwd;
  wire         _fetch_io_inst_lanes_1_valid;
  wire [31:0]  _fetch_io_inst_lanes_1_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_1_bits_inst;
  wire         _fetch_io_inst_lanes_1_bits_brchFwd;
  wire         _fetch_io_inst_lanes_2_valid;
  wire [31:0]  _fetch_io_inst_lanes_2_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_2_bits_inst;
  wire         _fetch_io_inst_lanes_2_bits_brchFwd;
  wire         _fetch_io_inst_lanes_3_valid;
  wire [31:0]  _fetch_io_inst_lanes_3_bits_addr;
  wire [31:0]  _fetch_io_inst_lanes_3_bits_inst;
  wire         _fetch_io_inst_lanes_3_bits_brchFwd;
  wire [31:0]  _fetch_io_pc;
  wire         _fetch_io_fault_valid;
  wire [31:0]  _fetch_io_fault_bits;
  wire [31:0]  _regfile_io_target_0_data;
  wire [31:0]  _regfile_io_target_1_data;
  wire [31:0]  _regfile_io_target_2_data;
  wire [31:0]  _regfile_io_target_3_data;
  wire [31:0]  _regfile_io_busPort_addr_0;
  wire [31:0]  _regfile_io_busPort_addr_1;
  wire [31:0]  _regfile_io_busPort_addr_2;
  wire [31:0]  _regfile_io_busPort_addr_3;
  wire [31:0]  _regfile_io_busPort_data_0;
  wire [31:0]  _regfile_io_busPort_data_1;
  wire [31:0]  _regfile_io_busPort_data_2;
  wire [31:0]  _regfile_io_busPort_data_3;
  wire         _regfile_io_readData_0_valid;
  wire [31:0]  _regfile_io_readData_0_data;
  wire         _regfile_io_readData_1_valid;
  wire [31:0]  _regfile_io_readData_1_data;
  wire         _regfile_io_readData_2_valid;
  wire [31:0]  _regfile_io_readData_2_data;
  wire         _regfile_io_readData_3_valid;
  wire [31:0]  _regfile_io_readData_3_data;
  wire         _regfile_io_readData_4_valid;
  wire [31:0]  _regfile_io_readData_4_data;
  wire         _regfile_io_readData_5_valid;
  wire [31:0]  _regfile_io_readData_5_data;
  wire         _regfile_io_readData_6_valid;
  wire [31:0]  _regfile_io_readData_6_data;
  wire         _regfile_io_readData_7_valid;
  wire [31:0]  _regfile_io_readData_7_data;
  wire [31:0]  _regfile_io_scoreboard_regd;
  wire [31:0]  _regfile_io_scoreboard_comb;
  wire         _isBranching_T = _bru_0_io_taken_valid | _bru_1_io_taken_valid;
  wire         branchTaken =
    _isBranching_T | _bru_2_io_taken_valid | _bru_3_io_taken_valid;
  wire         regfile_io_writeData_0_valid =
    _csr_io_rd_valid | _alu_0_io_rd_valid | _bru_0_io_rd_valid | io_rvvcore_rd_0_valid;
  wire [4:0]   regfile_io_writeData_0_bits_addr =
    (_csr_io_rd_valid ? _csr_io_rd_bits_addr : 5'h0)
    | (_alu_0_io_rd_valid ? _alu_0_io_rd_bits_addr : 5'h0)
    | (_bru_0_io_rd_valid ? _bru_0_io_rd_bits_addr : 5'h0)
    | (io_rvvcore_rd_0_valid ? io_rvvcore_rd_0_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_0_bits_data =
    (_csr_io_rd_valid ? _csr_io_rd_bits_data : 32'h0)
    | (_alu_0_io_rd_valid ? _alu_0_io_rd_bits_data : 32'h0)
    | (_bru_0_io_rd_valid ? _bru_0_io_rd_bits_data : 32'h0)
    | (io_rvvcore_rd_0_valid ? io_rvvcore_rd_0_bits_data : 32'h0);
  wire         regfile_io_writeData_1_valid =
    _alu_1_io_rd_valid | _bru_1_io_rd_valid | io_rvvcore_rd_1_valid;
  wire [4:0]   regfile_io_writeData_1_bits_addr =
    (_alu_1_io_rd_valid ? _alu_1_io_rd_bits_addr : 5'h0)
    | (_bru_1_io_rd_valid ? _bru_1_io_rd_bits_addr : 5'h0)
    | (io_rvvcore_rd_1_valid ? io_rvvcore_rd_1_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_1_bits_data =
    (_alu_1_io_rd_valid ? _alu_1_io_rd_bits_data : 32'h0)
    | (_bru_1_io_rd_valid ? _bru_1_io_rd_bits_data : 32'h0)
    | (io_rvvcore_rd_1_valid ? io_rvvcore_rd_1_bits_data : 32'h0);
  wire         regfile_io_writeData_2_valid =
    _alu_2_io_rd_valid | _bru_2_io_rd_valid | io_rvvcore_rd_2_valid;
  wire [4:0]   regfile_io_writeData_2_bits_addr =
    (_alu_2_io_rd_valid ? _alu_2_io_rd_bits_addr : 5'h0)
    | (_bru_2_io_rd_valid ? _bru_2_io_rd_bits_addr : 5'h0)
    | (io_rvvcore_rd_2_valid ? io_rvvcore_rd_2_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_2_bits_data =
    (_alu_2_io_rd_valid ? _alu_2_io_rd_bits_data : 32'h0)
    | (_bru_2_io_rd_valid ? _bru_2_io_rd_bits_data : 32'h0)
    | (io_rvvcore_rd_2_valid ? io_rvvcore_rd_2_bits_data : 32'h0);
  wire         regfile_io_writeData_3_valid =
    _alu_3_io_rd_valid | _bru_3_io_rd_valid | io_rvvcore_rd_3_valid;
  wire [4:0]   regfile_io_writeData_3_bits_addr =
    (_alu_3_io_rd_valid ? _alu_3_io_rd_bits_addr : 5'h0)
    | (_bru_3_io_rd_valid ? _bru_3_io_rd_bits_addr : 5'h0)
    | (io_rvvcore_rd_3_valid ? io_rvvcore_rd_3_bits_addr : 5'h0);
  wire [31:0]  regfile_io_writeData_3_bits_data =
    (_alu_3_io_rd_valid ? _alu_3_io_rd_bits_data : 32'h0)
    | (_bru_3_io_rd_valid ? _bru_3_io_rd_bits_data : 32'h0)
    | (io_rvvcore_rd_3_valid ? io_rvvcore_rd_3_bits_data : 32'h0);
  wire         writeMask_2 = _bru_0_io_taken_valid | _bru_1_io_taken_valid;
  reg          slogValid;
  reg  [1:0]   slogAddr;
  reg  [3:0]   debugEn;
  reg  [31:0]  debugAddr_0;
  reg  [31:0]  debugAddr_1;
  reg  [31:0]  debugAddr_2;
  reg  [31:0]  debugAddr_3;
  reg  [31:0]  debugInst_0;
  reg  [31:0]  debugInst_1;
  reg  [31:0]  debugInst_2;
  reg  [31:0]  debugInst_3;
  wire         _debugBrch_T_1 = _bru_2_io_taken_valid | _bru_3_io_taken_valid;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      slogValid <= 1'h0;
      slogAddr <= 2'h0;
      debugEn <= 4'h0;
      debugAddr_0 <= 32'h0;
      debugAddr_1 <= 32'h0;
      debugAddr_2 <= 32'h0;
      debugAddr_3 <= 32'h0;
      debugInst_0 <= 32'h0;
      debugInst_1 <= 32'h0;
      debugInst_2 <= 32'h0;
      debugInst_3 <= 32'h0;
    end
    else begin
      slogValid <= _dispatch_io_slog;
      if (_dispatch_io_slog)
        slogAddr <= _fetch_io_inst_lanes_0_bits_inst[13:12];
      debugEn <=
        {_fetch_io_inst_lanes_0_valid & _dispatch_io_inst_0_ready & ~branchTaken,
         _fetch_io_inst_lanes_1_valid & _dispatch_io_inst_1_ready & ~branchTaken,
         _fetch_io_inst_lanes_2_valid & _dispatch_io_inst_2_ready & ~branchTaken,
         _fetch_io_inst_lanes_3_valid & _dispatch_io_inst_3_ready & ~branchTaken};
      if (debugEn[0]) begin
        debugAddr_0 <= _fetch_io_inst_lanes_0_bits_addr;
        debugInst_0 <= _fetch_io_inst_lanes_0_bits_inst;
      end
      if (debugEn[1]) begin
        debugAddr_1 <= _fetch_io_inst_lanes_1_bits_addr;
        debugInst_1 <= _fetch_io_inst_lanes_1_bits_inst;
      end
      if (debugEn[2]) begin
        debugAddr_2 <= _fetch_io_inst_lanes_2_bits_addr;
        debugInst_2 <= _fetch_io_inst_lanes_2_bits_inst;
      end
      if (debugEn[3]) begin
        debugAddr_3 <= _fetch_io_inst_lanes_3_bits_addr;
        debugInst_3 <= _fetch_io_inst_lanes_3_bits_inst;
      end
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:8];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h9; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        slogValid = _RANDOM[4'h0][0];
        slogAddr = _RANDOM[4'h0][2:1];
        debugEn = _RANDOM[4'h0][6:3];
        debugAddr_0 = {_RANDOM[4'h0][31:7], _RANDOM[4'h1][6:0]};
        debugAddr_1 = {_RANDOM[4'h1][31:7], _RANDOM[4'h2][6:0]};
        debugAddr_2 = {_RANDOM[4'h2][31:7], _RANDOM[4'h3][6:0]};
        debugAddr_3 = {_RANDOM[4'h3][31:7], _RANDOM[4'h4][6:0]};
        debugInst_0 = {_RANDOM[4'h4][31:7], _RANDOM[4'h5][6:0]};
        debugInst_1 = {_RANDOM[4'h5][31:7], _RANDOM[4'h6][6:0]};
        debugInst_2 = {_RANDOM[4'h6][31:7], _RANDOM[4'h7][6:0]};
        debugInst_3 = {_RANDOM[4'h7][31:7], _RANDOM[4'h8][6:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        slogValid = 1'h0;
        slogAddr = 2'h0;
        debugEn = 4'h0;
        debugAddr_0 = 32'h0;
        debugAddr_1 = 32'h0;
        debugAddr_2 = 32'h0;
        debugAddr_3 = 32'h0;
        debugInst_0 = 32'h0;
        debugInst_1 = 32'h0;
        debugInst_2 = 32'h0;
        debugInst_3 = 32'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Regfile regfile (
    .clock                    (clock),
    .reset                    (reset),
    .io_readAddr_0_valid      (_dispatch_io_rs1Read_0_valid),
    .io_readAddr_0_addr       (_dispatch_io_rs1Read_0_addr),
    .io_readAddr_1_valid      (_dispatch_io_rs2Read_0_valid),
    .io_readAddr_1_addr       (_dispatch_io_rs2Read_0_addr),
    .io_readAddr_2_valid      (_dispatch_io_rs1Read_1_valid),
    .io_readAddr_2_addr       (_dispatch_io_rs1Read_1_addr),
    .io_readAddr_3_valid      (_dispatch_io_rs2Read_1_valid),
    .io_readAddr_3_addr       (_dispatch_io_rs2Read_1_addr),
    .io_readAddr_4_valid      (_dispatch_io_rs1Read_2_valid),
    .io_readAddr_4_addr       (_dispatch_io_rs1Read_2_addr),
    .io_readAddr_5_valid      (_dispatch_io_rs2Read_2_valid),
    .io_readAddr_5_addr       (_dispatch_io_rs2Read_2_addr),
    .io_readAddr_6_valid      (_dispatch_io_rs1Read_3_valid),
    .io_readAddr_6_addr       (_dispatch_io_rs1Read_3_addr),
    .io_readAddr_7_valid      (_dispatch_io_rs2Read_3_valid),
    .io_readAddr_7_addr       (_dispatch_io_rs2Read_3_addr),
    .io_readSet_0_valid       (_dispatch_io_rs1Set_0_valid),
    .io_readSet_0_value       (_dispatch_io_rs1Set_0_value),
    .io_readSet_1_valid       (_dispatch_io_rs2Set_0_valid),
    .io_readSet_1_value       (_dispatch_io_rs2Set_0_value),
    .io_readSet_2_valid       (_dispatch_io_rs1Set_1_valid),
    .io_readSet_2_value       (_dispatch_io_rs1Set_1_value),
    .io_readSet_3_valid       (_dispatch_io_rs2Set_1_valid),
    .io_readSet_3_value       (_dispatch_io_rs2Set_1_value),
    .io_readSet_4_valid       (_dispatch_io_rs1Set_2_valid),
    .io_readSet_4_value       (_dispatch_io_rs1Set_2_value),
    .io_readSet_5_valid       (_dispatch_io_rs2Set_2_valid),
    .io_readSet_5_value       (_dispatch_io_rs2Set_2_value),
    .io_readSet_6_valid       (_dispatch_io_rs1Set_3_valid),
    .io_readSet_6_value       (_dispatch_io_rs1Set_3_value),
    .io_readSet_7_valid       (_dispatch_io_rs2Set_3_valid),
    .io_readSet_7_value       (_dispatch_io_rs2Set_3_value),
    .io_writeAddr_0_valid     (_dispatch_io_rdMark_0_valid),
    .io_writeAddr_0_addr      (_dispatch_io_rdMark_0_addr),
    .io_writeAddr_1_valid     (_dispatch_io_rdMark_1_valid),
    .io_writeAddr_1_addr      (_dispatch_io_rdMark_1_addr),
    .io_writeAddr_2_valid     (_dispatch_io_rdMark_2_valid),
    .io_writeAddr_2_addr      (_dispatch_io_rdMark_2_addr),
    .io_writeAddr_3_valid     (_dispatch_io_rdMark_3_valid),
    .io_writeAddr_3_addr      (_dispatch_io_rdMark_3_addr),
    .io_busAddr_0_bypass      (_dispatch_io_busRead_0_bypass),
    .io_busAddr_0_immen       (_dispatch_io_busRead_0_immen),
    .io_busAddr_0_immed       (_dispatch_io_busRead_0_immed),
    .io_busAddr_1_bypass      (_dispatch_io_busRead_1_bypass),
    .io_busAddr_1_immed       (_dispatch_io_busRead_1_immed),
    .io_busAddr_2_bypass      (_dispatch_io_busRead_2_bypass),
    .io_busAddr_2_immed       (_dispatch_io_busRead_2_immed),
    .io_busAddr_3_bypass      (_dispatch_io_busRead_3_bypass),
    .io_busAddr_3_immed       (_dispatch_io_busRead_3_immed),
    .io_target_0_data         (_regfile_io_target_0_data),
    .io_target_1_data         (_regfile_io_target_1_data),
    .io_target_2_data         (_regfile_io_target_2_data),
    .io_target_3_data         (_regfile_io_target_3_data),
    .io_busPort_addr_0        (_regfile_io_busPort_addr_0),
    .io_busPort_addr_1        (_regfile_io_busPort_addr_1),
    .io_busPort_addr_2        (_regfile_io_busPort_addr_2),
    .io_busPort_addr_3        (_regfile_io_busPort_addr_3),
    .io_busPort_data_0        (_regfile_io_busPort_data_0),
    .io_busPort_data_1        (_regfile_io_busPort_data_1),
    .io_busPort_data_2        (_regfile_io_busPort_data_2),
    .io_busPort_data_3        (_regfile_io_busPort_data_3),
    .io_readData_0_valid      (_regfile_io_readData_0_valid),
    .io_readData_0_data       (_regfile_io_readData_0_data),
    .io_readData_1_valid      (_regfile_io_readData_1_valid),
    .io_readData_1_data       (_regfile_io_readData_1_data),
    .io_readData_2_valid      (_regfile_io_readData_2_valid),
    .io_readData_2_data       (_regfile_io_readData_2_data),
    .io_readData_3_valid      (_regfile_io_readData_3_valid),
    .io_readData_3_data       (_regfile_io_readData_3_data),
    .io_readData_4_valid      (_regfile_io_readData_4_valid),
    .io_readData_4_data       (_regfile_io_readData_4_data),
    .io_readData_5_valid      (_regfile_io_readData_5_valid),
    .io_readData_5_data       (_regfile_io_readData_5_data),
    .io_readData_6_valid      (_regfile_io_readData_6_valid),
    .io_readData_6_data       (_regfile_io_readData_6_data),
    .io_readData_7_valid      (_regfile_io_readData_7_valid),
    .io_readData_7_data       (_regfile_io_readData_7_data),
    .io_writeData_0_valid     (regfile_io_writeData_0_valid),
    .io_writeData_0_bits_addr (regfile_io_writeData_0_bits_addr),
    .io_writeData_0_bits_data (regfile_io_writeData_0_bits_data),
    .io_writeData_1_valid     (regfile_io_writeData_1_valid),
    .io_writeData_1_bits_addr (regfile_io_writeData_1_bits_addr),
    .io_writeData_1_bits_data (regfile_io_writeData_1_bits_data),
    .io_writeData_2_valid     (regfile_io_writeData_2_valid),
    .io_writeData_2_bits_addr (regfile_io_writeData_2_bits_addr),
    .io_writeData_2_bits_data (regfile_io_writeData_2_bits_data),
    .io_writeData_3_valid     (regfile_io_writeData_3_valid),
    .io_writeData_3_bits_addr (regfile_io_writeData_3_bits_addr),
    .io_writeData_3_bits_data (regfile_io_writeData_3_bits_data),
    .io_writeData_4_valid     (_arb_io_out_valid),
    .io_writeData_4_bits_addr (_arb_io_out_bits_addr),
    .io_writeData_4_bits_data (_arb_io_out_bits_data),
    .io_writeData_5_valid     (_lsu_io_rd_valid),
    .io_writeData_5_bits_addr (_lsu_io_rd_bits_addr),
    .io_writeData_5_bits_data (_lsu_io_rd_bits_data),
    .io_writeMask_1_valid     (_bru_0_io_taken_valid),
    .io_writeMask_2_valid     (writeMask_2),
    .io_writeMask_3_valid     (writeMask_2 | _bru_2_io_taken_valid),
    .io_writeMask_5_valid     (_lsu_io_fault_valid),
    .io_scoreboard_regd       (_regfile_io_scoreboard_regd),
    .io_scoreboard_comb       (_regfile_io_scoreboard_comb)
  );
  UncachedFetch fetch (
    .clock                        (clock),
    .reset                        (reset),
    .io_csr_value_0               (io_csr_in_value_0),
    .io_ibus_valid                (_fetch_io_ibus_valid),
    .io_ibus_ready                (~_lsu_io_ibus_valid),
    .io_ibus_addr                 (_fetch_io_ibus_addr),
    .io_ibus_rdata                (io_ibus_rdata),
    .io_ibus_fault_valid          (~_lsu_io_ibus_valid & io_ibus_fault_valid),
    .io_inst_lanes_0_ready        (_dispatch_io_inst_0_ready),
    .io_inst_lanes_0_valid        (_fetch_io_inst_lanes_0_valid),
    .io_inst_lanes_0_bits_addr    (_fetch_io_inst_lanes_0_bits_addr),
    .io_inst_lanes_0_bits_inst    (_fetch_io_inst_lanes_0_bits_inst),
    .io_inst_lanes_0_bits_brchFwd (_fetch_io_inst_lanes_0_bits_brchFwd),
    .io_inst_lanes_1_ready        (_dispatch_io_inst_1_ready),
    .io_inst_lanes_1_valid        (_fetch_io_inst_lanes_1_valid),
    .io_inst_lanes_1_bits_addr    (_fetch_io_inst_lanes_1_bits_addr),
    .io_inst_lanes_1_bits_inst    (_fetch_io_inst_lanes_1_bits_inst),
    .io_inst_lanes_1_bits_brchFwd (_fetch_io_inst_lanes_1_bits_brchFwd),
    .io_inst_lanes_2_ready        (_dispatch_io_inst_2_ready),
    .io_inst_lanes_2_valid        (_fetch_io_inst_lanes_2_valid),
    .io_inst_lanes_2_bits_addr    (_fetch_io_inst_lanes_2_bits_addr),
    .io_inst_lanes_2_bits_inst    (_fetch_io_inst_lanes_2_bits_inst),
    .io_inst_lanes_2_bits_brchFwd (_fetch_io_inst_lanes_2_bits_brchFwd),
    .io_inst_lanes_3_ready        (_dispatch_io_inst_3_ready),
    .io_inst_lanes_3_valid        (_fetch_io_inst_lanes_3_valid),
    .io_inst_lanes_3_bits_addr    (_fetch_io_inst_lanes_3_bits_addr),
    .io_inst_lanes_3_bits_inst    (_fetch_io_inst_lanes_3_bits_inst),
    .io_inst_lanes_3_bits_brchFwd (_fetch_io_inst_lanes_3_bits_brchFwd),
    .io_branch_0_valid            (_bru_0_io_taken_valid),
    .io_branch_0_value            (_bru_0_io_taken_value),
    .io_branch_1_valid            (_bru_1_io_taken_valid),
    .io_branch_1_value            (_bru_1_io_taken_value),
    .io_branch_2_valid            (_bru_2_io_taken_valid),
    .io_branch_2_value            (_bru_2_io_taken_value),
    .io_branch_3_valid            (_bru_3_io_taken_valid),
    .io_branch_3_value            (_bru_3_io_taken_value),
    .io_iflush_valid              (_lsu_io_flush_valid & _lsu_io_flush_fencei),
    .io_iflush_pcNext             (_lsu_io_flush_pcNext),
    .io_pc                        (_fetch_io_pc),
    .io_fault_valid               (_fetch_io_fault_valid),
    .io_fault_bits                (_fetch_io_fault_bits)
  );
  Csr csr (
    .clock                     (clock),
    .reset                     (reset),
    .io_csr_in_value_12        (_fetch_io_pc),
    .io_csr_out_value_0        (io_csr_out_value_0),
    .io_csr_out_value_1        (io_csr_out_value_1),
    .io_csr_out_value_2        (io_csr_out_value_2),
    .io_csr_out_value_3        (io_csr_out_value_3),
    .io_csr_out_value_4        (_csr_io_csr_out_value_4),
    .io_csr_out_value_5        (io_csr_out_value_5),
    .io_csr_out_value_6        (io_csr_out_value_6),
    .io_csr_out_value_7        (io_csr_out_value_7),
    .io_csr_out_value_8        (io_csr_out_value_8),
    .io_req_valid              (_dispatch_io_csr_valid),
    .io_req_bits_addr          (_dispatch_io_csr_bits_addr),
    .io_req_bits_index         (_dispatch_io_csr_bits_index),
    .io_req_bits_rs1           (_dispatch_io_csr_bits_rs1),
    .io_req_bits_op            (_dispatch_io_csr_bits_op),
    .io_rs1_valid              (_regfile_io_readData_0_valid),
    .io_rs1_data               (_regfile_io_readData_0_data),
    .io_rd_valid               (_csr_io_rd_valid),
    .io_rd_bits_addr           (_csr_io_rd_bits_addr),
    .io_rd_bits_data           (_csr_io_rd_bits_data),
    .io_bru_in_mode_valid      (_bru_0_io_csr_in_mode_valid),
    .io_bru_in_mode_bits       (_bru_0_io_csr_in_mode_bits),
    .io_bru_in_mcause_valid    (_bru_0_io_csr_in_mcause_valid),
    .io_bru_in_mcause_bits     (_bru_0_io_csr_in_mcause_bits),
    .io_bru_in_mepc_valid      (_bru_0_io_csr_in_mepc_valid),
    .io_bru_in_mepc_bits       (_bru_0_io_csr_in_mepc_bits),
    .io_bru_in_mtval_valid     (_bru_0_io_csr_in_mtval_valid),
    .io_bru_in_mtval_bits      (_bru_0_io_csr_in_mtval_bits),
    .io_bru_in_halt            (_bru_0_io_csr_in_halt),
    .io_bru_in_fault           (_bru_0_io_csr_in_fault),
    .io_bru_in_wfi             (_bru_0_io_csr_in_wfi),
    .io_bru_out_mode           (_csr_io_bru_out_mode),
    .io_bru_out_mepc           (_csr_io_bru_out_mepc),
    .io_bru_out_mtvec          (_csr_io_bru_out_mtvec),
    .io_float_in_fflags_valid  (_floatCore_io_csr_in_fflags_valid),
    .io_float_in_fflags_bits   (_floatCore_io_csr_in_fflags_bits),
    .io_float_out_frm          (_csr_io_float_out_frm),
    .io_rvv_vstart             (io_rvvcore_csr_vstart),
    .io_rvv_vl                 (io_rvvcore_configState_bits_vl[6:0]),
    .io_rvv_vtype
      ({io_rvvcore_configState_bits_vill,
        23'h0,
        io_rvvcore_configState_bits_ma,
        io_rvvcore_configState_bits_ta,
        io_rvvcore_configState_bits_sew,
        io_rvvcore_configState_bits_lmul_orig}),
    .io_rvv_vxrm               (io_rvvcore_csr_vxrm),
    .io_rvv_vxsat              (io_rvvcore_csr_vxsat),
    .io_rvv_vstart_write_valid (io_rvvcore_csr_vstart_write_valid),
    .io_rvv_vstart_write_bits  (io_rvvcore_csr_vstart_write_bits),
    .io_rvv_vxrm_write_valid   (io_rvvcore_csr_vxrm_write_valid),
    .io_rvv_vxrm_write_bits    (io_rvvcore_csr_vxrm_write_bits),
    .io_rvv_vxsat_write_valid  (io_rvvcore_csr_vxsat_write_valid),
    .io_rvv_vxsat_write_bits   (io_rvvcore_csr_vxsat_write_bits),
    .io_rvv_frm                (io_rvvcore_csr_frm),
    .io_counters_nRetired      (_retirement_buffer_io_nRetired),
    .io_halted                 (_csr_io_halted),
    .io_fault                  (io_fault),
    .io_wfi                    (_csr_io_wfi),
    .io_irq                    (io_irq)
  );
  DispatchV2 dispatch (
    .clock                             (clock),
    .reset                             (reset),
    .io_halted                         (_csr_io_halted | _csr_io_wfi),
    .io_lsuActive                      (_lsu_io_active),
    .io_scoreboard_regd                (_regfile_io_scoreboard_regd),
    .io_scoreboard_comb                (_regfile_io_scoreboard_comb),
    .io_fscoreboard                    (_fRegfile_io_scoreboard),
    .io_branchTaken                    (branchTaken),
    .io_csrFault_0                     (_dispatch_io_csrFault_0),
    .io_jalFault_0                     (_dispatch_io_jalFault_0),
    .io_jalFault_1                     (_dispatch_io_jalFault_1),
    .io_jalFault_2                     (_dispatch_io_jalFault_2),
    .io_jalFault_3                     (_dispatch_io_jalFault_3),
    .io_jalrFault_0                    (_dispatch_io_jalrFault_0),
    .io_jalrFault_1                    (_dispatch_io_jalrFault_1),
    .io_jalrFault_2                    (_dispatch_io_jalrFault_2),
    .io_jalrFault_3                    (_dispatch_io_jalrFault_3),
    .io_bxxFault_0                     (_dispatch_io_bxxFault_0),
    .io_bxxFault_1                     (_dispatch_io_bxxFault_1),
    .io_bxxFault_2                     (_dispatch_io_bxxFault_2),
    .io_bxxFault_3                     (_dispatch_io_bxxFault_3),
    .io_undefFault_0                   (_dispatch_io_undefFault_0),
    .io_rvvFault_0                     (_dispatch_io_rvvFault_0),
    .io_bruTarget_0                    (_dispatch_io_bruTarget_0),
    .io_bruTarget_1                    (_dispatch_io_bruTarget_1),
    .io_bruTarget_2                    (_dispatch_io_bruTarget_2),
    .io_bruTarget_3                    (_dispatch_io_bruTarget_3),
    .io_jalrTarget_0_data              (_regfile_io_target_0_data),
    .io_jalrTarget_1_data              (_regfile_io_target_1_data),
    .io_jalrTarget_2_data              (_regfile_io_target_2_data),
    .io_jalrTarget_3_data              (_regfile_io_target_3_data),
    .io_interlock                      (_bru_0_io_interlock | _lsu_io_flush_valid),
    .io_inst_0_ready                   (_dispatch_io_inst_0_ready),
    .io_inst_0_valid                   (_fetch_io_inst_lanes_0_valid),
    .io_inst_0_bits_addr               (_fetch_io_inst_lanes_0_bits_addr),
    .io_inst_0_bits_inst               (_fetch_io_inst_lanes_0_bits_inst),
    .io_inst_0_bits_brchFwd            (_fetch_io_inst_lanes_0_bits_brchFwd),
    .io_inst_1_ready                   (_dispatch_io_inst_1_ready),
    .io_inst_1_valid                   (_fetch_io_inst_lanes_1_valid),
    .io_inst_1_bits_addr               (_fetch_io_inst_lanes_1_bits_addr),
    .io_inst_1_bits_inst               (_fetch_io_inst_lanes_1_bits_inst),
    .io_inst_1_bits_brchFwd            (_fetch_io_inst_lanes_1_bits_brchFwd),
    .io_inst_2_ready                   (_dispatch_io_inst_2_ready),
    .io_inst_2_valid                   (_fetch_io_inst_lanes_2_valid),
    .io_inst_2_bits_addr               (_fetch_io_inst_lanes_2_bits_addr),
    .io_inst_2_bits_inst               (_fetch_io_inst_lanes_2_bits_inst),
    .io_inst_2_bits_brchFwd            (_fetch_io_inst_lanes_2_bits_brchFwd),
    .io_inst_3_ready                   (_dispatch_io_inst_3_ready),
    .io_inst_3_valid                   (_fetch_io_inst_lanes_3_valid),
    .io_inst_3_bits_addr               (_fetch_io_inst_lanes_3_bits_addr),
    .io_inst_3_bits_inst               (_fetch_io_inst_lanes_3_bits_inst),
    .io_inst_3_bits_brchFwd            (_fetch_io_inst_lanes_3_bits_brchFwd),
    .io_rs1Read_0_valid                (_dispatch_io_rs1Read_0_valid),
    .io_rs1Read_0_addr                 (_dispatch_io_rs1Read_0_addr),
    .io_rs1Read_1_valid                (_dispatch_io_rs1Read_1_valid),
    .io_rs1Read_1_addr                 (_dispatch_io_rs1Read_1_addr),
    .io_rs1Read_2_valid                (_dispatch_io_rs1Read_2_valid),
    .io_rs1Read_2_addr                 (_dispatch_io_rs1Read_2_addr),
    .io_rs1Read_3_valid                (_dispatch_io_rs1Read_3_valid),
    .io_rs1Read_3_addr                 (_dispatch_io_rs1Read_3_addr),
    .io_rs1Set_0_valid                 (_dispatch_io_rs1Set_0_valid),
    .io_rs1Set_0_value                 (_dispatch_io_rs1Set_0_value),
    .io_rs1Set_1_valid                 (_dispatch_io_rs1Set_1_valid),
    .io_rs1Set_1_value                 (_dispatch_io_rs1Set_1_value),
    .io_rs1Set_2_valid                 (_dispatch_io_rs1Set_2_valid),
    .io_rs1Set_2_value                 (_dispatch_io_rs1Set_2_value),
    .io_rs1Set_3_valid                 (_dispatch_io_rs1Set_3_valid),
    .io_rs1Set_3_value                 (_dispatch_io_rs1Set_3_value),
    .io_rs2Read_0_valid                (_dispatch_io_rs2Read_0_valid),
    .io_rs2Read_0_addr                 (_dispatch_io_rs2Read_0_addr),
    .io_rs2Read_1_valid                (_dispatch_io_rs2Read_1_valid),
    .io_rs2Read_1_addr                 (_dispatch_io_rs2Read_1_addr),
    .io_rs2Read_2_valid                (_dispatch_io_rs2Read_2_valid),
    .io_rs2Read_2_addr                 (_dispatch_io_rs2Read_2_addr),
    .io_rs2Read_3_valid                (_dispatch_io_rs2Read_3_valid),
    .io_rs2Read_3_addr                 (_dispatch_io_rs2Read_3_addr),
    .io_rs2Set_0_valid                 (_dispatch_io_rs2Set_0_valid),
    .io_rs2Set_0_value                 (_dispatch_io_rs2Set_0_value),
    .io_rs2Set_1_valid                 (_dispatch_io_rs2Set_1_valid),
    .io_rs2Set_1_value                 (_dispatch_io_rs2Set_1_value),
    .io_rs2Set_2_valid                 (_dispatch_io_rs2Set_2_valid),
    .io_rs2Set_2_value                 (_dispatch_io_rs2Set_2_value),
    .io_rs2Set_3_valid                 (_dispatch_io_rs2Set_3_valid),
    .io_rs2Set_3_value                 (_dispatch_io_rs2Set_3_value),
    .io_rdMark_0_valid                 (_dispatch_io_rdMark_0_valid),
    .io_rdMark_0_addr                  (_dispatch_io_rdMark_0_addr),
    .io_rdMark_1_valid                 (_dispatch_io_rdMark_1_valid),
    .io_rdMark_1_addr                  (_dispatch_io_rdMark_1_addr),
    .io_rdMark_2_valid                 (_dispatch_io_rdMark_2_valid),
    .io_rdMark_2_addr                  (_dispatch_io_rdMark_2_addr),
    .io_rdMark_3_valid                 (_dispatch_io_rdMark_3_valid),
    .io_rdMark_3_addr                  (_dispatch_io_rdMark_3_addr),
    .io_busRead_0_bypass               (_dispatch_io_busRead_0_bypass),
    .io_busRead_0_immen                (_dispatch_io_busRead_0_immen),
    .io_busRead_0_immed                (_dispatch_io_busRead_0_immed),
    .io_busRead_1_bypass               (_dispatch_io_busRead_1_bypass),
    .io_busRead_1_immed                (_dispatch_io_busRead_1_immed),
    .io_busRead_2_bypass               (_dispatch_io_busRead_2_bypass),
    .io_busRead_2_immed                (_dispatch_io_busRead_2_immed),
    .io_busRead_3_bypass               (_dispatch_io_busRead_3_bypass),
    .io_busRead_3_immed                (_dispatch_io_busRead_3_immed),
    .io_rdMark_flt_valid               (_dispatch_io_rdMark_flt_valid),
    .io_rdMark_flt_addr                (_dispatch_io_rdMark_flt_addr),
    .io_rvvRdMark_0_valid              (_dispatch_io_rvvRdMark_0_valid),
    .io_rvvRdMark_0_addr               (_dispatch_io_rvvRdMark_0_addr),
    .io_rvvRdMark_1_valid              (_dispatch_io_rvvRdMark_1_valid),
    .io_rvvRdMark_1_addr               (_dispatch_io_rvvRdMark_1_addr),
    .io_rvvRdMark_2_valid              (_dispatch_io_rvvRdMark_2_valid),
    .io_rvvRdMark_2_addr               (_dispatch_io_rvvRdMark_2_addr),
    .io_rvvRdMark_3_valid              (_dispatch_io_rvvRdMark_3_valid),
    .io_rvvRdMark_3_addr               (_dispatch_io_rvvRdMark_3_addr),
    .io_alu_0_valid                    (_dispatch_io_alu_0_valid),
    .io_alu_0_bits_addr                (_dispatch_io_alu_0_bits_addr),
    .io_alu_0_bits_op                  (_dispatch_io_alu_0_bits_op),
    .io_alu_1_valid                    (_dispatch_io_alu_1_valid),
    .io_alu_1_bits_addr                (_dispatch_io_alu_1_bits_addr),
    .io_alu_1_bits_op                  (_dispatch_io_alu_1_bits_op),
    .io_alu_2_valid                    (_dispatch_io_alu_2_valid),
    .io_alu_2_bits_addr                (_dispatch_io_alu_2_bits_addr),
    .io_alu_2_bits_op                  (_dispatch_io_alu_2_bits_op),
    .io_alu_3_valid                    (_dispatch_io_alu_3_valid),
    .io_alu_3_bits_addr                (_dispatch_io_alu_3_bits_addr),
    .io_alu_3_bits_op                  (_dispatch_io_alu_3_bits_op),
    .io_bru_0_valid                    (_dispatch_io_bru_0_valid),
    .io_bru_0_bits_fwd                 (_dispatch_io_bru_0_bits_fwd),
    .io_bru_0_bits_op                  (_dispatch_io_bru_0_bits_op),
    .io_bru_0_bits_pc                  (_dispatch_io_bru_0_bits_pc),
    .io_bru_0_bits_target              (_dispatch_io_bru_0_bits_target),
    .io_bru_0_bits_link                (_dispatch_io_bru_0_bits_link),
    .io_bru_1_valid                    (_dispatch_io_bru_1_valid),
    .io_bru_1_bits_fwd                 (_dispatch_io_bru_1_bits_fwd),
    .io_bru_1_bits_op                  (_dispatch_io_bru_1_bits_op),
    .io_bru_1_bits_pc                  (_dispatch_io_bru_1_bits_pc),
    .io_bru_1_bits_target              (_dispatch_io_bru_1_bits_target),
    .io_bru_1_bits_link                (_dispatch_io_bru_1_bits_link),
    .io_bru_2_valid                    (_dispatch_io_bru_2_valid),
    .io_bru_2_bits_fwd                 (_dispatch_io_bru_2_bits_fwd),
    .io_bru_2_bits_op                  (_dispatch_io_bru_2_bits_op),
    .io_bru_2_bits_pc                  (_dispatch_io_bru_2_bits_pc),
    .io_bru_2_bits_target              (_dispatch_io_bru_2_bits_target),
    .io_bru_2_bits_link                (_dispatch_io_bru_2_bits_link),
    .io_bru_3_valid                    (_dispatch_io_bru_3_valid),
    .io_bru_3_bits_fwd                 (_dispatch_io_bru_3_bits_fwd),
    .io_bru_3_bits_op                  (_dispatch_io_bru_3_bits_op),
    .io_bru_3_bits_pc                  (_dispatch_io_bru_3_bits_pc),
    .io_bru_3_bits_target              (_dispatch_io_bru_3_bits_target),
    .io_bru_3_bits_link                (_dispatch_io_bru_3_bits_link),
    .io_csr_valid                      (_dispatch_io_csr_valid),
    .io_csr_bits_addr                  (_dispatch_io_csr_bits_addr),
    .io_csr_bits_index                 (_dispatch_io_csr_bits_index),
    .io_csr_bits_rs1                   (_dispatch_io_csr_bits_rs1),
    .io_csr_bits_op                    (_dispatch_io_csr_bits_op),
    .io_lsu_0_ready                    (_lsu_io_req_0_ready),
    .io_lsu_0_valid                    (_dispatch_io_lsu_0_valid),
    .io_lsu_0_bits_store               (_dispatch_io_lsu_0_bits_store),
    .io_lsu_0_bits_addr                (_dispatch_io_lsu_0_bits_addr),
    .io_lsu_0_bits_op                  (_dispatch_io_lsu_0_bits_op),
    .io_lsu_0_bits_pc                  (_dispatch_io_lsu_0_bits_pc),
    .io_lsu_0_bits_elemWidth           (_dispatch_io_lsu_0_bits_elemWidth),
    .io_lsu_0_bits_nfields             (_dispatch_io_lsu_0_bits_nfields),
    .io_lsu_0_bits_umop                (_dispatch_io_lsu_0_bits_umop),
    .io_lsu_1_ready                    (_lsu_io_req_1_ready),
    .io_lsu_1_valid                    (_dispatch_io_lsu_1_valid),
    .io_lsu_1_bits_store               (_dispatch_io_lsu_1_bits_store),
    .io_lsu_1_bits_addr                (_dispatch_io_lsu_1_bits_addr),
    .io_lsu_1_bits_op                  (_dispatch_io_lsu_1_bits_op),
    .io_lsu_1_bits_pc                  (_dispatch_io_lsu_1_bits_pc),
    .io_lsu_1_bits_elemWidth           (_dispatch_io_lsu_1_bits_elemWidth),
    .io_lsu_1_bits_nfields             (_dispatch_io_lsu_1_bits_nfields),
    .io_lsu_1_bits_umop                (_dispatch_io_lsu_1_bits_umop),
    .io_lsu_2_ready                    (_lsu_io_req_2_ready),
    .io_lsu_2_valid                    (_dispatch_io_lsu_2_valid),
    .io_lsu_2_bits_store               (_dispatch_io_lsu_2_bits_store),
    .io_lsu_2_bits_addr                (_dispatch_io_lsu_2_bits_addr),
    .io_lsu_2_bits_op                  (_dispatch_io_lsu_2_bits_op),
    .io_lsu_2_bits_pc                  (_dispatch_io_lsu_2_bits_pc),
    .io_lsu_2_bits_elemWidth           (_dispatch_io_lsu_2_bits_elemWidth),
    .io_lsu_2_bits_nfields             (_dispatch_io_lsu_2_bits_nfields),
    .io_lsu_2_bits_umop                (_dispatch_io_lsu_2_bits_umop),
    .io_lsu_3_ready                    (_lsu_io_req_3_ready),
    .io_lsu_3_valid                    (_dispatch_io_lsu_3_valid),
    .io_lsu_3_bits_store               (_dispatch_io_lsu_3_bits_store),
    .io_lsu_3_bits_addr                (_dispatch_io_lsu_3_bits_addr),
    .io_lsu_3_bits_op                  (_dispatch_io_lsu_3_bits_op),
    .io_lsu_3_bits_pc                  (_dispatch_io_lsu_3_bits_pc),
    .io_lsu_3_bits_elemWidth           (_dispatch_io_lsu_3_bits_elemWidth),
    .io_lsu_3_bits_nfields             (_dispatch_io_lsu_3_bits_nfields),
    .io_lsu_3_bits_umop                (_dispatch_io_lsu_3_bits_umop),
    .io_lsuQueueCapacity               (_lsu_io_queueCapacity),
    .io_mlu_0_valid                    (_dispatch_io_mlu_0_valid),
    .io_mlu_0_bits_addr                (_dispatch_io_mlu_0_bits_addr),
    .io_mlu_0_bits_op                  (_dispatch_io_mlu_0_bits_op),
    .io_mlu_1_ready                    (_mlu_io_req_1_ready),
    .io_mlu_1_valid                    (_dispatch_io_mlu_1_valid),
    .io_mlu_1_bits_addr                (_dispatch_io_mlu_1_bits_addr),
    .io_mlu_1_bits_op                  (_dispatch_io_mlu_1_bits_op),
    .io_mlu_2_ready                    (_mlu_io_req_2_ready),
    .io_mlu_2_valid                    (_dispatch_io_mlu_2_valid),
    .io_mlu_2_bits_addr                (_dispatch_io_mlu_2_bits_addr),
    .io_mlu_2_bits_op                  (_dispatch_io_mlu_2_bits_op),
    .io_mlu_3_ready                    (_mlu_io_req_3_ready),
    .io_mlu_3_valid                    (_dispatch_io_mlu_3_valid),
    .io_mlu_3_bits_addr                (_dispatch_io_mlu_3_bits_addr),
    .io_mlu_3_bits_op                  (_dispatch_io_mlu_3_bits_op),
    .io_dvu_0_ready                    (_dvu_io_req_ready),
    .io_dvu_0_valid                    (_dispatch_io_dvu_0_valid),
    .io_dvu_0_bits_addr                (_dispatch_io_dvu_0_bits_addr),
    .io_dvu_0_bits_op                  (_dispatch_io_dvu_0_bits_op),
    .io_rvv_0_ready                    (io_rvvcore_inst_0_ready),
    .io_rvv_0_valid                    (io_rvvcore_inst_0_valid),
    .io_rvv_0_bits_pc                  (io_rvvcore_inst_0_bits_pc),
    .io_rvv_0_bits_opcode              (io_rvvcore_inst_0_bits_opcode),
    .io_rvv_0_bits_bits                (io_rvvcore_inst_0_bits_bits),
    .io_rvv_1_ready                    (io_rvvcore_inst_1_ready),
    .io_rvv_1_valid                    (io_rvvcore_inst_1_valid),
    .io_rvv_1_bits_pc                  (io_rvvcore_inst_1_bits_pc),
    .io_rvv_1_bits_opcode              (io_rvvcore_inst_1_bits_opcode),
    .io_rvv_1_bits_bits                (io_rvvcore_inst_1_bits_bits),
    .io_rvv_2_ready                    (io_rvvcore_inst_2_ready),
    .io_rvv_2_valid                    (io_rvvcore_inst_2_valid),
    .io_rvv_2_bits_pc                  (io_rvvcore_inst_2_bits_pc),
    .io_rvv_2_bits_opcode              (io_rvvcore_inst_2_bits_opcode),
    .io_rvv_2_bits_bits                (io_rvvcore_inst_2_bits_bits),
    .io_rvv_3_ready                    (io_rvvcore_inst_3_ready),
    .io_rvv_3_valid                    (io_rvvcore_inst_3_valid),
    .io_rvv_3_bits_pc                  (io_rvvcore_inst_3_bits_pc),
    .io_rvv_3_bits_opcode              (io_rvvcore_inst_3_bits_opcode),
    .io_rvv_3_bits_bits                (io_rvvcore_inst_3_bits_bits),
    .io_rvvState_valid                 (io_rvvcore_configState_valid),
    .io_rvvState_bits_vstart           (io_rvvcore_configState_bits_vstart),
    .io_rvvIdle                        (io_rvvcore_rvv_idle),
    .io_rvvQueueCapacity               (io_rvvcore_queue_capacity),
    .io_float_ready                    (_floatCore_io_inst_ready),
    .io_float_valid                    (_dispatch_io_float_valid),
    .io_float_bits_opcode              (_dispatch_io_float_bits_opcode),
    .io_float_bits_funct5              (_dispatch_io_float_bits_funct5),
    .io_float_bits_rs3                 (_dispatch_io_float_bits_rs3),
    .io_float_bits_rs2                 (_dispatch_io_float_bits_rs2),
    .io_float_bits_rs1                 (_dispatch_io_float_bits_rs1),
    .io_float_bits_rm                  (_dispatch_io_float_bits_rm),
    .io_float_bits_inst                (_dispatch_io_float_bits_inst),
    .io_float_bits_pc                  (_dispatch_io_float_bits_pc),
    .io_float_bits_scalar_rd           (_dispatch_io_float_bits_scalar_rd),
    .io_float_bits_scalar_rs1          (_dispatch_io_float_bits_scalar_rs1),
    .io_float_bits_float_rs1           (_dispatch_io_float_bits_float_rs1),
    .io_float_bits_rd                  (_dispatch_io_float_bits_rd),
    .io_float_bits_uses_rs3            (_dispatch_io_float_bits_uses_rs3),
    .io_float_bits_uses_rs2            (_dispatch_io_float_bits_uses_rs2),
    .io_csrFrm                         (_csr_io_float_out_frm),
    .io_fbusPortAddr                   (_dispatch_io_fbusPortAddr),
    .io_slog                           (_dispatch_io_slog),
    .io_retirement_buffer_nSpace       (_retirement_buffer_io_nSpace[4:0]),
    .io_retirement_buffer_empty        (_retirement_buffer_io_empty),
    .io_retirement_buffer_trap_pending (_retirement_buffer_io_trapPending),
    .io_branch_0                       (_dispatch_io_branch_0),
    .io_branch_1                       (_dispatch_io_branch_1),
    .io_branch_2                       (_dispatch_io_branch_2),
    .io_branch_3                       (_dispatch_io_branch_3),
    .io_jump_0                         (_dispatch_io_jump_0),
    .io_jump_1                         (_dispatch_io_jump_1),
    .io_jump_2                         (_dispatch_io_jump_2),
    .io_jump_3                         (_dispatch_io_jump_3)
  );
  LsuV2 lsu (
    .clock                                (clock),
    .reset                                (reset),
    .io_req_0_ready                       (_lsu_io_req_0_ready),
    .io_req_0_valid                       (_dispatch_io_lsu_0_valid),
    .io_req_0_bits_store                  (_dispatch_io_lsu_0_bits_store),
    .io_req_0_bits_addr                   (_dispatch_io_lsu_0_bits_addr),
    .io_req_0_bits_op                     (_dispatch_io_lsu_0_bits_op),
    .io_req_0_bits_pc                     (_dispatch_io_lsu_0_bits_pc),
    .io_req_0_bits_elemWidth              (_dispatch_io_lsu_0_bits_elemWidth),
    .io_req_0_bits_nfields                (_dispatch_io_lsu_0_bits_nfields),
    .io_req_0_bits_umop                   (_dispatch_io_lsu_0_bits_umop),
    .io_req_1_ready                       (_lsu_io_req_1_ready),
    .io_req_1_valid                       (_dispatch_io_lsu_1_valid),
    .io_req_1_bits_store                  (_dispatch_io_lsu_1_bits_store),
    .io_req_1_bits_addr                   (_dispatch_io_lsu_1_bits_addr),
    .io_req_1_bits_op                     (_dispatch_io_lsu_1_bits_op),
    .io_req_1_bits_pc                     (_dispatch_io_lsu_1_bits_pc),
    .io_req_1_bits_elemWidth              (_dispatch_io_lsu_1_bits_elemWidth),
    .io_req_1_bits_nfields                (_dispatch_io_lsu_1_bits_nfields),
    .io_req_1_bits_umop                   (_dispatch_io_lsu_1_bits_umop),
    .io_req_2_ready                       (_lsu_io_req_2_ready),
    .io_req_2_valid                       (_dispatch_io_lsu_2_valid),
    .io_req_2_bits_store                  (_dispatch_io_lsu_2_bits_store),
    .io_req_2_bits_addr                   (_dispatch_io_lsu_2_bits_addr),
    .io_req_2_bits_op                     (_dispatch_io_lsu_2_bits_op),
    .io_req_2_bits_pc                     (_dispatch_io_lsu_2_bits_pc),
    .io_req_2_bits_elemWidth              (_dispatch_io_lsu_2_bits_elemWidth),
    .io_req_2_bits_nfields                (_dispatch_io_lsu_2_bits_nfields),
    .io_req_2_bits_umop                   (_dispatch_io_lsu_2_bits_umop),
    .io_req_3_ready                       (_lsu_io_req_3_ready),
    .io_req_3_valid                       (_dispatch_io_lsu_3_valid),
    .io_req_3_bits_store                  (_dispatch_io_lsu_3_bits_store),
    .io_req_3_bits_addr                   (_dispatch_io_lsu_3_bits_addr),
    .io_req_3_bits_op                     (_dispatch_io_lsu_3_bits_op),
    .io_req_3_bits_pc                     (_dispatch_io_lsu_3_bits_pc),
    .io_req_3_bits_elemWidth              (_dispatch_io_lsu_3_bits_elemWidth),
    .io_req_3_bits_nfields                (_dispatch_io_lsu_3_bits_nfields),
    .io_req_3_bits_umop                   (_dispatch_io_lsu_3_bits_umop),
    .io_busPort_addr_0                    (_regfile_io_busPort_addr_0),
    .io_busPort_addr_1                    (_regfile_io_busPort_addr_1),
    .io_busPort_addr_2                    (_regfile_io_busPort_addr_2),
    .io_busPort_addr_3                    (_regfile_io_busPort_addr_3),
    .io_busPort_data_0                    (_regfile_io_busPort_data_0),
    .io_busPort_data_1                    (_regfile_io_busPort_data_1),
    .io_busPort_data_2                    (_regfile_io_busPort_data_2),
    .io_busPort_data_3                    (_regfile_io_busPort_data_3),
    .io_busPort_flt_data_0                (_fRegfile_io_busPort_data_0),
    .io_rd_valid                          (_lsu_io_rd_valid),
    .io_rd_bits_addr                      (_lsu_io_rd_bits_addr),
    .io_rd_bits_data                      (_lsu_io_rd_bits_data),
    .io_rd_flt_valid                      (_lsu_io_rd_flt_valid),
    .io_rd_flt_bits_addr                  (_lsu_io_rd_flt_bits_addr),
    .io_rd_flt_bits_data                  (_lsu_io_rd_flt_bits_data),
    .io_ibus_valid                        (_lsu_io_ibus_valid),
    .io_ibus_ready                        (_lsu_io_ibus_valid),
    .io_ibus_addr                         (_lsu_io_ibus_addr),
    .io_ibus_rdata                        (io_ibus_rdata),
    .io_dbus_valid                        (_lsu_io_dbus_valid),
    .io_dbus_write                        (_lsu_io_dbus_write),
    .io_dbus_addr                         (_lsu_io_dbus_addr),
    .io_dbus_wdata                        (_lsu_io_dbus_wdata),
    .io_dbus_wmask                        (io_dbus_wmask),
    .io_dbus_rdata                        (io_dbus_rdata),
    .io_flush_valid                       (_lsu_io_flush_valid),
    .io_flush_ready                       (_lsu_io_flush_valid),
    .io_flush_fencei                      (_lsu_io_flush_fencei),
    .io_flush_pcNext                      (_lsu_io_flush_pcNext),
    .io_fault_valid                       (_lsu_io_fault_valid),
    .io_fault_bits_write                  (_lsu_io_fault_bits_write),
    .io_fault_bits_addr                   (_lsu_io_fault_bits_addr),
    .io_fault_bits_epc                    (_lsu_io_fault_bits_epc),
    .io_ebus_dbus_valid                   (io_ebus_dbus_valid),
    .io_ebus_dbus_ready                   (io_ebus_dbus_ready),
    .io_ebus_dbus_write                   (io_ebus_dbus_write),
    .io_ebus_dbus_pc                      (io_ebus_dbus_pc),
    .io_ebus_dbus_addr                    (io_ebus_dbus_addr),
    .io_ebus_dbus_size                    (io_ebus_dbus_size),
    .io_ebus_dbus_wdata                   (io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask                   (io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata                   (io_ebus_dbus_rdata),
    .io_ebus_fault_valid                  (io_ebus_fault_valid),
    .io_ebus_fault_bits_write             (io_ebus_fault_bits_write),
    .io_ebus_fault_bits_addr              (io_ebus_fault_bits_addr),
    .io_ebus_fault_bits_epc               (io_ebus_fault_bits_epc),
    .io_rvv2lsu_0_ready                   (io_rvvcore_rvv2lsu_0_ready),
    .io_rvv2lsu_0_valid                   (io_rvvcore_rvv2lsu_0_valid),
    .io_rvv2lsu_0_bits_idx_valid          (io_rvvcore_rvv2lsu_0_bits_idx_valid),
    .io_rvv2lsu_0_bits_idx_bits_data      (io_rvvcore_rvv2lsu_0_bits_idx_bits_data),
    .io_rvv2lsu_0_bits_vregfile_valid     (io_rvvcore_rvv2lsu_0_bits_vregfile_valid),
    .io_rvv2lsu_0_bits_vregfile_bits_data (io_rvvcore_rvv2lsu_0_bits_vregfile_bits_data),
    .io_rvv2lsu_0_bits_mask_valid         (io_rvvcore_rvv2lsu_0_bits_mask_valid),
    .io_rvv2lsu_0_bits_mask_bits          (io_rvvcore_rvv2lsu_0_bits_mask_bits),
    .io_lsu2rvv_0_ready                   (io_rvvcore_lsu2rvv_0_ready),
    .io_lsu2rvv_0_valid                   (io_rvvcore_lsu2rvv_0_valid),
    .io_lsu2rvv_0_bits_addr               (io_rvvcore_lsu2rvv_0_bits_addr),
    .io_lsu2rvv_0_bits_data               (io_rvvcore_lsu2rvv_0_bits_data),
    .io_lsu2rvv_0_bits_last               (io_rvvcore_lsu2rvv_0_bits_last),
    .io_rvvState_bits_sew                 (io_rvvcore_configState_bits_sew),
    .io_rvvState_bits_lmul                (io_rvvcore_configState_bits_lmul),
    .io_queueCapacity                     (_lsu_io_queueCapacity),
    .io_active                            (_lsu_io_active),
    .io_storeComplete_valid               (_lsu_io_storeComplete_valid),
    .io_storeComplete_bits                (_lsu_io_storeComplete_bits)
  );
  FaultManager fault_manager (
    .io_in_fault_0_csr             (_dispatch_io_csrFault_0),
    .io_in_fault_0_jal             (_dispatch_io_jalFault_0),
    .io_in_fault_0_jalr            (_dispatch_io_jalrFault_0),
    .io_in_fault_0_bxx             (_dispatch_io_bxxFault_0),
    .io_in_fault_0_undef           (_dispatch_io_undefFault_0),
    .io_in_fault_0_rvv             (_dispatch_io_rvvFault_0),
    .io_in_fault_1_jal             (_dispatch_io_jalFault_1),
    .io_in_fault_1_jalr            (_dispatch_io_jalrFault_1),
    .io_in_fault_1_bxx             (_dispatch_io_bxxFault_1),
    .io_in_fault_2_jal             (_dispatch_io_jalFault_2),
    .io_in_fault_2_jalr            (_dispatch_io_jalrFault_2),
    .io_in_fault_2_bxx             (_dispatch_io_bxxFault_2),
    .io_in_fault_3_jal             (_dispatch_io_jalFault_3),
    .io_in_fault_3_jalr            (_dispatch_io_jalrFault_3),
    .io_in_fault_3_bxx             (_dispatch_io_bxxFault_3),
    .io_in_pc_0_pc                 (_fetch_io_inst_lanes_0_bits_addr),
    .io_in_pc_1_pc                 (_fetch_io_inst_lanes_1_bits_addr),
    .io_in_pc_2_pc                 (_fetch_io_inst_lanes_2_bits_addr),
    .io_in_pc_3_pc                 (_fetch_io_inst_lanes_3_bits_addr),
    .io_in_memory_fault_valid      (_lsu_io_fault_valid),
    .io_in_memory_fault_bits_write (_lsu_io_fault_bits_write),
    .io_in_memory_fault_bits_addr  (_lsu_io_fault_bits_addr),
    .io_in_memory_fault_bits_epc   (_lsu_io_fault_bits_epc),
    .io_in_rvv_fault_valid         (io_rvvcore_trap_valid),
    .io_in_rvv_fault_bits_mepc     (io_rvvcore_trap_bits_pc),
    .io_in_rvv_fault_bits_mtval
      ({io_rvvcore_trap_bits_bits,
        io_rvvcore_trap_bits_opcode == 2'h2
          ? 7'h57
          : {1'h0,
             io_rvvcore_trap_bits_opcode == 2'h1
               ? 6'h27
               : {3'h0, {3{io_rvvcore_trap_bits_opcode == 2'h0}}}}}),
    .io_in_undef_0_inst            (_fetch_io_inst_lanes_0_bits_inst),
    .io_in_undef_1_inst            (_fetch_io_inst_lanes_1_bits_inst),
    .io_in_undef_2_inst            (_fetch_io_inst_lanes_2_bits_inst),
    .io_in_undef_3_inst            (_fetch_io_inst_lanes_3_bits_inst),
    .io_in_jal_0_target            (_dispatch_io_bruTarget_0),
    .io_in_jal_1_target            (_dispatch_io_bruTarget_1),
    .io_in_jal_2_target            (_dispatch_io_bruTarget_2),
    .io_in_jal_3_target            (_dispatch_io_bruTarget_3),
    .io_in_jalr_0_target           (_regfile_io_target_0_data),
    .io_in_jalr_1_target           (_regfile_io_target_1_data),
    .io_in_jalr_2_target           (_regfile_io_target_2_data),
    .io_in_jalr_3_target           (_regfile_io_target_3_data),
    .io_in_fetchFault_valid
      (_fetch_io_fault_valid
       & ~(_isBranching_T | _bru_2_io_taken_valid | _bru_3_io_taken_valid)
       & _regfile_io_scoreboard_regd == 32'h0 & _fRegfile_io_scoreboard == 32'h0
       & io_rvvcore_rvv_idle & ~_lsu_io_active
       & ~(_fetch_io_inst_lanes_0_valid | _fetch_io_inst_lanes_1_valid
           | _fetch_io_inst_lanes_2_valid | _fetch_io_inst_lanes_3_valid)),
    .io_in_fetchFault_bits         (_fetch_io_fault_bits),
    .io_out_valid                  (_fault_manager_io_out_valid),
    .io_out_bits_mepc              (_fault_manager_io_out_bits_mepc),
    .io_out_bits_mtval             (_fault_manager_io_out_bits_mtval),
    .io_out_bits_mcause            (_fault_manager_io_out_bits_mcause),
    .io_out_bits_decode            (_fault_manager_io_out_bits_decode)
  );
  RetirementBuffer retirement_buffer (
    .clock                                    (clock),
    .reset                                    (reset),
    .io_inst_0_ready                          (_dispatch_io_inst_0_ready),
    .io_inst_0_valid                          (_fetch_io_inst_lanes_0_valid),
    .io_inst_0_bits_addr                      (_fetch_io_inst_lanes_0_bits_addr),
    .io_inst_0_bits_inst                      (_fetch_io_inst_lanes_0_bits_inst),
    .io_inst_1_ready                          (_dispatch_io_inst_1_ready),
    .io_inst_1_valid                          (_fetch_io_inst_lanes_1_valid),
    .io_inst_1_bits_addr                      (_fetch_io_inst_lanes_1_bits_addr),
    .io_inst_1_bits_inst                      (_fetch_io_inst_lanes_1_bits_inst),
    .io_inst_2_ready                          (_dispatch_io_inst_2_ready),
    .io_inst_2_valid                          (_fetch_io_inst_lanes_2_valid),
    .io_inst_2_bits_addr                      (_fetch_io_inst_lanes_2_bits_addr),
    .io_inst_2_bits_inst                      (_fetch_io_inst_lanes_2_bits_inst),
    .io_inst_3_ready                          (_dispatch_io_inst_3_ready),
    .io_inst_3_valid                          (_fetch_io_inst_lanes_3_valid),
    .io_inst_3_bits_addr                      (_fetch_io_inst_lanes_3_bits_addr),
    .io_inst_3_bits_inst                      (_fetch_io_inst_lanes_3_bits_inst),
    .io_targets_0                             (_dispatch_io_bruTarget_0),
    .io_targets_1                             (_dispatch_io_bruTarget_1),
    .io_targets_2                             (_dispatch_io_bruTarget_2),
    .io_targets_3                             (_dispatch_io_bruTarget_3),
    .io_jalrTargets_0                         (_regfile_io_target_0_data),
    .io_jalrTargets_1                         (_regfile_io_target_1_data),
    .io_jalrTargets_2                         (_regfile_io_target_2_data),
    .io_jalrTargets_3                         (_regfile_io_target_3_data),
    .io_jump_0                                (_dispatch_io_jump_0),
    .io_jump_1                                (_dispatch_io_jump_1),
    .io_jump_2                                (_dispatch_io_jump_2),
    .io_jump_3                                (_dispatch_io_jump_3),
    .io_branch_0                              (_dispatch_io_branch_0),
    .io_branch_1                              (_dispatch_io_branch_1),
    .io_branch_2                              (_dispatch_io_branch_2),
    .io_branch_3                              (_dispatch_io_branch_3),
    .io_storeComplete_valid                   (_lsu_io_storeComplete_valid),
    .io_storeComplete_bits                    (_lsu_io_storeComplete_bits),
    .io_writeAddrScalar_0_valid               (_dispatch_io_rdMark_0_valid),
    .io_writeAddrScalar_0_addr                (_dispatch_io_rdMark_0_addr),
    .io_writeAddrScalar_1_valid               (_dispatch_io_rdMark_1_valid),
    .io_writeAddrScalar_1_addr                (_dispatch_io_rdMark_1_addr),
    .io_writeAddrScalar_2_valid               (_dispatch_io_rdMark_2_valid),
    .io_writeAddrScalar_2_addr                (_dispatch_io_rdMark_2_addr),
    .io_writeAddrScalar_3_valid               (_dispatch_io_rdMark_3_valid),
    .io_writeAddrScalar_3_addr                (_dispatch_io_rdMark_3_addr),
    .io_writeDataScalar_0_valid               (regfile_io_writeData_0_valid),
    .io_writeDataScalar_0_bits_addr           (regfile_io_writeData_0_bits_addr),
    .io_writeDataScalar_1_valid               (regfile_io_writeData_1_valid),
    .io_writeDataScalar_1_bits_addr           (regfile_io_writeData_1_bits_addr),
    .io_writeDataScalar_2_valid               (regfile_io_writeData_2_valid),
    .io_writeDataScalar_2_bits_addr           (regfile_io_writeData_2_bits_addr),
    .io_writeDataScalar_3_valid               (regfile_io_writeData_3_valid),
    .io_writeDataScalar_3_bits_addr           (regfile_io_writeData_3_bits_addr),
    .io_writeDataScalar_4_valid               (_arb_io_out_valid),
    .io_writeDataScalar_4_bits_addr           (_arb_io_out_bits_addr),
    .io_writeDataScalar_5_valid               (_lsu_io_rd_valid),
    .io_writeDataScalar_5_bits_addr           (_lsu_io_rd_bits_addr),
    .io_writeAddrFloat_valid                  (_dispatch_io_rdMark_flt_valid),
    .io_writeAddrFloat_addr                   (_dispatch_io_rdMark_flt_addr),
    .io_writeDataFloat_0_valid                (_floatCore_io_write_ports_0_valid),
    .io_writeDataFloat_0_bits_addr            (_floatCore_io_write_ports_0_addr),
    .io_writeDataFloat_1_valid                (_floatCore_io_write_ports_1_valid),
    .io_writeDataFloat_1_bits_addr            (_floatCore_io_write_ports_1_addr),
    .io_writeAddrVector_0_valid               (_dispatch_io_rvvRdMark_0_valid),
    .io_writeAddrVector_0_addr                (_dispatch_io_rvvRdMark_0_addr),
    .io_writeAddrVector_1_valid               (_dispatch_io_rvvRdMark_1_valid),
    .io_writeAddrVector_1_addr                (_dispatch_io_rvvRdMark_1_addr),
    .io_writeAddrVector_2_valid               (_dispatch_io_rvvRdMark_2_valid),
    .io_writeAddrVector_2_addr                (_dispatch_io_rvvRdMark_2_addr),
    .io_writeAddrVector_3_valid               (_dispatch_io_rvvRdMark_3_valid),
    .io_writeAddrVector_3_addr                (_dispatch_io_rvvRdMark_3_addr),
    .io_writeDataVector_0_valid               (io_rvvcore_rd_rob2rt_o_0_w_valid),
    .io_writeDataVector_0_bits_addr           (io_rvvcore_rd_rob2rt_o_0_w_index),
    .io_writeDataVector_0_bits_uop_pc         (io_rvvcore_rd_rob2rt_o_0_uop_pc),
    .io_writeDataVector_0_bits_last_uop_valid (io_rvvcore_rd_rob2rt_o_0_last_uop_valid),
    .io_writeDataVector_1_valid               (io_rvvcore_rd_rob2rt_o_1_w_valid),
    .io_writeDataVector_1_bits_addr           (io_rvvcore_rd_rob2rt_o_1_w_index),
    .io_writeDataVector_1_bits_uop_pc         (io_rvvcore_rd_rob2rt_o_1_uop_pc),
    .io_writeDataVector_1_bits_last_uop_valid (io_rvvcore_rd_rob2rt_o_1_last_uop_valid),
    .io_writeDataVector_2_valid               (io_rvvcore_rd_rob2rt_o_2_w_valid),
    .io_writeDataVector_2_bits_addr           (io_rvvcore_rd_rob2rt_o_2_w_index),
    .io_writeDataVector_2_bits_uop_pc         (io_rvvcore_rd_rob2rt_o_2_uop_pc),
    .io_writeDataVector_2_bits_last_uop_valid (io_rvvcore_rd_rob2rt_o_2_last_uop_valid),
    .io_writeDataVector_3_valid               (io_rvvcore_rd_rob2rt_o_3_w_valid),
    .io_writeDataVector_3_bits_addr           (io_rvvcore_rd_rob2rt_o_3_w_index),
    .io_writeDataVector_3_bits_uop_pc         (io_rvvcore_rd_rob2rt_o_3_uop_pc),
    .io_writeDataVector_3_bits_last_uop_valid (io_rvvcore_rd_rob2rt_o_3_last_uop_valid),
    .io_fault_valid                           (_fault_manager_io_out_valid),
    .io_fault_bits_mepc                       (_fault_manager_io_out_bits_mepc),
    .io_fault_bits_mcause                     (_fault_manager_io_out_bits_mcause),
    .io_fault_bits_decode                     (_fault_manager_io_out_bits_decode),
    .io_nSpace                                (_retirement_buffer_io_nSpace),
    .io_nRetired                              (_retirement_buffer_io_nRetired),
    .io_empty                                 (_retirement_buffer_io_empty),
    .io_trapPending                           (_retirement_buffer_io_trapPending),
    .io_debug_inst_0_valid                    (io_debug_rb_inst_0_valid),
    .io_debug_inst_0_bits_pc                  (io_debug_rb_inst_0_bits_pc),
    .io_debug_inst_0_bits_idx                 (io_debug_rb_inst_0_bits_idx),
    .io_debug_inst_0_bits_trap                (io_debug_rb_inst_0_bits_trap),
    .io_debug_inst_1_valid                    (io_debug_rb_inst_1_valid),
    .io_debug_inst_1_bits_pc                  (io_debug_rb_inst_1_bits_pc),
    .io_debug_inst_1_bits_idx                 (io_debug_rb_inst_1_bits_idx),
    .io_debug_inst_1_bits_trap                (io_debug_rb_inst_1_bits_trap),
    .io_debug_inst_2_valid                    (io_debug_rb_inst_2_valid),
    .io_debug_inst_2_bits_pc                  (io_debug_rb_inst_2_bits_pc),
    .io_debug_inst_2_bits_idx                 (io_debug_rb_inst_2_bits_idx),
    .io_debug_inst_2_bits_trap                (io_debug_rb_inst_2_bits_trap),
    .io_debug_inst_3_valid                    (io_debug_rb_inst_3_valid),
    .io_debug_inst_3_bits_pc                  (io_debug_rb_inst_3_bits_pc),
    .io_debug_inst_3_bits_idx                 (io_debug_rb_inst_3_bits_idx),
    .io_debug_inst_3_bits_trap                (io_debug_rb_inst_3_bits_trap),
    .io_debug_inst_4_valid                    (io_debug_rb_inst_4_valid),
    .io_debug_inst_4_bits_pc                  (io_debug_rb_inst_4_bits_pc),
    .io_debug_inst_4_bits_idx                 (io_debug_rb_inst_4_bits_idx),
    .io_debug_inst_4_bits_trap                (io_debug_rb_inst_4_bits_trap),
    .io_debug_inst_5_valid                    (io_debug_rb_inst_5_valid),
    .io_debug_inst_5_bits_pc                  (io_debug_rb_inst_5_bits_pc),
    .io_debug_inst_5_bits_idx                 (io_debug_rb_inst_5_bits_idx),
    .io_debug_inst_5_bits_trap                (io_debug_rb_inst_5_bits_trap),
    .io_debug_inst_6_valid                    (io_debug_rb_inst_6_valid),
    .io_debug_inst_6_bits_pc                  (io_debug_rb_inst_6_bits_pc),
    .io_debug_inst_6_bits_idx                 (io_debug_rb_inst_6_bits_idx),
    .io_debug_inst_6_bits_trap                (io_debug_rb_inst_6_bits_trap),
    .io_debug_inst_7_valid                    (io_debug_rb_inst_7_valid),
    .io_debug_inst_7_bits_pc                  (io_debug_rb_inst_7_bits_pc),
    .io_debug_inst_7_bits_idx                 (io_debug_rb_inst_7_bits_idx),
    .io_debug_inst_7_bits_trap                (io_debug_rb_inst_7_bits_trap)
  );
  Alu alu_0 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_0_valid),
    .io_req_bits_addr (_dispatch_io_alu_0_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_0_bits_op),
    .io_rs1_valid     (_regfile_io_readData_0_valid),
    .io_rs1_data      (_regfile_io_readData_0_data),
    .io_rs2_valid     (_regfile_io_readData_1_valid),
    .io_rs2_data      (_regfile_io_readData_1_data),
    .io_rd_valid      (_alu_0_io_rd_valid),
    .io_rd_bits_addr  (_alu_0_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_0_io_rd_bits_data)
  );
  Alu alu_1 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_1_valid),
    .io_req_bits_addr (_dispatch_io_alu_1_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_1_bits_op),
    .io_rs1_valid     (_regfile_io_readData_2_valid),
    .io_rs1_data      (_regfile_io_readData_2_data),
    .io_rs2_valid     (_regfile_io_readData_3_valid),
    .io_rs2_data      (_regfile_io_readData_3_data),
    .io_rd_valid      (_alu_1_io_rd_valid),
    .io_rd_bits_addr  (_alu_1_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_1_io_rd_bits_data)
  );
  Alu alu_2 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_2_valid),
    .io_req_bits_addr (_dispatch_io_alu_2_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_2_bits_op),
    .io_rs1_valid     (_regfile_io_readData_4_valid),
    .io_rs1_data      (_regfile_io_readData_4_data),
    .io_rs2_valid     (_regfile_io_readData_5_valid),
    .io_rs2_data      (_regfile_io_readData_5_data),
    .io_rd_valid      (_alu_2_io_rd_valid),
    .io_rd_bits_addr  (_alu_2_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_2_io_rd_bits_data)
  );
  Alu alu_3 (
    .clock            (clock),
    .reset            (reset),
    .io_req_valid     (_dispatch_io_alu_3_valid),
    .io_req_bits_addr (_dispatch_io_alu_3_bits_addr),
    .io_req_bits_op   (_dispatch_io_alu_3_bits_op),
    .io_rs1_valid     (_regfile_io_readData_6_valid),
    .io_rs1_data      (_regfile_io_readData_6_data),
    .io_rs2_valid     (_regfile_io_readData_7_valid),
    .io_rs2_data      (_regfile_io_readData_7_data),
    .io_rd_valid      (_alu_3_io_rd_valid),
    .io_rd_bits_addr  (_alu_3_io_rd_bits_addr),
    .io_rd_bits_data  (_alu_3_io_rd_bits_data)
  );
  Bru bru_0 (
    .clock                        (clock),
    .reset                        (reset),
    .io_req_valid                 (_dispatch_io_bru_0_valid),
    .io_req_bits_fwd              (_dispatch_io_bru_0_bits_fwd),
    .io_req_bits_op               (_dispatch_io_bru_0_bits_op),
    .io_req_bits_pc               (_dispatch_io_bru_0_bits_pc),
    .io_req_bits_target           (_dispatch_io_bru_0_bits_target),
    .io_req_bits_link             (_dispatch_io_bru_0_bits_link),
    .io_csr_in_mode_valid         (_bru_0_io_csr_in_mode_valid),
    .io_csr_in_mode_bits          (_bru_0_io_csr_in_mode_bits),
    .io_csr_in_mcause_valid       (_bru_0_io_csr_in_mcause_valid),
    .io_csr_in_mcause_bits        (_bru_0_io_csr_in_mcause_bits),
    .io_csr_in_mepc_valid         (_bru_0_io_csr_in_mepc_valid),
    .io_csr_in_mepc_bits          (_bru_0_io_csr_in_mepc_bits),
    .io_csr_in_mtval_valid        (_bru_0_io_csr_in_mtval_valid),
    .io_csr_in_mtval_bits         (_bru_0_io_csr_in_mtval_bits),
    .io_csr_in_halt               (_bru_0_io_csr_in_halt),
    .io_csr_in_fault              (_bru_0_io_csr_in_fault),
    .io_csr_in_wfi                (_bru_0_io_csr_in_wfi),
    .io_csr_out_mode              (_csr_io_bru_out_mode),
    .io_csr_out_mepc              (_csr_io_bru_out_mepc),
    .io_csr_out_mtvec             (_csr_io_bru_out_mtvec),
    .io_rs1_valid                 (_regfile_io_readData_0_valid),
    .io_rs1_data                  (_regfile_io_readData_0_data),
    .io_rs2_valid                 (_regfile_io_readData_1_valid),
    .io_rs2_data                  (_regfile_io_readData_1_data),
    .io_rd_valid                  (_bru_0_io_rd_valid),
    .io_rd_bits_addr              (_bru_0_io_rd_bits_addr),
    .io_rd_bits_data              (_bru_0_io_rd_bits_data),
    .io_taken_valid               (_bru_0_io_taken_valid),
    .io_taken_value               (_bru_0_io_taken_value),
    .io_target_data               (_regfile_io_target_0_data),
    .io_interlock                 (_bru_0_io_interlock),
    .io_fault_manager_valid       (_fault_manager_io_out_valid),
    .io_fault_manager_bits_mepc   (_fault_manager_io_out_bits_mepc),
    .io_fault_manager_bits_mtval  (_fault_manager_io_out_bits_mtval),
    .io_fault_manager_bits_mcause (_fault_manager_io_out_bits_mcause)
  );
  Bru_1 bru_1 (
    .clock              (clock),
    .reset              (reset),
    .io_req_valid       (_dispatch_io_bru_1_valid),
    .io_req_bits_fwd    (_dispatch_io_bru_1_bits_fwd),
    .io_req_bits_op     (_dispatch_io_bru_1_bits_op),
    .io_req_bits_pc     (_dispatch_io_bru_1_bits_pc),
    .io_req_bits_target (_dispatch_io_bru_1_bits_target),
    .io_req_bits_link   (_dispatch_io_bru_1_bits_link),
    .io_rs1_valid       (_regfile_io_readData_2_valid),
    .io_rs1_data        (_regfile_io_readData_2_data),
    .io_rs2_valid       (_regfile_io_readData_3_valid),
    .io_rs2_data        (_regfile_io_readData_3_data),
    .io_rd_valid        (_bru_1_io_rd_valid),
    .io_rd_bits_addr    (_bru_1_io_rd_bits_addr),
    .io_rd_bits_data    (_bru_1_io_rd_bits_data),
    .io_taken_valid     (_bru_1_io_taken_valid),
    .io_taken_value     (_bru_1_io_taken_value),
    .io_target_data     (_regfile_io_target_1_data)
  );
  Bru_1 bru_2 (
    .clock              (clock),
    .reset              (reset),
    .io_req_valid       (_dispatch_io_bru_2_valid),
    .io_req_bits_fwd    (_dispatch_io_bru_2_bits_fwd),
    .io_req_bits_op     (_dispatch_io_bru_2_bits_op),
    .io_req_bits_pc     (_dispatch_io_bru_2_bits_pc),
    .io_req_bits_target (_dispatch_io_bru_2_bits_target),
    .io_req_bits_link   (_dispatch_io_bru_2_bits_link),
    .io_rs1_valid       (_regfile_io_readData_4_valid),
    .io_rs1_data        (_regfile_io_readData_4_data),
    .io_rs2_valid       (_regfile_io_readData_5_valid),
    .io_rs2_data        (_regfile_io_readData_5_data),
    .io_rd_valid        (_bru_2_io_rd_valid),
    .io_rd_bits_addr    (_bru_2_io_rd_bits_addr),
    .io_rd_bits_data    (_bru_2_io_rd_bits_data),
    .io_taken_valid     (_bru_2_io_taken_valid),
    .io_taken_value     (_bru_2_io_taken_value),
    .io_target_data     (_regfile_io_target_2_data)
  );
  Bru_1 bru_3 (
    .clock              (clock),
    .reset              (reset),
    .io_req_valid       (_dispatch_io_bru_3_valid),
    .io_req_bits_fwd    (_dispatch_io_bru_3_bits_fwd),
    .io_req_bits_op     (_dispatch_io_bru_3_bits_op),
    .io_req_bits_pc     (_dispatch_io_bru_3_bits_pc),
    .io_req_bits_target (_dispatch_io_bru_3_bits_target),
    .io_req_bits_link   (_dispatch_io_bru_3_bits_link),
    .io_rs1_valid       (_regfile_io_readData_6_valid),
    .io_rs1_data        (_regfile_io_readData_6_data),
    .io_rs2_valid       (_regfile_io_readData_7_valid),
    .io_rs2_data        (_regfile_io_readData_7_data),
    .io_rd_valid        (_bru_3_io_rd_valid),
    .io_rd_bits_addr    (_bru_3_io_rd_bits_addr),
    .io_rd_bits_data    (_bru_3_io_rd_bits_data),
    .io_taken_valid     (_bru_3_io_taken_valid),
    .io_taken_value     (_bru_3_io_taken_value),
    .io_target_data     (_regfile_io_target_3_data)
  );
  Mlu mlu (
    .clock              (clock),
    .reset              (reset),
    .io_req_0_valid     (_dispatch_io_mlu_0_valid),
    .io_req_0_bits_addr (_dispatch_io_mlu_0_bits_addr),
    .io_req_0_bits_op   (_dispatch_io_mlu_0_bits_op),
    .io_req_1_ready     (_mlu_io_req_1_ready),
    .io_req_1_valid     (_dispatch_io_mlu_1_valid),
    .io_req_1_bits_addr (_dispatch_io_mlu_1_bits_addr),
    .io_req_1_bits_op   (_dispatch_io_mlu_1_bits_op),
    .io_req_2_ready     (_mlu_io_req_2_ready),
    .io_req_2_valid     (_dispatch_io_mlu_2_valid),
    .io_req_2_bits_addr (_dispatch_io_mlu_2_bits_addr),
    .io_req_2_bits_op   (_dispatch_io_mlu_2_bits_op),
    .io_req_3_ready     (_mlu_io_req_3_ready),
    .io_req_3_valid     (_dispatch_io_mlu_3_valid),
    .io_req_3_bits_addr (_dispatch_io_mlu_3_bits_addr),
    .io_req_3_bits_op   (_dispatch_io_mlu_3_bits_op),
    .io_rs1_0_valid     (_regfile_io_readData_0_valid),
    .io_rs1_0_data      (_regfile_io_readData_0_data),
    .io_rs1_1_valid     (_regfile_io_readData_2_valid),
    .io_rs1_1_data      (_regfile_io_readData_2_data),
    .io_rs1_2_valid     (_regfile_io_readData_4_valid),
    .io_rs1_2_data      (_regfile_io_readData_4_data),
    .io_rs1_3_valid     (_regfile_io_readData_6_valid),
    .io_rs1_3_data      (_regfile_io_readData_6_data),
    .io_rs2_0_valid     (_regfile_io_readData_1_valid),
    .io_rs2_0_data      (_regfile_io_readData_1_data),
    .io_rs2_1_valid     (_regfile_io_readData_3_valid),
    .io_rs2_1_data      (_regfile_io_readData_3_data),
    .io_rs2_2_valid     (_regfile_io_readData_5_valid),
    .io_rs2_2_data      (_regfile_io_readData_5_data),
    .io_rs2_3_valid     (_regfile_io_readData_7_valid),
    .io_rs2_3_data      (_regfile_io_readData_7_data),
    .io_rd_valid        (_mlu_io_rd_valid),
    .io_rd_bits_addr    (_mlu_io_rd_bits_addr),
    .io_rd_bits_data    (_mlu_io_rd_bits_data)
  );
  Dvu dvu (
    .clock            (clock),
    .reset            (reset),
    .io_req_ready     (_dvu_io_req_ready),
    .io_req_valid     (_dispatch_io_dvu_0_valid),
    .io_req_bits_addr (_dispatch_io_dvu_0_bits_addr),
    .io_req_bits_op   (_dispatch_io_dvu_0_bits_op),
    .io_rs1_data      (_regfile_io_readData_0_data),
    .io_rs2_data      (_regfile_io_readData_1_data),
    .io_rd_ready      (_arb_io_in_1_ready),
    .io_rd_valid      (_dvu_io_rd_valid),
    .io_rd_bits_addr  (_dvu_io_rd_bits_addr),
    .io_rd_bits_data  (_dvu_io_rd_bits_data)
  );
  FloatCore floatCore (
    .clock                          (clock),
    .reset                          (reset),
    .io_inst_ready                  (_floatCore_io_inst_ready),
    .io_inst_valid                  (_dispatch_io_float_valid),
    .io_inst_bits_opcode            (_dispatch_io_float_bits_opcode),
    .io_inst_bits_funct5            (_dispatch_io_float_bits_funct5),
    .io_inst_bits_rs3               (_dispatch_io_float_bits_rs3),
    .io_inst_bits_rs2               (_dispatch_io_float_bits_rs2),
    .io_inst_bits_rs1               (_dispatch_io_float_bits_rs1),
    .io_inst_bits_rm                (_dispatch_io_float_bits_rm),
    .io_inst_bits_inst              (_dispatch_io_float_bits_inst),
    .io_inst_bits_pc                (_dispatch_io_float_bits_pc),
    .io_inst_bits_scalar_rd         (_dispatch_io_float_bits_scalar_rd),
    .io_inst_bits_scalar_rs1        (_dispatch_io_float_bits_scalar_rs1),
    .io_inst_bits_float_rs1         (_dispatch_io_float_bits_float_rs1),
    .io_inst_bits_rd                (_dispatch_io_float_bits_rd),
    .io_inst_bits_uses_rs3          (_dispatch_io_float_bits_uses_rs3),
    .io_inst_bits_uses_rs2          (_dispatch_io_float_bits_uses_rs2),
    .io_read_ports_0_valid          (_floatCore_io_read_ports_0_valid),
    .io_read_ports_0_addr           (_floatCore_io_read_ports_0_addr),
    .io_read_ports_0_data_mantissa  (_fRegfile_io_read_ports_0_data_mantissa),
    .io_read_ports_0_data_exponent  (_fRegfile_io_read_ports_0_data_exponent),
    .io_read_ports_0_data_sign      (_fRegfile_io_read_ports_0_data_sign),
    .io_read_ports_1_valid          (_floatCore_io_read_ports_1_valid),
    .io_read_ports_1_addr           (_floatCore_io_read_ports_1_addr),
    .io_read_ports_1_data_mantissa  (_fRegfile_io_read_ports_1_data_mantissa),
    .io_read_ports_1_data_exponent  (_fRegfile_io_read_ports_1_data_exponent),
    .io_read_ports_1_data_sign      (_fRegfile_io_read_ports_1_data_sign),
    .io_read_ports_2_valid          (_floatCore_io_read_ports_2_valid),
    .io_read_ports_2_addr           (_floatCore_io_read_ports_2_addr),
    .io_read_ports_2_data_mantissa  (_fRegfile_io_read_ports_2_data_mantissa),
    .io_read_ports_2_data_exponent  (_fRegfile_io_read_ports_2_data_exponent),
    .io_read_ports_2_data_sign      (_fRegfile_io_read_ports_2_data_sign),
    .io_write_ports_0_valid         (_floatCore_io_write_ports_0_valid),
    .io_write_ports_0_addr          (_floatCore_io_write_ports_0_addr),
    .io_write_ports_0_data_mantissa (_floatCore_io_write_ports_0_data_mantissa),
    .io_write_ports_0_data_exponent (_floatCore_io_write_ports_0_data_exponent),
    .io_write_ports_0_data_sign     (_floatCore_io_write_ports_0_data_sign),
    .io_write_ports_1_valid         (_floatCore_io_write_ports_1_valid),
    .io_write_ports_1_addr          (_floatCore_io_write_ports_1_addr),
    .io_write_ports_1_data_mantissa (_floatCore_io_write_ports_1_data_mantissa),
    .io_write_ports_1_data_exponent (_floatCore_io_write_ports_1_data_exponent),
    .io_write_ports_1_data_sign     (_floatCore_io_write_ports_1_data_sign),
    .io_rs1_data                    (_regfile_io_readData_0_data),
    .io_scalar_rd_ready             (_arb_io_in_3_ready),
    .io_scalar_rd_valid             (_floatCore_io_scalar_rd_valid),
    .io_scalar_rd_bits_addr         (_floatCore_io_scalar_rd_bits_addr),
    .io_scalar_rd_bits_data         (_floatCore_io_scalar_rd_bits_data),
    .io_csr_in_fflags_valid         (_floatCore_io_csr_in_fflags_valid),
    .io_csr_in_fflags_bits          (_floatCore_io_csr_in_fflags_bits),
    .io_csr_out_frm                 (_csr_io_float_out_frm),
    .io_lsu_rd_valid                (_lsu_io_rd_flt_valid),
    .io_lsu_rd_bits_addr            (_lsu_io_rd_flt_bits_addr),
    .io_lsu_rd_bits_data            (_lsu_io_rd_flt_bits_data)
  );
  FRegfile fRegfile (
    .clock                          (clock),
    .reset                          (reset),
    .io_read_ports_0_valid          (_floatCore_io_read_ports_0_valid),
    .io_read_ports_0_addr           (_floatCore_io_read_ports_0_addr),
    .io_read_ports_0_data_mantissa  (_fRegfile_io_read_ports_0_data_mantissa),
    .io_read_ports_0_data_exponent  (_fRegfile_io_read_ports_0_data_exponent),
    .io_read_ports_0_data_sign      (_fRegfile_io_read_ports_0_data_sign),
    .io_read_ports_1_valid          (_floatCore_io_read_ports_1_valid),
    .io_read_ports_1_addr           (_floatCore_io_read_ports_1_addr),
    .io_read_ports_1_data_mantissa  (_fRegfile_io_read_ports_1_data_mantissa),
    .io_read_ports_1_data_exponent  (_fRegfile_io_read_ports_1_data_exponent),
    .io_read_ports_1_data_sign      (_fRegfile_io_read_ports_1_data_sign),
    .io_read_ports_2_valid          (_floatCore_io_read_ports_2_valid),
    .io_read_ports_2_addr           (_floatCore_io_read_ports_2_addr),
    .io_read_ports_2_data_mantissa  (_fRegfile_io_read_ports_2_data_mantissa),
    .io_read_ports_2_data_exponent  (_fRegfile_io_read_ports_2_data_exponent),
    .io_read_ports_2_data_sign      (_fRegfile_io_read_ports_2_data_sign),
    .io_write_ports_0_valid         (_floatCore_io_write_ports_0_valid),
    .io_write_ports_0_addr          (_floatCore_io_write_ports_0_addr),
    .io_write_ports_0_data_mantissa (_floatCore_io_write_ports_0_data_mantissa),
    .io_write_ports_0_data_exponent (_floatCore_io_write_ports_0_data_exponent),
    .io_write_ports_0_data_sign     (_floatCore_io_write_ports_0_data_sign),
    .io_write_ports_1_valid         (_floatCore_io_write_ports_1_valid),
    .io_write_ports_1_addr          (_floatCore_io_write_ports_1_addr),
    .io_write_ports_1_data_mantissa (_floatCore_io_write_ports_1_data_mantissa),
    .io_write_ports_1_data_exponent (_floatCore_io_write_ports_1_data_exponent),
    .io_write_ports_1_data_sign     (_floatCore_io_write_ports_1_data_sign),
    .io_scoreboard_set
      (_dispatch_io_rdMark_flt_valid ? 32'h1 << _dispatch_io_rdMark_flt_addr : 32'h0),
    .io_scoreboard                  (_fRegfile_io_scoreboard),
    .io_busPort_data_0              (_fRegfile_io_busPort_data_0),
    .io_busPortAddr                 (_dispatch_io_fbusPortAddr)
  );
  Arbiter4_RegfileWriteDataIO arb (
    .io_in_0_valid     (_mlu_io_rd_valid),
    .io_in_0_bits_addr (_mlu_io_rd_bits_addr),
    .io_in_0_bits_data (_mlu_io_rd_bits_data),
    .io_in_1_ready     (_arb_io_in_1_ready),
    .io_in_1_valid     (_dvu_io_rd_valid),
    .io_in_1_bits_addr (_dvu_io_rd_bits_addr),
    .io_in_1_bits_data (_dvu_io_rd_bits_data),
    .io_in_2_ready     (io_rvvcore_async_rd_ready),
    .io_in_2_valid     (io_rvvcore_async_rd_valid),
    .io_in_2_bits_addr (io_rvvcore_async_rd_bits_addr),
    .io_in_2_bits_data (io_rvvcore_async_rd_bits_data),
    .io_in_3_ready     (_arb_io_in_3_ready),
    .io_in_3_valid     (_floatCore_io_scalar_rd_valid),
    .io_in_3_bits_addr (_floatCore_io_scalar_rd_bits_addr),
    .io_in_3_bits_data (_floatCore_io_scalar_rd_bits_data),
    .io_out_valid      (_arb_io_out_valid),
    .io_out_bits_addr  (_arb_io_out_bits_addr),
    .io_out_bits_data  (_arb_io_out_bits_data)
  );
  assign io_csr_out_value_4 = _csr_io_csr_out_value_4;
  assign io_halted = _csr_io_halted;
  assign io_wfi = _csr_io_wfi;
  assign io_ibus_valid = _lsu_io_ibus_valid ? _lsu_io_ibus_valid : _fetch_io_ibus_valid;
  assign io_ibus_addr = _lsu_io_ibus_valid ? _lsu_io_ibus_addr : _fetch_io_ibus_addr;
  assign io_dbus_valid = _lsu_io_dbus_valid;
  assign io_dbus_write = _lsu_io_dbus_write;
  assign io_dbus_addr = _lsu_io_dbus_addr;
  assign io_dbus_wdata = _lsu_io_dbus_wdata;
  assign io_rvvcore_rs_0_valid = _regfile_io_readData_0_valid;
  assign io_rvvcore_rs_0_data = _regfile_io_readData_0_data;
  assign io_rvvcore_rs_1_valid = _regfile_io_readData_1_valid;
  assign io_rvvcore_rs_1_data = _regfile_io_readData_1_data;
  assign io_rvvcore_rs_2_valid = _regfile_io_readData_2_valid;
  assign io_rvvcore_rs_2_data = _regfile_io_readData_2_data;
  assign io_rvvcore_rs_3_valid = _regfile_io_readData_3_valid;
  assign io_rvvcore_rs_3_data = _regfile_io_readData_3_data;
  assign io_rvvcore_rs_4_valid = _regfile_io_readData_4_valid;
  assign io_rvvcore_rs_4_data = _regfile_io_readData_4_data;
  assign io_rvvcore_rs_5_valid = _regfile_io_readData_5_valid;
  assign io_rvvcore_rs_5_data = _regfile_io_readData_5_data;
  assign io_rvvcore_rs_6_valid = _regfile_io_readData_6_valid;
  assign io_rvvcore_rs_6_data = _regfile_io_readData_6_data;
  assign io_rvvcore_rs_7_valid = _regfile_io_readData_7_valid;
  assign io_rvvcore_rs_7_data = _regfile_io_readData_7_data;
  assign io_rvvcore_frs_0 =
    {_fRegfile_io_read_ports_0_data_sign,
     _fRegfile_io_read_ports_0_data_exponent,
     _fRegfile_io_read_ports_0_data_mantissa};
  assign io_slog_valid = slogValid;
  assign io_slog_addr = {3'h0, slogValid ? slogAddr : 2'h0};
  assign io_slog_data = slogValid ? _regfile_io_readData_0_data : 32'h0;
  assign io_debug_en =
    {~(_bru_1_io_taken_valid | _debugBrch_T_1),
     ~_debugBrch_T_1,
     ~_bru_3_io_taken_valid,
     1'h1} & debugEn;
  assign io_debug_addr_0 = debugAddr_0;
  assign io_debug_addr_1 = debugAddr_1;
  assign io_debug_addr_2 = debugAddr_2;
  assign io_debug_addr_3 = debugAddr_3;
  assign io_debug_inst_0 = debugInst_0;
  assign io_debug_inst_1 = debugInst_1;
  assign io_debug_inst_2 = debugInst_2;
  assign io_debug_inst_3 = debugInst_3;
  assign io_debug_cycles = _csr_io_csr_out_value_4;
  assign io_debug_dbus_valid = _lsu_io_dbus_valid;
  assign io_debug_dbus_bits_addr = _lsu_io_dbus_addr;
  assign io_debug_dbus_bits_wdata = _lsu_io_dbus_wdata;
  assign io_debug_dbus_bits_write = _lsu_io_dbus_write;
  assign io_debug_dispatch_0_instFire =
    _dispatch_io_inst_0_ready & _fetch_io_inst_lanes_0_valid;
  assign io_debug_dispatch_0_instAddr = _fetch_io_inst_lanes_0_bits_addr;
  assign io_debug_dispatch_0_instInst = _fetch_io_inst_lanes_0_bits_inst;
  assign io_debug_dispatch_1_instFire =
    _dispatch_io_inst_1_ready & _fetch_io_inst_lanes_1_valid;
  assign io_debug_dispatch_1_instAddr = _fetch_io_inst_lanes_1_bits_addr;
  assign io_debug_dispatch_1_instInst = _fetch_io_inst_lanes_1_bits_inst;
  assign io_debug_dispatch_2_instFire =
    _dispatch_io_inst_2_ready & _fetch_io_inst_lanes_2_valid;
  assign io_debug_dispatch_2_instAddr = _fetch_io_inst_lanes_2_bits_addr;
  assign io_debug_dispatch_2_instInst = _fetch_io_inst_lanes_2_bits_inst;
  assign io_debug_dispatch_3_instFire =
    _dispatch_io_inst_3_ready & _fetch_io_inst_lanes_3_valid;
  assign io_debug_dispatch_3_instAddr = _fetch_io_inst_lanes_3_bits_addr;
  assign io_debug_dispatch_3_instInst = _fetch_io_inst_lanes_3_bits_inst;
  assign io_debug_regfile_writeAddr_0_valid = _dispatch_io_rdMark_0_valid;
  assign io_debug_regfile_writeAddr_0_bits = _dispatch_io_rdMark_0_addr;
  assign io_debug_regfile_writeAddr_1_valid = _dispatch_io_rdMark_1_valid;
  assign io_debug_regfile_writeAddr_1_bits = _dispatch_io_rdMark_1_addr;
  assign io_debug_regfile_writeAddr_2_valid = _dispatch_io_rdMark_2_valid;
  assign io_debug_regfile_writeAddr_2_bits = _dispatch_io_rdMark_2_addr;
  assign io_debug_regfile_writeAddr_3_valid = _dispatch_io_rdMark_3_valid;
  assign io_debug_regfile_writeAddr_3_bits = _dispatch_io_rdMark_3_addr;
  assign io_debug_regfile_writeData_0_valid = regfile_io_writeData_0_valid;
  assign io_debug_regfile_writeData_0_bits_addr = regfile_io_writeData_0_bits_addr;
  assign io_debug_regfile_writeData_0_bits_data = regfile_io_writeData_0_bits_data;
  assign io_debug_regfile_writeData_1_valid = regfile_io_writeData_1_valid;
  assign io_debug_regfile_writeData_1_bits_addr = regfile_io_writeData_1_bits_addr;
  assign io_debug_regfile_writeData_1_bits_data = regfile_io_writeData_1_bits_data;
  assign io_debug_regfile_writeData_2_valid = regfile_io_writeData_2_valid;
  assign io_debug_regfile_writeData_2_bits_addr = regfile_io_writeData_2_bits_addr;
  assign io_debug_regfile_writeData_2_bits_data = regfile_io_writeData_2_bits_data;
  assign io_debug_regfile_writeData_3_valid = regfile_io_writeData_3_valid;
  assign io_debug_regfile_writeData_3_bits_addr = regfile_io_writeData_3_bits_addr;
  assign io_debug_regfile_writeData_3_bits_data = regfile_io_writeData_3_bits_data;
  assign io_debug_regfile_writeData_4_valid = _arb_io_out_valid;
  assign io_debug_regfile_writeData_4_bits_addr = _arb_io_out_bits_addr;
  assign io_debug_regfile_writeData_4_bits_data = _arb_io_out_bits_data;
  assign io_debug_regfile_writeData_5_valid = _lsu_io_rd_valid;
  assign io_debug_regfile_writeData_5_bits_addr = _lsu_io_rd_bits_addr;
  assign io_debug_regfile_writeData_5_bits_data = _lsu_io_rd_bits_data;
  assign io_debug_float_writeAddr_valid = _dispatch_io_rdMark_flt_valid;
  assign io_debug_float_writeAddr_bits = _dispatch_io_rdMark_flt_addr;
  assign io_debug_float_writeData_0_valid = _floatCore_io_write_ports_0_valid;
  assign io_debug_float_writeData_0_bits_addr = {27'h0, _floatCore_io_write_ports_0_addr};
  assign io_debug_float_writeData_0_bits_data =
    {_floatCore_io_write_ports_0_data_sign,
     _floatCore_io_write_ports_0_data_exponent,
     _floatCore_io_write_ports_0_data_mantissa};
  assign io_debug_float_writeData_1_valid = _floatCore_io_write_ports_1_valid;
  assign io_debug_float_writeData_1_bits_addr = {27'h0, _floatCore_io_write_ports_1_addr};
  assign io_debug_float_writeData_1_bits_data =
    {_floatCore_io_write_ports_1_data_sign,
     _floatCore_io_write_ports_1_data_exponent,
     _floatCore_io_write_ports_1_data_mantissa};
endmodule

module RvvCoreShim(
  input          clock,
                 reset,
  output         io_inst_0_ready,
  input          io_inst_0_valid,
  input  [31:0]  io_inst_0_bits_pc,
  input  [1:0]   io_inst_0_bits_opcode,
  input  [24:0]  io_inst_0_bits_bits,
  output         io_inst_1_ready,
  input          io_inst_1_valid,
  input  [31:0]  io_inst_1_bits_pc,
  input  [1:0]   io_inst_1_bits_opcode,
  input  [24:0]  io_inst_1_bits_bits,
  output         io_inst_2_ready,
  input          io_inst_2_valid,
  input  [31:0]  io_inst_2_bits_pc,
  input  [1:0]   io_inst_2_bits_opcode,
  input  [24:0]  io_inst_2_bits_bits,
  output         io_inst_3_ready,
  input          io_inst_3_valid,
  input  [31:0]  io_inst_3_bits_pc,
  input  [1:0]   io_inst_3_bits_opcode,
  input  [24:0]  io_inst_3_bits_bits,
  input          io_rs_0_valid,
  input  [31:0]  io_rs_0_data,
  input          io_rs_1_valid,
  input  [31:0]  io_rs_1_data,
  input          io_rs_2_valid,
  input  [31:0]  io_rs_2_data,
  input          io_rs_3_valid,
  input  [31:0]  io_rs_3_data,
  input          io_rs_4_valid,
  input  [31:0]  io_rs_4_data,
  input          io_rs_5_valid,
  input  [31:0]  io_rs_5_data,
  input          io_rs_6_valid,
  input  [31:0]  io_rs_6_data,
  input          io_rs_7_valid,
  input  [31:0]  io_rs_7_data,
  output         io_rd_0_valid,
  output [4:0]   io_rd_0_bits_addr,
  output [31:0]  io_rd_0_bits_data,
  output         io_rd_1_valid,
  output [4:0]   io_rd_1_bits_addr,
  output [31:0]  io_rd_1_bits_data,
  output         io_rd_2_valid,
  output [4:0]   io_rd_2_bits_addr,
  output [31:0]  io_rd_2_bits_data,
  output         io_rd_3_valid,
  output [4:0]   io_rd_3_bits_addr,
  output [31:0]  io_rd_3_bits_data,
  input  [31:0]  io_frs_0,
  input          io_rvv2lsu_0_ready,
  output         io_rvv2lsu_0_valid,
                 io_rvv2lsu_0_bits_idx_valid,
  output [127:0] io_rvv2lsu_0_bits_idx_bits_data,
  output         io_rvv2lsu_0_bits_vregfile_valid,
  output [127:0] io_rvv2lsu_0_bits_vregfile_bits_data,
  output         io_rvv2lsu_0_bits_mask_valid,
  output [15:0]  io_rvv2lsu_0_bits_mask_bits,
  output         io_lsu2rvv_0_ready,
  input          io_lsu2rvv_0_valid,
  input  [4:0]   io_lsu2rvv_0_bits_addr,
  input  [127:0] io_lsu2rvv_0_bits_data,
  input          io_lsu2rvv_0_bits_last,
  output         io_configState_valid,
  output [7:0]   io_configState_bits_vl,
  output [6:0]   io_configState_bits_vstart,
  output         io_configState_bits_ma,
                 io_configState_bits_ta,
  output [2:0]   io_configState_bits_sew,
                 io_configState_bits_lmul,
                 io_configState_bits_lmul_orig,
  output         io_configState_bits_vill,
  input          io_async_rd_ready,
  output         io_async_rd_valid,
  output [4:0]   io_async_rd_bits_addr,
  output [31:0]  io_async_rd_bits_data,
  output         io_trap_valid,
  output [31:0]  io_trap_bits_pc,
  output [1:0]   io_trap_bits_opcode,
  output [24:0]  io_trap_bits_bits,
  output [6:0]   io_csr_vstart,
  output [1:0]   io_csr_vxrm,
  output         io_csr_vxsat,
  input  [2:0]   io_csr_frm,
  input          io_csr_vstart_write_valid,
  input  [6:0]   io_csr_vstart_write_bits,
  input          io_csr_vxrm_write_valid,
  input  [1:0]   io_csr_vxrm_write_bits,
  input          io_csr_vxsat_write_valid,
                 io_csr_vxsat_write_bits,
  output         io_rvv_idle,
  output [3:0]   io_queue_capacity,
  output         io_rd_rob2rt_o_0_w_valid,
  output [4:0]   io_rd_rob2rt_o_0_w_index,
  output [31:0]  io_rd_rob2rt_o_0_uop_pc,
  output         io_rd_rob2rt_o_0_last_uop_valid,
                 io_rd_rob2rt_o_1_w_valid,
  output [4:0]   io_rd_rob2rt_o_1_w_index,
  output [31:0]  io_rd_rob2rt_o_1_uop_pc,
  output         io_rd_rob2rt_o_1_last_uop_valid,
                 io_rd_rob2rt_o_2_w_valid,
  output [4:0]   io_rd_rob2rt_o_2_w_index,
  output [31:0]  io_rd_rob2rt_o_2_uop_pc,
  output         io_rd_rob2rt_o_2_last_uop_valid,
                 io_rd_rob2rt_o_3_w_valid,
  output [4:0]   io_rd_rob2rt_o_3_w_index,
  output [31:0]  io_rd_rob2rt_o_3_uop_pc,
  output         io_rd_rob2rt_o_3_last_uop_valid
);

  wire       _rvvCoreWrapper_vcsr_valid;
  wire [6:0] _rvvCoreWrapper_vcsr_vstart;
  wire [1:0] _rvvCoreWrapper_vcsr_xrm;
  wire       _rvvCoreWrapper_vcsr_vxsat;
  wire       _rvvCoreWrapper_wr_vxsat_valid_o;
  wire       _rvvCoreWrapper_wr_vxsat_o;
  wire       _rvvCoreWrapper_configStateValid;
  reg  [6:0] vstart;
  reg  [1:0] vxrm;
  reg        vxsat;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      vstart <= 7'h0;
      vxrm <= 2'h0;
      vxsat <= 1'h0;
    end
    else begin
      if (_rvvCoreWrapper_vcsr_valid) begin
        vstart <= _rvvCoreWrapper_vcsr_vstart;
        vxrm <= _rvvCoreWrapper_vcsr_xrm;
      end
      else begin
        if (io_csr_vstart_write_valid)
          vstart <= io_csr_vstart_write_bits;
        if (io_csr_vxrm_write_valid)
          vxrm <= io_csr_vxrm_write_bits;
      end
      if (_rvvCoreWrapper_wr_vxsat_valid_o)
        vxsat <= vxsat | _rvvCoreWrapper_wr_vxsat_o;
      else if (_rvvCoreWrapper_vcsr_valid)
        vxsat <= _rvvCoreWrapper_vcsr_vxsat;
      else if (io_csr_vxsat_write_valid)
        vxsat <= io_csr_vxsat_write_bits;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        vstart = _RANDOM[/*Zero width*/ 1'b0][6:0];
        vxrm = _RANDOM[/*Zero width*/ 1'b0][8:7];
        vxsat = _RANDOM[/*Zero width*/ 1'b0][9];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        vstart = 7'h0;
        vxrm = 2'h0;
        vxsat = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  RvvCoreWrapper rvvCoreWrapper (
    .clk                                (clock),
    .rstn                               (~reset),
    .vstart
      (io_csr_vstart_write_valid ? io_csr_vstart_write_bits : vstart),
    .vxrm
      (io_csr_vxrm_write_valid ? io_csr_vxrm_write_bits : vxrm),
    .vxsat
      (io_csr_vxsat_write_valid ? io_csr_vxsat_write_bits : vxsat),
    .frm                                (io_csr_frm),
    .inst_0_ready                       (io_inst_0_ready),
    .inst_0_valid                       (io_inst_0_valid),
    .inst_0_bits_pc                     (io_inst_0_bits_pc),
    .inst_0_bits_opcode                 (io_inst_0_bits_opcode),
    .inst_0_bits_bits                   (io_inst_0_bits_bits),
    .inst_1_ready                       (io_inst_1_ready),
    .inst_1_valid                       (io_inst_1_valid),
    .inst_1_bits_pc                     (io_inst_1_bits_pc),
    .inst_1_bits_opcode                 (io_inst_1_bits_opcode),
    .inst_1_bits_bits                   (io_inst_1_bits_bits),
    .inst_2_ready                       (io_inst_2_ready),
    .inst_2_valid                       (io_inst_2_valid),
    .inst_2_bits_pc                     (io_inst_2_bits_pc),
    .inst_2_bits_opcode                 (io_inst_2_bits_opcode),
    .inst_2_bits_bits                   (io_inst_2_bits_bits),
    .inst_3_ready                       (io_inst_3_ready),
    .inst_3_valid                       (io_inst_3_valid),
    .inst_3_bits_pc                     (io_inst_3_bits_pc),
    .inst_3_bits_opcode                 (io_inst_3_bits_opcode),
    .inst_3_bits_bits                   (io_inst_3_bits_bits),
    .rs_0_valid                         (io_rs_0_valid),
    .rs_0_data                          (io_rs_0_data),
    .rs_1_valid                         (io_rs_1_valid),
    .rs_1_data                          (io_rs_1_data),
    .rs_2_valid                         (io_rs_2_valid),
    .rs_2_data                          (io_rs_2_data),
    .rs_3_valid                         (io_rs_3_valid),
    .rs_3_data                          (io_rs_3_data),
    .rs_4_valid                         (io_rs_4_valid),
    .rs_4_data                          (io_rs_4_data),
    .rs_5_valid                         (io_rs_5_valid),
    .rs_5_data                          (io_rs_5_data),
    .rs_6_valid                         (io_rs_6_valid),
    .rs_6_data                          (io_rs_6_data),
    .rs_7_valid                         (io_rs_7_valid),
    .rs_7_data                          (io_rs_7_data),
    .rd_0_valid                         (io_rd_0_valid),
    .rd_0_bits_addr                     (io_rd_0_bits_addr),
    .rd_0_bits_data                     (io_rd_0_bits_data),
    .rd_1_valid                         (io_rd_1_valid),
    .rd_1_bits_addr                     (io_rd_1_bits_addr),
    .rd_1_bits_data                     (io_rd_1_bits_data),
    .rd_2_valid                         (io_rd_2_valid),
    .rd_2_bits_addr                     (io_rd_2_bits_addr),
    .rd_2_bits_data                     (io_rd_2_bits_data),
    .rd_3_valid                         (io_rd_3_valid),
    .rd_3_bits_addr                     (io_rd_3_bits_addr),
    .rd_3_bits_data                     (io_rd_3_bits_data),
    .frs_0                              (io_frs_0),
    .frs_1                              (32'h0),
    .frs_2                              (32'h0),
    .frs_3                              (32'h0),
    .async_rd_ready                     (io_async_rd_ready),
    .async_rd_valid                     (io_async_rd_valid),
    .async_rd_bits_addr                 (io_async_rd_bits_addr),
    .async_rd_bits_data                 (io_async_rd_bits_data),
    .async_frd_ready                    (1'h0),
    .async_frd_valid                    (/* unused */),
    .async_frd_bits_addr                (/* unused */),
    .async_frd_bits_data                (/* unused */),
    .rd_rob2rt_o_0_w_valid              (io_rd_rob2rt_o_0_w_valid),
    .rd_rob2rt_o_0_w_index              (io_rd_rob2rt_o_0_w_index),
    .rd_rob2rt_o_0_w_data               (/* unused */),
    .rd_rob2rt_o_0_w_type               (/* unused */),
    .rd_rob2rt_o_0_vd_type              (/* unused */),
    .rd_rob2rt_o_0_trap_flag            (/* unused */),
    .rd_rob2rt_o_0_vector_csr_vl        (/* unused */),
    .rd_rob2rt_o_0_vector_csr_vstart    (/* unused */),
    .rd_rob2rt_o_0_vector_csr_ma        (/* unused */),
    .rd_rob2rt_o_0_vector_csr_ta        (/* unused */),
    .rd_rob2rt_o_0_vector_csr_xrm       (/* unused */),
    .rd_rob2rt_o_0_vector_csr_sew       (/* unused */),
    .rd_rob2rt_o_0_vector_csr_lmul      (/* unused */),
    .rd_rob2rt_o_0_vector_csr_lmul_orig (/* unused */),
    .rd_rob2rt_o_0_vector_csr_vill      (/* unused */),
    .rd_rob2rt_o_0_vxsaturate           (/* unused */),
    .rd_rob2rt_o_0_uop_pc               (io_rd_rob2rt_o_0_uop_pc),
    .rd_rob2rt_o_0_last_uop_valid       (io_rd_rob2rt_o_0_last_uop_valid),
    .rd_rob2rt_o_1_w_valid              (io_rd_rob2rt_o_1_w_valid),
    .rd_rob2rt_o_1_w_index              (io_rd_rob2rt_o_1_w_index),
    .rd_rob2rt_o_1_w_data               (/* unused */),
    .rd_rob2rt_o_1_w_type               (/* unused */),
    .rd_rob2rt_o_1_vd_type              (/* unused */),
    .rd_rob2rt_o_1_trap_flag            (/* unused */),
    .rd_rob2rt_o_1_vector_csr_vl        (/* unused */),
    .rd_rob2rt_o_1_vector_csr_vstart    (/* unused */),
    .rd_rob2rt_o_1_vector_csr_ma        (/* unused */),
    .rd_rob2rt_o_1_vector_csr_ta        (/* unused */),
    .rd_rob2rt_o_1_vector_csr_xrm       (/* unused */),
    .rd_rob2rt_o_1_vector_csr_sew       (/* unused */),
    .rd_rob2rt_o_1_vector_csr_lmul      (/* unused */),
    .rd_rob2rt_o_1_vector_csr_lmul_orig (/* unused */),
    .rd_rob2rt_o_1_vector_csr_vill      (/* unused */),
    .rd_rob2rt_o_1_vxsaturate           (/* unused */),
    .rd_rob2rt_o_1_uop_pc               (io_rd_rob2rt_o_1_uop_pc),
    .rd_rob2rt_o_1_last_uop_valid       (io_rd_rob2rt_o_1_last_uop_valid),
    .rd_rob2rt_o_2_w_valid              (io_rd_rob2rt_o_2_w_valid),
    .rd_rob2rt_o_2_w_index              (io_rd_rob2rt_o_2_w_index),
    .rd_rob2rt_o_2_w_data               (/* unused */),
    .rd_rob2rt_o_2_w_type               (/* unused */),
    .rd_rob2rt_o_2_vd_type              (/* unused */),
    .rd_rob2rt_o_2_trap_flag            (/* unused */),
    .rd_rob2rt_o_2_vector_csr_vl        (/* unused */),
    .rd_rob2rt_o_2_vector_csr_vstart    (/* unused */),
    .rd_rob2rt_o_2_vector_csr_ma        (/* unused */),
    .rd_rob2rt_o_2_vector_csr_ta        (/* unused */),
    .rd_rob2rt_o_2_vector_csr_xrm       (/* unused */),
    .rd_rob2rt_o_2_vector_csr_sew       (/* unused */),
    .rd_rob2rt_o_2_vector_csr_lmul      (/* unused */),
    .rd_rob2rt_o_2_vector_csr_lmul_orig (/* unused */),
    .rd_rob2rt_o_2_vector_csr_vill      (/* unused */),
    .rd_rob2rt_o_2_vxsaturate           (/* unused */),
    .rd_rob2rt_o_2_uop_pc               (io_rd_rob2rt_o_2_uop_pc),
    .rd_rob2rt_o_2_last_uop_valid       (io_rd_rob2rt_o_2_last_uop_valid),
    .rd_rob2rt_o_3_w_valid              (io_rd_rob2rt_o_3_w_valid),
    .rd_rob2rt_o_3_w_index              (io_rd_rob2rt_o_3_w_index),
    .rd_rob2rt_o_3_w_data               (/* unused */),
    .rd_rob2rt_o_3_w_type               (/* unused */),
    .rd_rob2rt_o_3_vd_type              (/* unused */),
    .rd_rob2rt_o_3_trap_flag            (/* unused */),
    .rd_rob2rt_o_3_vector_csr_vl        (/* unused */),
    .rd_rob2rt_o_3_vector_csr_vstart    (/* unused */),
    .rd_rob2rt_o_3_vector_csr_ma        (/* unused */),
    .rd_rob2rt_o_3_vector_csr_ta        (/* unused */),
    .rd_rob2rt_o_3_vector_csr_xrm       (/* unused */),
    .rd_rob2rt_o_3_vector_csr_sew       (/* unused */),
    .rd_rob2rt_o_3_vector_csr_lmul      (/* unused */),
    .rd_rob2rt_o_3_vector_csr_lmul_orig (/* unused */),
    .rd_rob2rt_o_3_vector_csr_vill      (/* unused */),
    .rd_rob2rt_o_3_vxsaturate           (/* unused */),
    .rd_rob2rt_o_3_uop_pc               (io_rd_rob2rt_o_3_uop_pc),
    .rd_rob2rt_o_3_last_uop_valid       (io_rd_rob2rt_o_3_last_uop_valid),
    .trap_valid                         (io_trap_valid),
    .trap_bits_pc                       (io_trap_bits_pc),
    .trap_bits_opcode                   (io_trap_bits_opcode),
    .trap_bits_bits                     (io_trap_bits_bits),
    .vcsr_valid                         (_rvvCoreWrapper_vcsr_valid),
    .vcsr_vstart                        (_rvvCoreWrapper_vcsr_vstart),
    .vcsr_xrm                           (_rvvCoreWrapper_vcsr_xrm),
    .vcsr_vxsat                         (_rvvCoreWrapper_vcsr_vxsat),
    .vcsr_ready                         (1'h1),
    .wr_vxsat_valid_o                   (_rvvCoreWrapper_wr_vxsat_valid_o),
    .wr_vxsat_o                         (_rvvCoreWrapper_wr_vxsat_o),
    .rvv2lsu_0_ready                    (io_rvv2lsu_0_ready),
    .rvv2lsu_0_valid                    (io_rvv2lsu_0_valid),
    .rvv2lsu_0_bits_idx_valid           (io_rvv2lsu_0_bits_idx_valid),
    .rvv2lsu_0_bits_idx_bits_addr       (/* unused */),
    .rvv2lsu_0_bits_idx_bits_data       (io_rvv2lsu_0_bits_idx_bits_data),
    .rvv2lsu_0_bits_vregfile_valid      (io_rvv2lsu_0_bits_vregfile_valid),
    .rvv2lsu_0_bits_vregfile_bits_addr  (/* unused */),
    .rvv2lsu_0_bits_vregfile_bits_data  (io_rvv2lsu_0_bits_vregfile_bits_data),
    .rvv2lsu_0_bits_mask_valid          (io_rvv2lsu_0_bits_mask_valid),
    .rvv2lsu_0_bits_mask_bits           (io_rvv2lsu_0_bits_mask_bits),
    .rvv2lsu_1_ready                    (1'h0),
    .rvv2lsu_1_valid                    (/* unused */),
    .rvv2lsu_1_bits_idx_valid           (/* unused */),
    .rvv2lsu_1_bits_idx_bits_addr       (/* unused */),
    .rvv2lsu_1_bits_idx_bits_data       (/* unused */),
    .rvv2lsu_1_bits_vregfile_valid      (/* unused */),
    .rvv2lsu_1_bits_vregfile_bits_addr  (/* unused */),
    .rvv2lsu_1_bits_vregfile_bits_data  (/* unused */),
    .rvv2lsu_1_bits_mask_valid          (/* unused */),
    .rvv2lsu_1_bits_mask_bits           (/* unused */),
    .lsu2rvv_0_ready                    (io_lsu2rvv_0_ready),
    .lsu2rvv_0_valid                    (io_lsu2rvv_0_valid),
    .lsu2rvv_0_bits_addr                (io_lsu2rvv_0_bits_addr),
    .lsu2rvv_0_bits_data                (io_lsu2rvv_0_bits_data),
    .lsu2rvv_0_bits_last                (io_lsu2rvv_0_bits_last),
    .lsu2rvv_1_ready                    (/* unused */),
    .lsu2rvv_1_valid                    (1'h0),
    .lsu2rvv_1_bits_addr                (5'h0),
    .lsu2rvv_1_bits_data                (128'h0),
    .lsu2rvv_1_bits_last                (1'h1),
    .configStateValid                   (_rvvCoreWrapper_configStateValid),
    .configVl                           (io_configState_bits_vl),
    .configVstart                       (io_configState_bits_vstart),
    .configMa                           (io_configState_bits_ma),
    .configTa                           (io_configState_bits_ta),
    .configXrm                          (/* unused */),
    .configSew                          (io_configState_bits_sew),
    .configLmul                         (io_configState_bits_lmul),
    .configLmulOrig                     (io_configState_bits_lmul_orig),
    .configVill                         (io_configState_bits_vill),
    .rvv_idle                           (io_rvv_idle),
    .queue_capacity                     (io_queue_capacity)
  );
  assign io_configState_valid =
    _rvvCoreWrapper_configStateValid & ~_rvvCoreWrapper_vcsr_valid
    & ~io_csr_vstart_write_valid & ~io_csr_vxrm_write_valid & ~io_csr_vxsat_write_valid;
  assign io_csr_vstart = vstart;
  assign io_csr_vxrm = vxrm;
  assign io_csr_vxsat = vxsat;
endmodule

module RvvCoreMini(
  input          clock,
                 reset,
  input  [31:0]  io_csr_in_value_0,
  output [31:0]  io_csr_out_value_0,
                 io_csr_out_value_1,
                 io_csr_out_value_2,
                 io_csr_out_value_3,
                 io_csr_out_value_4,
                 io_csr_out_value_5,
                 io_csr_out_value_6,
                 io_csr_out_value_7,
                 io_csr_out_value_8,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output         io_ibus_valid,
  output [31:0]  io_ibus_addr,
  input  [127:0] io_ibus_rdata,
  input          io_ibus_fault_valid,
  output         io_dbus_valid,
                 io_dbus_write,
  output [31:0]  io_dbus_addr,
  output [127:0] io_dbus_wdata,
  output [15:0]  io_dbus_wmask,
  input  [127:0] io_dbus_rdata,
  output         io_ebus_dbus_valid,
  input          io_ebus_dbus_ready,
  output         io_ebus_dbus_write,
  output [31:0]  io_ebus_dbus_pc,
                 io_ebus_dbus_addr,
  output [4:0]   io_ebus_dbus_size,
  output [127:0] io_ebus_dbus_wdata,
  output [15:0]  io_ebus_dbus_wmask,
  input  [127:0] io_ebus_dbus_rdata,
  input          io_ebus_fault_valid,
                 io_ebus_fault_bits_write,
  input  [31:0]  io_ebus_fault_bits_addr,
                 io_ebus_fault_bits_epc,
  output         io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_addr_2,
                 io_debug_addr_3,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_inst_2,
                 io_debug_inst_3,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_dispatch_2_instFire,
  output [31:0]  io_debug_dispatch_2_instAddr,
                 io_debug_dispatch_2_instInst,
  output         io_debug_dispatch_3_instFire,
  output [31:0]  io_debug_dispatch_3_instAddr,
                 io_debug_dispatch_3_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeAddr_2_valid,
  output [4:0]   io_debug_regfile_writeAddr_2_bits,
  output         io_debug_regfile_writeAddr_3_valid,
  output [4:0]   io_debug_regfile_writeAddr_3_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_regfile_writeData_4_valid,
  output [4:0]   io_debug_regfile_writeData_4_bits_addr,
  output [31:0]  io_debug_regfile_writeData_4_bits_data,
  output         io_debug_regfile_writeData_5_valid,
  output [4:0]   io_debug_regfile_writeData_5_bits_addr,
  output [31:0]  io_debug_regfile_writeData_5_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data,
  output         io_debug_rb_inst_0_valid,
  output [31:0]  io_debug_rb_inst_0_bits_pc,
  output [6:0]   io_debug_rb_inst_0_bits_idx,
  output         io_debug_rb_inst_0_bits_trap,
                 io_debug_rb_inst_1_valid,
  output [31:0]  io_debug_rb_inst_1_bits_pc,
  output [6:0]   io_debug_rb_inst_1_bits_idx,
  output         io_debug_rb_inst_1_bits_trap,
                 io_debug_rb_inst_2_valid,
  output [31:0]  io_debug_rb_inst_2_bits_pc,
  output [6:0]   io_debug_rb_inst_2_bits_idx,
  output         io_debug_rb_inst_2_bits_trap,
                 io_debug_rb_inst_3_valid,
  output [31:0]  io_debug_rb_inst_3_bits_pc,
  output [6:0]   io_debug_rb_inst_3_bits_idx,
  output         io_debug_rb_inst_3_bits_trap,
                 io_debug_rb_inst_4_valid,
  output [31:0]  io_debug_rb_inst_4_bits_pc,
  output [6:0]   io_debug_rb_inst_4_bits_idx,
  output         io_debug_rb_inst_4_bits_trap,
                 io_debug_rb_inst_5_valid,
  output [31:0]  io_debug_rb_inst_5_bits_pc,
  output [6:0]   io_debug_rb_inst_5_bits_idx,
  output         io_debug_rb_inst_5_bits_trap,
                 io_debug_rb_inst_6_valid,
  output [31:0]  io_debug_rb_inst_6_bits_pc,
  output [6:0]   io_debug_rb_inst_6_bits_idx,
  output         io_debug_rb_inst_6_bits_trap,
                 io_debug_rb_inst_7_valid,
  output [31:0]  io_debug_rb_inst_7_bits_pc,
  output [6:0]   io_debug_rb_inst_7_bits_idx,
  output         io_debug_rb_inst_7_bits_trap
);

  wire         _rvvCore_io_inst_0_ready;
  wire         _rvvCore_io_inst_1_ready;
  wire         _rvvCore_io_inst_2_ready;
  wire         _rvvCore_io_inst_3_ready;
  wire         _rvvCore_io_rd_0_valid;
  wire [4:0]   _rvvCore_io_rd_0_bits_addr;
  wire [31:0]  _rvvCore_io_rd_0_bits_data;
  wire         _rvvCore_io_rd_1_valid;
  wire [4:0]   _rvvCore_io_rd_1_bits_addr;
  wire [31:0]  _rvvCore_io_rd_1_bits_data;
  wire         _rvvCore_io_rd_2_valid;
  wire [4:0]   _rvvCore_io_rd_2_bits_addr;
  wire [31:0]  _rvvCore_io_rd_2_bits_data;
  wire         _rvvCore_io_rd_3_valid;
  wire [4:0]   _rvvCore_io_rd_3_bits_addr;
  wire [31:0]  _rvvCore_io_rd_3_bits_data;
  wire         _rvvCore_io_rvv2lsu_0_valid;
  wire         _rvvCore_io_rvv2lsu_0_bits_idx_valid;
  wire [127:0] _rvvCore_io_rvv2lsu_0_bits_idx_bits_data;
  wire         _rvvCore_io_rvv2lsu_0_bits_vregfile_valid;
  wire [127:0] _rvvCore_io_rvv2lsu_0_bits_vregfile_bits_data;
  wire         _rvvCore_io_rvv2lsu_0_bits_mask_valid;
  wire [15:0]  _rvvCore_io_rvv2lsu_0_bits_mask_bits;
  wire         _rvvCore_io_lsu2rvv_0_ready;
  wire         _rvvCore_io_configState_valid;
  wire [7:0]   _rvvCore_io_configState_bits_vl;
  wire [6:0]   _rvvCore_io_configState_bits_vstart;
  wire         _rvvCore_io_configState_bits_ma;
  wire         _rvvCore_io_configState_bits_ta;
  wire [2:0]   _rvvCore_io_configState_bits_sew;
  wire [2:0]   _rvvCore_io_configState_bits_lmul;
  wire [2:0]   _rvvCore_io_configState_bits_lmul_orig;
  wire         _rvvCore_io_configState_bits_vill;
  wire         _rvvCore_io_async_rd_valid;
  wire [4:0]   _rvvCore_io_async_rd_bits_addr;
  wire [31:0]  _rvvCore_io_async_rd_bits_data;
  wire         _rvvCore_io_trap_valid;
  wire [31:0]  _rvvCore_io_trap_bits_pc;
  wire [1:0]   _rvvCore_io_trap_bits_opcode;
  wire [24:0]  _rvvCore_io_trap_bits_bits;
  wire [6:0]   _rvvCore_io_csr_vstart;
  wire [1:0]   _rvvCore_io_csr_vxrm;
  wire         _rvvCore_io_csr_vxsat;
  wire         _rvvCore_io_rvv_idle;
  wire [3:0]   _rvvCore_io_queue_capacity;
  wire         _rvvCore_io_rd_rob2rt_o_0_w_valid;
  wire [4:0]   _rvvCore_io_rd_rob2rt_o_0_w_index;
  wire [31:0]  _rvvCore_io_rd_rob2rt_o_0_uop_pc;
  wire         _rvvCore_io_rd_rob2rt_o_0_last_uop_valid;
  wire         _rvvCore_io_rd_rob2rt_o_1_w_valid;
  wire [4:0]   _rvvCore_io_rd_rob2rt_o_1_w_index;
  wire [31:0]  _rvvCore_io_rd_rob2rt_o_1_uop_pc;
  wire         _rvvCore_io_rd_rob2rt_o_1_last_uop_valid;
  wire         _rvvCore_io_rd_rob2rt_o_2_w_valid;
  wire [4:0]   _rvvCore_io_rd_rob2rt_o_2_w_index;
  wire [31:0]  _rvvCore_io_rd_rob2rt_o_2_uop_pc;
  wire         _rvvCore_io_rd_rob2rt_o_2_last_uop_valid;
  wire         _rvvCore_io_rd_rob2rt_o_3_w_valid;
  wire [4:0]   _rvvCore_io_rd_rob2rt_o_3_w_index;
  wire [31:0]  _rvvCore_io_rd_rob2rt_o_3_uop_pc;
  wire         _rvvCore_io_rd_rob2rt_o_3_last_uop_valid;
  wire         _score_io_rvvcore_inst_0_valid;
  wire [31:0]  _score_io_rvvcore_inst_0_bits_pc;
  wire [1:0]   _score_io_rvvcore_inst_0_bits_opcode;
  wire [24:0]  _score_io_rvvcore_inst_0_bits_bits;
  wire         _score_io_rvvcore_inst_1_valid;
  wire [31:0]  _score_io_rvvcore_inst_1_bits_pc;
  wire [1:0]   _score_io_rvvcore_inst_1_bits_opcode;
  wire [24:0]  _score_io_rvvcore_inst_1_bits_bits;
  wire         _score_io_rvvcore_inst_2_valid;
  wire [31:0]  _score_io_rvvcore_inst_2_bits_pc;
  wire [1:0]   _score_io_rvvcore_inst_2_bits_opcode;
  wire [24:0]  _score_io_rvvcore_inst_2_bits_bits;
  wire         _score_io_rvvcore_inst_3_valid;
  wire [31:0]  _score_io_rvvcore_inst_3_bits_pc;
  wire [1:0]   _score_io_rvvcore_inst_3_bits_opcode;
  wire [24:0]  _score_io_rvvcore_inst_3_bits_bits;
  wire         _score_io_rvvcore_rs_0_valid;
  wire [31:0]  _score_io_rvvcore_rs_0_data;
  wire         _score_io_rvvcore_rs_1_valid;
  wire [31:0]  _score_io_rvvcore_rs_1_data;
  wire         _score_io_rvvcore_rs_2_valid;
  wire [31:0]  _score_io_rvvcore_rs_2_data;
  wire         _score_io_rvvcore_rs_3_valid;
  wire [31:0]  _score_io_rvvcore_rs_3_data;
  wire         _score_io_rvvcore_rs_4_valid;
  wire [31:0]  _score_io_rvvcore_rs_4_data;
  wire         _score_io_rvvcore_rs_5_valid;
  wire [31:0]  _score_io_rvvcore_rs_5_data;
  wire         _score_io_rvvcore_rs_6_valid;
  wire [31:0]  _score_io_rvvcore_rs_6_data;
  wire         _score_io_rvvcore_rs_7_valid;
  wire [31:0]  _score_io_rvvcore_rs_7_data;
  wire [31:0]  _score_io_rvvcore_frs_0;
  wire         _score_io_rvvcore_rvv2lsu_0_ready;
  wire         _score_io_rvvcore_lsu2rvv_0_valid;
  wire [4:0]   _score_io_rvvcore_lsu2rvv_0_bits_addr;
  wire [127:0] _score_io_rvvcore_lsu2rvv_0_bits_data;
  wire         _score_io_rvvcore_lsu2rvv_0_bits_last;
  wire         _score_io_rvvcore_async_rd_ready;
  wire [2:0]   _score_io_rvvcore_csr_frm;
  wire         _score_io_rvvcore_csr_vstart_write_valid;
  wire [6:0]   _score_io_rvvcore_csr_vstart_write_bits;
  wire         _score_io_rvvcore_csr_vxrm_write_valid;
  wire [1:0]   _score_io_rvvcore_csr_vxrm_write_bits;
  wire         _score_io_rvvcore_csr_vxsat_write_valid;
  wire         _score_io_rvvcore_csr_vxsat_write_bits;
  SCore score (
    .clock                                        (clock),
    .reset                                        (reset),
    .io_csr_in_value_0                            (io_csr_in_value_0),
    .io_csr_out_value_0                           (io_csr_out_value_0),
    .io_csr_out_value_1                           (io_csr_out_value_1),
    .io_csr_out_value_2                           (io_csr_out_value_2),
    .io_csr_out_value_3                           (io_csr_out_value_3),
    .io_csr_out_value_4                           (io_csr_out_value_4),
    .io_csr_out_value_5                           (io_csr_out_value_5),
    .io_csr_out_value_6                           (io_csr_out_value_6),
    .io_csr_out_value_7                           (io_csr_out_value_7),
    .io_csr_out_value_8                           (io_csr_out_value_8),
    .io_halted                                    (io_halted),
    .io_fault                                     (io_fault),
    .io_wfi                                       (io_wfi),
    .io_irq                                       (io_irq),
    .io_ibus_valid                                (io_ibus_valid),
    .io_ibus_addr                                 (io_ibus_addr),
    .io_ibus_rdata                                (io_ibus_rdata),
    .io_ibus_fault_valid                          (io_ibus_fault_valid),
    .io_dbus_valid                                (io_dbus_valid),
    .io_dbus_write                                (io_dbus_write),
    .io_dbus_addr                                 (io_dbus_addr),
    .io_dbus_wdata                                (io_dbus_wdata),
    .io_dbus_wmask                                (io_dbus_wmask),
    .io_dbus_rdata                                (io_dbus_rdata),
    .io_ebus_dbus_valid                           (io_ebus_dbus_valid),
    .io_ebus_dbus_ready                           (io_ebus_dbus_ready),
    .io_ebus_dbus_write                           (io_ebus_dbus_write),
    .io_ebus_dbus_pc                              (io_ebus_dbus_pc),
    .io_ebus_dbus_addr                            (io_ebus_dbus_addr),
    .io_ebus_dbus_size                            (io_ebus_dbus_size),
    .io_ebus_dbus_wdata                           (io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask                           (io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata                           (io_ebus_dbus_rdata),
    .io_ebus_fault_valid                          (io_ebus_fault_valid),
    .io_ebus_fault_bits_write                     (io_ebus_fault_bits_write),
    .io_ebus_fault_bits_addr                      (io_ebus_fault_bits_addr),
    .io_ebus_fault_bits_epc                       (io_ebus_fault_bits_epc),
    .io_rvvcore_inst_0_ready                      (_rvvCore_io_inst_0_ready),
    .io_rvvcore_inst_0_valid                      (_score_io_rvvcore_inst_0_valid),
    .io_rvvcore_inst_0_bits_pc                    (_score_io_rvvcore_inst_0_bits_pc),
    .io_rvvcore_inst_0_bits_opcode                (_score_io_rvvcore_inst_0_bits_opcode),
    .io_rvvcore_inst_0_bits_bits                  (_score_io_rvvcore_inst_0_bits_bits),
    .io_rvvcore_inst_1_ready                      (_rvvCore_io_inst_1_ready),
    .io_rvvcore_inst_1_valid                      (_score_io_rvvcore_inst_1_valid),
    .io_rvvcore_inst_1_bits_pc                    (_score_io_rvvcore_inst_1_bits_pc),
    .io_rvvcore_inst_1_bits_opcode                (_score_io_rvvcore_inst_1_bits_opcode),
    .io_rvvcore_inst_1_bits_bits                  (_score_io_rvvcore_inst_1_bits_bits),
    .io_rvvcore_inst_2_ready                      (_rvvCore_io_inst_2_ready),
    .io_rvvcore_inst_2_valid                      (_score_io_rvvcore_inst_2_valid),
    .io_rvvcore_inst_2_bits_pc                    (_score_io_rvvcore_inst_2_bits_pc),
    .io_rvvcore_inst_2_bits_opcode                (_score_io_rvvcore_inst_2_bits_opcode),
    .io_rvvcore_inst_2_bits_bits                  (_score_io_rvvcore_inst_2_bits_bits),
    .io_rvvcore_inst_3_ready                      (_rvvCore_io_inst_3_ready),
    .io_rvvcore_inst_3_valid                      (_score_io_rvvcore_inst_3_valid),
    .io_rvvcore_inst_3_bits_pc                    (_score_io_rvvcore_inst_3_bits_pc),
    .io_rvvcore_inst_3_bits_opcode                (_score_io_rvvcore_inst_3_bits_opcode),
    .io_rvvcore_inst_3_bits_bits                  (_score_io_rvvcore_inst_3_bits_bits),
    .io_rvvcore_rs_0_valid                        (_score_io_rvvcore_rs_0_valid),
    .io_rvvcore_rs_0_data                         (_score_io_rvvcore_rs_0_data),
    .io_rvvcore_rs_1_valid                        (_score_io_rvvcore_rs_1_valid),
    .io_rvvcore_rs_1_data                         (_score_io_rvvcore_rs_1_data),
    .io_rvvcore_rs_2_valid                        (_score_io_rvvcore_rs_2_valid),
    .io_rvvcore_rs_2_data                         (_score_io_rvvcore_rs_2_data),
    .io_rvvcore_rs_3_valid                        (_score_io_rvvcore_rs_3_valid),
    .io_rvvcore_rs_3_data                         (_score_io_rvvcore_rs_3_data),
    .io_rvvcore_rs_4_valid                        (_score_io_rvvcore_rs_4_valid),
    .io_rvvcore_rs_4_data                         (_score_io_rvvcore_rs_4_data),
    .io_rvvcore_rs_5_valid                        (_score_io_rvvcore_rs_5_valid),
    .io_rvvcore_rs_5_data                         (_score_io_rvvcore_rs_5_data),
    .io_rvvcore_rs_6_valid                        (_score_io_rvvcore_rs_6_valid),
    .io_rvvcore_rs_6_data                         (_score_io_rvvcore_rs_6_data),
    .io_rvvcore_rs_7_valid                        (_score_io_rvvcore_rs_7_valid),
    .io_rvvcore_rs_7_data                         (_score_io_rvvcore_rs_7_data),
    .io_rvvcore_rd_0_valid                        (_rvvCore_io_rd_0_valid),
    .io_rvvcore_rd_0_bits_addr                    (_rvvCore_io_rd_0_bits_addr),
    .io_rvvcore_rd_0_bits_data                    (_rvvCore_io_rd_0_bits_data),
    .io_rvvcore_rd_1_valid                        (_rvvCore_io_rd_1_valid),
    .io_rvvcore_rd_1_bits_addr                    (_rvvCore_io_rd_1_bits_addr),
    .io_rvvcore_rd_1_bits_data                    (_rvvCore_io_rd_1_bits_data),
    .io_rvvcore_rd_2_valid                        (_rvvCore_io_rd_2_valid),
    .io_rvvcore_rd_2_bits_addr                    (_rvvCore_io_rd_2_bits_addr),
    .io_rvvcore_rd_2_bits_data                    (_rvvCore_io_rd_2_bits_data),
    .io_rvvcore_rd_3_valid                        (_rvvCore_io_rd_3_valid),
    .io_rvvcore_rd_3_bits_addr                    (_rvvCore_io_rd_3_bits_addr),
    .io_rvvcore_rd_3_bits_data                    (_rvvCore_io_rd_3_bits_data),
    .io_rvvcore_frs_0                             (_score_io_rvvcore_frs_0),
    .io_rvvcore_rvv2lsu_0_ready                   (_score_io_rvvcore_rvv2lsu_0_ready),
    .io_rvvcore_rvv2lsu_0_valid                   (_rvvCore_io_rvv2lsu_0_valid),
    .io_rvvcore_rvv2lsu_0_bits_idx_valid          (_rvvCore_io_rvv2lsu_0_bits_idx_valid),
    .io_rvvcore_rvv2lsu_0_bits_idx_bits_data
      (_rvvCore_io_rvv2lsu_0_bits_idx_bits_data),
    .io_rvvcore_rvv2lsu_0_bits_vregfile_valid
      (_rvvCore_io_rvv2lsu_0_bits_vregfile_valid),
    .io_rvvcore_rvv2lsu_0_bits_vregfile_bits_data
      (_rvvCore_io_rvv2lsu_0_bits_vregfile_bits_data),
    .io_rvvcore_rvv2lsu_0_bits_mask_valid         (_rvvCore_io_rvv2lsu_0_bits_mask_valid),
    .io_rvvcore_rvv2lsu_0_bits_mask_bits          (_rvvCore_io_rvv2lsu_0_bits_mask_bits),
    .io_rvvcore_lsu2rvv_0_ready                   (_rvvCore_io_lsu2rvv_0_ready),
    .io_rvvcore_lsu2rvv_0_valid                   (_score_io_rvvcore_lsu2rvv_0_valid),
    .io_rvvcore_lsu2rvv_0_bits_addr               (_score_io_rvvcore_lsu2rvv_0_bits_addr),
    .io_rvvcore_lsu2rvv_0_bits_data               (_score_io_rvvcore_lsu2rvv_0_bits_data),
    .io_rvvcore_lsu2rvv_0_bits_last               (_score_io_rvvcore_lsu2rvv_0_bits_last),
    .io_rvvcore_configState_valid                 (_rvvCore_io_configState_valid),
    .io_rvvcore_configState_bits_vl               (_rvvCore_io_configState_bits_vl),
    .io_rvvcore_configState_bits_vstart           (_rvvCore_io_configState_bits_vstart),
    .io_rvvcore_configState_bits_ma               (_rvvCore_io_configState_bits_ma),
    .io_rvvcore_configState_bits_ta               (_rvvCore_io_configState_bits_ta),
    .io_rvvcore_configState_bits_sew              (_rvvCore_io_configState_bits_sew),
    .io_rvvcore_configState_bits_lmul             (_rvvCore_io_configState_bits_lmul),
    .io_rvvcore_configState_bits_lmul_orig
      (_rvvCore_io_configState_bits_lmul_orig),
    .io_rvvcore_configState_bits_vill             (_rvvCore_io_configState_bits_vill),
    .io_rvvcore_async_rd_ready                    (_score_io_rvvcore_async_rd_ready),
    .io_rvvcore_async_rd_valid                    (_rvvCore_io_async_rd_valid),
    .io_rvvcore_async_rd_bits_addr                (_rvvCore_io_async_rd_bits_addr),
    .io_rvvcore_async_rd_bits_data                (_rvvCore_io_async_rd_bits_data),
    .io_rvvcore_trap_valid                        (_rvvCore_io_trap_valid),
    .io_rvvcore_trap_bits_pc                      (_rvvCore_io_trap_bits_pc),
    .io_rvvcore_trap_bits_opcode                  (_rvvCore_io_trap_bits_opcode),
    .io_rvvcore_trap_bits_bits                    (_rvvCore_io_trap_bits_bits),
    .io_rvvcore_csr_vstart                        (_rvvCore_io_csr_vstart),
    .io_rvvcore_csr_vxrm                          (_rvvCore_io_csr_vxrm),
    .io_rvvcore_csr_vxsat                         (_rvvCore_io_csr_vxsat),
    .io_rvvcore_csr_frm                           (_score_io_rvvcore_csr_frm),
    .io_rvvcore_csr_vstart_write_valid
      (_score_io_rvvcore_csr_vstart_write_valid),
    .io_rvvcore_csr_vstart_write_bits
      (_score_io_rvvcore_csr_vstart_write_bits),
    .io_rvvcore_csr_vxrm_write_valid
      (_score_io_rvvcore_csr_vxrm_write_valid),
    .io_rvvcore_csr_vxrm_write_bits               (_score_io_rvvcore_csr_vxrm_write_bits),
    .io_rvvcore_csr_vxsat_write_valid
      (_score_io_rvvcore_csr_vxsat_write_valid),
    .io_rvvcore_csr_vxsat_write_bits
      (_score_io_rvvcore_csr_vxsat_write_bits),
    .io_rvvcore_rvv_idle                          (_rvvCore_io_rvv_idle),
    .io_rvvcore_queue_capacity                    (_rvvCore_io_queue_capacity),
    .io_rvvcore_rd_rob2rt_o_0_w_valid             (_rvvCore_io_rd_rob2rt_o_0_w_valid),
    .io_rvvcore_rd_rob2rt_o_0_w_index             (_rvvCore_io_rd_rob2rt_o_0_w_index),
    .io_rvvcore_rd_rob2rt_o_0_uop_pc              (_rvvCore_io_rd_rob2rt_o_0_uop_pc),
    .io_rvvcore_rd_rob2rt_o_0_last_uop_valid
      (_rvvCore_io_rd_rob2rt_o_0_last_uop_valid),
    .io_rvvcore_rd_rob2rt_o_1_w_valid             (_rvvCore_io_rd_rob2rt_o_1_w_valid),
    .io_rvvcore_rd_rob2rt_o_1_w_index             (_rvvCore_io_rd_rob2rt_o_1_w_index),
    .io_rvvcore_rd_rob2rt_o_1_uop_pc              (_rvvCore_io_rd_rob2rt_o_1_uop_pc),
    .io_rvvcore_rd_rob2rt_o_1_last_uop_valid
      (_rvvCore_io_rd_rob2rt_o_1_last_uop_valid),
    .io_rvvcore_rd_rob2rt_o_2_w_valid             (_rvvCore_io_rd_rob2rt_o_2_w_valid),
    .io_rvvcore_rd_rob2rt_o_2_w_index             (_rvvCore_io_rd_rob2rt_o_2_w_index),
    .io_rvvcore_rd_rob2rt_o_2_uop_pc              (_rvvCore_io_rd_rob2rt_o_2_uop_pc),
    .io_rvvcore_rd_rob2rt_o_2_last_uop_valid
      (_rvvCore_io_rd_rob2rt_o_2_last_uop_valid),
    .io_rvvcore_rd_rob2rt_o_3_w_valid             (_rvvCore_io_rd_rob2rt_o_3_w_valid),
    .io_rvvcore_rd_rob2rt_o_3_w_index             (_rvvCore_io_rd_rob2rt_o_3_w_index),
    .io_rvvcore_rd_rob2rt_o_3_uop_pc              (_rvvCore_io_rd_rob2rt_o_3_uop_pc),
    .io_rvvcore_rd_rob2rt_o_3_last_uop_valid
      (_rvvCore_io_rd_rob2rt_o_3_last_uop_valid),
    .io_slog_valid                                (io_slog_valid),
    .io_slog_addr                                 (io_slog_addr),
    .io_slog_data                                 (io_slog_data),
    .io_debug_en                                  (io_debug_en),
    .io_debug_addr_0                              (io_debug_addr_0),
    .io_debug_addr_1                              (io_debug_addr_1),
    .io_debug_addr_2                              (io_debug_addr_2),
    .io_debug_addr_3                              (io_debug_addr_3),
    .io_debug_inst_0                              (io_debug_inst_0),
    .io_debug_inst_1                              (io_debug_inst_1),
    .io_debug_inst_2                              (io_debug_inst_2),
    .io_debug_inst_3                              (io_debug_inst_3),
    .io_debug_cycles                              (io_debug_cycles),
    .io_debug_dbus_valid                          (io_debug_dbus_valid),
    .io_debug_dbus_bits_addr                      (io_debug_dbus_bits_addr),
    .io_debug_dbus_bits_wdata                     (io_debug_dbus_bits_wdata),
    .io_debug_dbus_bits_write                     (io_debug_dbus_bits_write),
    .io_debug_dispatch_0_instFire                 (io_debug_dispatch_0_instFire),
    .io_debug_dispatch_0_instAddr                 (io_debug_dispatch_0_instAddr),
    .io_debug_dispatch_0_instInst                 (io_debug_dispatch_0_instInst),
    .io_debug_dispatch_1_instFire                 (io_debug_dispatch_1_instFire),
    .io_debug_dispatch_1_instAddr                 (io_debug_dispatch_1_instAddr),
    .io_debug_dispatch_1_instInst                 (io_debug_dispatch_1_instInst),
    .io_debug_dispatch_2_instFire                 (io_debug_dispatch_2_instFire),
    .io_debug_dispatch_2_instAddr                 (io_debug_dispatch_2_instAddr),
    .io_debug_dispatch_2_instInst                 (io_debug_dispatch_2_instInst),
    .io_debug_dispatch_3_instFire                 (io_debug_dispatch_3_instFire),
    .io_debug_dispatch_3_instAddr                 (io_debug_dispatch_3_instAddr),
    .io_debug_dispatch_3_instInst                 (io_debug_dispatch_3_instInst),
    .io_debug_regfile_writeAddr_0_valid           (io_debug_regfile_writeAddr_0_valid),
    .io_debug_regfile_writeAddr_0_bits            (io_debug_regfile_writeAddr_0_bits),
    .io_debug_regfile_writeAddr_1_valid           (io_debug_regfile_writeAddr_1_valid),
    .io_debug_regfile_writeAddr_1_bits            (io_debug_regfile_writeAddr_1_bits),
    .io_debug_regfile_writeAddr_2_valid           (io_debug_regfile_writeAddr_2_valid),
    .io_debug_regfile_writeAddr_2_bits            (io_debug_regfile_writeAddr_2_bits),
    .io_debug_regfile_writeAddr_3_valid           (io_debug_regfile_writeAddr_3_valid),
    .io_debug_regfile_writeAddr_3_bits            (io_debug_regfile_writeAddr_3_bits),
    .io_debug_regfile_writeData_0_valid           (io_debug_regfile_writeData_0_valid),
    .io_debug_regfile_writeData_0_bits_addr
      (io_debug_regfile_writeData_0_bits_addr),
    .io_debug_regfile_writeData_0_bits_data
      (io_debug_regfile_writeData_0_bits_data),
    .io_debug_regfile_writeData_1_valid           (io_debug_regfile_writeData_1_valid),
    .io_debug_regfile_writeData_1_bits_addr
      (io_debug_regfile_writeData_1_bits_addr),
    .io_debug_regfile_writeData_1_bits_data
      (io_debug_regfile_writeData_1_bits_data),
    .io_debug_regfile_writeData_2_valid           (io_debug_regfile_writeData_2_valid),
    .io_debug_regfile_writeData_2_bits_addr
      (io_debug_regfile_writeData_2_bits_addr),
    .io_debug_regfile_writeData_2_bits_data
      (io_debug_regfile_writeData_2_bits_data),
    .io_debug_regfile_writeData_3_valid           (io_debug_regfile_writeData_3_valid),
    .io_debug_regfile_writeData_3_bits_addr
      (io_debug_regfile_writeData_3_bits_addr),
    .io_debug_regfile_writeData_3_bits_data
      (io_debug_regfile_writeData_3_bits_data),
    .io_debug_regfile_writeData_4_valid           (io_debug_regfile_writeData_4_valid),
    .io_debug_regfile_writeData_4_bits_addr
      (io_debug_regfile_writeData_4_bits_addr),
    .io_debug_regfile_writeData_4_bits_data
      (io_debug_regfile_writeData_4_bits_data),
    .io_debug_regfile_writeData_5_valid           (io_debug_regfile_writeData_5_valid),
    .io_debug_regfile_writeData_5_bits_addr
      (io_debug_regfile_writeData_5_bits_addr),
    .io_debug_regfile_writeData_5_bits_data
      (io_debug_regfile_writeData_5_bits_data),
    .io_debug_float_writeAddr_valid               (io_debug_float_writeAddr_valid),
    .io_debug_float_writeAddr_bits                (io_debug_float_writeAddr_bits),
    .io_debug_float_writeData_0_valid             (io_debug_float_writeData_0_valid),
    .io_debug_float_writeData_0_bits_addr         (io_debug_float_writeData_0_bits_addr),
    .io_debug_float_writeData_0_bits_data         (io_debug_float_writeData_0_bits_data),
    .io_debug_float_writeData_1_valid             (io_debug_float_writeData_1_valid),
    .io_debug_float_writeData_1_bits_addr         (io_debug_float_writeData_1_bits_addr),
    .io_debug_float_writeData_1_bits_data         (io_debug_float_writeData_1_bits_data),
    .io_debug_rb_inst_0_valid                     (io_debug_rb_inst_0_valid),
    .io_debug_rb_inst_0_bits_pc                   (io_debug_rb_inst_0_bits_pc),
    .io_debug_rb_inst_0_bits_idx                  (io_debug_rb_inst_0_bits_idx),
    .io_debug_rb_inst_0_bits_trap                 (io_debug_rb_inst_0_bits_trap),
    .io_debug_rb_inst_1_valid                     (io_debug_rb_inst_1_valid),
    .io_debug_rb_inst_1_bits_pc                   (io_debug_rb_inst_1_bits_pc),
    .io_debug_rb_inst_1_bits_idx                  (io_debug_rb_inst_1_bits_idx),
    .io_debug_rb_inst_1_bits_trap                 (io_debug_rb_inst_1_bits_trap),
    .io_debug_rb_inst_2_valid                     (io_debug_rb_inst_2_valid),
    .io_debug_rb_inst_2_bits_pc                   (io_debug_rb_inst_2_bits_pc),
    .io_debug_rb_inst_2_bits_idx                  (io_debug_rb_inst_2_bits_idx),
    .io_debug_rb_inst_2_bits_trap                 (io_debug_rb_inst_2_bits_trap),
    .io_debug_rb_inst_3_valid                     (io_debug_rb_inst_3_valid),
    .io_debug_rb_inst_3_bits_pc                   (io_debug_rb_inst_3_bits_pc),
    .io_debug_rb_inst_3_bits_idx                  (io_debug_rb_inst_3_bits_idx),
    .io_debug_rb_inst_3_bits_trap                 (io_debug_rb_inst_3_bits_trap),
    .io_debug_rb_inst_4_valid                     (io_debug_rb_inst_4_valid),
    .io_debug_rb_inst_4_bits_pc                   (io_debug_rb_inst_4_bits_pc),
    .io_debug_rb_inst_4_bits_idx                  (io_debug_rb_inst_4_bits_idx),
    .io_debug_rb_inst_4_bits_trap                 (io_debug_rb_inst_4_bits_trap),
    .io_debug_rb_inst_5_valid                     (io_debug_rb_inst_5_valid),
    .io_debug_rb_inst_5_bits_pc                   (io_debug_rb_inst_5_bits_pc),
    .io_debug_rb_inst_5_bits_idx                  (io_debug_rb_inst_5_bits_idx),
    .io_debug_rb_inst_5_bits_trap                 (io_debug_rb_inst_5_bits_trap),
    .io_debug_rb_inst_6_valid                     (io_debug_rb_inst_6_valid),
    .io_debug_rb_inst_6_bits_pc                   (io_debug_rb_inst_6_bits_pc),
    .io_debug_rb_inst_6_bits_idx                  (io_debug_rb_inst_6_bits_idx),
    .io_debug_rb_inst_6_bits_trap                 (io_debug_rb_inst_6_bits_trap),
    .io_debug_rb_inst_7_valid                     (io_debug_rb_inst_7_valid),
    .io_debug_rb_inst_7_bits_pc                   (io_debug_rb_inst_7_bits_pc),
    .io_debug_rb_inst_7_bits_idx                  (io_debug_rb_inst_7_bits_idx),
    .io_debug_rb_inst_7_bits_trap                 (io_debug_rb_inst_7_bits_trap)
  );
  RvvCoreShim rvvCore (
    .clock                                (clock),
    .reset                                (reset),
    .io_inst_0_ready                      (_rvvCore_io_inst_0_ready),
    .io_inst_0_valid                      (_score_io_rvvcore_inst_0_valid),
    .io_inst_0_bits_pc                    (_score_io_rvvcore_inst_0_bits_pc),
    .io_inst_0_bits_opcode                (_score_io_rvvcore_inst_0_bits_opcode),
    .io_inst_0_bits_bits                  (_score_io_rvvcore_inst_0_bits_bits),
    .io_inst_1_ready                      (_rvvCore_io_inst_1_ready),
    .io_inst_1_valid                      (_score_io_rvvcore_inst_1_valid),
    .io_inst_1_bits_pc                    (_score_io_rvvcore_inst_1_bits_pc),
    .io_inst_1_bits_opcode                (_score_io_rvvcore_inst_1_bits_opcode),
    .io_inst_1_bits_bits                  (_score_io_rvvcore_inst_1_bits_bits),
    .io_inst_2_ready                      (_rvvCore_io_inst_2_ready),
    .io_inst_2_valid                      (_score_io_rvvcore_inst_2_valid),
    .io_inst_2_bits_pc                    (_score_io_rvvcore_inst_2_bits_pc),
    .io_inst_2_bits_opcode                (_score_io_rvvcore_inst_2_bits_opcode),
    .io_inst_2_bits_bits                  (_score_io_rvvcore_inst_2_bits_bits),
    .io_inst_3_ready                      (_rvvCore_io_inst_3_ready),
    .io_inst_3_valid                      (_score_io_rvvcore_inst_3_valid),
    .io_inst_3_bits_pc                    (_score_io_rvvcore_inst_3_bits_pc),
    .io_inst_3_bits_opcode                (_score_io_rvvcore_inst_3_bits_opcode),
    .io_inst_3_bits_bits                  (_score_io_rvvcore_inst_3_bits_bits),
    .io_rs_0_valid                        (_score_io_rvvcore_rs_0_valid),
    .io_rs_0_data                         (_score_io_rvvcore_rs_0_data),
    .io_rs_1_valid                        (_score_io_rvvcore_rs_1_valid),
    .io_rs_1_data                         (_score_io_rvvcore_rs_1_data),
    .io_rs_2_valid                        (_score_io_rvvcore_rs_2_valid),
    .io_rs_2_data                         (_score_io_rvvcore_rs_2_data),
    .io_rs_3_valid                        (_score_io_rvvcore_rs_3_valid),
    .io_rs_3_data                         (_score_io_rvvcore_rs_3_data),
    .io_rs_4_valid                        (_score_io_rvvcore_rs_4_valid),
    .io_rs_4_data                         (_score_io_rvvcore_rs_4_data),
    .io_rs_5_valid                        (_score_io_rvvcore_rs_5_valid),
    .io_rs_5_data                         (_score_io_rvvcore_rs_5_data),
    .io_rs_6_valid                        (_score_io_rvvcore_rs_6_valid),
    .io_rs_6_data                         (_score_io_rvvcore_rs_6_data),
    .io_rs_7_valid                        (_score_io_rvvcore_rs_7_valid),
    .io_rs_7_data                         (_score_io_rvvcore_rs_7_data),
    .io_rd_0_valid                        (_rvvCore_io_rd_0_valid),
    .io_rd_0_bits_addr                    (_rvvCore_io_rd_0_bits_addr),
    .io_rd_0_bits_data                    (_rvvCore_io_rd_0_bits_data),
    .io_rd_1_valid                        (_rvvCore_io_rd_1_valid),
    .io_rd_1_bits_addr                    (_rvvCore_io_rd_1_bits_addr),
    .io_rd_1_bits_data                    (_rvvCore_io_rd_1_bits_data),
    .io_rd_2_valid                        (_rvvCore_io_rd_2_valid),
    .io_rd_2_bits_addr                    (_rvvCore_io_rd_2_bits_addr),
    .io_rd_2_bits_data                    (_rvvCore_io_rd_2_bits_data),
    .io_rd_3_valid                        (_rvvCore_io_rd_3_valid),
    .io_rd_3_bits_addr                    (_rvvCore_io_rd_3_bits_addr),
    .io_rd_3_bits_data                    (_rvvCore_io_rd_3_bits_data),
    .io_frs_0                             (_score_io_rvvcore_frs_0),
    .io_rvv2lsu_0_ready                   (_score_io_rvvcore_rvv2lsu_0_ready),
    .io_rvv2lsu_0_valid                   (_rvvCore_io_rvv2lsu_0_valid),
    .io_rvv2lsu_0_bits_idx_valid          (_rvvCore_io_rvv2lsu_0_bits_idx_valid),
    .io_rvv2lsu_0_bits_idx_bits_data      (_rvvCore_io_rvv2lsu_0_bits_idx_bits_data),
    .io_rvv2lsu_0_bits_vregfile_valid     (_rvvCore_io_rvv2lsu_0_bits_vregfile_valid),
    .io_rvv2lsu_0_bits_vregfile_bits_data (_rvvCore_io_rvv2lsu_0_bits_vregfile_bits_data),
    .io_rvv2lsu_0_bits_mask_valid         (_rvvCore_io_rvv2lsu_0_bits_mask_valid),
    .io_rvv2lsu_0_bits_mask_bits          (_rvvCore_io_rvv2lsu_0_bits_mask_bits),
    .io_lsu2rvv_0_ready                   (_rvvCore_io_lsu2rvv_0_ready),
    .io_lsu2rvv_0_valid                   (_score_io_rvvcore_lsu2rvv_0_valid),
    .io_lsu2rvv_0_bits_addr               (_score_io_rvvcore_lsu2rvv_0_bits_addr),
    .io_lsu2rvv_0_bits_data               (_score_io_rvvcore_lsu2rvv_0_bits_data),
    .io_lsu2rvv_0_bits_last               (_score_io_rvvcore_lsu2rvv_0_bits_last),
    .io_configState_valid                 (_rvvCore_io_configState_valid),
    .io_configState_bits_vl               (_rvvCore_io_configState_bits_vl),
    .io_configState_bits_vstart           (_rvvCore_io_configState_bits_vstart),
    .io_configState_bits_ma               (_rvvCore_io_configState_bits_ma),
    .io_configState_bits_ta               (_rvvCore_io_configState_bits_ta),
    .io_configState_bits_sew              (_rvvCore_io_configState_bits_sew),
    .io_configState_bits_lmul             (_rvvCore_io_configState_bits_lmul),
    .io_configState_bits_lmul_orig        (_rvvCore_io_configState_bits_lmul_orig),
    .io_configState_bits_vill             (_rvvCore_io_configState_bits_vill),
    .io_async_rd_ready                    (_score_io_rvvcore_async_rd_ready),
    .io_async_rd_valid                    (_rvvCore_io_async_rd_valid),
    .io_async_rd_bits_addr                (_rvvCore_io_async_rd_bits_addr),
    .io_async_rd_bits_data                (_rvvCore_io_async_rd_bits_data),
    .io_trap_valid                        (_rvvCore_io_trap_valid),
    .io_trap_bits_pc                      (_rvvCore_io_trap_bits_pc),
    .io_trap_bits_opcode                  (_rvvCore_io_trap_bits_opcode),
    .io_trap_bits_bits                    (_rvvCore_io_trap_bits_bits),
    .io_csr_vstart                        (_rvvCore_io_csr_vstart),
    .io_csr_vxrm                          (_rvvCore_io_csr_vxrm),
    .io_csr_vxsat                         (_rvvCore_io_csr_vxsat),
    .io_csr_frm                           (_score_io_rvvcore_csr_frm),
    .io_csr_vstart_write_valid            (_score_io_rvvcore_csr_vstart_write_valid),
    .io_csr_vstart_write_bits             (_score_io_rvvcore_csr_vstart_write_bits),
    .io_csr_vxrm_write_valid              (_score_io_rvvcore_csr_vxrm_write_valid),
    .io_csr_vxrm_write_bits               (_score_io_rvvcore_csr_vxrm_write_bits),
    .io_csr_vxsat_write_valid             (_score_io_rvvcore_csr_vxsat_write_valid),
    .io_csr_vxsat_write_bits              (_score_io_rvvcore_csr_vxsat_write_bits),
    .io_rvv_idle                          (_rvvCore_io_rvv_idle),
    .io_queue_capacity                    (_rvvCore_io_queue_capacity),
    .io_rd_rob2rt_o_0_w_valid             (_rvvCore_io_rd_rob2rt_o_0_w_valid),
    .io_rd_rob2rt_o_0_w_index             (_rvvCore_io_rd_rob2rt_o_0_w_index),
    .io_rd_rob2rt_o_0_uop_pc              (_rvvCore_io_rd_rob2rt_o_0_uop_pc),
    .io_rd_rob2rt_o_0_last_uop_valid      (_rvvCore_io_rd_rob2rt_o_0_last_uop_valid),
    .io_rd_rob2rt_o_1_w_valid             (_rvvCore_io_rd_rob2rt_o_1_w_valid),
    .io_rd_rob2rt_o_1_w_index             (_rvvCore_io_rd_rob2rt_o_1_w_index),
    .io_rd_rob2rt_o_1_uop_pc              (_rvvCore_io_rd_rob2rt_o_1_uop_pc),
    .io_rd_rob2rt_o_1_last_uop_valid      (_rvvCore_io_rd_rob2rt_o_1_last_uop_valid),
    .io_rd_rob2rt_o_2_w_valid             (_rvvCore_io_rd_rob2rt_o_2_w_valid),
    .io_rd_rob2rt_o_2_w_index             (_rvvCore_io_rd_rob2rt_o_2_w_index),
    .io_rd_rob2rt_o_2_uop_pc              (_rvvCore_io_rd_rob2rt_o_2_uop_pc),
    .io_rd_rob2rt_o_2_last_uop_valid      (_rvvCore_io_rd_rob2rt_o_2_last_uop_valid),
    .io_rd_rob2rt_o_3_w_valid             (_rvvCore_io_rd_rob2rt_o_3_w_valid),
    .io_rd_rob2rt_o_3_w_index             (_rvvCore_io_rd_rob2rt_o_3_w_index),
    .io_rd_rob2rt_o_3_uop_pc              (_rvvCore_io_rd_rob2rt_o_3_uop_pc),
    .io_rd_rob2rt_o_3_last_uop_valid      (_rvvCore_io_rd_rob2rt_o_3_last_uop_valid)
  );
endmodule

module SRAM_512x128(
  input          clock,
  input  [8:0]   io_addr,
  input          io_enable,
                 io_write,
  input  [127:0] io_wdata,
  input  [15:0]  io_wmask,
  output [127:0] io_rdata
);

  Sram_512x128 sramModules_0 (
    .clock  (clock),
    .enable (io_enable),
    .write  (io_write),
    .addr   (io_addr),
    .wdata  (io_wdata),
    .wmask  (io_wmask),
    .rdata  (io_rdata)
  );
endmodule

module TCM128(
  input        clock,
  input  [8:0] io_addr,
  input        io_enable,
               io_write,
  input  [7:0] io_wdata_0,
               io_wdata_1,
               io_wdata_2,
               io_wdata_3,
               io_wdata_4,
               io_wdata_5,
               io_wdata_6,
               io_wdata_7,
               io_wdata_8,
               io_wdata_9,
               io_wdata_10,
               io_wdata_11,
               io_wdata_12,
               io_wdata_13,
               io_wdata_14,
               io_wdata_15,
  input        io_wmask_0,
               io_wmask_1,
               io_wmask_2,
               io_wmask_3,
               io_wmask_4,
               io_wmask_5,
               io_wmask_6,
               io_wmask_7,
               io_wmask_8,
               io_wmask_9,
               io_wmask_10,
               io_wmask_11,
               io_wmask_12,
               io_wmask_13,
               io_wmask_14,
               io_wmask_15,
  output [7:0] io_rdata_0,
               io_rdata_1,
               io_rdata_2,
               io_rdata_3,
               io_rdata_4,
               io_rdata_5,
               io_rdata_6,
               io_rdata_7,
               io_rdata_8,
               io_rdata_9,
               io_rdata_10,
               io_rdata_11,
               io_rdata_12,
               io_rdata_13,
               io_rdata_14,
               io_rdata_15
);

  wire [127:0] _sram_io_rdata;
  SRAM_512x128 sram (
    .clock     (clock),
    .io_addr   (io_addr),
    .io_enable (io_enable),
    .io_write  (io_write),
    .io_wdata
      ({io_wdata_15,
        io_wdata_14,
        io_wdata_13,
        io_wdata_12,
        io_wdata_11,
        io_wdata_10,
        io_wdata_9,
        io_wdata_8,
        io_wdata_7,
        io_wdata_6,
        io_wdata_5,
        io_wdata_4,
        io_wdata_3,
        io_wdata_2,
        io_wdata_1,
        io_wdata_0}),
    .io_wmask
      ({io_wmask_15,
        io_wmask_14,
        io_wmask_13,
        io_wmask_12,
        io_wmask_11,
        io_wmask_10,
        io_wmask_9,
        io_wmask_8,
        io_wmask_7,
        io_wmask_6,
        io_wmask_5,
        io_wmask_4,
        io_wmask_3,
        io_wmask_2,
        io_wmask_1,
        io_wmask_0}),
    .io_rdata  (_sram_io_rdata)
  );
  assign io_rdata_0 = _sram_io_rdata[127:120];
  assign io_rdata_1 = _sram_io_rdata[119:112];
  assign io_rdata_2 = _sram_io_rdata[111:104];
  assign io_rdata_3 = _sram_io_rdata[103:96];
  assign io_rdata_4 = _sram_io_rdata[95:88];
  assign io_rdata_5 = _sram_io_rdata[87:80];
  assign io_rdata_6 = _sram_io_rdata[79:72];
  assign io_rdata_7 = _sram_io_rdata[71:64];
  assign io_rdata_8 = _sram_io_rdata[63:56];
  assign io_rdata_9 = _sram_io_rdata[55:48];
  assign io_rdata_10 = _sram_io_rdata[47:40];
  assign io_rdata_11 = _sram_io_rdata[39:32];
  assign io_rdata_12 = _sram_io_rdata[31:24];
  assign io_rdata_13 = _sram_io_rdata[23:16];
  assign io_rdata_14 = _sram_io_rdata[15:8];
  assign io_rdata_15 = _sram_io_rdata[7:0];
endmodule

module SRAM(
  input          clock,
                 reset,
                 io_fabric_readDataAddr_valid,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  input  [15:0]  io_fabric_writeDataStrb,
  output [8:0]   io_sram_address,
  output         io_sram_enable,
                 io_sram_isWrite,
  input  [7:0]   io_sram_readData_0,
                 io_sram_readData_1,
                 io_sram_readData_2,
                 io_sram_readData_3,
                 io_sram_readData_4,
                 io_sram_readData_5,
                 io_sram_readData_6,
                 io_sram_readData_7,
                 io_sram_readData_8,
                 io_sram_readData_9,
                 io_sram_readData_10,
                 io_sram_readData_11,
                 io_sram_readData_12,
                 io_sram_readData_13,
                 io_sram_readData_14,
                 io_sram_readData_15,
  output [7:0]   io_sram_writeData_0,
                 io_sram_writeData_1,
                 io_sram_writeData_2,
                 io_sram_writeData_3,
                 io_sram_writeData_4,
                 io_sram_writeData_5,
                 io_sram_writeData_6,
                 io_sram_writeData_7,
                 io_sram_writeData_8,
                 io_sram_writeData_9,
                 io_sram_writeData_10,
                 io_sram_writeData_11,
                 io_sram_writeData_12,
                 io_sram_writeData_13,
                 io_sram_writeData_14,
                 io_sram_writeData_15,
  output         io_sram_mask_0,
                 io_sram_mask_1,
                 io_sram_mask_2,
                 io_sram_mask_3,
                 io_sram_mask_4,
                 io_sram_mask_5,
                 io_sram_mask_6,
                 io_sram_mask_7,
                 io_sram_mask_8,
                 io_sram_mask_9,
                 io_sram_mask_10,
                 io_sram_mask_11,
                 io_sram_mask_12,
                 io_sram_mask_13,
                 io_sram_mask_14,
                 io_sram_mask_15
);

  reg readIssued;
  always @(posedge clock or posedge reset) begin
    if (reset)
      readIssued <= 1'h0;
    else
      readIssued <= io_fabric_readDataAddr_valid & ~io_fabric_writeDataAddr_valid;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        readIssued = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        readIssued = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readIssued;
  assign io_fabric_readData_bits =
    readIssued
      ? {io_sram_readData_0,
         io_sram_readData_1,
         io_sram_readData_2,
         io_sram_readData_3,
         io_sram_readData_4,
         io_sram_readData_5,
         io_sram_readData_6,
         io_sram_readData_7,
         io_sram_readData_8,
         io_sram_readData_9,
         io_sram_readData_10,
         io_sram_readData_11,
         io_sram_readData_12,
         io_sram_readData_13,
         io_sram_readData_14,
         io_sram_readData_15}
      : 128'h0;
  assign io_sram_address =
    (io_fabric_writeDataAddr_valid ? io_fabric_writeDataAddr_bits[12:4] : 9'h0)
    | (io_fabric_readDataAddr_valid ? io_fabric_readDataAddr_bits[12:4] : 9'h0);
  assign io_sram_enable = io_fabric_writeDataAddr_valid | io_fabric_readDataAddr_valid;
  assign io_sram_isWrite = io_fabric_writeDataAddr_valid;
  assign io_sram_writeData_0 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[7:0] : 8'h0;
  assign io_sram_writeData_1 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[15:8] : 8'h0;
  assign io_sram_writeData_2 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[23:16] : 8'h0;
  assign io_sram_writeData_3 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[31:24] : 8'h0;
  assign io_sram_writeData_4 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[39:32] : 8'h0;
  assign io_sram_writeData_5 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[47:40] : 8'h0;
  assign io_sram_writeData_6 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[55:48] : 8'h0;
  assign io_sram_writeData_7 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[63:56] : 8'h0;
  assign io_sram_writeData_8 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[71:64] : 8'h0;
  assign io_sram_writeData_9 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[79:72] : 8'h0;
  assign io_sram_writeData_10 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[87:80] : 8'h0;
  assign io_sram_writeData_11 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[95:88] : 8'h0;
  assign io_sram_writeData_12 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[103:96] : 8'h0;
  assign io_sram_writeData_13 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[111:104] : 8'h0;
  assign io_sram_writeData_14 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[119:112] : 8'h0;
  assign io_sram_writeData_15 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[127:120] : 8'h0;
  assign io_sram_mask_0 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[0];
  assign io_sram_mask_1 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[1];
  assign io_sram_mask_2 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[2];
  assign io_sram_mask_3 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[3];
  assign io_sram_mask_4 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[4];
  assign io_sram_mask_5 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[5];
  assign io_sram_mask_6 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[6];
  assign io_sram_mask_7 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[7];
  assign io_sram_mask_8 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[8];
  assign io_sram_mask_9 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[9];
  assign io_sram_mask_10 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[10];
  assign io_sram_mask_11 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[11];
  assign io_sram_mask_12 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[12];
  assign io_sram_mask_13 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[13];
  assign io_sram_mask_14 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[14];
  assign io_sram_mask_15 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[15];
endmodule

module FabricArbiter(
  input          clock,
                 reset,
                 io_source_0_readDataAddr_valid,
  input  [31:0]  io_source_0_readDataAddr_bits,
  output [127:0] io_source_0_readData_bits,
  input          io_source_0_writeDataAddr_valid,
  input  [31:0]  io_source_0_writeDataAddr_bits,
  input  [127:0] io_source_0_writeDataBits,
  input  [15:0]  io_source_0_writeDataStrb,
  input          io_source_1_readDataAddr_valid,
  input  [31:0]  io_source_1_readDataAddr_bits,
  output         io_source_1_readData_valid,
  output [127:0] io_source_1_readData_bits,
  input          io_source_1_writeDataAddr_valid,
  input  [31:0]  io_source_1_writeDataAddr_bits,
  input  [127:0] io_source_1_writeDataBits,
  input  [15:0]  io_source_1_writeDataStrb,
  output         io_fabricBusy_1,
                 io_port_readDataAddr_valid,
  output [31:0]  io_port_readDataAddr_bits,
  input          io_port_readData_valid,
  input  [127:0] io_port_readData_bits,
  output         io_port_writeDataAddr_valid,
  output [31:0]  io_port_writeDataAddr_bits,
  output [127:0] io_port_writeDataBits,
  output [15:0]  io_port_writeDataStrb
);

  wire sourceValid_0 = io_source_0_readDataAddr_valid | io_source_0_writeDataAddr_valid;
  wire sourceValid_1 = io_source_1_readDataAddr_valid | io_source_1_writeDataAddr_valid;
  assign io_source_0_readData_bits = io_port_readData_bits;
  assign io_source_1_readData_valid = io_port_readData_valid;
  assign io_source_1_readData_bits = io_port_readData_bits;
  assign io_fabricBusy_1 = sourceValid_0;
  assign io_port_readDataAddr_valid =
    sourceValid_0
      ? io_source_0_readDataAddr_valid
      : sourceValid_1 & io_source_1_readDataAddr_valid;
  assign io_port_readDataAddr_bits =
    sourceValid_0
      ? io_source_0_readDataAddr_bits
      : sourceValid_1 ? io_source_1_readDataAddr_bits : 32'h0;
  assign io_port_writeDataAddr_valid =
    sourceValid_0
      ? io_source_0_writeDataAddr_valid
      : sourceValid_1 & io_source_1_writeDataAddr_valid;
  assign io_port_writeDataAddr_bits =
    sourceValid_0
      ? io_source_0_writeDataAddr_bits
      : sourceValid_1 ? io_source_1_writeDataAddr_bits : 32'h0;
  assign io_port_writeDataBits =
    sourceValid_0
      ? io_source_0_writeDataBits
      : sourceValid_1 ? io_source_1_writeDataBits : 128'h0;
  assign io_port_writeDataStrb =
    sourceValid_0
      ? io_source_0_writeDataStrb
      : sourceValid_1 ? io_source_1_writeDataStrb : 16'h0;
endmodule

module SRAM_2048x128(
  input          clock,
  input  [10:0]  io_addr,
  input          io_enable,
                 io_write,
  input  [127:0] io_wdata,
  input  [15:0]  io_wmask,
  output [127:0] io_rdata
);

  Sram_2048x128 sramModules_0 (
    .clock  (clock),
    .enable (io_enable),
    .write  (io_write),
    .addr   (io_addr),
    .wdata  (io_wdata),
    .wmask  (io_wmask),
    .rdata  (io_rdata)
  );
endmodule

module TCM128_1(
  input         clock,
  input  [10:0] io_addr,
  input         io_enable,
                io_write,
  input  [7:0]  io_wdata_0,
                io_wdata_1,
                io_wdata_2,
                io_wdata_3,
                io_wdata_4,
                io_wdata_5,
                io_wdata_6,
                io_wdata_7,
                io_wdata_8,
                io_wdata_9,
                io_wdata_10,
                io_wdata_11,
                io_wdata_12,
                io_wdata_13,
                io_wdata_14,
                io_wdata_15,
  input         io_wmask_0,
                io_wmask_1,
                io_wmask_2,
                io_wmask_3,
                io_wmask_4,
                io_wmask_5,
                io_wmask_6,
                io_wmask_7,
                io_wmask_8,
                io_wmask_9,
                io_wmask_10,
                io_wmask_11,
                io_wmask_12,
                io_wmask_13,
                io_wmask_14,
                io_wmask_15,
  output [7:0]  io_rdata_0,
                io_rdata_1,
                io_rdata_2,
                io_rdata_3,
                io_rdata_4,
                io_rdata_5,
                io_rdata_6,
                io_rdata_7,
                io_rdata_8,
                io_rdata_9,
                io_rdata_10,
                io_rdata_11,
                io_rdata_12,
                io_rdata_13,
                io_rdata_14,
                io_rdata_15
);

  wire [127:0] _sram_io_rdata;
  SRAM_2048x128 sram (
    .clock     (clock),
    .io_addr   (io_addr),
    .io_enable (io_enable),
    .io_write  (io_write),
    .io_wdata
      ({io_wdata_15,
        io_wdata_14,
        io_wdata_13,
        io_wdata_12,
        io_wdata_11,
        io_wdata_10,
        io_wdata_9,
        io_wdata_8,
        io_wdata_7,
        io_wdata_6,
        io_wdata_5,
        io_wdata_4,
        io_wdata_3,
        io_wdata_2,
        io_wdata_1,
        io_wdata_0}),
    .io_wmask
      ({io_wmask_15,
        io_wmask_14,
        io_wmask_13,
        io_wmask_12,
        io_wmask_11,
        io_wmask_10,
        io_wmask_9,
        io_wmask_8,
        io_wmask_7,
        io_wmask_6,
        io_wmask_5,
        io_wmask_4,
        io_wmask_3,
        io_wmask_2,
        io_wmask_1,
        io_wmask_0}),
    .io_rdata  (_sram_io_rdata)
  );
  assign io_rdata_0 = _sram_io_rdata[127:120];
  assign io_rdata_1 = _sram_io_rdata[119:112];
  assign io_rdata_2 = _sram_io_rdata[111:104];
  assign io_rdata_3 = _sram_io_rdata[103:96];
  assign io_rdata_4 = _sram_io_rdata[95:88];
  assign io_rdata_5 = _sram_io_rdata[87:80];
  assign io_rdata_6 = _sram_io_rdata[79:72];
  assign io_rdata_7 = _sram_io_rdata[71:64];
  assign io_rdata_8 = _sram_io_rdata[63:56];
  assign io_rdata_9 = _sram_io_rdata[55:48];
  assign io_rdata_10 = _sram_io_rdata[47:40];
  assign io_rdata_11 = _sram_io_rdata[39:32];
  assign io_rdata_12 = _sram_io_rdata[31:24];
  assign io_rdata_13 = _sram_io_rdata[23:16];
  assign io_rdata_14 = _sram_io_rdata[15:8];
  assign io_rdata_15 = _sram_io_rdata[7:0];
endmodule

module SRAM_1(
  input          clock,
                 reset,
                 io_fabric_readDataAddr_valid,
  input  [31:0]  io_fabric_readDataAddr_bits,
  output         io_fabric_readData_valid,
  output [127:0] io_fabric_readData_bits,
  input          io_fabric_writeDataAddr_valid,
  input  [31:0]  io_fabric_writeDataAddr_bits,
  input  [127:0] io_fabric_writeDataBits,
  input  [15:0]  io_fabric_writeDataStrb,
  output [10:0]  io_sram_address,
  output         io_sram_enable,
                 io_sram_isWrite,
  input  [7:0]   io_sram_readData_0,
                 io_sram_readData_1,
                 io_sram_readData_2,
                 io_sram_readData_3,
                 io_sram_readData_4,
                 io_sram_readData_5,
                 io_sram_readData_6,
                 io_sram_readData_7,
                 io_sram_readData_8,
                 io_sram_readData_9,
                 io_sram_readData_10,
                 io_sram_readData_11,
                 io_sram_readData_12,
                 io_sram_readData_13,
                 io_sram_readData_14,
                 io_sram_readData_15,
  output [7:0]   io_sram_writeData_0,
                 io_sram_writeData_1,
                 io_sram_writeData_2,
                 io_sram_writeData_3,
                 io_sram_writeData_4,
                 io_sram_writeData_5,
                 io_sram_writeData_6,
                 io_sram_writeData_7,
                 io_sram_writeData_8,
                 io_sram_writeData_9,
                 io_sram_writeData_10,
                 io_sram_writeData_11,
                 io_sram_writeData_12,
                 io_sram_writeData_13,
                 io_sram_writeData_14,
                 io_sram_writeData_15,
  output         io_sram_mask_0,
                 io_sram_mask_1,
                 io_sram_mask_2,
                 io_sram_mask_3,
                 io_sram_mask_4,
                 io_sram_mask_5,
                 io_sram_mask_6,
                 io_sram_mask_7,
                 io_sram_mask_8,
                 io_sram_mask_9,
                 io_sram_mask_10,
                 io_sram_mask_11,
                 io_sram_mask_12,
                 io_sram_mask_13,
                 io_sram_mask_14,
                 io_sram_mask_15
);

  reg readIssued;
  always @(posedge clock or posedge reset) begin
    if (reset)
      readIssued <= 1'h0;
    else
      readIssued <= io_fabric_readDataAddr_valid & ~io_fabric_writeDataAddr_valid;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        readIssued = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        readIssued = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_fabric_readData_valid = readIssued;
  assign io_fabric_readData_bits =
    readIssued
      ? {io_sram_readData_0,
         io_sram_readData_1,
         io_sram_readData_2,
         io_sram_readData_3,
         io_sram_readData_4,
         io_sram_readData_5,
         io_sram_readData_6,
         io_sram_readData_7,
         io_sram_readData_8,
         io_sram_readData_9,
         io_sram_readData_10,
         io_sram_readData_11,
         io_sram_readData_12,
         io_sram_readData_13,
         io_sram_readData_14,
         io_sram_readData_15}
      : 128'h0;
  assign io_sram_address =
    (io_fabric_writeDataAddr_valid ? io_fabric_writeDataAddr_bits[14:4] : 11'h0)
    | (io_fabric_readDataAddr_valid ? io_fabric_readDataAddr_bits[14:4] : 11'h0);
  assign io_sram_enable = io_fabric_writeDataAddr_valid | io_fabric_readDataAddr_valid;
  assign io_sram_isWrite = io_fabric_writeDataAddr_valid;
  assign io_sram_writeData_0 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[7:0] : 8'h0;
  assign io_sram_writeData_1 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[15:8] : 8'h0;
  assign io_sram_writeData_2 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[23:16] : 8'h0;
  assign io_sram_writeData_3 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[31:24] : 8'h0;
  assign io_sram_writeData_4 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[39:32] : 8'h0;
  assign io_sram_writeData_5 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[47:40] : 8'h0;
  assign io_sram_writeData_6 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[55:48] : 8'h0;
  assign io_sram_writeData_7 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[63:56] : 8'h0;
  assign io_sram_writeData_8 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[71:64] : 8'h0;
  assign io_sram_writeData_9 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[79:72] : 8'h0;
  assign io_sram_writeData_10 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[87:80] : 8'h0;
  assign io_sram_writeData_11 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[95:88] : 8'h0;
  assign io_sram_writeData_12 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[103:96] : 8'h0;
  assign io_sram_writeData_13 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[111:104] : 8'h0;
  assign io_sram_writeData_14 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[119:112] : 8'h0;
  assign io_sram_writeData_15 =
    io_fabric_writeDataAddr_valid ? io_fabric_writeDataBits[127:120] : 8'h0;
  assign io_sram_mask_0 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[0];
  assign io_sram_mask_1 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[1];
  assign io_sram_mask_2 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[2];
  assign io_sram_mask_3 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[3];
  assign io_sram_mask_4 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[4];
  assign io_sram_mask_5 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[5];
  assign io_sram_mask_6 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[6];
  assign io_sram_mask_7 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[7];
  assign io_sram_mask_8 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[8];
  assign io_sram_mask_9 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[9];
  assign io_sram_mask_10 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[10];
  assign io_sram_mask_11 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[11];
  assign io_sram_mask_12 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[12];
  assign io_sram_mask_13 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[13];
  assign io_sram_mask_14 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[14];
  assign io_sram_mask_15 = ~io_fabric_writeDataAddr_valid | io_fabric_writeDataStrb[15];
endmodule

module FabricMux(
  input          clock,
                 reset,
                 io_source_readDataAddr_valid,
  input  [31:0]  io_source_readDataAddr_bits,
  output         io_source_readData_valid,
  output [127:0] io_source_readData_bits,
  input          io_source_writeDataAddr_valid,
  input  [31:0]  io_source_writeDataAddr_bits,
  input  [127:0] io_source_writeDataBits,
  input  [15:0]  io_source_writeDataStrb,
  output         io_source_writeResp,
                 io_fabricBusy,
                 io_ports_0_readDataAddr_valid,
  output [31:0]  io_ports_0_readDataAddr_bits,
  input          io_ports_0_readData_valid,
  input  [127:0] io_ports_0_readData_bits,
  output         io_ports_0_writeDataAddr_valid,
  output [31:0]  io_ports_0_writeDataAddr_bits,
  output [127:0] io_ports_0_writeDataBits,
  output [15:0]  io_ports_0_writeDataStrb,
  output         io_ports_1_readDataAddr_valid,
  output [31:0]  io_ports_1_readDataAddr_bits,
  input          io_ports_1_readData_valid,
  input  [127:0] io_ports_1_readData_bits,
  output         io_ports_1_writeDataAddr_valid,
  output [31:0]  io_ports_1_writeDataAddr_bits,
  output [127:0] io_ports_1_writeDataBits,
  output [15:0]  io_ports_1_writeDataStrb,
  output [31:0]  io_ports_2_readDataAddr_bits,
  input          io_ports_2_readData_valid,
  input  [127:0] io_ports_2_readData_bits,
  output         io_ports_2_writeDataAddr_valid,
  output [31:0]  io_ports_2_writeDataAddr_bits,
  output [127:0] io_ports_2_writeDataBits,
  input          io_ports_2_writeResp,
                 io_periBusy_0,
                 io_periBusy_1
);

  wire        sourceValid = io_source_readDataAddr_valid | io_source_writeDataAddr_valid;
  wire [31:0] addr =
    (io_source_readDataAddr_valid ? io_source_readDataAddr_bits : 32'h0)
    | (io_source_writeDataAddr_valid ? io_source_writeDataAddr_bits : 32'h0);
  wire        _selected_T_5 = sourceValid & addr < 32'h2000;
  wire        _selected_T_11 = sourceValid & (|(addr[31:16])) & addr < 32'h18000;
  wire        _selected_T_18_valid = sourceValid & addr > 32'h2FFFF & addr < 32'h31000;
  wire        selected_valid = _selected_T_5 | _selected_T_11 | _selected_T_18_valid;
  wire [1:0]  selected_bits =
    _selected_T_5 ? 2'h0 : _selected_T_11 ? 2'h1 : {_selected_T_18_valid, 1'h0};
  wire        _io_fabricBusy_T = selected_bits == 2'h0;
  wire        portSelected_0 = selected_valid & _io_fabricBusy_T & ~io_periBusy_0;
  wire        _io_fabricBusy_T_2 = selected_bits == 2'h1;
  wire        portSelected_1 = selected_valid & _io_fabricBusy_T_2 & ~io_periBusy_1;
  wire        _io_fabricBusy_T_4 = selected_bits == 2'h2;
  wire        _portSelected_T_7 = selected_valid & _io_fabricBusy_T_4;
  wire        _io_fabricBusy_T_1 = selected_valid & _io_fabricBusy_T;
  wire        _io_fabricBusy_T_3 = selected_valid & _io_fabricBusy_T_2;
  wire        io_ports_0_readDataAddr_valid_0 =
    portSelected_0 & io_source_readDataAddr_valid;
  wire        io_ports_1_readDataAddr_valid_0 =
    portSelected_1 & io_source_readDataAddr_valid;
  wire        _lastReadSelected_T_19 = _portSelected_T_7 & io_source_readDataAddr_valid;
  reg         lastReadSelected_valid;
  reg  [1:0]  lastReadSelected_bits;
  wire        _io_source_readData_T_1 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h0;
  wire        _io_source_readData_T_3 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h1;
  wire        _io_source_readData_T_5 =
    lastReadSelected_valid & lastReadSelected_bits == 2'h2;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      lastReadSelected_valid <= 1'h0;
      lastReadSelected_bits <= 2'h0;
    end
    else begin
      lastReadSelected_valid <=
        io_ports_0_readDataAddr_valid_0 | io_ports_1_readDataAddr_valid_0
        | _lastReadSelected_T_19;
      lastReadSelected_bits <=
        {1'h0, io_ports_1_readDataAddr_valid_0} | {_lastReadSelected_T_19, 1'h0};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        lastReadSelected_valid = _RANDOM[/*Zero width*/ 1'b0][0];
        lastReadSelected_bits = _RANDOM[/*Zero width*/ 1'b0][2:1];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        lastReadSelected_valid = 1'h0;
        lastReadSelected_bits = 2'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_source_readData_valid =
    _io_source_readData_T_1 & io_ports_0_readData_valid | _io_source_readData_T_3
    & io_ports_1_readData_valid | _io_source_readData_T_5 & io_ports_2_readData_valid;
  assign io_source_readData_bits =
    (_io_source_readData_T_1 ? io_ports_0_readData_bits : 128'h0)
    | (_io_source_readData_T_3 ? io_ports_1_readData_bits : 128'h0)
    | (_io_source_readData_T_5 ? io_ports_2_readData_bits : 128'h0);
  assign io_source_writeResp =
    portSelected_0 | portSelected_1 | _portSelected_T_7 & io_ports_2_writeResp;
  assign io_fabricBusy =
    _io_fabricBusy_T_1 & io_periBusy_0 | _io_fabricBusy_T_3 & io_periBusy_1;
  assign io_ports_0_readDataAddr_valid = io_ports_0_readDataAddr_valid_0;
  assign io_ports_0_readDataAddr_bits =
    portSelected_0 ? io_source_readDataAddr_bits : 32'h0;
  assign io_ports_0_writeDataAddr_valid = portSelected_0 & io_source_writeDataAddr_valid;
  assign io_ports_0_writeDataAddr_bits =
    portSelected_0 ? io_source_writeDataAddr_bits : 32'h0;
  assign io_ports_0_writeDataBits = portSelected_0 ? io_source_writeDataBits : 128'h0;
  assign io_ports_0_writeDataStrb = portSelected_0 ? io_source_writeDataStrb : 16'h0;
  assign io_ports_1_readDataAddr_valid = io_ports_1_readDataAddr_valid_0;
  assign io_ports_1_readDataAddr_bits =
    portSelected_1 ? io_source_readDataAddr_bits & 32'hFFFEFFFF : 32'h0;
  assign io_ports_1_writeDataAddr_valid = portSelected_1 & io_source_writeDataAddr_valid;
  assign io_ports_1_writeDataAddr_bits =
    portSelected_1 ? io_source_writeDataAddr_bits & 32'hFFFEFFFF : 32'h0;
  assign io_ports_1_writeDataBits = portSelected_1 ? io_source_writeDataBits : 128'h0;
  assign io_ports_1_writeDataStrb = portSelected_1 ? io_source_writeDataStrb : 16'h0;
  assign io_ports_2_readDataAddr_bits =
    _portSelected_T_7 ? io_source_readDataAddr_bits & 32'hFFFCFFFF : 32'h0;
  assign io_ports_2_writeDataAddr_valid =
    _portSelected_T_7 & io_source_writeDataAddr_valid;
  assign io_ports_2_writeDataAddr_bits =
    _portSelected_T_7 ? io_source_writeDataAddr_bits & 32'hFFFCFFFF : 32'h0;
  assign io_ports_2_writeDataBits = _portSelected_T_7 ? io_source_writeDataBits : 128'h0;
endmodule

module CoralNPURRArbiter(
  input         clock,
                reset,
  output        io_in_0_ready,
  input         io_in_0_valid,
  input  [31:0] io_in_0_bits_addr,
  input  [2:0]  io_in_0_bits_prot,
  input  [5:0]  io_in_0_bits_id,
  input  [7:0]  io_in_0_bits_len,
  input  [2:0]  io_in_0_bits_size,
  input  [1:0]  io_in_0_bits_burst,
  input         io_in_0_bits_lock,
  input  [3:0]  io_in_0_bits_cache,
                io_in_0_bits_qos,
                io_in_0_bits_region,
  output        io_in_1_ready,
  input         io_in_1_valid,
  input  [31:0] io_in_1_bits_addr,
  input  [2:0]  io_in_1_bits_prot,
  input  [5:0]  io_in_1_bits_id,
  input  [7:0]  io_in_1_bits_len,
  input  [2:0]  io_in_1_bits_size,
  input  [1:0]  io_in_1_bits_burst,
  input         io_in_1_bits_lock,
  input  [3:0]  io_in_1_bits_cache,
                io_in_1_bits_qos,
                io_in_1_bits_region,
  input         io_out_ready,
  output        io_out_valid,
  output [31:0] io_out_bits_addr,
  output [2:0]  io_out_bits_prot,
  output [5:0]  io_out_bits_id,
  output [7:0]  io_out_bits_len,
  output [2:0]  io_out_bits_size,
  output [1:0]  io_out_bits_burst,
  output        io_out_bits_lock,
  output [3:0]  io_out_bits_cache,
                io_out_bits_qos,
                io_out_bits_region,
  output        io_chosen
);

  wire io_chosen_choice;
  wire io_out_valid_0 = io_chosen_choice ? io_in_1_valid : io_in_0_valid;
  reg  ctrl_validMask_grantMask_lastGrant;
  wire ctrl_validMask_1 = io_in_1_valid & ~ctrl_validMask_grantMask_lastGrant;
  assign io_chosen_choice = ctrl_validMask_1 | ~io_in_0_valid;
  always @(posedge clock or posedge reset) begin
    if (reset)
      ctrl_validMask_grantMask_lastGrant <= 1'h0;
    else if (io_out_ready & io_out_valid_0)
      ctrl_validMask_grantMask_lastGrant <= io_chosen_choice;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        ctrl_validMask_grantMask_lastGrant = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        ctrl_validMask_grantMask_lastGrant = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_in_0_ready = ~ctrl_validMask_1 & io_out_ready;
  assign io_in_1_ready =
    (~ctrl_validMask_grantMask_lastGrant | ~(ctrl_validMask_1 | io_in_0_valid))
    & io_out_ready;
  assign io_out_valid = io_out_valid_0;
  assign io_out_bits_addr = io_chosen_choice ? io_in_1_bits_addr : io_in_0_bits_addr;
  assign io_out_bits_prot = io_chosen_choice ? io_in_1_bits_prot : io_in_0_bits_prot;
  assign io_out_bits_id = io_chosen_choice ? io_in_1_bits_id : io_in_0_bits_id;
  assign io_out_bits_len = io_chosen_choice ? io_in_1_bits_len : io_in_0_bits_len;
  assign io_out_bits_size = io_chosen_choice ? io_in_1_bits_size : io_in_0_bits_size;
  assign io_out_bits_burst = io_chosen_choice ? io_in_1_bits_burst : io_in_0_bits_burst;
  assign io_out_bits_lock = io_chosen_choice ? io_in_1_bits_lock : io_in_0_bits_lock;
  assign io_out_bits_cache = io_chosen_choice ? io_in_1_bits_cache : io_in_0_bits_cache;
  assign io_out_bits_qos = io_chosen_choice ? io_in_1_bits_qos : io_in_0_bits_qos;
  assign io_out_bits_region =
    io_chosen_choice ? io_in_1_bits_region : io_in_0_bits_region;
  assign io_chosen = io_chosen_choice;
endmodule

// VCS coverage exclude_module
module ram_2x67(
  input         R0_addr,
                R0_en,
                R0_clk,
  output [66:0] R0_data,
  input         W0_addr,
                W0_en,
                W0_clk,
  input  [66:0] W0_data
);

  reg [66:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [95:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [6:0] j = 7'h0; j < 7'h60; j += 7'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[66:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 67'bx;
endmodule

module Queue2_AxiAddress(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr,
  input  [2:0]  io_enq_bits_prot,
  input  [5:0]  io_enq_bits_id,
  input  [7:0]  io_enq_bits_len,
  input  [2:0]  io_enq_bits_size,
  input  [1:0]  io_enq_bits_burst,
  input         io_enq_bits_lock,
  input  [3:0]  io_enq_bits_cache,
                io_enq_bits_qos,
                io_enq_bits_region,
  input         io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_addr,
  output [2:0]  io_deq_bits_prot,
  output [5:0]  io_deq_bits_id,
  output [7:0]  io_deq_bits_len,
  output [2:0]  io_deq_bits_size,
  output [1:0]  io_deq_bits_burst,
  output        io_deq_bits_lock,
  output [3:0]  io_deq_bits_cache,
                io_deq_bits_qos,
                io_deq_bits_region
);

  wire [66:0] _ram_ext_R0_data;
  reg         wrap;
  reg         wrap_1;
  reg         maybe_full;
  wire        ptr_match = wrap == wrap_1;
  wire        empty = ptr_match & ~maybe_full;
  wire        full = ptr_match & maybe_full;
  wire        do_enq = ~full & io_enq_valid;
  wire        do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x67 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data
      ({io_enq_bits_addr,
        io_enq_bits_prot,
        io_enq_bits_id,
        io_enq_bits_len,
        io_enq_bits_size,
        io_enq_bits_burst,
        io_enq_bits_lock,
        io_enq_bits_cache,
        io_enq_bits_qos,
        io_enq_bits_region})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_addr = _ram_ext_R0_data[66:35];
  assign io_deq_bits_prot = _ram_ext_R0_data[34:32];
  assign io_deq_bits_id = _ram_ext_R0_data[31:26];
  assign io_deq_bits_len = _ram_ext_R0_data[25:18];
  assign io_deq_bits_size = _ram_ext_R0_data[17:15];
  assign io_deq_bits_burst = _ram_ext_R0_data[14:13];
  assign io_deq_bits_lock = _ram_ext_R0_data[12];
  assign io_deq_bits_cache = _ram_ext_R0_data[11:8];
  assign io_deq_bits_qos = _ram_ext_R0_data[7:4];
  assign io_deq_bits_region = _ram_ext_R0_data[3:0];
endmodule

module Queue1_RWAxiAddress(
  input         clock,
                reset,
  output        io_enq_ready,
  input         io_enq_valid,
  input  [31:0] io_enq_bits_addr_addr,
  input  [2:0]  io_enq_bits_addr_prot,
  input  [5:0]  io_enq_bits_addr_id,
  input  [7:0]  io_enq_bits_addr_len,
  input  [2:0]  io_enq_bits_addr_size,
  input  [1:0]  io_enq_bits_addr_burst,
  input         io_enq_bits_addr_lock,
  input  [3:0]  io_enq_bits_addr_cache,
                io_enq_bits_addr_qos,
                io_enq_bits_addr_region,
  input         io_enq_bits_write,
                io_deq_ready,
  output        io_deq_valid,
  output [31:0] io_deq_bits_addr_addr,
  output [5:0]  io_deq_bits_addr_id,
  output [7:0]  io_deq_bits_addr_len,
  output [2:0]  io_deq_bits_addr_size,
  output [1:0]  io_deq_bits_addr_burst,
  output        io_deq_bits_write
);

  reg  [67:0] ram;
  wire        io_enq_ready_0;
  reg         full;
  wire        do_enq = io_enq_ready_0 & io_enq_valid;
  assign io_enq_ready_0 = io_deq_ready | ~full;
  always @(posedge clock or posedge reset) begin
    if (reset)
      full <= 1'h0;
    else if (~(do_enq == (io_deq_ready & full)))
      full <= do_enq;
  end // always @(posedge, posedge)
  always @(posedge clock) begin
    if (do_enq)
      ram <=
        {io_enq_bits_addr_addr,
         io_enq_bits_addr_prot,
         io_enq_bits_addr_id,
         io_enq_bits_addr_len,
         io_enq_bits_addr_size,
         io_enq_bits_addr_burst,
         io_enq_bits_addr_lock,
         io_enq_bits_addr_cache,
         io_enq_bits_addr_qos,
         io_enq_bits_addr_region,
         io_enq_bits_write};
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:2];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        full = _RANDOM[2'h0][0];
        ram = {_RANDOM[2'h0][31:1], _RANDOM[2'h1], _RANDOM[2'h2][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset)
        full = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_enq_ready = io_enq_ready_0;
  assign io_deq_valid = full;
  assign io_deq_bits_addr_addr = ram[67:36];
  assign io_deq_bits_addr_id = ram[32:27];
  assign io_deq_bits_addr_len = ram[26:19];
  assign io_deq_bits_addr_size = ram[18:16];
  assign io_deq_bits_addr_burst = ram[15:14];
  assign io_deq_bits_write = ram[0];
endmodule

// VCS coverage exclude_module
module ram_3x145(
  input  [1:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [144:0] R0_data,
  input  [1:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [144:0] W0_data
);

  reg [144:0] Memory[0:2];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i] = _RANDOM_MEM[144:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 145'bx;
endmodule

module Queue3_AxiWriteData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input          io_enq_bits_last,
  input  [15:0]  io_enq_bits_strb,
  input          io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output         io_deq_bits_last,
  output [15:0]  io_deq_bits_strb
);

  wire [144:0] _ram_ext_R0_data;
  reg  [1:0]   enq_ptr_value;
  reg  [1:0]   deq_ptr_value;
  reg          maybe_full;
  wire         ptr_match = enq_ptr_value == deq_ptr_value;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      enq_ptr_value <= 2'h0;
      deq_ptr_value <= 2'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        enq_ptr_value <= enq_ptr_value == 2'h2 ? 2'h0 : enq_ptr_value + 2'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value == 2'h2 ? 2'h0 : deq_ptr_value + 2'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        enq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][1:0];
        deq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][3:2];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][4];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        enq_ptr_value = 2'h0;
        deq_ptr_value = 2'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_3x145 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, io_enq_bits_last, io_enq_bits_strb})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[144:17];
  assign io_deq_bits_last = _ram_ext_R0_data[16];
  assign io_deq_bits_strb = _ram_ext_R0_data[15:0];
endmodule

// VCS coverage exclude_module
module ram_2x8(
  input        R0_addr,
               R0_en,
               R0_clk,
  output [7:0] R0_data,
  input        W0_addr,
               W0_en,
               W0_clk,
  input  [7:0] W0_data
);

  reg [7:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [31:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM_MEM = `RANDOM;
          Memory[i[0]] = _RANDOM_MEM[7:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 8'bx;
endmodule

module Queue2_AxiWriteResponse(
  input        clock,
               reset,
  output       io_enq_ready,
  input        io_enq_valid,
  input  [5:0] io_enq_bits_id,
  input  [1:0] io_enq_bits_resp,
  input        io_deq_ready,
  output       io_deq_valid,
  output [5:0] io_deq_bits_id,
  output [1:0] io_deq_bits_resp
);

  wire [7:0] _ram_ext_R0_data;
  reg        wrap;
  reg        wrap_1;
  reg        maybe_full;
  wire       ptr_match = wrap == wrap_1;
  wire       empty = ptr_match & ~maybe_full;
  wire       full = ptr_match & maybe_full;
  wire       do_enq = ~full & io_enq_valid;
  wire       do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x8 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_id, io_enq_bits_resp})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_id = _ram_ext_R0_data[7:2];
  assign io_deq_bits_resp = _ram_ext_R0_data[1:0];
endmodule

// VCS coverage exclude_module
module ram_3x137(
  input  [1:0]   R0_addr,
  input          R0_en,
                 R0_clk,
  output [136:0] R0_data,
  input  [1:0]   W0_addr,
  input          W0_en,
                 W0_clk,
  input  [136:0] W0_data
);

  reg [136:0] Memory[0:2];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h3; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i] = _RANDOM_MEM[136:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 137'bx;
endmodule

module Queue3_AxiReadData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input  [5:0]   io_enq_bits_id,
  input  [1:0]   io_enq_bits_resp,
  input          io_enq_bits_last,
                 io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output [5:0]   io_deq_bits_id,
  output [1:0]   io_deq_bits_resp,
  output         io_deq_bits_last,
  output [1:0]   io_count
);

  wire [136:0] _ram_ext_R0_data;
  reg  [1:0]   enq_ptr_value;
  reg  [1:0]   deq_ptr_value;
  reg          maybe_full;
  wire         ptr_match = enq_ptr_value == deq_ptr_value;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire [1:0]   _ptr_diff_T = enq_ptr_value - deq_ptr_value;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      enq_ptr_value <= 2'h0;
      deq_ptr_value <= 2'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        enq_ptr_value <= enq_ptr_value == 2'h2 ? 2'h0 : enq_ptr_value + 2'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value == 2'h2 ? 2'h0 : deq_ptr_value + 2'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        enq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][1:0];
        deq_ptr_value = _RANDOM[/*Zero width*/ 1'b0][3:2];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][4];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        enq_ptr_value = 2'h0;
        deq_ptr_value = 2'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_3x137 ram_ext (
    .R0_addr (deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, io_enq_bits_id, io_enq_bits_resp, io_enq_bits_last})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[136:9];
  assign io_deq_bits_id = _ram_ext_R0_data[8:3];
  assign io_deq_bits_resp = _ram_ext_R0_data[2:1];
  assign io_deq_bits_last = _ram_ext_R0_data[0];
  assign io_count =
    ptr_match
      ? {2{maybe_full}}
      : deq_ptr_value > enq_ptr_value ? _ptr_diff_T - 2'h1 : _ptr_diff_T;
endmodule

module AxiSlave(
  input          clock,
                 reset,
  output         io_axi_write_addr_ready,
  input          io_axi_write_addr_valid,
  input  [31:0]  io_axi_write_addr_bits_addr,
  input  [2:0]   io_axi_write_addr_bits_prot,
  input  [5:0]   io_axi_write_addr_bits_id,
  input  [7:0]   io_axi_write_addr_bits_len,
  input  [2:0]   io_axi_write_addr_bits_size,
  input  [1:0]   io_axi_write_addr_bits_burst,
  input          io_axi_write_addr_bits_lock,
  input  [3:0]   io_axi_write_addr_bits_cache,
                 io_axi_write_addr_bits_qos,
                 io_axi_write_addr_bits_region,
  output         io_axi_write_data_ready,
  input          io_axi_write_data_valid,
  input  [127:0] io_axi_write_data_bits_data,
  input          io_axi_write_data_bits_last,
  input  [15:0]  io_axi_write_data_bits_strb,
  input          io_axi_write_resp_ready,
  output         io_axi_write_resp_valid,
  output [5:0]   io_axi_write_resp_bits_id,
  output [1:0]   io_axi_write_resp_bits_resp,
  output         io_axi_read_addr_ready,
  input          io_axi_read_addr_valid,
  input  [31:0]  io_axi_read_addr_bits_addr,
  input  [2:0]   io_axi_read_addr_bits_prot,
  input  [5:0]   io_axi_read_addr_bits_id,
  input  [7:0]   io_axi_read_addr_bits_len,
  input  [2:0]   io_axi_read_addr_bits_size,
  input  [1:0]   io_axi_read_addr_bits_burst,
  input          io_axi_read_addr_bits_lock,
  input  [3:0]   io_axi_read_addr_bits_cache,
                 io_axi_read_addr_bits_qos,
                 io_axi_read_addr_bits_region,
  input          io_axi_read_data_ready,
  output         io_axi_read_data_valid,
  output [127:0] io_axi_read_data_bits_data,
  output [5:0]   io_axi_read_data_bits_id,
  output [1:0]   io_axi_read_data_bits_resp,
  output         io_axi_read_data_bits_last,
                 io_fabric_readDataAddr_valid,
  output [31:0]  io_fabric_readDataAddr_bits,
  input          io_fabric_readData_valid,
  input  [127:0] io_fabric_readData_bits,
  output         io_fabric_writeDataAddr_valid,
  output [31:0]  io_fabric_writeDataAddr_bits,
  output [127:0] io_fabric_writeDataBits,
  output [15:0]  io_fabric_writeDataStrb,
  input          io_fabric_writeResp,
                 io_periBusy
);

  wire        _readDataQueue_io_enq_ready;
  wire [1:0]  _readDataQueue_io_count;
  wire        _io_axi_write_resp_q_io_enq_ready;
  wire        _writeData_q_io_deq_valid;
  wire        _writeData_q_io_deq_bits_last;
  wire        _axiAddrCmd_q_io_enq_ready;
  wire        _axiAddrCmd_q_io_deq_valid;
  wire [31:0] _axiAddrCmd_q_io_deq_bits_addr_addr;
  wire [5:0]  _axiAddrCmd_q_io_deq_bits_addr_id;
  wire [7:0]  _axiAddrCmd_q_io_deq_bits_addr_len;
  wire [2:0]  _axiAddrCmd_q_io_deq_bits_addr_size;
  wire [1:0]  _axiAddrCmd_q_io_deq_bits_addr_burst;
  wire        _axiAddrCmd_q_io_deq_bits_write;
  wire        _addrArbiter_io_in_1_q_io_deq_valid;
  wire [31:0] _addrArbiter_io_in_1_q_io_deq_bits_addr;
  wire [2:0]  _addrArbiter_io_in_1_q_io_deq_bits_prot;
  wire [5:0]  _addrArbiter_io_in_1_q_io_deq_bits_id;
  wire [7:0]  _addrArbiter_io_in_1_q_io_deq_bits_len;
  wire [2:0]  _addrArbiter_io_in_1_q_io_deq_bits_size;
  wire [1:0]  _addrArbiter_io_in_1_q_io_deq_bits_burst;
  wire        _addrArbiter_io_in_1_q_io_deq_bits_lock;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_cache;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_qos;
  wire [3:0]  _addrArbiter_io_in_1_q_io_deq_bits_region;
  wire        _addrArbiter_io_in_0_q_io_deq_valid;
  wire [31:0] _addrArbiter_io_in_0_q_io_deq_bits_addr;
  wire [2:0]  _addrArbiter_io_in_0_q_io_deq_bits_prot;
  wire [5:0]  _addrArbiter_io_in_0_q_io_deq_bits_id;
  wire [7:0]  _addrArbiter_io_in_0_q_io_deq_bits_len;
  wire [2:0]  _addrArbiter_io_in_0_q_io_deq_bits_size;
  wire [1:0]  _addrArbiter_io_in_0_q_io_deq_bits_burst;
  wire        _addrArbiter_io_in_0_q_io_deq_bits_lock;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_cache;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_qos;
  wire [3:0]  _addrArbiter_io_in_0_q_io_deq_bits_region;
  wire        _addrArbiter_io_in_0_ready;
  wire        _addrArbiter_io_in_1_ready;
  wire        _addrArbiter_io_out_valid;
  wire [31:0] _addrArbiter_io_out_bits_addr;
  wire [2:0]  _addrArbiter_io_out_bits_prot;
  wire [5:0]  _addrArbiter_io_out_bits_id;
  wire [7:0]  _addrArbiter_io_out_bits_len;
  wire [2:0]  _addrArbiter_io_out_bits_size;
  wire [1:0]  _addrArbiter_io_out_bits_burst;
  wire        _addrArbiter_io_out_bits_lock;
  wire [3:0]  _addrArbiter_io_out_bits_cache;
  wire [3:0]  _addrArbiter_io_out_bits_qos;
  wire [3:0]  _addrArbiter_io_out_bits_region;
  wire        _addrArbiter_io_chosen;
  wire        writeActive = _axiAddrCmd_q_io_deq_valid & _axiAddrCmd_q_io_deq_bits_write;
  wire        readActive = _axiAddrCmd_q_io_deq_valid & ~_axiAddrCmd_q_io_deq_bits_write;
  reg  [31:0] cmdAddr;
  wire        maybeWriteData =
    writeActive & _writeData_q_io_deq_valid & _io_axi_write_resp_q_io_enq_ready;
  wire        writeData_q_io_deq_ready = maybeWriteData & ~io_periBusy;
  wire        writeResponse_valid =
    writeData_q_io_deq_ready & _writeData_q_io_deq_bits_last;
  reg         readIssued_valid;
  reg  [5:0]  readIssued_bits_id;
  reg         readIssued_bits_last;
  reg  [8:0]  readsIssued;
  wire [1:0]  _maybeIssueRead_T = 2'h3 - _readDataQueue_io_count;
  wire        maybeIssueRead = readActive & _maybeIssueRead_T[1];
  wire        issueRead = maybeIssueRead & ~io_periBusy;
  wire        lastRead = readsIssued == {1'h0, _axiAddrCmd_q_io_deq_bits_addr_len};
  wire        _addrNext_T = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h0;
  wire        _addrNext_T_2 = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h1;
  wire        _addrNext_T_7 = _axiAddrCmd_q_io_deq_bits_addr_burst == 2'h2;
  wire        validBurst =
    _axiAddrCmd_q_io_deq_valid & (_addrNext_T | _addrNext_T_2 | _addrNext_T_7);
  wire        _addrNext_T_1 = validBurst & _addrNext_T;
  wire        _addrNext_T_3 = validBurst & _addrNext_T_2;
  wire        _addrNext_T_8 = validBurst & _addrNext_T_7;
  wire        axiAddrCmd_q_io_deq_ready =
    writeActive ? writeResponse_valid : readActive & issueRead & lastRead;
  wire [31:0] cmdAddrBase =
    _axiAddrCmd_q_io_deq_bits_addr_addr
    & {25'h1FFFFFF,
       _axiAddrCmd_q_io_deq_bits_addr_size != 3'h7,
       _axiAddrCmd_q_io_deq_bits_addr_size[2:1] != 2'h3,
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h5,
       ~(_axiAddrCmd_q_io_deq_bits_addr_size[2]),
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h3,
       _axiAddrCmd_q_io_deq_bits_addr_size < 3'h2,
       _axiAddrCmd_q_io_deq_bits_addr_size == 3'h0};
  wire [31:0] _GEN = {24'h0, 8'h1 << _axiAddrCmd_q_io_deq_bits_addr_size};
  wire [31:0] _addrNext_newAddr_T_1 = cmdAddr + _GEN;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      cmdAddr <= 32'h0;
      readIssued_valid <= 1'h0;
      readIssued_bits_id <= 6'h0;
      readIssued_bits_last <= 1'h0;
      readsIssued <= 9'h0;
    end
    else begin
      if (_axiAddrCmd_q_io_enq_ready & _addrArbiter_io_out_valid)
        cmdAddr <= _addrArbiter_io_out_bits_addr;
      else if (maybeWriteData & ~io_periBusy | maybeIssueRead & ~io_periBusy)
        cmdAddr <=
          (_addrNext_T_1 ? cmdAddr : 32'h0) | (_addrNext_T_3 ? cmdAddr + _GEN : 32'h0)
          | (_addrNext_T_8
               ? (_addrNext_newAddr_T_1 >= cmdAddrBase + 32'h10
                    ? cmdAddrBase
                    : _addrNext_newAddr_T_1)
               : 32'h0)
          | (_addrNext_T_1 | _addrNext_T_3 | _addrNext_T_8 ? 32'h0 : cmdAddr);
      readIssued_valid <= issueRead;
      readIssued_bits_id <= _axiAddrCmd_q_io_deq_bits_addr_id;
      readIssued_bits_last <= lastRead;
      readsIssued <=
        axiAddrCmd_q_io_deq_ready & _axiAddrCmd_q_io_deq_valid
          ? 9'h0
          : readsIssued + {8'h0, issueRead};
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:1];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          _RANDOM[i[0]] = `RANDOM;
        end
        cmdAddr = _RANDOM[1'h0];
        readIssued_valid = _RANDOM[1'h1][0];
        readIssued_bits_id = _RANDOM[1'h1][6:1];
        readIssued_bits_last = _RANDOM[1'h1][7];
        readsIssued = _RANDOM[1'h1][16:8];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        cmdAddr = 32'h0;
        readIssued_valid = 1'h0;
        readIssued_bits_id = 6'h0;
        readIssued_bits_last = 1'h0;
        readsIssued = 9'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  CoralNPURRArbiter addrArbiter (
    .clock               (clock),
    .reset               (reset),
    .io_in_0_ready       (_addrArbiter_io_in_0_ready),
    .io_in_0_valid       (_addrArbiter_io_in_0_q_io_deq_valid),
    .io_in_0_bits_addr   (_addrArbiter_io_in_0_q_io_deq_bits_addr),
    .io_in_0_bits_prot   (_addrArbiter_io_in_0_q_io_deq_bits_prot),
    .io_in_0_bits_id     (_addrArbiter_io_in_0_q_io_deq_bits_id),
    .io_in_0_bits_len    (_addrArbiter_io_in_0_q_io_deq_bits_len),
    .io_in_0_bits_size   (_addrArbiter_io_in_0_q_io_deq_bits_size),
    .io_in_0_bits_burst  (_addrArbiter_io_in_0_q_io_deq_bits_burst),
    .io_in_0_bits_lock   (_addrArbiter_io_in_0_q_io_deq_bits_lock),
    .io_in_0_bits_cache  (_addrArbiter_io_in_0_q_io_deq_bits_cache),
    .io_in_0_bits_qos    (_addrArbiter_io_in_0_q_io_deq_bits_qos),
    .io_in_0_bits_region (_addrArbiter_io_in_0_q_io_deq_bits_region),
    .io_in_1_ready       (_addrArbiter_io_in_1_ready),
    .io_in_1_valid       (_addrArbiter_io_in_1_q_io_deq_valid),
    .io_in_1_bits_addr   (_addrArbiter_io_in_1_q_io_deq_bits_addr),
    .io_in_1_bits_prot   (_addrArbiter_io_in_1_q_io_deq_bits_prot),
    .io_in_1_bits_id     (_addrArbiter_io_in_1_q_io_deq_bits_id),
    .io_in_1_bits_len    (_addrArbiter_io_in_1_q_io_deq_bits_len),
    .io_in_1_bits_size   (_addrArbiter_io_in_1_q_io_deq_bits_size),
    .io_in_1_bits_burst  (_addrArbiter_io_in_1_q_io_deq_bits_burst),
    .io_in_1_bits_lock   (_addrArbiter_io_in_1_q_io_deq_bits_lock),
    .io_in_1_bits_cache  (_addrArbiter_io_in_1_q_io_deq_bits_cache),
    .io_in_1_bits_qos    (_addrArbiter_io_in_1_q_io_deq_bits_qos),
    .io_in_1_bits_region (_addrArbiter_io_in_1_q_io_deq_bits_region),
    .io_out_ready        (_axiAddrCmd_q_io_enq_ready),
    .io_out_valid        (_addrArbiter_io_out_valid),
    .io_out_bits_addr    (_addrArbiter_io_out_bits_addr),
    .io_out_bits_prot    (_addrArbiter_io_out_bits_prot),
    .io_out_bits_id      (_addrArbiter_io_out_bits_id),
    .io_out_bits_len     (_addrArbiter_io_out_bits_len),
    .io_out_bits_size    (_addrArbiter_io_out_bits_size),
    .io_out_bits_burst   (_addrArbiter_io_out_bits_burst),
    .io_out_bits_lock    (_addrArbiter_io_out_bits_lock),
    .io_out_bits_cache   (_addrArbiter_io_out_bits_cache),
    .io_out_bits_qos     (_addrArbiter_io_out_bits_qos),
    .io_out_bits_region  (_addrArbiter_io_out_bits_region),
    .io_chosen           (_addrArbiter_io_chosen)
  );
  Queue2_AxiAddress addrArbiter_io_in_0_q (
    .clock              (clock),
    .reset              (reset),
    .io_enq_ready       (io_axi_read_addr_ready),
    .io_enq_valid       (io_axi_read_addr_valid),
    .io_enq_bits_addr   (io_axi_read_addr_bits_addr),
    .io_enq_bits_prot   (io_axi_read_addr_bits_prot),
    .io_enq_bits_id     (io_axi_read_addr_bits_id),
    .io_enq_bits_len    (io_axi_read_addr_bits_len),
    .io_enq_bits_size   (io_axi_read_addr_bits_size),
    .io_enq_bits_burst  (io_axi_read_addr_bits_burst),
    .io_enq_bits_lock   (io_axi_read_addr_bits_lock),
    .io_enq_bits_cache  (io_axi_read_addr_bits_cache),
    .io_enq_bits_qos    (io_axi_read_addr_bits_qos),
    .io_enq_bits_region (io_axi_read_addr_bits_region),
    .io_deq_ready       (_addrArbiter_io_in_0_ready),
    .io_deq_valid       (_addrArbiter_io_in_0_q_io_deq_valid),
    .io_deq_bits_addr   (_addrArbiter_io_in_0_q_io_deq_bits_addr),
    .io_deq_bits_prot   (_addrArbiter_io_in_0_q_io_deq_bits_prot),
    .io_deq_bits_id     (_addrArbiter_io_in_0_q_io_deq_bits_id),
    .io_deq_bits_len    (_addrArbiter_io_in_0_q_io_deq_bits_len),
    .io_deq_bits_size   (_addrArbiter_io_in_0_q_io_deq_bits_size),
    .io_deq_bits_burst  (_addrArbiter_io_in_0_q_io_deq_bits_burst),
    .io_deq_bits_lock   (_addrArbiter_io_in_0_q_io_deq_bits_lock),
    .io_deq_bits_cache  (_addrArbiter_io_in_0_q_io_deq_bits_cache),
    .io_deq_bits_qos    (_addrArbiter_io_in_0_q_io_deq_bits_qos),
    .io_deq_bits_region (_addrArbiter_io_in_0_q_io_deq_bits_region)
  );
  Queue2_AxiAddress addrArbiter_io_in_1_q (
    .clock              (clock),
    .reset              (reset),
    .io_enq_ready       (io_axi_write_addr_ready),
    .io_enq_valid       (io_axi_write_addr_valid),
    .io_enq_bits_addr   (io_axi_write_addr_bits_addr),
    .io_enq_bits_prot   (io_axi_write_addr_bits_prot),
    .io_enq_bits_id     (io_axi_write_addr_bits_id),
    .io_enq_bits_len    (io_axi_write_addr_bits_len),
    .io_enq_bits_size   (io_axi_write_addr_bits_size),
    .io_enq_bits_burst  (io_axi_write_addr_bits_burst),
    .io_enq_bits_lock   (io_axi_write_addr_bits_lock),
    .io_enq_bits_cache  (io_axi_write_addr_bits_cache),
    .io_enq_bits_qos    (io_axi_write_addr_bits_qos),
    .io_enq_bits_region (io_axi_write_addr_bits_region),
    .io_deq_ready       (_addrArbiter_io_in_1_ready),
    .io_deq_valid       (_addrArbiter_io_in_1_q_io_deq_valid),
    .io_deq_bits_addr   (_addrArbiter_io_in_1_q_io_deq_bits_addr),
    .io_deq_bits_prot   (_addrArbiter_io_in_1_q_io_deq_bits_prot),
    .io_deq_bits_id     (_addrArbiter_io_in_1_q_io_deq_bits_id),
    .io_deq_bits_len    (_addrArbiter_io_in_1_q_io_deq_bits_len),
    .io_deq_bits_size   (_addrArbiter_io_in_1_q_io_deq_bits_size),
    .io_deq_bits_burst  (_addrArbiter_io_in_1_q_io_deq_bits_burst),
    .io_deq_bits_lock   (_addrArbiter_io_in_1_q_io_deq_bits_lock),
    .io_deq_bits_cache  (_addrArbiter_io_in_1_q_io_deq_bits_cache),
    .io_deq_bits_qos    (_addrArbiter_io_in_1_q_io_deq_bits_qos),
    .io_deq_bits_region (_addrArbiter_io_in_1_q_io_deq_bits_region)
  );
  Queue1_RWAxiAddress axiAddrCmd_q (
    .clock                   (clock),
    .reset                   (reset),
    .io_enq_ready            (_axiAddrCmd_q_io_enq_ready),
    .io_enq_valid            (_addrArbiter_io_out_valid),
    .io_enq_bits_addr_addr   (_addrArbiter_io_out_bits_addr),
    .io_enq_bits_addr_prot   (_addrArbiter_io_out_bits_prot),
    .io_enq_bits_addr_id     (_addrArbiter_io_out_bits_id),
    .io_enq_bits_addr_len    (_addrArbiter_io_out_bits_len),
    .io_enq_bits_addr_size   (_addrArbiter_io_out_bits_size),
    .io_enq_bits_addr_burst  (_addrArbiter_io_out_bits_burst),
    .io_enq_bits_addr_lock   (_addrArbiter_io_out_bits_lock),
    .io_enq_bits_addr_cache  (_addrArbiter_io_out_bits_cache),
    .io_enq_bits_addr_qos    (_addrArbiter_io_out_bits_qos),
    .io_enq_bits_addr_region (_addrArbiter_io_out_bits_region),
    .io_enq_bits_write       (_addrArbiter_io_chosen),
    .io_deq_ready            (axiAddrCmd_q_io_deq_ready),
    .io_deq_valid            (_axiAddrCmd_q_io_deq_valid),
    .io_deq_bits_addr_addr   (_axiAddrCmd_q_io_deq_bits_addr_addr),
    .io_deq_bits_addr_id     (_axiAddrCmd_q_io_deq_bits_addr_id),
    .io_deq_bits_addr_len    (_axiAddrCmd_q_io_deq_bits_addr_len),
    .io_deq_bits_addr_size   (_axiAddrCmd_q_io_deq_bits_addr_size),
    .io_deq_bits_addr_burst  (_axiAddrCmd_q_io_deq_bits_addr_burst),
    .io_deq_bits_write       (_axiAddrCmd_q_io_deq_bits_write)
  );
  Queue3_AxiWriteData writeData_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (io_axi_write_data_ready),
    .io_enq_valid     (io_axi_write_data_valid),
    .io_enq_bits_data (io_axi_write_data_bits_data),
    .io_enq_bits_last (io_axi_write_data_bits_last),
    .io_enq_bits_strb (io_axi_write_data_bits_strb),
    .io_deq_ready     (writeData_q_io_deq_ready),
    .io_deq_valid     (_writeData_q_io_deq_valid),
    .io_deq_bits_data (io_fabric_writeDataBits),
    .io_deq_bits_last (_writeData_q_io_deq_bits_last),
    .io_deq_bits_strb (io_fabric_writeDataStrb)
  );
  Queue2_AxiWriteResponse io_axi_write_resp_q (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_io_axi_write_resp_q_io_enq_ready),
    .io_enq_valid     (writeResponse_valid),
    .io_enq_bits_id   (_axiAddrCmd_q_io_deq_bits_addr_id),
    .io_enq_bits_resp ({~io_fabric_writeResp, 1'h0}),
    .io_deq_ready     (io_axi_write_resp_ready),
    .io_deq_valid     (io_axi_write_resp_valid),
    .io_deq_bits_id   (io_axi_write_resp_bits_id),
    .io_deq_bits_resp (io_axi_write_resp_bits_resp)
  );
  Queue3_AxiReadData readDataQueue (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_readDataQueue_io_enq_ready),
    .io_enq_valid     (readIssued_valid),
    .io_enq_bits_data (io_fabric_readData_bits),
    .io_enq_bits_id   (readIssued_bits_id),
    .io_enq_bits_resp ({~io_fabric_readData_valid, 1'h0}),
    .io_enq_bits_last (readIssued_bits_last),
    .io_deq_ready     (io_axi_read_data_ready),
    .io_deq_valid     (io_axi_read_data_valid),
    .io_deq_bits_data (io_axi_read_data_bits_data),
    .io_deq_bits_id   (io_axi_read_data_bits_id),
    .io_deq_bits_resp (io_axi_read_data_bits_resp),
    .io_deq_bits_last (io_axi_read_data_bits_last),
    .io_count         (_readDataQueue_io_count)
  );
  assign io_fabric_readDataAddr_valid = maybeIssueRead;
  assign io_fabric_readDataAddr_bits = cmdAddr;
  assign io_fabric_writeDataAddr_valid = maybeWriteData;
  assign io_fabric_writeDataAddr_bits = cmdAddr;
endmodule

// VCS coverage exclude_module
module ram_2x145(
  input          R0_addr,
                 R0_en,
                 R0_clk,
  output [144:0] R0_data,
  input          W0_addr,
                 W0_en,
                 W0_clk,
  input  [144:0] W0_data
);

  reg [144:0] Memory[0:1];
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_MEM_
    reg [159:0] _RANDOM_MEM;
    initial begin
      `INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_MEM_INIT
        for (logic [1:0] i = 2'h0; i < 2'h2; i += 2'h1) begin
          for (logic [7:0] j = 8'h0; j < 8'hA0; j += 8'h20) begin
            _RANDOM_MEM[j +: 32] = `RANDOM;
          end
          Memory[i[0]] = _RANDOM_MEM[144:0];
        end
      `endif // RANDOMIZE_MEM_INIT
    end // initial
  `endif // ENABLE_INITIAL_MEM_
  assign R0_data = R0_en ? Memory[R0_addr] : 145'bx;
endmodule

module Queue2_AxiWriteData(
  input          clock,
                 reset,
  output         io_enq_ready,
  input          io_enq_valid,
  input  [127:0] io_enq_bits_data,
  input  [15:0]  io_enq_bits_strb,
  input          io_deq_ready,
  output         io_deq_valid,
  output [127:0] io_deq_bits_data,
  output         io_deq_bits_last,
  output [15:0]  io_deq_bits_strb
);

  wire [144:0] _ram_ext_R0_data;
  reg          wrap;
  reg          wrap_1;
  reg          maybe_full;
  wire         ptr_match = wrap == wrap_1;
  wire         empty = ptr_match & ~maybe_full;
  wire         full = ptr_match & maybe_full;
  wire         do_enq = ~full & io_enq_valid;
  wire         do_deq = io_deq_ready & ~empty;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      wrap <= 1'h0;
      wrap_1 <= 1'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        wrap <= wrap - 1'h1;
      if (do_deq)
        wrap_1 <= wrap_1 - 1'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        wrap = _RANDOM[/*Zero width*/ 1'b0][0];
        wrap_1 = _RANDOM[/*Zero width*/ 1'b0][1];
        maybe_full = _RANDOM[/*Zero width*/ 1'b0][2];
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        wrap = 1'h0;
        wrap_1 = 1'h0;
        maybe_full = 1'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  ram_2x145 ram_ext (
    .R0_addr (wrap_1),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (_ram_ext_R0_data),
    .W0_addr (wrap),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data ({io_enq_bits_data, 1'h1, io_enq_bits_strb})
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = ~empty;
  assign io_deq_bits_data = _ram_ext_R0_data[144:17];
  assign io_deq_bits_last = _ram_ext_R0_data[16];
  assign io_deq_bits_strb = _ram_ext_R0_data[15:0];
endmodule

module DBus2AxiV2(
  input          clock,
                 reset,
                 io_dbus_valid,
  output         io_dbus_ready,
  input          io_dbus_write,
  input  [31:0]  io_dbus_pc,
                 io_dbus_addr,
  input  [4:0]   io_dbus_size,
  input  [127:0] io_dbus_wdata,
  input  [15:0]  io_dbus_wmask,
  output [127:0] io_dbus_rdata,
  input          io_axi_write_addr_ready,
  output         io_axi_write_addr_valid,
  output [31:0]  io_axi_write_addr_bits_addr,
  output [2:0]   io_axi_write_addr_bits_size,
  input          io_axi_write_data_ready,
  output         io_axi_write_data_valid,
  output [127:0] io_axi_write_data_bits_data,
  output         io_axi_write_data_bits_last,
  output [15:0]  io_axi_write_data_bits_strb,
  output         io_axi_write_resp_ready,
  input          io_axi_write_resp_valid,
  input  [1:0]   io_axi_write_resp_bits_resp,
  input          io_axi_read_addr_ready,
  output         io_axi_read_addr_valid,
  output [31:0]  io_axi_read_addr_bits_addr,
  output [2:0]   io_axi_read_addr_bits_size,
  output         io_axi_read_data_ready,
  input          io_axi_read_data_valid,
  input  [127:0] io_axi_read_data_bits_data,
  input  [1:0]   io_axi_read_data_bits_resp,
  output         io_fault_valid,
                 io_fault_bits_write,
  output [31:0]  io_fault_bits_addr,
                 io_fault_bits_epc
);

  wire         _wdataQueue_io_enq_ready;
  reg          waddrFired;
  wire         io_axi_write_addr_valid_0 = ~waddrFired & io_dbus_valid & io_dbus_write;
  reg          wdataFired;
  wire         wdataQueue_io_enq_valid = ~wdataFired & io_dbus_valid & io_dbus_write;
  reg          wrespReceived;
  wire         io_axi_write_resp_ready_0 = ~wrespReceived & io_dbus_valid & io_dbus_write;
  wire         _waddrFired_T = io_axi_write_addr_ready & io_axi_write_addr_valid_0;
  wire         _wdataFired_T = _wdataQueue_io_enq_ready & wdataQueue_io_enq_valid;
  wire         _wrespReceived_T = io_axi_write_resp_ready_0 & io_axi_write_resp_valid;
  wire         writeFinished =
    (_waddrFired_T | waddrFired) & (_wdataFired_T | wdataFired)
    & (_wrespReceived_T | wrespReceived);
  reg          raddrFired;
  wire         io_axi_read_addr_valid_0 = ~raddrFired & io_dbus_valid & ~io_dbus_write;
  reg          rdataReceived_valid;
  reg  [127:0] rdataReceived_bits;
  wire         io_axi_read_data_ready_0 =
    ~rdataReceived_valid & io_dbus_valid & ~io_dbus_write;
  wire         _raddrFired_T = io_axi_read_addr_ready & io_axi_read_addr_valid_0;
  wire         _readNext_T = io_axi_read_data_ready_0 & io_axi_read_data_valid;
  wire         readFinished =
    (_raddrFired_T | raddrFired) & (_readNext_T | rdataReceived_valid);
  reg  [127:0] readNext;
  always @(posedge clock or posedge reset) begin
    if (reset) begin
      waddrFired <= 1'h0;
      wdataFired <= 1'h0;
      wrespReceived <= 1'h0;
      raddrFired <= 1'h0;
      rdataReceived_valid <= 1'h0;
      rdataReceived_bits <= 128'h0;
      readNext <= 128'h0;
    end
    else begin
      waddrFired <= ~writeFinished & (_waddrFired_T | waddrFired);
      wdataFired <= ~writeFinished & (_wdataFired_T | wdataFired);
      wrespReceived <= ~writeFinished & (_wrespReceived_T | wrespReceived);
      raddrFired <= ~readFinished & (_raddrFired_T | raddrFired);
      rdataReceived_valid <= ~readFinished & (_readNext_T | rdataReceived_valid);
      if (readFinished) begin
        rdataReceived_bits <= 128'h0;
        readNext <= _readNext_T ? io_axi_read_data_bits_data : rdataReceived_bits;
      end
      else if (_readNext_T)
        rdataReceived_bits <= io_axi_read_data_bits_data;
    end
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:8];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h9; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        waddrFired = _RANDOM[4'h0][0];
        wdataFired = _RANDOM[4'h0][1];
        wrespReceived = _RANDOM[4'h0][2];
        raddrFired = _RANDOM[4'h0][3];
        rdataReceived_valid = _RANDOM[4'h0][4];
        rdataReceived_bits =
          {_RANDOM[4'h0][31:5],
           _RANDOM[4'h1],
           _RANDOM[4'h2],
           _RANDOM[4'h3],
           _RANDOM[4'h4][4:0]};
        readNext =
          {_RANDOM[4'h4][31:5],
           _RANDOM[4'h5],
           _RANDOM[4'h6],
           _RANDOM[4'h7],
           _RANDOM[4'h8][4:0]};
      `endif // RANDOMIZE_REG_INIT
      if (reset) begin
        waddrFired = 1'h0;
        wdataFired = 1'h0;
        wrespReceived = 1'h0;
        raddrFired = 1'h0;
        rdataReceived_valid = 1'h0;
        rdataReceived_bits = 128'h0;
        readNext = 128'h0;
      end
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  Queue2_AxiWriteData wdataQueue (
    .clock            (clock),
    .reset            (reset),
    .io_enq_ready     (_wdataQueue_io_enq_ready),
    .io_enq_valid     (wdataQueue_io_enq_valid),
    .io_enq_bits_data (io_dbus_wdata),
    .io_enq_bits_strb (io_dbus_wmask),
    .io_deq_ready     (io_axi_write_data_ready),
    .io_deq_valid     (io_axi_write_data_valid),
    .io_deq_bits_data (io_axi_write_data_bits_data),
    .io_deq_bits_last (io_axi_write_data_bits_last),
    .io_deq_bits_strb (io_axi_write_data_bits_strb)
  );
  assign io_dbus_ready = io_dbus_write ? writeFinished : readFinished;
  assign io_dbus_rdata = readNext;
  assign io_axi_write_addr_valid = io_axi_write_addr_valid_0;
  assign io_axi_write_addr_bits_addr = io_dbus_addr;
  assign io_axi_write_addr_bits_size =
    io_dbus_size[0]
      ? 3'h0
      : io_dbus_size[1]
          ? 3'h1
          : io_dbus_size[2] ? 3'h2 : io_dbus_size[3] ? 3'h3 : {2'h2, ~(io_dbus_size[4])};
  assign io_axi_write_resp_ready = io_axi_write_resp_ready_0;
  assign io_axi_read_addr_valid = io_axi_read_addr_valid_0;
  assign io_axi_read_addr_bits_addr = io_dbus_addr;
  assign io_axi_read_addr_bits_size =
    io_dbus_size[0]
      ? 3'h0
      : io_dbus_size[1]
          ? 3'h1
          : io_dbus_size[2] ? 3'h2 : io_dbus_size[3] ? 3'h3 : {2'h2, ~(io_dbus_size[4])};
  assign io_axi_read_data_ready = io_axi_read_data_ready_0;
  assign io_fault_valid =
    io_dbus_valid
    & (io_dbus_write
         ? io_axi_write_resp_valid & (|io_axi_write_resp_bits_resp)
         : io_axi_read_data_valid & (|io_axi_read_data_bits_resp));
  assign io_fault_bits_write = io_dbus_write;
  assign io_fault_bits_addr = io_dbus_addr;
  assign io_fault_bits_epc = io_dbus_pc;
endmodule

module RvvCoreMiniAxi(
  input          io_aclk,
                 io_aresetn,
  output         io_axi_slave_write_addr_ready,
  input          io_axi_slave_write_addr_valid,
  input  [31:0]  io_axi_slave_write_addr_bits_addr,
  input  [2:0]   io_axi_slave_write_addr_bits_prot,
  input  [5:0]   io_axi_slave_write_addr_bits_id,
  input  [7:0]   io_axi_slave_write_addr_bits_len,
  input  [2:0]   io_axi_slave_write_addr_bits_size,
  input  [1:0]   io_axi_slave_write_addr_bits_burst,
  input          io_axi_slave_write_addr_bits_lock,
  input  [3:0]   io_axi_slave_write_addr_bits_cache,
                 io_axi_slave_write_addr_bits_qos,
                 io_axi_slave_write_addr_bits_region,
  output         io_axi_slave_write_data_ready,
  input          io_axi_slave_write_data_valid,
  input  [127:0] io_axi_slave_write_data_bits_data,
  input          io_axi_slave_write_data_bits_last,
  input  [15:0]  io_axi_slave_write_data_bits_strb,
  input          io_axi_slave_write_resp_ready,
  output         io_axi_slave_write_resp_valid,
  output [5:0]   io_axi_slave_write_resp_bits_id,
  output [1:0]   io_axi_slave_write_resp_bits_resp,
  output         io_axi_slave_read_addr_ready,
  input          io_axi_slave_read_addr_valid,
  input  [31:0]  io_axi_slave_read_addr_bits_addr,
  input  [2:0]   io_axi_slave_read_addr_bits_prot,
  input  [5:0]   io_axi_slave_read_addr_bits_id,
  input  [7:0]   io_axi_slave_read_addr_bits_len,
  input  [2:0]   io_axi_slave_read_addr_bits_size,
  input  [1:0]   io_axi_slave_read_addr_bits_burst,
  input          io_axi_slave_read_addr_bits_lock,
  input  [3:0]   io_axi_slave_read_addr_bits_cache,
                 io_axi_slave_read_addr_bits_qos,
                 io_axi_slave_read_addr_bits_region,
  input          io_axi_slave_read_data_ready,
  output         io_axi_slave_read_data_valid,
  output [127:0] io_axi_slave_read_data_bits_data,
  output [5:0]   io_axi_slave_read_data_bits_id,
  output [1:0]   io_axi_slave_read_data_bits_resp,
  output         io_axi_slave_read_data_bits_last,
  input          io_axi_master_write_addr_ready,
  output         io_axi_master_write_addr_valid,
  output [31:0]  io_axi_master_write_addr_bits_addr,
  output [2:0]   io_axi_master_write_addr_bits_prot,
  output [5:0]   io_axi_master_write_addr_bits_id,
  output [7:0]   io_axi_master_write_addr_bits_len,
  output [2:0]   io_axi_master_write_addr_bits_size,
  output [1:0]   io_axi_master_write_addr_bits_burst,
  output         io_axi_master_write_addr_bits_lock,
  output [3:0]   io_axi_master_write_addr_bits_cache,
                 io_axi_master_write_addr_bits_qos,
                 io_axi_master_write_addr_bits_region,
  input          io_axi_master_write_data_ready,
  output         io_axi_master_write_data_valid,
  output [127:0] io_axi_master_write_data_bits_data,
  output         io_axi_master_write_data_bits_last,
  output [15:0]  io_axi_master_write_data_bits_strb,
  output         io_axi_master_write_resp_ready,
  input          io_axi_master_write_resp_valid,
  input  [5:0]   io_axi_master_write_resp_bits_id,
  input  [1:0]   io_axi_master_write_resp_bits_resp,
  input          io_axi_master_read_addr_ready,
  output         io_axi_master_read_addr_valid,
  output [31:0]  io_axi_master_read_addr_bits_addr,
  output [2:0]   io_axi_master_read_addr_bits_prot,
  output [5:0]   io_axi_master_read_addr_bits_id,
  output [7:0]   io_axi_master_read_addr_bits_len,
  output [2:0]   io_axi_master_read_addr_bits_size,
  output [1:0]   io_axi_master_read_addr_bits_burst,
  output         io_axi_master_read_addr_bits_lock,
  output [3:0]   io_axi_master_read_addr_bits_cache,
                 io_axi_master_read_addr_bits_qos,
                 io_axi_master_read_addr_bits_region,
  output         io_axi_master_read_data_ready,
  input          io_axi_master_read_data_valid,
  input  [127:0] io_axi_master_read_data_bits_data,
  input  [5:0]   io_axi_master_read_data_bits_id,
  input  [1:0]   io_axi_master_read_data_bits_resp,
  input          io_axi_master_read_data_bits_last,
  output         io_halted,
                 io_fault,
                 io_wfi,
  input          io_irq,
  output [3:0]   io_debug_en,
  output [31:0]  io_debug_addr_0,
                 io_debug_addr_1,
                 io_debug_addr_2,
                 io_debug_addr_3,
                 io_debug_inst_0,
                 io_debug_inst_1,
                 io_debug_inst_2,
                 io_debug_inst_3,
                 io_debug_cycles,
  output         io_debug_dbus_valid,
  output [31:0]  io_debug_dbus_bits_addr,
  output [127:0] io_debug_dbus_bits_wdata,
  output         io_debug_dbus_bits_write,
                 io_debug_dispatch_0_instFire,
  output [31:0]  io_debug_dispatch_0_instAddr,
                 io_debug_dispatch_0_instInst,
  output         io_debug_dispatch_1_instFire,
  output [31:0]  io_debug_dispatch_1_instAddr,
                 io_debug_dispatch_1_instInst,
  output         io_debug_dispatch_2_instFire,
  output [31:0]  io_debug_dispatch_2_instAddr,
                 io_debug_dispatch_2_instInst,
  output         io_debug_dispatch_3_instFire,
  output [31:0]  io_debug_dispatch_3_instAddr,
                 io_debug_dispatch_3_instInst,
  output         io_debug_regfile_writeAddr_0_valid,
  output [4:0]   io_debug_regfile_writeAddr_0_bits,
  output         io_debug_regfile_writeAddr_1_valid,
  output [4:0]   io_debug_regfile_writeAddr_1_bits,
  output         io_debug_regfile_writeAddr_2_valid,
  output [4:0]   io_debug_regfile_writeAddr_2_bits,
  output         io_debug_regfile_writeAddr_3_valid,
  output [4:0]   io_debug_regfile_writeAddr_3_bits,
  output         io_debug_regfile_writeData_0_valid,
  output [4:0]   io_debug_regfile_writeData_0_bits_addr,
  output [31:0]  io_debug_regfile_writeData_0_bits_data,
  output         io_debug_regfile_writeData_1_valid,
  output [4:0]   io_debug_regfile_writeData_1_bits_addr,
  output [31:0]  io_debug_regfile_writeData_1_bits_data,
  output         io_debug_regfile_writeData_2_valid,
  output [4:0]   io_debug_regfile_writeData_2_bits_addr,
  output [31:0]  io_debug_regfile_writeData_2_bits_data,
  output         io_debug_regfile_writeData_3_valid,
  output [4:0]   io_debug_regfile_writeData_3_bits_addr,
  output [31:0]  io_debug_regfile_writeData_3_bits_data,
  output         io_debug_regfile_writeData_4_valid,
  output [4:0]   io_debug_regfile_writeData_4_bits_addr,
  output [31:0]  io_debug_regfile_writeData_4_bits_data,
  output         io_debug_regfile_writeData_5_valid,
  output [4:0]   io_debug_regfile_writeData_5_bits_addr,
  output [31:0]  io_debug_regfile_writeData_5_bits_data,
  output         io_debug_float_writeAddr_valid,
  output [4:0]   io_debug_float_writeAddr_bits,
  output         io_debug_float_writeData_0_valid,
  output [31:0]  io_debug_float_writeData_0_bits_addr,
                 io_debug_float_writeData_0_bits_data,
  output         io_debug_float_writeData_1_valid,
  output [31:0]  io_debug_float_writeData_1_bits_addr,
                 io_debug_float_writeData_1_bits_data,
  output         io_debug_rb_inst_0_valid,
  output [31:0]  io_debug_rb_inst_0_bits_pc,
                 io_debug_rb_inst_0_bits_inst,
  output [6:0]   io_debug_rb_inst_0_bits_idx,
  output [127:0] io_debug_rb_inst_0_bits_data,
  output         io_debug_rb_inst_0_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_0_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_0_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_0_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_0_bits_trap,
                 io_debug_rb_inst_1_valid,
  output [31:0]  io_debug_rb_inst_1_bits_pc,
                 io_debug_rb_inst_1_bits_inst,
  output [6:0]   io_debug_rb_inst_1_bits_idx,
  output [127:0] io_debug_rb_inst_1_bits_data,
  output         io_debug_rb_inst_1_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_1_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_1_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_1_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_1_bits_trap,
                 io_debug_rb_inst_2_valid,
  output [31:0]  io_debug_rb_inst_2_bits_pc,
                 io_debug_rb_inst_2_bits_inst,
  output [6:0]   io_debug_rb_inst_2_bits_idx,
  output [127:0] io_debug_rb_inst_2_bits_data,
  output         io_debug_rb_inst_2_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_2_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_2_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_2_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_2_bits_trap,
                 io_debug_rb_inst_3_valid,
  output [31:0]  io_debug_rb_inst_3_bits_pc,
                 io_debug_rb_inst_3_bits_inst,
  output [6:0]   io_debug_rb_inst_3_bits_idx,
  output [127:0] io_debug_rb_inst_3_bits_data,
  output         io_debug_rb_inst_3_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_3_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_3_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_3_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_3_bits_trap,
                 io_debug_rb_inst_4_valid,
  output [31:0]  io_debug_rb_inst_4_bits_pc,
                 io_debug_rb_inst_4_bits_inst,
  output [6:0]   io_debug_rb_inst_4_bits_idx,
  output [127:0] io_debug_rb_inst_4_bits_data,
  output         io_debug_rb_inst_4_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_4_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_4_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_4_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_4_bits_trap,
                 io_debug_rb_inst_5_valid,
  output [31:0]  io_debug_rb_inst_5_bits_pc,
                 io_debug_rb_inst_5_bits_inst,
  output [6:0]   io_debug_rb_inst_5_bits_idx,
  output [127:0] io_debug_rb_inst_5_bits_data,
  output         io_debug_rb_inst_5_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_5_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_5_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_5_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_5_bits_trap,
                 io_debug_rb_inst_6_valid,
  output [31:0]  io_debug_rb_inst_6_bits_pc,
                 io_debug_rb_inst_6_bits_inst,
  output [6:0]   io_debug_rb_inst_6_bits_idx,
  output [127:0] io_debug_rb_inst_6_bits_data,
  output         io_debug_rb_inst_6_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_6_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_6_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_6_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_6_bits_trap,
                 io_debug_rb_inst_7_valid,
  output [31:0]  io_debug_rb_inst_7_bits_pc,
                 io_debug_rb_inst_7_bits_inst,
  output [6:0]   io_debug_rb_inst_7_bits_idx,
  output [127:0] io_debug_rb_inst_7_bits_data,
  output         io_debug_rb_inst_7_bits_vecWrites_0_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_0_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_0_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_1_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_1_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_1_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_2_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_2_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_2_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_3_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_3_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_3_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_4_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_4_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_4_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_5_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_5_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_5_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_6_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_6_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_6_bits_idx,
  output         io_debug_rb_inst_7_bits_vecWrites_7_valid,
  output [127:0] io_debug_rb_inst_7_bits_vecWrites_7_bits_data,
  output [4:0]   io_debug_rb_inst_7_bits_vecWrites_7_bits_idx,
  output         io_debug_rb_inst_7_bits_trap,
                 io_slog_valid,
  output [4:0]   io_slog_addr,
  output [31:0]  io_slog_data,
  input          io_te
);

  wire         _ebus2axi_io_dbus_ready;
  wire [127:0] _ebus2axi_io_dbus_rdata;
  wire         _ebus2axi_io_fault_valid;
  wire         _ebus2axi_io_fault_bits_write;
  wire [31:0]  _ebus2axi_io_fault_bits_addr;
  wire [31:0]  _ebus2axi_io_fault_bits_epc;
  wire         _axiSlave_io_axi_write_addr_ready;
  wire         _axiSlave_io_axi_write_data_ready;
  wire         _axiSlave_io_axi_write_resp_valid;
  wire         _axiSlave_io_axi_read_addr_ready;
  wire         _axiSlave_io_axi_read_data_valid;
  wire         _axiSlave_io_fabric_readDataAddr_valid;
  wire [31:0]  _axiSlave_io_fabric_readDataAddr_bits;
  wire         _axiSlave_io_fabric_writeDataAddr_valid;
  wire [31:0]  _axiSlave_io_fabric_writeDataAddr_bits;
  wire [127:0] _axiSlave_io_fabric_writeDataBits;
  wire [15:0]  _axiSlave_io_fabric_writeDataStrb;
  wire         _fabricMux_io_source_readData_valid;
  wire [127:0] _fabricMux_io_source_readData_bits;
  wire         _fabricMux_io_source_writeResp;
  wire         _fabricMux_io_fabricBusy;
  wire         _fabricMux_io_ports_0_readDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_0_readDataAddr_bits;
  wire         _fabricMux_io_ports_0_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_0_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_0_writeDataBits;
  wire [15:0]  _fabricMux_io_ports_0_writeDataStrb;
  wire         _fabricMux_io_ports_1_readDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_1_readDataAddr_bits;
  wire         _fabricMux_io_ports_1_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_1_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_1_writeDataBits;
  wire [15:0]  _fabricMux_io_ports_1_writeDataStrb;
  wire [31:0]  _fabricMux_io_ports_2_readDataAddr_bits;
  wire         _fabricMux_io_ports_2_writeDataAddr_valid;
  wire [31:0]  _fabricMux_io_ports_2_writeDataAddr_bits;
  wire [127:0] _fabricMux_io_ports_2_writeDataBits;
  wire [127:0] _dtcmArbiter_io_source_0_readData_bits;
  wire         _dtcmArbiter_io_source_1_readData_valid;
  wire [127:0] _dtcmArbiter_io_source_1_readData_bits;
  wire         _dtcmArbiter_io_fabricBusy_1;
  wire         _dtcmArbiter_io_port_readDataAddr_valid;
  wire [31:0]  _dtcmArbiter_io_port_readDataAddr_bits;
  wire         _dtcmArbiter_io_port_writeDataAddr_valid;
  wire [31:0]  _dtcmArbiter_io_port_writeDataAddr_bits;
  wire [127:0] _dtcmArbiter_io_port_writeDataBits;
  wire [15:0]  _dtcmArbiter_io_port_writeDataStrb;
  wire         _dtcmWrapper_io_fabric_readData_valid;
  wire [127:0] _dtcmWrapper_io_fabric_readData_bits;
  wire [10:0]  _dtcmWrapper_io_sram_address;
  wire         _dtcmWrapper_io_sram_enable;
  wire         _dtcmWrapper_io_sram_isWrite;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_0;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_1;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_2;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_3;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_4;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_5;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_6;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_7;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_8;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_9;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_10;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_11;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_12;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_13;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_14;
  wire [7:0]   _dtcmWrapper_io_sram_writeData_15;
  wire         _dtcmWrapper_io_sram_mask_0;
  wire         _dtcmWrapper_io_sram_mask_1;
  wire         _dtcmWrapper_io_sram_mask_2;
  wire         _dtcmWrapper_io_sram_mask_3;
  wire         _dtcmWrapper_io_sram_mask_4;
  wire         _dtcmWrapper_io_sram_mask_5;
  wire         _dtcmWrapper_io_sram_mask_6;
  wire         _dtcmWrapper_io_sram_mask_7;
  wire         _dtcmWrapper_io_sram_mask_8;
  wire         _dtcmWrapper_io_sram_mask_9;
  wire         _dtcmWrapper_io_sram_mask_10;
  wire         _dtcmWrapper_io_sram_mask_11;
  wire         _dtcmWrapper_io_sram_mask_12;
  wire         _dtcmWrapper_io_sram_mask_13;
  wire         _dtcmWrapper_io_sram_mask_14;
  wire         _dtcmWrapper_io_sram_mask_15;
  wire [7:0]   _dtcm_io_rdata_0;
  wire [7:0]   _dtcm_io_rdata_1;
  wire [7:0]   _dtcm_io_rdata_2;
  wire [7:0]   _dtcm_io_rdata_3;
  wire [7:0]   _dtcm_io_rdata_4;
  wire [7:0]   _dtcm_io_rdata_5;
  wire [7:0]   _dtcm_io_rdata_6;
  wire [7:0]   _dtcm_io_rdata_7;
  wire [7:0]   _dtcm_io_rdata_8;
  wire [7:0]   _dtcm_io_rdata_9;
  wire [7:0]   _dtcm_io_rdata_10;
  wire [7:0]   _dtcm_io_rdata_11;
  wire [7:0]   _dtcm_io_rdata_12;
  wire [7:0]   _dtcm_io_rdata_13;
  wire [7:0]   _dtcm_io_rdata_14;
  wire [7:0]   _dtcm_io_rdata_15;
  wire [127:0] _itcmArbiter_io_source_0_readData_bits;
  wire         _itcmArbiter_io_source_1_readData_valid;
  wire [127:0] _itcmArbiter_io_source_1_readData_bits;
  wire         _itcmArbiter_io_fabricBusy_1;
  wire         _itcmArbiter_io_port_readDataAddr_valid;
  wire [31:0]  _itcmArbiter_io_port_readDataAddr_bits;
  wire         _itcmArbiter_io_port_writeDataAddr_valid;
  wire [31:0]  _itcmArbiter_io_port_writeDataAddr_bits;
  wire [127:0] _itcmArbiter_io_port_writeDataBits;
  wire [15:0]  _itcmArbiter_io_port_writeDataStrb;
  wire         _itcmWrapper_io_fabric_readData_valid;
  wire [127:0] _itcmWrapper_io_fabric_readData_bits;
  wire [8:0]   _itcmWrapper_io_sram_address;
  wire         _itcmWrapper_io_sram_enable;
  wire         _itcmWrapper_io_sram_isWrite;
  wire [7:0]   _itcmWrapper_io_sram_writeData_0;
  wire [7:0]   _itcmWrapper_io_sram_writeData_1;
  wire [7:0]   _itcmWrapper_io_sram_writeData_2;
  wire [7:0]   _itcmWrapper_io_sram_writeData_3;
  wire [7:0]   _itcmWrapper_io_sram_writeData_4;
  wire [7:0]   _itcmWrapper_io_sram_writeData_5;
  wire [7:0]   _itcmWrapper_io_sram_writeData_6;
  wire [7:0]   _itcmWrapper_io_sram_writeData_7;
  wire [7:0]   _itcmWrapper_io_sram_writeData_8;
  wire [7:0]   _itcmWrapper_io_sram_writeData_9;
  wire [7:0]   _itcmWrapper_io_sram_writeData_10;
  wire [7:0]   _itcmWrapper_io_sram_writeData_11;
  wire [7:0]   _itcmWrapper_io_sram_writeData_12;
  wire [7:0]   _itcmWrapper_io_sram_writeData_13;
  wire [7:0]   _itcmWrapper_io_sram_writeData_14;
  wire [7:0]   _itcmWrapper_io_sram_writeData_15;
  wire         _itcmWrapper_io_sram_mask_0;
  wire         _itcmWrapper_io_sram_mask_1;
  wire         _itcmWrapper_io_sram_mask_2;
  wire         _itcmWrapper_io_sram_mask_3;
  wire         _itcmWrapper_io_sram_mask_4;
  wire         _itcmWrapper_io_sram_mask_5;
  wire         _itcmWrapper_io_sram_mask_6;
  wire         _itcmWrapper_io_sram_mask_7;
  wire         _itcmWrapper_io_sram_mask_8;
  wire         _itcmWrapper_io_sram_mask_9;
  wire         _itcmWrapper_io_sram_mask_10;
  wire         _itcmWrapper_io_sram_mask_11;
  wire         _itcmWrapper_io_sram_mask_12;
  wire         _itcmWrapper_io_sram_mask_13;
  wire         _itcmWrapper_io_sram_mask_14;
  wire         _itcmWrapper_io_sram_mask_15;
  wire [7:0]   _itcm_io_rdata_0;
  wire [7:0]   _itcm_io_rdata_1;
  wire [7:0]   _itcm_io_rdata_2;
  wire [7:0]   _itcm_io_rdata_3;
  wire [7:0]   _itcm_io_rdata_4;
  wire [7:0]   _itcm_io_rdata_5;
  wire [7:0]   _itcm_io_rdata_6;
  wire [7:0]   _itcm_io_rdata_7;
  wire [7:0]   _itcm_io_rdata_8;
  wire [7:0]   _itcm_io_rdata_9;
  wire [7:0]   _itcm_io_rdata_10;
  wire [7:0]   _itcm_io_rdata_11;
  wire [7:0]   _itcm_io_rdata_12;
  wire [7:0]   _itcm_io_rdata_13;
  wire [7:0]   _itcm_io_rdata_14;
  wire [7:0]   _itcm_io_rdata_15;
  wire [31:0]  _core_io_csr_out_value_0;
  wire [31:0]  _core_io_csr_out_value_1;
  wire [31:0]  _core_io_csr_out_value_2;
  wire [31:0]  _core_io_csr_out_value_3;
  wire [31:0]  _core_io_csr_out_value_4;
  wire [31:0]  _core_io_csr_out_value_5;
  wire [31:0]  _core_io_csr_out_value_6;
  wire [31:0]  _core_io_csr_out_value_7;
  wire [31:0]  _core_io_csr_out_value_8;
  wire         _core_io_halted;
  wire         _core_io_fault;
  wire         _core_io_wfi;
  wire         _core_io_ibus_valid;
  wire [31:0]  _core_io_ibus_addr;
  wire         _core_io_dbus_valid;
  wire         _core_io_dbus_write;
  wire [31:0]  _core_io_dbus_addr;
  wire [127:0] _core_io_dbus_wdata;
  wire [15:0]  _core_io_dbus_wmask;
  wire         _core_io_ebus_dbus_valid;
  wire         _core_io_ebus_dbus_write;
  wire [31:0]  _core_io_ebus_dbus_pc;
  wire [31:0]  _core_io_ebus_dbus_addr;
  wire [4:0]   _core_io_ebus_dbus_size;
  wire [127:0] _core_io_ebus_dbus_wdata;
  wire [15:0]  _core_io_ebus_dbus_wmask;
  wire         _cg_clk_o;
  wire         _csr_io_fabric_readData_valid;
  wire [127:0] _csr_io_fabric_readData_bits;
  wire         _csr_io_fabric_writeResp;
  wire         _csr_io_reset;
  wire         _csr_io_cg;
  wire [31:0]  _csr_io_pcStart;
  wire         _rst_sync_clk_o;
  wire         _rst_sync_rstn_o;
  wire         _global_reset_T_2 = ~(io_te ? io_aresetn : _rst_sync_rstn_o);
  reg          axiSlaveEnable;
  always @(posedge _rst_sync_clk_o or posedge _global_reset_T_2) begin
    if (_global_reset_T_2)
      axiSlaveEnable <= 1'h0;
    else
      axiSlaveEnable <= 1'h1;
  end // always @(posedge, posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    logic [31:0] _RANDOM[0:0];
    initial begin
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        axiSlaveEnable = _RANDOM[/*Zero width*/ 1'b0][0];
      `endif // RANDOMIZE_REG_INIT
      if (_global_reset_T_2)
        axiSlaveEnable = 1'h0;
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  RstSync rst_sync (
    .clk_i  (io_aclk),
    .rstn_i (io_aresetn),
    .clk_en (1'h1),
    .te     (io_te),
    .clk_o  (_rst_sync_clk_o),
    .rstn_o (_rst_sync_rstn_o)
  );
  CoreCSR csr (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_bits   (_fabricMux_io_ports_2_readDataAddr_bits),
    .io_fabric_readData_valid      (_csr_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_csr_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_fabricMux_io_ports_2_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_fabricMux_io_ports_2_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_fabricMux_io_ports_2_writeDataBits),
    .io_fabric_writeResp           (_csr_io_fabric_writeResp),
    .io_reset                      (_csr_io_reset),
    .io_cg                         (_csr_io_cg),
    .io_pcStart                    (_csr_io_pcStart),
    .io_halted                     (_core_io_halted),
    .io_fault                      (_core_io_fault),
    .io_coralnpu_csr_value_0       (_core_io_csr_out_value_0),
    .io_coralnpu_csr_value_1       (_core_io_csr_out_value_1),
    .io_coralnpu_csr_value_2       (_core_io_csr_out_value_2),
    .io_coralnpu_csr_value_3       (_core_io_csr_out_value_3),
    .io_coralnpu_csr_value_4       (_core_io_csr_out_value_4),
    .io_coralnpu_csr_value_5       (_core_io_csr_out_value_5),
    .io_coralnpu_csr_value_6       (_core_io_csr_out_value_6),
    .io_coralnpu_csr_value_7       (_core_io_csr_out_value_7),
    .io_coralnpu_csr_value_8       (_core_io_csr_out_value_8)
  );
  ClockGate cg (
    .clk_i  (_rst_sync_clk_o),
    .enable (io_irq | ~_csr_io_cg & ~_core_io_wfi),
    .te     (io_te),
    .clk_o  (_cg_clk_o)
  );
  RvvCoreMini core (
    .clock                                  (_cg_clk_o),
    .reset                                  (io_te ? ~io_aresetn : _csr_io_reset),
    .io_csr_in_value_0                      (_csr_io_pcStart),
    .io_csr_out_value_0                     (_core_io_csr_out_value_0),
    .io_csr_out_value_1                     (_core_io_csr_out_value_1),
    .io_csr_out_value_2                     (_core_io_csr_out_value_2),
    .io_csr_out_value_3                     (_core_io_csr_out_value_3),
    .io_csr_out_value_4                     (_core_io_csr_out_value_4),
    .io_csr_out_value_5                     (_core_io_csr_out_value_5),
    .io_csr_out_value_6                     (_core_io_csr_out_value_6),
    .io_csr_out_value_7                     (_core_io_csr_out_value_7),
    .io_csr_out_value_8                     (_core_io_csr_out_value_8),
    .io_halted                              (_core_io_halted),
    .io_fault                               (_core_io_fault),
    .io_wfi                                 (_core_io_wfi),
    .io_irq                                 (io_irq),
    .io_ibus_valid                          (_core_io_ibus_valid),
    .io_ibus_addr                           (_core_io_ibus_addr),
    .io_ibus_rdata                          (_itcmArbiter_io_source_0_readData_bits),
    .io_ibus_fault_valid
      (_core_io_ibus_valid & (|(_core_io_ibus_addr[31:13]))),
    .io_dbus_valid                          (_core_io_dbus_valid),
    .io_dbus_write                          (_core_io_dbus_write),
    .io_dbus_addr                           (_core_io_dbus_addr),
    .io_dbus_wdata                          (_core_io_dbus_wdata),
    .io_dbus_wmask                          (_core_io_dbus_wmask),
    .io_dbus_rdata                          (_dtcmArbiter_io_source_0_readData_bits),
    .io_ebus_dbus_valid                     (_core_io_ebus_dbus_valid),
    .io_ebus_dbus_ready                     (_ebus2axi_io_dbus_ready),
    .io_ebus_dbus_write                     (_core_io_ebus_dbus_write),
    .io_ebus_dbus_pc                        (_core_io_ebus_dbus_pc),
    .io_ebus_dbus_addr                      (_core_io_ebus_dbus_addr),
    .io_ebus_dbus_size                      (_core_io_ebus_dbus_size),
    .io_ebus_dbus_wdata                     (_core_io_ebus_dbus_wdata),
    .io_ebus_dbus_wmask                     (_core_io_ebus_dbus_wmask),
    .io_ebus_dbus_rdata                     (_ebus2axi_io_dbus_rdata),
    .io_ebus_fault_valid                    (_ebus2axi_io_fault_valid),
    .io_ebus_fault_bits_write               (_ebus2axi_io_fault_bits_write),
    .io_ebus_fault_bits_addr                (_ebus2axi_io_fault_bits_addr),
    .io_ebus_fault_bits_epc                 (_ebus2axi_io_fault_bits_epc),
    .io_slog_valid                          (io_slog_valid),
    .io_slog_addr                           (io_slog_addr),
    .io_slog_data                           (io_slog_data),
    .io_debug_en                            (io_debug_en),
    .io_debug_addr_0                        (io_debug_addr_0),
    .io_debug_addr_1                        (io_debug_addr_1),
    .io_debug_addr_2                        (io_debug_addr_2),
    .io_debug_addr_3                        (io_debug_addr_3),
    .io_debug_inst_0                        (io_debug_inst_0),
    .io_debug_inst_1                        (io_debug_inst_1),
    .io_debug_inst_2                        (io_debug_inst_2),
    .io_debug_inst_3                        (io_debug_inst_3),
    .io_debug_cycles                        (io_debug_cycles),
    .io_debug_dbus_valid                    (io_debug_dbus_valid),
    .io_debug_dbus_bits_addr                (io_debug_dbus_bits_addr),
    .io_debug_dbus_bits_wdata               (io_debug_dbus_bits_wdata),
    .io_debug_dbus_bits_write               (io_debug_dbus_bits_write),
    .io_debug_dispatch_0_instFire           (io_debug_dispatch_0_instFire),
    .io_debug_dispatch_0_instAddr           (io_debug_dispatch_0_instAddr),
    .io_debug_dispatch_0_instInst           (io_debug_dispatch_0_instInst),
    .io_debug_dispatch_1_instFire           (io_debug_dispatch_1_instFire),
    .io_debug_dispatch_1_instAddr           (io_debug_dispatch_1_instAddr),
    .io_debug_dispatch_1_instInst           (io_debug_dispatch_1_instInst),
    .io_debug_dispatch_2_instFire           (io_debug_dispatch_2_instFire),
    .io_debug_dispatch_2_instAddr           (io_debug_dispatch_2_instAddr),
    .io_debug_dispatch_2_instInst           (io_debug_dispatch_2_instInst),
    .io_debug_dispatch_3_instFire           (io_debug_dispatch_3_instFire),
    .io_debug_dispatch_3_instAddr           (io_debug_dispatch_3_instAddr),
    .io_debug_dispatch_3_instInst           (io_debug_dispatch_3_instInst),
    .io_debug_regfile_writeAddr_0_valid     (io_debug_regfile_writeAddr_0_valid),
    .io_debug_regfile_writeAddr_0_bits      (io_debug_regfile_writeAddr_0_bits),
    .io_debug_regfile_writeAddr_1_valid     (io_debug_regfile_writeAddr_1_valid),
    .io_debug_regfile_writeAddr_1_bits      (io_debug_regfile_writeAddr_1_bits),
    .io_debug_regfile_writeAddr_2_valid     (io_debug_regfile_writeAddr_2_valid),
    .io_debug_regfile_writeAddr_2_bits      (io_debug_regfile_writeAddr_2_bits),
    .io_debug_regfile_writeAddr_3_valid     (io_debug_regfile_writeAddr_3_valid),
    .io_debug_regfile_writeAddr_3_bits      (io_debug_regfile_writeAddr_3_bits),
    .io_debug_regfile_writeData_0_valid     (io_debug_regfile_writeData_0_valid),
    .io_debug_regfile_writeData_0_bits_addr (io_debug_regfile_writeData_0_bits_addr),
    .io_debug_regfile_writeData_0_bits_data (io_debug_regfile_writeData_0_bits_data),
    .io_debug_regfile_writeData_1_valid     (io_debug_regfile_writeData_1_valid),
    .io_debug_regfile_writeData_1_bits_addr (io_debug_regfile_writeData_1_bits_addr),
    .io_debug_regfile_writeData_1_bits_data (io_debug_regfile_writeData_1_bits_data),
    .io_debug_regfile_writeData_2_valid     (io_debug_regfile_writeData_2_valid),
    .io_debug_regfile_writeData_2_bits_addr (io_debug_regfile_writeData_2_bits_addr),
    .io_debug_regfile_writeData_2_bits_data (io_debug_regfile_writeData_2_bits_data),
    .io_debug_regfile_writeData_3_valid     (io_debug_regfile_writeData_3_valid),
    .io_debug_regfile_writeData_3_bits_addr (io_debug_regfile_writeData_3_bits_addr),
    .io_debug_regfile_writeData_3_bits_data (io_debug_regfile_writeData_3_bits_data),
    .io_debug_regfile_writeData_4_valid     (io_debug_regfile_writeData_4_valid),
    .io_debug_regfile_writeData_4_bits_addr (io_debug_regfile_writeData_4_bits_addr),
    .io_debug_regfile_writeData_4_bits_data (io_debug_regfile_writeData_4_bits_data),
    .io_debug_regfile_writeData_5_valid     (io_debug_regfile_writeData_5_valid),
    .io_debug_regfile_writeData_5_bits_addr (io_debug_regfile_writeData_5_bits_addr),
    .io_debug_regfile_writeData_5_bits_data (io_debug_regfile_writeData_5_bits_data),
    .io_debug_float_writeAddr_valid         (io_debug_float_writeAddr_valid),
    .io_debug_float_writeAddr_bits          (io_debug_float_writeAddr_bits),
    .io_debug_float_writeData_0_valid       (io_debug_float_writeData_0_valid),
    .io_debug_float_writeData_0_bits_addr   (io_debug_float_writeData_0_bits_addr),
    .io_debug_float_writeData_0_bits_data   (io_debug_float_writeData_0_bits_data),
    .io_debug_float_writeData_1_valid       (io_debug_float_writeData_1_valid),
    .io_debug_float_writeData_1_bits_addr   (io_debug_float_writeData_1_bits_addr),
    .io_debug_float_writeData_1_bits_data   (io_debug_float_writeData_1_bits_data),
    .io_debug_rb_inst_0_valid               (io_debug_rb_inst_0_valid),
    .io_debug_rb_inst_0_bits_pc             (io_debug_rb_inst_0_bits_pc),
    .io_debug_rb_inst_0_bits_idx            (io_debug_rb_inst_0_bits_idx),
    .io_debug_rb_inst_0_bits_trap           (io_debug_rb_inst_0_bits_trap),
    .io_debug_rb_inst_1_valid               (io_debug_rb_inst_1_valid),
    .io_debug_rb_inst_1_bits_pc             (io_debug_rb_inst_1_bits_pc),
    .io_debug_rb_inst_1_bits_idx            (io_debug_rb_inst_1_bits_idx),
    .io_debug_rb_inst_1_bits_trap           (io_debug_rb_inst_1_bits_trap),
    .io_debug_rb_inst_2_valid               (io_debug_rb_inst_2_valid),
    .io_debug_rb_inst_2_bits_pc             (io_debug_rb_inst_2_bits_pc),
    .io_debug_rb_inst_2_bits_idx            (io_debug_rb_inst_2_bits_idx),
    .io_debug_rb_inst_2_bits_trap           (io_debug_rb_inst_2_bits_trap),
    .io_debug_rb_inst_3_valid               (io_debug_rb_inst_3_valid),
    .io_debug_rb_inst_3_bits_pc             (io_debug_rb_inst_3_bits_pc),
    .io_debug_rb_inst_3_bits_idx            (io_debug_rb_inst_3_bits_idx),
    .io_debug_rb_inst_3_bits_trap           (io_debug_rb_inst_3_bits_trap),
    .io_debug_rb_inst_4_valid               (io_debug_rb_inst_4_valid),
    .io_debug_rb_inst_4_bits_pc             (io_debug_rb_inst_4_bits_pc),
    .io_debug_rb_inst_4_bits_idx            (io_debug_rb_inst_4_bits_idx),
    .io_debug_rb_inst_4_bits_trap           (io_debug_rb_inst_4_bits_trap),
    .io_debug_rb_inst_5_valid               (io_debug_rb_inst_5_valid),
    .io_debug_rb_inst_5_bits_pc             (io_debug_rb_inst_5_bits_pc),
    .io_debug_rb_inst_5_bits_idx            (io_debug_rb_inst_5_bits_idx),
    .io_debug_rb_inst_5_bits_trap           (io_debug_rb_inst_5_bits_trap),
    .io_debug_rb_inst_6_valid               (io_debug_rb_inst_6_valid),
    .io_debug_rb_inst_6_bits_pc             (io_debug_rb_inst_6_bits_pc),
    .io_debug_rb_inst_6_bits_idx            (io_debug_rb_inst_6_bits_idx),
    .io_debug_rb_inst_6_bits_trap           (io_debug_rb_inst_6_bits_trap),
    .io_debug_rb_inst_7_valid               (io_debug_rb_inst_7_valid),
    .io_debug_rb_inst_7_bits_pc             (io_debug_rb_inst_7_bits_pc),
    .io_debug_rb_inst_7_bits_idx            (io_debug_rb_inst_7_bits_idx),
    .io_debug_rb_inst_7_bits_trap           (io_debug_rb_inst_7_bits_trap)
  );
  TCM128 itcm (
    .clock       (_rst_sync_clk_o),
    .io_addr     (_itcmWrapper_io_sram_address),
    .io_enable   (_itcmWrapper_io_sram_enable),
    .io_write    (_itcmWrapper_io_sram_isWrite),
    .io_wdata_0  (_itcmWrapper_io_sram_writeData_0),
    .io_wdata_1  (_itcmWrapper_io_sram_writeData_1),
    .io_wdata_2  (_itcmWrapper_io_sram_writeData_2),
    .io_wdata_3  (_itcmWrapper_io_sram_writeData_3),
    .io_wdata_4  (_itcmWrapper_io_sram_writeData_4),
    .io_wdata_5  (_itcmWrapper_io_sram_writeData_5),
    .io_wdata_6  (_itcmWrapper_io_sram_writeData_6),
    .io_wdata_7  (_itcmWrapper_io_sram_writeData_7),
    .io_wdata_8  (_itcmWrapper_io_sram_writeData_8),
    .io_wdata_9  (_itcmWrapper_io_sram_writeData_9),
    .io_wdata_10 (_itcmWrapper_io_sram_writeData_10),
    .io_wdata_11 (_itcmWrapper_io_sram_writeData_11),
    .io_wdata_12 (_itcmWrapper_io_sram_writeData_12),
    .io_wdata_13 (_itcmWrapper_io_sram_writeData_13),
    .io_wdata_14 (_itcmWrapper_io_sram_writeData_14),
    .io_wdata_15 (_itcmWrapper_io_sram_writeData_15),
    .io_wmask_0  (_itcmWrapper_io_sram_mask_0),
    .io_wmask_1  (_itcmWrapper_io_sram_mask_1),
    .io_wmask_2  (_itcmWrapper_io_sram_mask_2),
    .io_wmask_3  (_itcmWrapper_io_sram_mask_3),
    .io_wmask_4  (_itcmWrapper_io_sram_mask_4),
    .io_wmask_5  (_itcmWrapper_io_sram_mask_5),
    .io_wmask_6  (_itcmWrapper_io_sram_mask_6),
    .io_wmask_7  (_itcmWrapper_io_sram_mask_7),
    .io_wmask_8  (_itcmWrapper_io_sram_mask_8),
    .io_wmask_9  (_itcmWrapper_io_sram_mask_9),
    .io_wmask_10 (_itcmWrapper_io_sram_mask_10),
    .io_wmask_11 (_itcmWrapper_io_sram_mask_11),
    .io_wmask_12 (_itcmWrapper_io_sram_mask_12),
    .io_wmask_13 (_itcmWrapper_io_sram_mask_13),
    .io_wmask_14 (_itcmWrapper_io_sram_mask_14),
    .io_wmask_15 (_itcmWrapper_io_sram_mask_15),
    .io_rdata_0  (_itcm_io_rdata_0),
    .io_rdata_1  (_itcm_io_rdata_1),
    .io_rdata_2  (_itcm_io_rdata_2),
    .io_rdata_3  (_itcm_io_rdata_3),
    .io_rdata_4  (_itcm_io_rdata_4),
    .io_rdata_5  (_itcm_io_rdata_5),
    .io_rdata_6  (_itcm_io_rdata_6),
    .io_rdata_7  (_itcm_io_rdata_7),
    .io_rdata_8  (_itcm_io_rdata_8),
    .io_rdata_9  (_itcm_io_rdata_9),
    .io_rdata_10 (_itcm_io_rdata_10),
    .io_rdata_11 (_itcm_io_rdata_11),
    .io_rdata_12 (_itcm_io_rdata_12),
    .io_rdata_13 (_itcm_io_rdata_13),
    .io_rdata_14 (_itcm_io_rdata_14),
    .io_rdata_15 (_itcm_io_rdata_15)
  );
  SRAM itcmWrapper (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_valid  (_itcmArbiter_io_port_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_itcmArbiter_io_port_readDataAddr_bits),
    .io_fabric_readData_valid      (_itcmWrapper_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_itcmWrapper_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_itcmArbiter_io_port_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_itcmArbiter_io_port_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_itcmArbiter_io_port_writeDataBits),
    .io_fabric_writeDataStrb       (_itcmArbiter_io_port_writeDataStrb),
    .io_sram_address               (_itcmWrapper_io_sram_address),
    .io_sram_enable                (_itcmWrapper_io_sram_enable),
    .io_sram_isWrite               (_itcmWrapper_io_sram_isWrite),
    .io_sram_readData_0            (_itcm_io_rdata_0),
    .io_sram_readData_1            (_itcm_io_rdata_1),
    .io_sram_readData_2            (_itcm_io_rdata_2),
    .io_sram_readData_3            (_itcm_io_rdata_3),
    .io_sram_readData_4            (_itcm_io_rdata_4),
    .io_sram_readData_5            (_itcm_io_rdata_5),
    .io_sram_readData_6            (_itcm_io_rdata_6),
    .io_sram_readData_7            (_itcm_io_rdata_7),
    .io_sram_readData_8            (_itcm_io_rdata_8),
    .io_sram_readData_9            (_itcm_io_rdata_9),
    .io_sram_readData_10           (_itcm_io_rdata_10),
    .io_sram_readData_11           (_itcm_io_rdata_11),
    .io_sram_readData_12           (_itcm_io_rdata_12),
    .io_sram_readData_13           (_itcm_io_rdata_13),
    .io_sram_readData_14           (_itcm_io_rdata_14),
    .io_sram_readData_15           (_itcm_io_rdata_15),
    .io_sram_writeData_0           (_itcmWrapper_io_sram_writeData_0),
    .io_sram_writeData_1           (_itcmWrapper_io_sram_writeData_1),
    .io_sram_writeData_2           (_itcmWrapper_io_sram_writeData_2),
    .io_sram_writeData_3           (_itcmWrapper_io_sram_writeData_3),
    .io_sram_writeData_4           (_itcmWrapper_io_sram_writeData_4),
    .io_sram_writeData_5           (_itcmWrapper_io_sram_writeData_5),
    .io_sram_writeData_6           (_itcmWrapper_io_sram_writeData_6),
    .io_sram_writeData_7           (_itcmWrapper_io_sram_writeData_7),
    .io_sram_writeData_8           (_itcmWrapper_io_sram_writeData_8),
    .io_sram_writeData_9           (_itcmWrapper_io_sram_writeData_9),
    .io_sram_writeData_10          (_itcmWrapper_io_sram_writeData_10),
    .io_sram_writeData_11          (_itcmWrapper_io_sram_writeData_11),
    .io_sram_writeData_12          (_itcmWrapper_io_sram_writeData_12),
    .io_sram_writeData_13          (_itcmWrapper_io_sram_writeData_13),
    .io_sram_writeData_14          (_itcmWrapper_io_sram_writeData_14),
    .io_sram_writeData_15          (_itcmWrapper_io_sram_writeData_15),
    .io_sram_mask_0                (_itcmWrapper_io_sram_mask_0),
    .io_sram_mask_1                (_itcmWrapper_io_sram_mask_1),
    .io_sram_mask_2                (_itcmWrapper_io_sram_mask_2),
    .io_sram_mask_3                (_itcmWrapper_io_sram_mask_3),
    .io_sram_mask_4                (_itcmWrapper_io_sram_mask_4),
    .io_sram_mask_5                (_itcmWrapper_io_sram_mask_5),
    .io_sram_mask_6                (_itcmWrapper_io_sram_mask_6),
    .io_sram_mask_7                (_itcmWrapper_io_sram_mask_7),
    .io_sram_mask_8                (_itcmWrapper_io_sram_mask_8),
    .io_sram_mask_9                (_itcmWrapper_io_sram_mask_9),
    .io_sram_mask_10               (_itcmWrapper_io_sram_mask_10),
    .io_sram_mask_11               (_itcmWrapper_io_sram_mask_11),
    .io_sram_mask_12               (_itcmWrapper_io_sram_mask_12),
    .io_sram_mask_13               (_itcmWrapper_io_sram_mask_13),
    .io_sram_mask_14               (_itcmWrapper_io_sram_mask_14),
    .io_sram_mask_15               (_itcmWrapper_io_sram_mask_15)
  );
  FabricArbiter itcmArbiter (
    .clock                           (_rst_sync_clk_o),
    .reset                           (_global_reset_T_2),
    .io_source_0_readDataAddr_valid  (_core_io_ibus_valid),
    .io_source_0_readDataAddr_bits   (_core_io_ibus_addr),
    .io_source_0_readData_bits       (_itcmArbiter_io_source_0_readData_bits),
    .io_source_0_writeDataAddr_valid (1'h0),
    .io_source_0_writeDataAddr_bits  (32'h0),
    .io_source_0_writeDataBits       (128'h0),
    .io_source_0_writeDataStrb       (16'h0),
    .io_source_1_readDataAddr_valid  (_fabricMux_io_ports_0_readDataAddr_valid),
    .io_source_1_readDataAddr_bits   (_fabricMux_io_ports_0_readDataAddr_bits),
    .io_source_1_readData_valid      (_itcmArbiter_io_source_1_readData_valid),
    .io_source_1_readData_bits       (_itcmArbiter_io_source_1_readData_bits),
    .io_source_1_writeDataAddr_valid (_fabricMux_io_ports_0_writeDataAddr_valid),
    .io_source_1_writeDataAddr_bits  (_fabricMux_io_ports_0_writeDataAddr_bits),
    .io_source_1_writeDataBits       (_fabricMux_io_ports_0_writeDataBits),
    .io_source_1_writeDataStrb       (_fabricMux_io_ports_0_writeDataStrb),
    .io_fabricBusy_1                 (_itcmArbiter_io_fabricBusy_1),
    .io_port_readDataAddr_valid      (_itcmArbiter_io_port_readDataAddr_valid),
    .io_port_readDataAddr_bits       (_itcmArbiter_io_port_readDataAddr_bits),
    .io_port_readData_valid          (_itcmWrapper_io_fabric_readData_valid),
    .io_port_readData_bits           (_itcmWrapper_io_fabric_readData_bits),
    .io_port_writeDataAddr_valid     (_itcmArbiter_io_port_writeDataAddr_valid),
    .io_port_writeDataAddr_bits      (_itcmArbiter_io_port_writeDataAddr_bits),
    .io_port_writeDataBits           (_itcmArbiter_io_port_writeDataBits),
    .io_port_writeDataStrb           (_itcmArbiter_io_port_writeDataStrb)
  );
  TCM128_1 dtcm (
    .clock       (_rst_sync_clk_o),
    .io_addr     (_dtcmWrapper_io_sram_address),
    .io_enable   (_dtcmWrapper_io_sram_enable),
    .io_write    (_dtcmWrapper_io_sram_isWrite),
    .io_wdata_0  (_dtcmWrapper_io_sram_writeData_0),
    .io_wdata_1  (_dtcmWrapper_io_sram_writeData_1),
    .io_wdata_2  (_dtcmWrapper_io_sram_writeData_2),
    .io_wdata_3  (_dtcmWrapper_io_sram_writeData_3),
    .io_wdata_4  (_dtcmWrapper_io_sram_writeData_4),
    .io_wdata_5  (_dtcmWrapper_io_sram_writeData_5),
    .io_wdata_6  (_dtcmWrapper_io_sram_writeData_6),
    .io_wdata_7  (_dtcmWrapper_io_sram_writeData_7),
    .io_wdata_8  (_dtcmWrapper_io_sram_writeData_8),
    .io_wdata_9  (_dtcmWrapper_io_sram_writeData_9),
    .io_wdata_10 (_dtcmWrapper_io_sram_writeData_10),
    .io_wdata_11 (_dtcmWrapper_io_sram_writeData_11),
    .io_wdata_12 (_dtcmWrapper_io_sram_writeData_12),
    .io_wdata_13 (_dtcmWrapper_io_sram_writeData_13),
    .io_wdata_14 (_dtcmWrapper_io_sram_writeData_14),
    .io_wdata_15 (_dtcmWrapper_io_sram_writeData_15),
    .io_wmask_0  (_dtcmWrapper_io_sram_mask_0),
    .io_wmask_1  (_dtcmWrapper_io_sram_mask_1),
    .io_wmask_2  (_dtcmWrapper_io_sram_mask_2),
    .io_wmask_3  (_dtcmWrapper_io_sram_mask_3),
    .io_wmask_4  (_dtcmWrapper_io_sram_mask_4),
    .io_wmask_5  (_dtcmWrapper_io_sram_mask_5),
    .io_wmask_6  (_dtcmWrapper_io_sram_mask_6),
    .io_wmask_7  (_dtcmWrapper_io_sram_mask_7),
    .io_wmask_8  (_dtcmWrapper_io_sram_mask_8),
    .io_wmask_9  (_dtcmWrapper_io_sram_mask_9),
    .io_wmask_10 (_dtcmWrapper_io_sram_mask_10),
    .io_wmask_11 (_dtcmWrapper_io_sram_mask_11),
    .io_wmask_12 (_dtcmWrapper_io_sram_mask_12),
    .io_wmask_13 (_dtcmWrapper_io_sram_mask_13),
    .io_wmask_14 (_dtcmWrapper_io_sram_mask_14),
    .io_wmask_15 (_dtcmWrapper_io_sram_mask_15),
    .io_rdata_0  (_dtcm_io_rdata_0),
    .io_rdata_1  (_dtcm_io_rdata_1),
    .io_rdata_2  (_dtcm_io_rdata_2),
    .io_rdata_3  (_dtcm_io_rdata_3),
    .io_rdata_4  (_dtcm_io_rdata_4),
    .io_rdata_5  (_dtcm_io_rdata_5),
    .io_rdata_6  (_dtcm_io_rdata_6),
    .io_rdata_7  (_dtcm_io_rdata_7),
    .io_rdata_8  (_dtcm_io_rdata_8),
    .io_rdata_9  (_dtcm_io_rdata_9),
    .io_rdata_10 (_dtcm_io_rdata_10),
    .io_rdata_11 (_dtcm_io_rdata_11),
    .io_rdata_12 (_dtcm_io_rdata_12),
    .io_rdata_13 (_dtcm_io_rdata_13),
    .io_rdata_14 (_dtcm_io_rdata_14),
    .io_rdata_15 (_dtcm_io_rdata_15)
  );
  SRAM_1 dtcmWrapper (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_fabric_readDataAddr_valid  (_dtcmArbiter_io_port_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_dtcmArbiter_io_port_readDataAddr_bits),
    .io_fabric_readData_valid      (_dtcmWrapper_io_fabric_readData_valid),
    .io_fabric_readData_bits       (_dtcmWrapper_io_fabric_readData_bits),
    .io_fabric_writeDataAddr_valid (_dtcmArbiter_io_port_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_dtcmArbiter_io_port_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_dtcmArbiter_io_port_writeDataBits),
    .io_fabric_writeDataStrb       (_dtcmArbiter_io_port_writeDataStrb),
    .io_sram_address               (_dtcmWrapper_io_sram_address),
    .io_sram_enable                (_dtcmWrapper_io_sram_enable),
    .io_sram_isWrite               (_dtcmWrapper_io_sram_isWrite),
    .io_sram_readData_0            (_dtcm_io_rdata_0),
    .io_sram_readData_1            (_dtcm_io_rdata_1),
    .io_sram_readData_2            (_dtcm_io_rdata_2),
    .io_sram_readData_3            (_dtcm_io_rdata_3),
    .io_sram_readData_4            (_dtcm_io_rdata_4),
    .io_sram_readData_5            (_dtcm_io_rdata_5),
    .io_sram_readData_6            (_dtcm_io_rdata_6),
    .io_sram_readData_7            (_dtcm_io_rdata_7),
    .io_sram_readData_8            (_dtcm_io_rdata_8),
    .io_sram_readData_9            (_dtcm_io_rdata_9),
    .io_sram_readData_10           (_dtcm_io_rdata_10),
    .io_sram_readData_11           (_dtcm_io_rdata_11),
    .io_sram_readData_12           (_dtcm_io_rdata_12),
    .io_sram_readData_13           (_dtcm_io_rdata_13),
    .io_sram_readData_14           (_dtcm_io_rdata_14),
    .io_sram_readData_15           (_dtcm_io_rdata_15),
    .io_sram_writeData_0           (_dtcmWrapper_io_sram_writeData_0),
    .io_sram_writeData_1           (_dtcmWrapper_io_sram_writeData_1),
    .io_sram_writeData_2           (_dtcmWrapper_io_sram_writeData_2),
    .io_sram_writeData_3           (_dtcmWrapper_io_sram_writeData_3),
    .io_sram_writeData_4           (_dtcmWrapper_io_sram_writeData_4),
    .io_sram_writeData_5           (_dtcmWrapper_io_sram_writeData_5),
    .io_sram_writeData_6           (_dtcmWrapper_io_sram_writeData_6),
    .io_sram_writeData_7           (_dtcmWrapper_io_sram_writeData_7),
    .io_sram_writeData_8           (_dtcmWrapper_io_sram_writeData_8),
    .io_sram_writeData_9           (_dtcmWrapper_io_sram_writeData_9),
    .io_sram_writeData_10          (_dtcmWrapper_io_sram_writeData_10),
    .io_sram_writeData_11          (_dtcmWrapper_io_sram_writeData_11),
    .io_sram_writeData_12          (_dtcmWrapper_io_sram_writeData_12),
    .io_sram_writeData_13          (_dtcmWrapper_io_sram_writeData_13),
    .io_sram_writeData_14          (_dtcmWrapper_io_sram_writeData_14),
    .io_sram_writeData_15          (_dtcmWrapper_io_sram_writeData_15),
    .io_sram_mask_0                (_dtcmWrapper_io_sram_mask_0),
    .io_sram_mask_1                (_dtcmWrapper_io_sram_mask_1),
    .io_sram_mask_2                (_dtcmWrapper_io_sram_mask_2),
    .io_sram_mask_3                (_dtcmWrapper_io_sram_mask_3),
    .io_sram_mask_4                (_dtcmWrapper_io_sram_mask_4),
    .io_sram_mask_5                (_dtcmWrapper_io_sram_mask_5),
    .io_sram_mask_6                (_dtcmWrapper_io_sram_mask_6),
    .io_sram_mask_7                (_dtcmWrapper_io_sram_mask_7),
    .io_sram_mask_8                (_dtcmWrapper_io_sram_mask_8),
    .io_sram_mask_9                (_dtcmWrapper_io_sram_mask_9),
    .io_sram_mask_10               (_dtcmWrapper_io_sram_mask_10),
    .io_sram_mask_11               (_dtcmWrapper_io_sram_mask_11),
    .io_sram_mask_12               (_dtcmWrapper_io_sram_mask_12),
    .io_sram_mask_13               (_dtcmWrapper_io_sram_mask_13),
    .io_sram_mask_14               (_dtcmWrapper_io_sram_mask_14),
    .io_sram_mask_15               (_dtcmWrapper_io_sram_mask_15)
  );
  FabricArbiter dtcmArbiter (
    .clock                           (_rst_sync_clk_o),
    .reset                           (_global_reset_T_2),
    .io_source_0_readDataAddr_valid  (_core_io_dbus_valid & ~_core_io_dbus_write),
    .io_source_0_readDataAddr_bits   (_core_io_dbus_addr),
    .io_source_0_readData_bits       (_dtcmArbiter_io_source_0_readData_bits),
    .io_source_0_writeDataAddr_valid (_core_io_dbus_valid & _core_io_dbus_write),
    .io_source_0_writeDataAddr_bits  (_core_io_dbus_addr),
    .io_source_0_writeDataBits       (_core_io_dbus_wdata),
    .io_source_0_writeDataStrb       (_core_io_dbus_wmask),
    .io_source_1_readDataAddr_valid  (_fabricMux_io_ports_1_readDataAddr_valid),
    .io_source_1_readDataAddr_bits   (_fabricMux_io_ports_1_readDataAddr_bits),
    .io_source_1_readData_valid      (_dtcmArbiter_io_source_1_readData_valid),
    .io_source_1_readData_bits       (_dtcmArbiter_io_source_1_readData_bits),
    .io_source_1_writeDataAddr_valid (_fabricMux_io_ports_1_writeDataAddr_valid),
    .io_source_1_writeDataAddr_bits  (_fabricMux_io_ports_1_writeDataAddr_bits),
    .io_source_1_writeDataBits       (_fabricMux_io_ports_1_writeDataBits),
    .io_source_1_writeDataStrb       (_fabricMux_io_ports_1_writeDataStrb),
    .io_fabricBusy_1                 (_dtcmArbiter_io_fabricBusy_1),
    .io_port_readDataAddr_valid      (_dtcmArbiter_io_port_readDataAddr_valid),
    .io_port_readDataAddr_bits       (_dtcmArbiter_io_port_readDataAddr_bits),
    .io_port_readData_valid          (_dtcmWrapper_io_fabric_readData_valid),
    .io_port_readData_bits           (_dtcmWrapper_io_fabric_readData_bits),
    .io_port_writeDataAddr_valid     (_dtcmArbiter_io_port_writeDataAddr_valid),
    .io_port_writeDataAddr_bits      (_dtcmArbiter_io_port_writeDataAddr_bits),
    .io_port_writeDataBits           (_dtcmArbiter_io_port_writeDataBits),
    .io_port_writeDataStrb           (_dtcmArbiter_io_port_writeDataStrb)
  );
  FabricMux fabricMux (
    .clock                          (_rst_sync_clk_o),
    .reset                          (_global_reset_T_2),
    .io_source_readDataAddr_valid   (_axiSlave_io_fabric_readDataAddr_valid),
    .io_source_readDataAddr_bits    (_axiSlave_io_fabric_readDataAddr_bits),
    .io_source_readData_valid       (_fabricMux_io_source_readData_valid),
    .io_source_readData_bits        (_fabricMux_io_source_readData_bits),
    .io_source_writeDataAddr_valid  (_axiSlave_io_fabric_writeDataAddr_valid),
    .io_source_writeDataAddr_bits   (_axiSlave_io_fabric_writeDataAddr_bits),
    .io_source_writeDataBits        (_axiSlave_io_fabric_writeDataBits),
    .io_source_writeDataStrb        (_axiSlave_io_fabric_writeDataStrb),
    .io_source_writeResp            (_fabricMux_io_source_writeResp),
    .io_fabricBusy                  (_fabricMux_io_fabricBusy),
    .io_ports_0_readDataAddr_valid  (_fabricMux_io_ports_0_readDataAddr_valid),
    .io_ports_0_readDataAddr_bits   (_fabricMux_io_ports_0_readDataAddr_bits),
    .io_ports_0_readData_valid      (_itcmArbiter_io_source_1_readData_valid),
    .io_ports_0_readData_bits       (_itcmArbiter_io_source_1_readData_bits),
    .io_ports_0_writeDataAddr_valid (_fabricMux_io_ports_0_writeDataAddr_valid),
    .io_ports_0_writeDataAddr_bits  (_fabricMux_io_ports_0_writeDataAddr_bits),
    .io_ports_0_writeDataBits       (_fabricMux_io_ports_0_writeDataBits),
    .io_ports_0_writeDataStrb       (_fabricMux_io_ports_0_writeDataStrb),
    .io_ports_1_readDataAddr_valid  (_fabricMux_io_ports_1_readDataAddr_valid),
    .io_ports_1_readDataAddr_bits   (_fabricMux_io_ports_1_readDataAddr_bits),
    .io_ports_1_readData_valid      (_dtcmArbiter_io_source_1_readData_valid),
    .io_ports_1_readData_bits       (_dtcmArbiter_io_source_1_readData_bits),
    .io_ports_1_writeDataAddr_valid (_fabricMux_io_ports_1_writeDataAddr_valid),
    .io_ports_1_writeDataAddr_bits  (_fabricMux_io_ports_1_writeDataAddr_bits),
    .io_ports_1_writeDataBits       (_fabricMux_io_ports_1_writeDataBits),
    .io_ports_1_writeDataStrb       (_fabricMux_io_ports_1_writeDataStrb),
    .io_ports_2_readDataAddr_bits   (_fabricMux_io_ports_2_readDataAddr_bits),
    .io_ports_2_readData_valid      (_csr_io_fabric_readData_valid),
    .io_ports_2_readData_bits       (_csr_io_fabric_readData_bits),
    .io_ports_2_writeDataAddr_valid (_fabricMux_io_ports_2_writeDataAddr_valid),
    .io_ports_2_writeDataAddr_bits  (_fabricMux_io_ports_2_writeDataAddr_bits),
    .io_ports_2_writeDataBits       (_fabricMux_io_ports_2_writeDataBits),
    .io_ports_2_writeResp           (_csr_io_fabric_writeResp),
    .io_periBusy_0                  (_itcmArbiter_io_fabricBusy_1),
    .io_periBusy_1                  (_dtcmArbiter_io_fabricBusy_1)
  );
  AxiSlave axiSlave (
    .clock                         (_rst_sync_clk_o),
    .reset                         (_global_reset_T_2),
    .io_axi_write_addr_ready       (_axiSlave_io_axi_write_addr_ready),
    .io_axi_write_addr_valid       (io_axi_slave_write_addr_valid & axiSlaveEnable),
    .io_axi_write_addr_bits_addr   (io_axi_slave_write_addr_bits_addr),
    .io_axi_write_addr_bits_prot   (io_axi_slave_write_addr_bits_prot),
    .io_axi_write_addr_bits_id     (io_axi_slave_write_addr_bits_id),
    .io_axi_write_addr_bits_len    (io_axi_slave_write_addr_bits_len),
    .io_axi_write_addr_bits_size   (io_axi_slave_write_addr_bits_size),
    .io_axi_write_addr_bits_burst  (io_axi_slave_write_addr_bits_burst),
    .io_axi_write_addr_bits_lock   (io_axi_slave_write_addr_bits_lock),
    .io_axi_write_addr_bits_cache  (io_axi_slave_write_addr_bits_cache),
    .io_axi_write_addr_bits_qos    (io_axi_slave_write_addr_bits_qos),
    .io_axi_write_addr_bits_region (io_axi_slave_write_addr_bits_region),
    .io_axi_write_data_ready       (_axiSlave_io_axi_write_data_ready),
    .io_axi_write_data_valid       (io_axi_slave_write_data_valid & axiSlaveEnable),
    .io_axi_write_data_bits_data   (io_axi_slave_write_data_bits_data),
    .io_axi_write_data_bits_last   (io_axi_slave_write_data_bits_last),
    .io_axi_write_data_bits_strb   (io_axi_slave_write_data_bits_strb),
    .io_axi_write_resp_ready       (io_axi_slave_write_resp_ready & axiSlaveEnable),
    .io_axi_write_resp_valid       (_axiSlave_io_axi_write_resp_valid),
    .io_axi_write_resp_bits_id     (io_axi_slave_write_resp_bits_id),
    .io_axi_write_resp_bits_resp   (io_axi_slave_write_resp_bits_resp),
    .io_axi_read_addr_ready        (_axiSlave_io_axi_read_addr_ready),
    .io_axi_read_addr_valid        (io_axi_slave_read_addr_valid & axiSlaveEnable),
    .io_axi_read_addr_bits_addr    (io_axi_slave_read_addr_bits_addr),
    .io_axi_read_addr_bits_prot    (io_axi_slave_read_addr_bits_prot),
    .io_axi_read_addr_bits_id      (io_axi_slave_read_addr_bits_id),
    .io_axi_read_addr_bits_len     (io_axi_slave_read_addr_bits_len),
    .io_axi_read_addr_bits_size    (io_axi_slave_read_addr_bits_size),
    .io_axi_read_addr_bits_burst   (io_axi_slave_read_addr_bits_burst),
    .io_axi_read_addr_bits_lock    (io_axi_slave_read_addr_bits_lock),
    .io_axi_read_addr_bits_cache   (io_axi_slave_read_addr_bits_cache),
    .io_axi_read_addr_bits_qos     (io_axi_slave_read_addr_bits_qos),
    .io_axi_read_addr_bits_region  (io_axi_slave_read_addr_bits_region),
    .io_axi_read_data_ready        (io_axi_slave_read_data_ready & axiSlaveEnable),
    .io_axi_read_data_valid        (_axiSlave_io_axi_read_data_valid),
    .io_axi_read_data_bits_data    (io_axi_slave_read_data_bits_data),
    .io_axi_read_data_bits_id      (io_axi_slave_read_data_bits_id),
    .io_axi_read_data_bits_resp    (io_axi_slave_read_data_bits_resp),
    .io_axi_read_data_bits_last    (io_axi_slave_read_data_bits_last),
    .io_fabric_readDataAddr_valid  (_axiSlave_io_fabric_readDataAddr_valid),
    .io_fabric_readDataAddr_bits   (_axiSlave_io_fabric_readDataAddr_bits),
    .io_fabric_readData_valid      (_fabricMux_io_source_readData_valid),
    .io_fabric_readData_bits       (_fabricMux_io_source_readData_bits),
    .io_fabric_writeDataAddr_valid (_axiSlave_io_fabric_writeDataAddr_valid),
    .io_fabric_writeDataAddr_bits  (_axiSlave_io_fabric_writeDataAddr_bits),
    .io_fabric_writeDataBits       (_axiSlave_io_fabric_writeDataBits),
    .io_fabric_writeDataStrb       (_axiSlave_io_fabric_writeDataStrb),
    .io_fabric_writeResp           (_fabricMux_io_source_writeResp),
    .io_periBusy                   (_fabricMux_io_fabricBusy)
  );
  DBus2AxiV2 ebus2axi (
    .clock                       (_rst_sync_clk_o),
    .reset                       (_global_reset_T_2),
    .io_dbus_valid               (_core_io_ebus_dbus_valid),
    .io_dbus_ready               (_ebus2axi_io_dbus_ready),
    .io_dbus_write               (_core_io_ebus_dbus_write),
    .io_dbus_pc                  (_core_io_ebus_dbus_pc),
    .io_dbus_addr                (_core_io_ebus_dbus_addr),
    .io_dbus_size                (_core_io_ebus_dbus_size),
    .io_dbus_wdata               (_core_io_ebus_dbus_wdata),
    .io_dbus_wmask               (_core_io_ebus_dbus_wmask),
    .io_dbus_rdata               (_ebus2axi_io_dbus_rdata),
    .io_axi_write_addr_ready     (io_axi_master_write_addr_ready),
    .io_axi_write_addr_valid     (io_axi_master_write_addr_valid),
    .io_axi_write_addr_bits_addr (io_axi_master_write_addr_bits_addr),
    .io_axi_write_addr_bits_size (io_axi_master_write_addr_bits_size),
    .io_axi_write_data_ready     (io_axi_master_write_data_ready),
    .io_axi_write_data_valid     (io_axi_master_write_data_valid),
    .io_axi_write_data_bits_data (io_axi_master_write_data_bits_data),
    .io_axi_write_data_bits_last (io_axi_master_write_data_bits_last),
    .io_axi_write_data_bits_strb (io_axi_master_write_data_bits_strb),
    .io_axi_write_resp_ready     (io_axi_master_write_resp_ready),
    .io_axi_write_resp_valid     (io_axi_master_write_resp_valid),
    .io_axi_write_resp_bits_resp (io_axi_master_write_resp_bits_resp),
    .io_axi_read_addr_ready      (io_axi_master_read_addr_ready),
    .io_axi_read_addr_valid      (io_axi_master_read_addr_valid),
    .io_axi_read_addr_bits_addr  (io_axi_master_read_addr_bits_addr),
    .io_axi_read_addr_bits_size  (io_axi_master_read_addr_bits_size),
    .io_axi_read_data_ready      (io_axi_master_read_data_ready),
    .io_axi_read_data_valid      (io_axi_master_read_data_valid),
    .io_axi_read_data_bits_data  (io_axi_master_read_data_bits_data),
    .io_axi_read_data_bits_resp  (io_axi_master_read_data_bits_resp),
    .io_fault_valid              (_ebus2axi_io_fault_valid),
    .io_fault_bits_write         (_ebus2axi_io_fault_bits_write),
    .io_fault_bits_addr          (_ebus2axi_io_fault_bits_addr),
    .io_fault_bits_epc           (_ebus2axi_io_fault_bits_epc)
  );
  assign io_axi_slave_write_addr_ready =
    _axiSlave_io_axi_write_addr_ready & axiSlaveEnable;
  assign io_axi_slave_write_data_ready =
    _axiSlave_io_axi_write_data_ready & axiSlaveEnable;
  assign io_axi_slave_write_resp_valid =
    _axiSlave_io_axi_write_resp_valid & axiSlaveEnable;
  assign io_axi_slave_read_addr_ready = _axiSlave_io_axi_read_addr_ready & axiSlaveEnable;
  assign io_axi_slave_read_data_valid = _axiSlave_io_axi_read_data_valid & axiSlaveEnable;
  assign io_axi_master_write_addr_bits_prot = 3'h2;
  assign io_axi_master_write_addr_bits_id = 6'h0;
  assign io_axi_master_write_addr_bits_len = 8'h0;
  assign io_axi_master_write_addr_bits_burst = 2'h1;
  assign io_axi_master_write_addr_bits_lock = 1'h0;
  assign io_axi_master_write_addr_bits_cache = 4'h0;
  assign io_axi_master_write_addr_bits_qos = 4'h0;
  assign io_axi_master_write_addr_bits_region = 4'h0;
  assign io_axi_master_read_addr_bits_prot = 3'h2;
  assign io_axi_master_read_addr_bits_id = 6'h0;
  assign io_axi_master_read_addr_bits_len = 8'h0;
  assign io_axi_master_read_addr_bits_burst = 2'h1;
  assign io_axi_master_read_addr_bits_lock = 1'h0;
  assign io_axi_master_read_addr_bits_cache = 4'h0;
  assign io_axi_master_read_addr_bits_qos = 4'h0;
  assign io_axi_master_read_addr_bits_region = 4'h0;
  assign io_halted = _core_io_halted;
  assign io_fault = _core_io_fault;
  assign io_wfi = _core_io_wfi;
  assign io_debug_rb_inst_0_bits_inst = 32'h0;
  assign io_debug_rb_inst_0_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_0_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_inst = 32'h0;
  assign io_debug_rb_inst_1_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_1_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_inst = 32'h0;
  assign io_debug_rb_inst_2_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_2_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_inst = 32'h0;
  assign io_debug_rb_inst_3_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_3_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_inst = 32'h0;
  assign io_debug_rb_inst_4_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_4_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_inst = 32'h0;
  assign io_debug_rb_inst_5_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_5_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_inst = 32'h0;
  assign io_debug_rb_inst_6_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_6_bits_vecWrites_7_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_inst = 32'h0;
  assign io_debug_rb_inst_7_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_0_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_0_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_0_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_1_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_1_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_1_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_2_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_2_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_2_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_3_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_3_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_3_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_4_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_4_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_4_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_5_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_5_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_5_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_6_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_6_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_6_bits_idx = 5'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_7_valid = 1'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_7_bits_data = 128'h0;
  assign io_debug_rb_inst_7_bits_vecWrites_7_bits_idx = 5'h0;
endmodule


// ----- 8< ----- FILE "verification/cover/layers-RvvCoreMiniAxi-Verification_Cover.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_RvvCoreMiniAxi_Verification_Cover
`define layers_RvvCoreMiniAxi_Verification_Cover
`endif // layers_RvvCoreMiniAxi_Verification_Cover

// ----- 8< ----- FILE "verification/assume/layers-RvvCoreMiniAxi-Verification_Assume.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_RvvCoreMiniAxi_Verification_Assume
`define layers_RvvCoreMiniAxi_Verification_Assume
`endif // layers_RvvCoreMiniAxi_Verification_Assume

// ----- 8< ----- FILE "verification/assert/layers-RvvCoreMiniAxi-Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef layers_RvvCoreMiniAxi_Verification_Assert
`define layers_RvvCoreMiniAxi_Verification_Assert
bind Regfile Regfile_Verification_Assert verification_Assert (
  ._GEN             (valid_1),
  ._GEN_0           (valid_2),
  ._GEN_1           (_valid_T),
  ._GEN_2           (_valid_T_8),
  ._GEN_3           (valid_5),
  ._GEN_4           (valid_3),
  .reset            (reset),
  ._GEN_5           (1'h1),
  ._GEN_6           (valid_1_1),
  ._GEN_7           (valid_2_1),
  ._GEN_8           (_valid_T_12),
  ._GEN_9           (_valid_T_20),
  ._GEN_10          (valid_5_1),
  ._GEN_11          (valid_3_1),
  ._GEN_12          (valid_1_2),
  ._GEN_13          (valid_2_2),
  ._GEN_14          (_valid_T_24),
  ._GEN_15          (_valid_T_32),
  ._GEN_16          (valid_5_2),
  ._GEN_17          (valid_3_2),
  ._GEN_18          (valid_1_3),
  ._GEN_19          (valid_2_3),
  ._GEN_20          (_valid_T_36),
  ._GEN_21          (_valid_T_44),
  ._GEN_22          (valid_5_3),
  ._GEN_23          (valid_3_3),
  ._GEN_24          (valid_1_4),
  ._GEN_25          (valid_2_4),
  ._GEN_26          (_valid_T_48),
  ._GEN_27          (_valid_T_56),
  ._GEN_28          (valid_5_4),
  ._GEN_29          (valid_3_4),
  ._GEN_30          (valid_1_5),
  ._GEN_31          (valid_2_5),
  ._GEN_32          (_valid_T_60),
  ._GEN_33          (_valid_T_68),
  ._GEN_34          (valid_5_5),
  ._GEN_35          (valid_3_5),
  ._GEN_36          (valid_1_6),
  ._GEN_37          (valid_2_6),
  ._GEN_38          (_valid_T_72),
  ._GEN_39          (_valid_T_80),
  ._GEN_40          (valid_5_6),
  ._GEN_41          (valid_3_6),
  ._GEN_42          (valid_1_7),
  ._GEN_43          (valid_2_7),
  ._GEN_44          (_valid_T_84),
  ._GEN_45          (_valid_T_92),
  ._GEN_46          (valid_5_7),
  ._GEN_47          (valid_3_7),
  ._GEN_48          (valid_1_8),
  ._GEN_49          (valid_2_8),
  ._GEN_50          (_valid_T_96),
  ._GEN_51          (_valid_T_104),
  ._GEN_52          (valid_5_8),
  ._GEN_53          (valid_3_8),
  ._GEN_54          (valid_1_9),
  ._GEN_55          (valid_2_9),
  ._GEN_56          (_valid_T_108),
  ._GEN_57          (_valid_T_116),
  ._GEN_58          (valid_5_9),
  ._GEN_59          (valid_3_9),
  ._GEN_60          (valid_1_10),
  ._GEN_61          (valid_2_10),
  ._GEN_62          (_valid_T_120),
  ._GEN_63          (_valid_T_128),
  ._GEN_64          (valid_5_10),
  ._GEN_65          (valid_3_10),
  ._GEN_66          (valid_1_11),
  ._GEN_67          (valid_2_11),
  ._GEN_68          (_valid_T_132),
  ._GEN_69          (_valid_T_140),
  ._GEN_70          (valid_5_11),
  ._GEN_71          (valid_3_11),
  ._GEN_72          (valid_1_12),
  ._GEN_73          (valid_2_12),
  ._GEN_74          (_valid_T_144),
  ._GEN_75          (_valid_T_152),
  ._GEN_76          (valid_5_12),
  ._GEN_77          (valid_3_12),
  ._GEN_78          (valid_1_13),
  ._GEN_79          (valid_2_13),
  ._GEN_80          (_valid_T_156),
  ._GEN_81          (_valid_T_164),
  ._GEN_82          (valid_5_13),
  ._GEN_83          (valid_3_13),
  ._GEN_84          (valid_1_14),
  ._GEN_85          (valid_2_14),
  ._GEN_86          (_valid_T_168),
  ._GEN_87          (_valid_T_176),
  ._GEN_88          (valid_5_14),
  ._GEN_89          (valid_3_14),
  ._GEN_90          (valid_1_15),
  ._GEN_91          (valid_2_15),
  ._GEN_92          (_valid_T_180),
  ._GEN_93          (_valid_T_188),
  ._GEN_94          (valid_5_15),
  ._GEN_95          (valid_3_15),
  ._GEN_96          (valid_1_16),
  ._GEN_97          (valid_2_16),
  ._GEN_98          (_valid_T_192),
  ._GEN_99          (_valid_T_200),
  ._GEN_100         (valid_5_16),
  ._GEN_101         (valid_3_16),
  ._GEN_102         (valid_1_17),
  ._GEN_103         (valid_2_17),
  ._GEN_104         (_valid_T_204),
  ._GEN_105         (_valid_T_212),
  ._GEN_106         (valid_5_17),
  ._GEN_107         (valid_3_17),
  ._GEN_108         (valid_1_18),
  ._GEN_109         (valid_2_18),
  ._GEN_110         (_valid_T_216),
  ._GEN_111         (_valid_T_224),
  ._GEN_112         (valid_5_18),
  ._GEN_113         (valid_3_18),
  ._GEN_114         (valid_1_19),
  ._GEN_115         (valid_2_19),
  ._GEN_116         (_valid_T_228),
  ._GEN_117         (_valid_T_236),
  ._GEN_118         (valid_5_19),
  ._GEN_119         (valid_3_19),
  ._GEN_120         (valid_1_20),
  ._GEN_121         (valid_2_20),
  ._GEN_122         (_valid_T_240),
  ._GEN_123         (_valid_T_248),
  ._GEN_124         (valid_5_20),
  ._GEN_125         (valid_3_20),
  ._GEN_126         (valid_1_21),
  ._GEN_127         (valid_2_21),
  ._GEN_128         (_valid_T_252),
  ._GEN_129         (_valid_T_260),
  ._GEN_130         (valid_5_21),
  ._GEN_131         (valid_3_21),
  ._GEN_132         (valid_1_22),
  ._GEN_133         (valid_2_22),
  ._GEN_134         (_valid_T_264),
  ._GEN_135         (_valid_T_272),
  ._GEN_136         (valid_5_22),
  ._GEN_137         (valid_3_22),
  ._GEN_138         (valid_1_23),
  ._GEN_139         (valid_2_23),
  ._GEN_140         (_valid_T_276),
  ._GEN_141         (_valid_T_284),
  ._GEN_142         (valid_5_23),
  ._GEN_143         (valid_3_23),
  ._GEN_144         (valid_1_24),
  ._GEN_145         (valid_2_24),
  ._GEN_146         (_valid_T_288),
  ._GEN_147         (_valid_T_296),
  ._GEN_148         (valid_5_24),
  ._GEN_149         (valid_3_24),
  ._GEN_150         (valid_1_25),
  ._GEN_151         (valid_2_25),
  ._GEN_152         (_valid_T_300),
  ._GEN_153         (_valid_T_308),
  ._GEN_154         (valid_5_25),
  ._GEN_155         (valid_3_25),
  ._GEN_156         (valid_1_26),
  ._GEN_157         (valid_2_26),
  ._GEN_158         (_valid_T_312),
  ._GEN_159         (_valid_T_320),
  ._GEN_160         (valid_5_26),
  ._GEN_161         (valid_3_26),
  ._GEN_162         (valid_1_27),
  ._GEN_163         (valid_2_27),
  ._GEN_164         (_valid_T_324),
  ._GEN_165         (_valid_T_332),
  ._GEN_166         (valid_5_27),
  ._GEN_167         (valid_3_27),
  ._GEN_168         (valid_1_28),
  ._GEN_169         (valid_2_28),
  ._GEN_170         (_valid_T_336),
  ._GEN_171         (_valid_T_344),
  ._GEN_172         (valid_5_28),
  ._GEN_173         (valid_3_28),
  ._GEN_174         (valid_1_29),
  ._GEN_175         (valid_2_29),
  ._GEN_176         (_valid_T_348),
  ._GEN_177         (_valid_T_356),
  ._GEN_178         (valid_5_29),
  ._GEN_179         (valid_3_29),
  ._GEN_180         (valid_1_30),
  ._GEN_181         (valid_2_30),
  ._GEN_182         (_valid_T_360),
  ._GEN_183         (_valid_T_368),
  ._GEN_184         (valid_5_30),
  ._GEN_185         (valid_3_30),
  .write_fail       (write_fail),
  .write_fail_1     (write_fail_1),
  .write_fail_2     (write_fail_2),
  .write_fail_3     (write_fail_3),
  .write_fail_4     (write_fail_4),
  .write_fail_5     (write_fail_5),
  .write_fail_6     (write_fail_6),
  .write_fail_7     (write_fail_7),
  .write_fail_8     (write_fail_8),
  .write_fail_9     (write_fail_9),
  .write_fail_10    (write_fail_10),
  .write_fail_11    (write_fail_11),
  .write_fail_12    (write_fail_12),
  .write_fail_13    (write_fail_13),
  .write_fail_14    (write_fail_14),
  .scoreboard_error (scoreboard_error),
  .clock            (clock)
);
bind FetchControl FetchControl_Verification_Assert verification_Assert (
  .predecode_firstJumpOH_2 (predecode_firstJumpOH_enc[2]),
  .predecode_firstJumpOH_3 (predecode_firstJumpOH_enc[3]),
  .predecode_firstJumpOH_0 (predecode_firstJumpOH_enc[0]),
  .predecode_firstJumpOH_1 (predecode_firstJumpOH_enc[1]),
  .reset                   (reset),
  ._GEN                    (1'h1),
  .clock                   (clock)
);
bind CircularBufferMulti CircularBufferMulti_Verification_Assert verification_Assert (
  .io_nEnqueued (nEnqueued),
  .io_enqValid  (io_enqValid),
  .io_deqReady  (io_deqReady),
  .reset        (reset),
  ._GEN         (4'h8),
  .clock        (clock)
);
bind InstructionBuffer InstructionBuffer_Verification_Assert verification_Assert (
  ._GEN   (_nReady_T),
  ._GEN_0 (_nReady_T_1),
  ._GEN_1 (_nReady_T_2),
  ._GEN_2 (_nReady_T_3),
  .reset  (reset),
  .clock  (clock)
);
bind Csr Csr_Verification_Assert verification_Assert (
  .csr_address  (req_bits_index),
  ._GEN         (fflagsEn),
  ._GEN_0       (frmEn),
  ._GEN_1       (fcsrEn),
  ._GEN_2       (vstartEn),
  ._GEN_3       (vxsatEn),
  ._GEN_4       (vxrmEn),
  ._GEN_5       (mstatusEn),
  ._GEN_6       (misaEn),
  ._GEN_7       (mieEn),
  ._GEN_8       (mtvecEn),
  ._GEN_9       (mscratchEn),
  ._GEN_10      (mepcEn),
  ._GEN_11      (mcauseEn),
  ._GEN_12      (mtvalEn),
  ._GEN_13      (mcontext0En),
  ._GEN_14      (mcontext1En),
  ._GEN_15      (mcontext2En),
  ._GEN_16      (mcontext3En),
  ._GEN_17      (mcontext4En),
  ._GEN_18      (mcontext5En),
  ._GEN_19      (mcontext6En),
  ._GEN_20      (mcontext7En),
  ._GEN_21      (mpcEn),
  ._GEN_22      (mspEn),
  ._GEN_23      (mcycleEn),
  ._GEN_24      (minstretEn),
  ._GEN_25      (mcyclehEn),
  ._GEN_26      (minstrethEn),
  ._GEN_27      (vlEn),
  ._GEN_28      (vtypeEn),
  ._GEN_29      (vlenbEn),
  ._GEN_30      (mvendoridEn),
  ._GEN_31      (kscm0En),
  ._GEN_32      (kscm1En),
  ._GEN_33      (kscm2En),
  ._GEN_34      (kscm3En),
  ._GEN_35      (kscm4En),
  .req_valid    (req_valid),
  .reset        (reset),
  .io_halted    (halted),
  .io_wfi       (wfi),
  .io_fault     (fault),
  ._GEN_36      (1'h1),
  .io_rs1_valid (io_rs1_valid),
  .clock        (clock)
);
bind DispatchV2 DispatchV2_Verification_Assert verification_Assert (
  .decodedInsts_0_sub      (decodedInsts_0_sub),
  ._GEN                    (_alu_T_160),
  ._GEN_0                  (_alu_T_158),
  ._GEN_1                  (_alu_T_163),
  ._GEN_2                  (_alu_T_164),
  ._GEN_3                  (_alu_T_161),
  ._GEN_4                  (_alu_T_162),
  ._GEN_5                  (_alu_T_166),
  ._GEN_6                  (_alu_T_167),
  ._GEN_7                  (_alu_T_165),
  .decodedInsts_0_orn      (decodedInsts_0_orn),
  .decodedInsts_0_xnor     (decodedInsts_0_xnor),
  .decodedInsts_0_lui      (decodedInsts_0_lui),
  .decodedInsts_0_andn     (decodedInsts_0_andn),
  .decodedInsts_0_ctz      (decodedInsts_0_ctz),
  .decodedInsts_0_cpop     (decodedInsts_0_cpop),
  .decodedInsts_0_clz      (decodedInsts_0_clz),
  .decodedInsts_0_min      (decodedInsts_0_min),
  .decodedInsts_0_minu     (decodedInsts_0_minu),
  .decodedInsts_0_max      (decodedInsts_0_max),
  .decodedInsts_0_maxu     (decodedInsts_0_maxu),
  .decodedInsts_0_rol      (decodedInsts_0_rol),
  .decodedInsts_0_ror      (decodedInsts_0_ror),
  .decodedInsts_0_sextb    (decodedInsts_0_sextb),
  .decodedInsts_0_sexth    (decodedInsts_0_sexth),
  .decodedInsts_0_zexth    (decodedInsts_0_zexth),
  .decodedInsts_0_rori     (decodedInsts_0_rori),
  .decodedInsts_0_orcb     (decodedInsts_0_orcb),
  .decodedInsts_0_rev8     (decodedInsts_0_rev8),
  .reset                   (reset),
  ._GEN_8                  (1'h1),
  .decodedInsts_0_jalr     (decodedInsts_0_jalr),
  .decodedInsts_0_beq      (decodedInsts_0_beq),
  .decodedInsts_0_jal      (decodedInsts_0_jal),
  .decodedInsts_0_blt      (decodedInsts_0_blt),
  .decodedInsts_0_bge      (decodedInsts_0_bge),
  .decodedInsts_0_bne      (decodedInsts_0_bne),
  .decodedInsts_0_bgeu     (decodedInsts_0_bgeu),
  .decodedInsts_0_ebreak   (decodedInsts_0_ebreak),
  .decodedInsts_0_bltu     (decodedInsts_0_bltu),
  .decodedInsts_0_mret     (decodedInsts_0_mret),
  .decodedInsts_0_wfi      (decodedInsts_0_wfi),
  .decodedInsts_0_ecall    (decodedInsts_0_ecall),
  .decodedInsts_0_mpause   (decodedInsts_0_mpause),
  .decodedInsts_0_mulhsu   (decodedInsts_0_mulhsu),
  .decodedInsts_0_mulhu    (decodedInsts_0_mulhu),
  .decodedInsts_0_mul      (decodedInsts_0_mul),
  .decodedInsts_0_mulh     (decodedInsts_0_mulh),
  .decodedInsts_0_rem      (decodedInsts_0_rem),
  .decodedInsts_0_remu     (decodedInsts_0_remu),
  .decodedInsts_0_div      (decodedInsts_0_div),
  .decodedInsts_0_divu     (decodedInsts_0_divu),
  .decodedInsts_0_lbu      (decodedInsts_0_lbu),
  .decodedInsts_0_lhu      (decodedInsts_0_lhu),
  .decodedInsts_0_lw       (decodedInsts_0_lw),
  .decodedInsts_0_lb       (decodedInsts_0_lb),
  .decodedInsts_0_lh       (decodedInsts_0_lh),
  .decodedInsts_0_fencei   (decodedInsts_0_fencei),
  .decodedInsts_0_sw       (decodedInsts_0_sw),
  .decodedInsts_0_sb       (decodedInsts_0_sb),
  .decodedInsts_0_sh       (decodedInsts_0_sh),
  ._GEN_9                  (_lsu_T_142),
  ._GEN_10                 (_lsu_T_143),
  ._GEN_11                 (_lsu_T_141),
  .decodedInsts_0_flushat  (decodedInsts_0_flushat),
  .decodedInsts_0_flushall (decodedInsts_0_flushall),
  ._GEN_12                 (_lsu_T_145),
  ._GEN_13                 (_lsu_T_146),
  ._GEN_14                 (_lsu_T_144),
  ._GEN_15                 (_lsu_T_148),
  ._GEN_16                 (_lsu_T_149),
  ._GEN_17                 (_lsu_T_147),
  .decodedInsts_0_csrrs    (decodedInsts_0_csrrs),
  .decodedInsts_0_csrrc    (decodedInsts_0_csrrc),
  .decodedInsts_0_csrrw    (decodedInsts_0_csrrw),
  .decodedInsts_1_sub      (decodedInsts_1_sub),
  ._GEN_18                 (_alu_T_378),
  ._GEN_19                 (_alu_T_376),
  ._GEN_20                 (_alu_T_381),
  ._GEN_21                 (_alu_T_382),
  ._GEN_22                 (_alu_T_379),
  ._GEN_23                 (_alu_T_380),
  ._GEN_24                 (_alu_T_384),
  ._GEN_25                 (_alu_T_385),
  ._GEN_26                 (_alu_T_383),
  .decodedInsts_1_orn      (decodedInsts_1_orn),
  .decodedInsts_1_xnor     (decodedInsts_1_xnor),
  .decodedInsts_1_lui      (decodedInsts_1_lui),
  .decodedInsts_1_andn     (decodedInsts_1_andn),
  .decodedInsts_1_ctz      (decodedInsts_1_ctz),
  .decodedInsts_1_cpop     (decodedInsts_1_cpop),
  .decodedInsts_1_clz      (decodedInsts_1_clz),
  .decodedInsts_1_min      (decodedInsts_1_min),
  .decodedInsts_1_minu     (decodedInsts_1_minu),
  .decodedInsts_1_max      (decodedInsts_1_max),
  .decodedInsts_1_maxu     (decodedInsts_1_maxu),
  .decodedInsts_1_rol      (decodedInsts_1_rol),
  .decodedInsts_1_ror      (decodedInsts_1_ror),
  .decodedInsts_1_sextb    (decodedInsts_1_sextb),
  .decodedInsts_1_sexth    (decodedInsts_1_sexth),
  .decodedInsts_1_zexth    (decodedInsts_1_zexth),
  .decodedInsts_1_rori     (decodedInsts_1_rori),
  .decodedInsts_1_orcb     (decodedInsts_1_orcb),
  .decodedInsts_1_rev8     (decodedInsts_1_rev8),
  .decodedInsts_1_jalr     (decodedInsts_1_jalr),
  .decodedInsts_1_beq      (decodedInsts_1_beq),
  .decodedInsts_1_jal      (decodedInsts_1_jal),
  .decodedInsts_1_blt      (decodedInsts_1_blt),
  .decodedInsts_1_bge      (decodedInsts_1_bge),
  .decodedInsts_1_bne      (decodedInsts_1_bne),
  .decodedInsts_1_bgeu     (decodedInsts_1_bgeu),
  .decodedInsts_1_bltu     (decodedInsts_1_bltu),
  .decodedInsts_1_mulhsu   (decodedInsts_1_mulhsu),
  .decodedInsts_1_mulhu    (decodedInsts_1_mulhu),
  .decodedInsts_1_mul      (decodedInsts_1_mul),
  .decodedInsts_1_mulh     (decodedInsts_1_mulh),
  .decodedInsts_1_lbu      (decodedInsts_1_lbu),
  .decodedInsts_1_lhu      (decodedInsts_1_lhu),
  .decodedInsts_1_lw       (decodedInsts_1_lw),
  .decodedInsts_1_lb       (decodedInsts_1_lb),
  .decodedInsts_1_lh       (decodedInsts_1_lh),
  .decodedInsts_1_sw       (decodedInsts_1_sw),
  .decodedInsts_1_sb       (decodedInsts_1_sb),
  .decodedInsts_1_sh       (decodedInsts_1_sh),
  ._GEN_27                 (_lsu_T_318),
  ._GEN_28                 (_lsu_T_319),
  ._GEN_29                 (_lsu_T_317),
  ._GEN_30                 (_lsu_T_321),
  ._GEN_31                 (_lsu_T_322),
  ._GEN_32                 (_lsu_T_320),
  ._GEN_33                 (_lsu_T_315),
  ._GEN_34                 (_lsu_T_316),
  .decodedInsts_2_sub      (decodedInsts_2_sub),
  ._GEN_35                 (_alu_T_596),
  ._GEN_36                 (_alu_T_594),
  ._GEN_37                 (_alu_T_599),
  ._GEN_38                 (_alu_T_600),
  ._GEN_39                 (_alu_T_597),
  ._GEN_40                 (_alu_T_598),
  ._GEN_41                 (_alu_T_602),
  ._GEN_42                 (_alu_T_603),
  ._GEN_43                 (_alu_T_601),
  .decodedInsts_2_orn      (decodedInsts_2_orn),
  .decodedInsts_2_xnor     (decodedInsts_2_xnor),
  .decodedInsts_2_lui      (decodedInsts_2_lui),
  .decodedInsts_2_andn     (decodedInsts_2_andn),
  .decodedInsts_2_ctz      (decodedInsts_2_ctz),
  .decodedInsts_2_cpop     (decodedInsts_2_cpop),
  .decodedInsts_2_clz      (decodedInsts_2_clz),
  .decodedInsts_2_min      (decodedInsts_2_min),
  .decodedInsts_2_minu     (decodedInsts_2_minu),
  .decodedInsts_2_max      (decodedInsts_2_max),
  .decodedInsts_2_maxu     (decodedInsts_2_maxu),
  .decodedInsts_2_rol      (decodedInsts_2_rol),
  .decodedInsts_2_ror      (decodedInsts_2_ror),
  .decodedInsts_2_sextb    (decodedInsts_2_sextb),
  .decodedInsts_2_sexth    (decodedInsts_2_sexth),
  .decodedInsts_2_zexth    (decodedInsts_2_zexth),
  .decodedInsts_2_rori     (decodedInsts_2_rori),
  .decodedInsts_2_orcb     (decodedInsts_2_orcb),
  .decodedInsts_2_rev8     (decodedInsts_2_rev8),
  .decodedInsts_2_jalr     (decodedInsts_2_jalr),
  .decodedInsts_2_beq      (decodedInsts_2_beq),
  .decodedInsts_2_jal      (decodedInsts_2_jal),
  .decodedInsts_2_blt      (decodedInsts_2_blt),
  .decodedInsts_2_bge      (decodedInsts_2_bge),
  .decodedInsts_2_bne      (decodedInsts_2_bne),
  .decodedInsts_2_bgeu     (decodedInsts_2_bgeu),
  .decodedInsts_2_bltu     (decodedInsts_2_bltu),
  .decodedInsts_2_mulhsu   (decodedInsts_2_mulhsu),
  .decodedInsts_2_mulhu    (decodedInsts_2_mulhu),
  .decodedInsts_2_mul      (decodedInsts_2_mul),
  .decodedInsts_2_mulh     (decodedInsts_2_mulh),
  .decodedInsts_2_lbu      (decodedInsts_2_lbu),
  .decodedInsts_2_lhu      (decodedInsts_2_lhu),
  .decodedInsts_2_lw       (decodedInsts_2_lw),
  .decodedInsts_2_lb       (decodedInsts_2_lb),
  .decodedInsts_2_lh       (decodedInsts_2_lh),
  .decodedInsts_2_sw       (decodedInsts_2_sw),
  .decodedInsts_2_sb       (decodedInsts_2_sb),
  .decodedInsts_2_sh       (decodedInsts_2_sh),
  ._GEN_44                 (_lsu_T_491),
  ._GEN_45                 (_lsu_T_492),
  ._GEN_46                 (_lsu_T_490),
  ._GEN_47                 (_lsu_T_494),
  ._GEN_48                 (_lsu_T_495),
  ._GEN_49                 (_lsu_T_493),
  ._GEN_50                 (_lsu_T_488),
  ._GEN_51                 (_lsu_T_489),
  .decodedInsts_3_sub      (decodedInsts_3_sub),
  ._GEN_52                 (_alu_T_814),
  ._GEN_53                 (_alu_T_812),
  ._GEN_54                 (_alu_T_817),
  ._GEN_55                 (_alu_T_818),
  ._GEN_56                 (_alu_T_815),
  ._GEN_57                 (_alu_T_816),
  ._GEN_58                 (_alu_T_820),
  ._GEN_59                 (_alu_T_821),
  ._GEN_60                 (_alu_T_819),
  .decodedInsts_3_orn      (decodedInsts_3_orn),
  .decodedInsts_3_xnor     (decodedInsts_3_xnor),
  .decodedInsts_3_lui      (decodedInsts_3_lui),
  .decodedInsts_3_andn     (decodedInsts_3_andn),
  .decodedInsts_3_ctz      (decodedInsts_3_ctz),
  .decodedInsts_3_cpop     (decodedInsts_3_cpop),
  .decodedInsts_3_clz      (decodedInsts_3_clz),
  .decodedInsts_3_min      (decodedInsts_3_min),
  .decodedInsts_3_minu     (decodedInsts_3_minu),
  .decodedInsts_3_max      (decodedInsts_3_max),
  .decodedInsts_3_maxu     (decodedInsts_3_maxu),
  .decodedInsts_3_rol      (decodedInsts_3_rol),
  .decodedInsts_3_ror      (decodedInsts_3_ror),
  .decodedInsts_3_sextb    (decodedInsts_3_sextb),
  .decodedInsts_3_sexth    (decodedInsts_3_sexth),
  .decodedInsts_3_zexth    (decodedInsts_3_zexth),
  .decodedInsts_3_rori     (decodedInsts_3_rori),
  .decodedInsts_3_orcb     (decodedInsts_3_orcb),
  .decodedInsts_3_rev8     (decodedInsts_3_rev8),
  .decodedInsts_3_jalr     (decodedInsts_3_jalr),
  .decodedInsts_3_beq      (decodedInsts_3_beq),
  .decodedInsts_3_jal      (decodedInsts_3_jal),
  .decodedInsts_3_blt      (decodedInsts_3_blt),
  .decodedInsts_3_bge      (decodedInsts_3_bge),
  .decodedInsts_3_bne      (decodedInsts_3_bne),
  .decodedInsts_3_bgeu     (decodedInsts_3_bgeu),
  .decodedInsts_3_bltu     (decodedInsts_3_bltu),
  .decodedInsts_3_mulhsu   (decodedInsts_3_mulhsu),
  .decodedInsts_3_mulhu    (decodedInsts_3_mulhu),
  .decodedInsts_3_mul      (decodedInsts_3_mul),
  .decodedInsts_3_mulh     (decodedInsts_3_mulh),
  .decodedInsts_3_lbu      (decodedInsts_3_lbu),
  .decodedInsts_3_lhu      (decodedInsts_3_lhu),
  .decodedInsts_3_lw       (decodedInsts_3_lw),
  .decodedInsts_3_lb       (decodedInsts_3_lb),
  .decodedInsts_3_lh       (decodedInsts_3_lh),
  .decodedInsts_3_sw       (decodedInsts_3_sw),
  .decodedInsts_3_sb       (decodedInsts_3_sb),
  .decodedInsts_3_sh       (decodedInsts_3_sh),
  ._GEN_61                 (_lsu_T_664),
  ._GEN_62                 (_lsu_T_665),
  ._GEN_63                 (_lsu_T_663),
  ._GEN_64                 (_lsu_T_667),
  ._GEN_65                 (_lsu_T_668),
  ._GEN_66                 (_lsu_T_666),
  ._GEN_67                 (_lsu_T_661),
  ._GEN_68                 (_lsu_T_662),
  .clock                   (clock)
);
bind CircularBufferMulti_1 CircularBufferMulti_1_Verification_Assert verification_Assert (
  .io_nEnqueued (nEnqueued),
  .io_enqValid  (io_enqValid),
  .io_deqReady  (io_deqReady),
  .reset        (reset),
  ._GEN         (3'h4),
  .clock        (clock)
);
bind LsuV2 LsuV2_Verification_Assert verification_Assert (
  ._GEN                           (_ops_emul_data_T_20),
  ._GEN_0                         (_ops_emul_data_T_25),
  ._GEN_1                         (_ops_emul_data_T_2),
  ._GEN_2                         (_ops_emul_data_T_11),
  .reset                          (reset),
  ._GEN_3                         (1'h1),
  .io_req_0_bits_nfields          (io_req_0_bits_nfields),
  ._GEN_4                         (_ops_result_emul_data_T_14),
  ._GEN_5                         (&io_req_0_bits_nfields),
  ._GEN_6                         (_ops_result_emul_data_T_30),
  ._GEN_7                         (_ops_result_nfields_T_5),
  ._GEN_8                         (_ops_result_nfields_T_11),
  ._GEN_9                         (_ops_emul_data_T_65),
  ._GEN_10                        (_ops_emul_data_T_70),
  ._GEN_11                        (_ops_emul_data_T_47),
  ._GEN_12                        (_ops_emul_data_T_56),
  .io_req_1_bits_nfields          (io_req_1_bits_nfields),
  ._GEN_13                        (_ops_result_emul_data_T_57),
  ._GEN_14                        (&io_req_1_bits_nfields),
  ._GEN_15                        (_ops_result_emul_data_T_73),
  ._GEN_16                        (_ops_result_nfields_T_27),
  ._GEN_17                        (_ops_result_nfields_T_33),
  ._GEN_18                        (_ops_emul_data_T_110),
  ._GEN_19                        (_ops_emul_data_T_115),
  ._GEN_20                        (_ops_emul_data_T_92),
  ._GEN_21                        (_ops_emul_data_T_101),
  .io_req_2_bits_nfields          (io_req_2_bits_nfields),
  ._GEN_22                        (_ops_result_emul_data_T_100),
  ._GEN_23                        (&io_req_2_bits_nfields),
  ._GEN_24                        (_ops_result_emul_data_T_116),
  ._GEN_25                        (_ops_result_nfields_T_49),
  ._GEN_26                        (_ops_result_nfields_T_55),
  ._GEN_27                        (_ops_emul_data_T_155),
  ._GEN_28                        (_ops_emul_data_T_160),
  ._GEN_29                        (_ops_emul_data_T_137),
  ._GEN_30                        (_ops_emul_data_T_146),
  .io_req_3_bits_nfields          (io_req_3_bits_nfields),
  ._GEN_31                        (_ops_result_emul_data_T_143),
  ._GEN_32                        (&io_req_3_bits_nfields),
  ._GEN_33                        (_ops_result_emul_data_T_159),
  ._GEN_34                        (_ops_result_nfields_T_71),
  ._GEN_35                        (_ops_result_nfields_T_77),
  .opQueue_io_enqValid            (opQueue_io_enqValid),
  .opQueue_io_nSpace              (_opQueue_io_nSpace),
  ._GEN_36                        (_nextSlot_elemMultiplier_T_5),
  ._GEN_37                        (_nextSlot_elemMultiplier_T_8),
  ._GEN_38                        (_nextSlot_elemMultiplier_T_2),
  ._GEN_39                        (_nextSlot_max_subvector_T_7),
  ._GEN_40                        (_nextSlot_max_subvector_T_11),
  ._GEN_41                        (_nextSlot_max_subvector_T_3),
  ._GEN_42                        (_nextSlot_result_indexParitions_T_5),
  ._GEN_43                        (_nextSlot_result_indexParitions_T_8),
  ._GEN_44                        (_nextSlot_result_indexParitions_T_2),
  ._nextSlot_active_WIRE_3_5      (_nextSlot_T_17),
  ._nextSlot_active_WIRE_3_4      (_nextSlot_result_elemStride_T_1),
  ._nextSlot_active_WIRE_3_7      (_nextSlot_unitStride_T_3),
  ._nextSlot_active_WIRE_3_6      (_nextSlot_unitStride_T_2),
  ._nextSlot_active_WIRE_3_1      (_nextSlot_T_16),
  ._nextSlot_active_WIRE_3_0      (_nextSlot_result_elemStride_T),
  ._nextSlot_active_WIRE_3_3      (_nextSlot_unitStride_T_1),
  ._nextSlot_active_WIRE_3_2      (_nextSlot_unitStride_T),
  ._GEN_45                        (|_nextSlot_active_T_13),
  ._GEN_46                        (|_nextSlot_active_T_3),
  ._GEN_47                        (|_nextSlot_active_T_8),
  ._GEN_48                        (_nextSlot_unitStride_T_24),
  ._GEN_49                        (_nextSlot_unitStride_T_25),
  ._GEN_50                        (_nextSlot_unitStride_T_33),
  ._GEN_51                        (_nextSlot_unitStride_T_7),
  ._GEN_52                        (_nextSlot_unitStride_T_8),
  ._GEN_53                        (_nextSlot_unitStride_T_16),
  ._GEN_54                        (_vectorUpdatedSlot_indices_T_13),
  ._GEN_55                        (_vectorUpdatedSlot_indices_T_18),
  ._GEN_56                        (_vectorUpdatedSlot_indices_T_3),
  ._GEN_57                        (_vectorUpdatedSlot_indices_T_8),
  ._GEN_58                        (_writebackUpdatedSlot_result_baseAddr_T_21),
  ._GEN_59                        (_writebackUpdatedSlot_result_baseAddr_T_25),
  ._GEN_60                        (_writebackUpdatedSlot_result_baseAddr_T_17),
  ._GEN_61                        (_vectorUpdatedSlot_updateAddrs_T_803),
  ._GEN_62                        (_vectorUpdatedSlot_updateAddrs_T_868),
  ._GEN_63                        (_vectorUpdatedSlot_updateAddrs_T_770),
  ._GEN_64                        (|_vectorUpdatedSlot_updateAddrs_T_384),
  ._GEN_65                        (|_vectorUpdatedSlot_updateAddrs_T_768),
  ._GEN_66                        (|_vectorUpdatedSlot_updateAddrs_T_2),
  .lineActive_0                   (lineActive_0),
  .lineActive_1                   (lineActive_1),
  .wactive_1                      (|selectionMatrix_1),
  .wactive_0                      (|valueSet_1),
  .lineActive_2                   (lineActive_2),
  .lineActive_3                   (lineActive_3),
  .wactive_3                      (|selectionMatrix_3),
  .wactive_2                      (|selectionMatrix_2),
  .lineActive_4                   (lineActive_4),
  .lineActive_5                   (lineActive_5),
  .wactive_5                      (|selectionMatrix_5),
  .wactive_4                      (|selectionMatrix_4),
  .lineActive_6                   (lineActive_6),
  .lineActive_7                   (lineActive_7),
  .wactive_7                      (|selectionMatrix_7),
  .wactive_6                      (|selectionMatrix_6),
  .lineActive_8                   (lineActive_8),
  .lineActive_9                   (lineActive_9),
  .wactive_9                      (|selectionMatrix_9),
  .wactive_8                      (|selectionMatrix_8),
  .lineActive_10                  (lineActive_10),
  .lineActive_11                  (lineActive_11),
  .wactive_11                     (|selectionMatrix_11),
  .wactive_10                     (|selectionMatrix_10),
  .lineActive_12                  (lineActive_12),
  .lineActive_13                  (lineActive_13),
  .wactive_13                     (|selectionMatrix_13),
  .wactive_12                     (|selectionMatrix_12),
  .lineActive_14                  (lineActive_14),
  .lineActive_15                  (lineActive_15),
  .wactive_15                     (|selectionMatrix_15),
  .wactive_14                     (|selectionMatrix_14),
  ._GEN_67                        (|_size_T_14),
  ._GEN_68                        (|_size_T_25),
  ._GEN_69                        (|_size_T_3),
  ._GEN_70                        (|_size_T_8),
  ._GEN_71                        (_alignedAddress_T_10),
  ._GEN_72                        (_alignedAddress_T_16),
  ._GEN_73                        (|_alignedAddress_T_3),
  .io_dbus_valid                  (io_dbus_valid_0),
  ._GEN_74                        (ebusFired),
  ._GEN_75                        (ibusFired),
  .io_rd_flt_valid                (io_rd_flt_valid_0),
  ._GEN_76                        (lsu2RvvFire),
  .io_rd_valid                    (io_rd_valid_0),
  .slot_vectorLoop_subvector_curr (slot_vectorLoop_subvector_curr),
  .slot_vectorLoop_subvector_max  (slot_vectorLoop_subvector_max),
  ._GEN_77                        (vectorUpdate),
  ._GEN_78                        (_io_active_T),
  .slot_active_2                  (slot_active_2),
  .slot_active_3                  (slot_active_3),
  .slot_active_4                  (slot_active_4),
  .slot_active_5                  (slot_active_5),
  .slot_active_6                  (slot_active_6),
  .slot_active_7                  (slot_active_7),
  .slot_active_8                  (slot_active_8),
  .slot_active_9                  (slot_active_9),
  .slot_active_10                 (slot_active_10),
  .slot_active_11                 (slot_active_11),
  .slot_active_12                 (slot_active_12),
  .slot_active_13                 (slot_active_13),
  .slot_active_14                 (slot_active_14),
  .slot_active_15                 (slot_active_15),
  .slot_pendingWriteback          (slot_pendingWriteback),
  .faultReg_valid                 (faultReg_valid),
  ._GEN_79                        (writebackFired),
  .clock                          (clock)
);
bind CircularBufferMulti_2 CircularBufferMulti_2_Verification_Assert verification_Assert (
  .io_nEnqueued (nEnqueued),
  .io_enqValid  (io_enqValid),
  .io_deqReady  (io_deqReady),
  .reset        (reset),
  ._GEN         (4'h8),
  .clock        (clock)
);
bind RetirementBuffer RetirementBuffer_Verification_Assert verification_Assert (
  ._GEN   (instFires_1),
  ._GEN_0 (instFires_0),
  ._GEN_1 (instFires_2),
  ._GEN_2 (instFires_3),
  .reset  (reset),
  .clock  (clock)
);
bind Alu Alu_Verification_Assert verification_Assert (
  .io_rs1_valid    (io_rs1_valid),
  ._GEN            (op == 5'hA),
  .valid           (valid),
  .reset           (reset),
  .io_rs2_valid    (io_rs2_valid),
  ._rs1Only_WIRE_5 (op == 5'h15),
  ._rs1Only_WIRE_4 (op == 5'h16),
  ._rs1Only_WIRE_7 (op == 5'h1A),
  ._rs1Only_WIRE_6 (op == 5'h19),
  ._rs1Only_WIRE_1 (op == 5'hF),
  ._rs1Only_WIRE_0 (op == 5'hE),
  ._rs1Only_WIRE_3 (op == 5'h1B),
  ._rs1Only_WIRE_2 (op == 5'h10),
  .clock           (clock)
);
bind Bru Bru_Verification_Assert verification_Assert (
  .io_rs1_valid   (io_rs1_valid),
  .stateReg_valid (stateReg_valid),
  ._ignore_WIRE_5 (_ignore_T_5),
  ._ignore_WIRE_4 (_ignore_T_4),
  ._ignore_WIRE_7 (_ignore_T_7),
  ._ignore_WIRE_6 (_ignore_T_6),
  ._ignore_WIRE_1 (stateReg_bits_op == 4'h1),
  ._ignore_WIRE_0 (~(|stateReg_bits_op)),
  ._ignore_WIRE_3 (_ignore_T_3),
  ._ignore_WIRE_2 (_ignore_T_2),
  .reset          (reset),
  .io_rs2_valid   (io_rs2_valid),
  .clock          (clock)
);
bind Bru_1 Bru_1_Verification_Assert verification_Assert (
  ._GEN           (_ignore_T_6),
  ._GEN_0         (_ignore_T_5),
  ._GEN_1         (_ignore_T_3),
  ._GEN_2         (_ignore_T_2),
  ._GEN_3         (_ignore_T_4),
  .reset          (reset),
  .io_rs1_valid   (io_rs1_valid),
  .stateReg_valid (stateReg_valid),
  ._ignore_WIRE_5 (_ignore_T_5),
  ._ignore_WIRE_4 (_ignore_T_4),
  ._ignore_WIRE_7 (stateReg_bits_op == 4'hD),
  ._ignore_WIRE_6 (_ignore_T_6),
  ._ignore_WIRE_1 (stateReg_bits_op == 4'h1),
  ._ignore_WIRE_0 (~(|stateReg_bits_op)),
  ._ignore_WIRE_3 (_ignore_T_3),
  ._ignore_WIRE_2 (_ignore_T_2),
  .io_rs2_valid   (io_rs2_valid),
  .clock          (clock)
);
bind Mlu Mlu_Verification_Assert verification_Assert (
  .io_rs1_0_valid             (io_rs1_0_valid),
  .stage2Input_q_io_deq_valid (_stage2Input_q_io_deq_valid),
  ._GEN                       (_stage2Input_q_io_deq_bits_sel[0]),
  .reset                      (reset),
  .io_rs2_0_valid             (io_rs2_0_valid),
  .io_rs1_1_valid             (io_rs1_1_valid),
  ._GEN_0                     (_stage2Input_q_io_deq_bits_sel[1]),
  .io_rs2_1_valid             (io_rs2_1_valid),
  .io_rs1_2_valid             (io_rs1_2_valid),
  ._GEN_1                     (_stage2Input_q_io_deq_bits_sel[2]),
  .io_rs2_2_valid             (io_rs2_2_valid),
  .io_rs1_3_valid             (io_rs1_3_valid),
  ._GEN_2                     (_stage2Input_q_io_deq_bits_sel[3]),
  .io_rs2_3_valid             (io_rs2_3_valid),
  .clock                      (clock)
);
bind FRegfile FRegfile_Verification_Assert verification_Assert (
  .reset            (reset),
  .scoreboard_error (scoreboard_error),
  .clock            (clock)
);
bind SCore SCore_Verification_Assert verification_Assert (
  .csr_io_rd_valid       (_csr_io_rd_valid),
  .alu_0_io_rd_valid     (_alu_0_io_rd_valid),
  .bru_0_io_rd_valid     (_bru_0_io_rd_valid),
  .io_rvvcore_rd_0_valid (io_rvvcore_rd_0_valid),
  .reset                 (reset),
  ._GEN                  (1'h1),
  .alu_1_io_rd_valid     (_alu_1_io_rd_valid),
  .bru_1_io_rd_valid     (_bru_1_io_rd_valid),
  .io_rvvcore_rd_1_valid (io_rvvcore_rd_1_valid),
  .alu_2_io_rd_valid     (_alu_2_io_rd_valid),
  .bru_2_io_rd_valid     (_bru_2_io_rd_valid),
  .io_rvvcore_rd_2_valid (io_rvvcore_rd_2_valid),
  .alu_3_io_rd_valid     (_alu_3_io_rd_valid),
  .bru_3_io_rd_valid     (_bru_3_io_rd_valid),
  .io_rvvcore_rd_3_valid (io_rvvcore_rd_3_valid),
  .clock                 (clock)
);
bind SRAM SRAM_Verification_Assert verification_Assert (
  .io_fabric_writeDataAddr_valid (io_fabric_writeDataAddr_valid),
  .io_fabric_readDataAddr_valid  (io_fabric_readDataAddr_valid),
  .reset                         (reset),
  ._GEN                          (1'h1),
  .clock                         (clock)
);
bind FabricArbiter FabricArbiter_Verification_Assert verification_Assert (
  .io_source_1_readDataAddr_valid  (io_source_1_readDataAddr_valid),
  .io_source_1_writeDataAddr_valid (io_source_1_writeDataAddr_valid),
  .io_source_0_readDataAddr_valid  (io_source_0_readDataAddr_valid),
  .io_source_0_writeDataAddr_valid (io_source_0_writeDataAddr_valid),
  .reset                           (reset),
  .clock                           (clock)
);
bind SRAM_1 SRAM_1_Verification_Assert verification_Assert (
  .io_fabric_writeDataAddr_valid (io_fabric_writeDataAddr_valid),
  .io_fabric_readDataAddr_valid  (io_fabric_readDataAddr_valid),
  .reset                         (reset),
  ._GEN                          (1'h1),
  .clock                         (clock)
);
bind FabricMux FabricMux_Verification_Assert verification_Assert (
  .io_source_readDataAddr_valid  (io_source_readDataAddr_valid),
  .io_source_writeDataAddr_valid (io_source_writeDataAddr_valid),
  .reset                         (reset),
  ._GEN                          (1'h1),
  ._GEN_0                        (portSelected_1),
  ._GEN_1                        (_portSelected_T_7),
  ._GEN_2                        (portSelected_0),
  ._GEN_3                        (selected_valid),
  ._GEN_4                        (_io_fabricBusy_T_4),
  ._GEN_5                        (_io_fabricBusy_T_3),
  ._GEN_6                        (_io_fabricBusy_T_1),
  ._GEN_7                        (portSelected_1),
  ._GEN_8                        (_portSelected_T_7),
  ._GEN_9                        (portSelected_0),
  ._GEN_10                       (io_ports_1_readDataAddr_valid_0),
  ._GEN_11                       (_lastReadSelected_T_19),
  ._GEN_12                       (io_ports_0_readDataAddr_valid_0),
  ._GEN_13                       (_io_source_readData_T_3),
  ._GEN_14                       (_io_source_readData_T_5),
  ._GEN_15                       (_io_source_readData_T_1),
  .clock                         (clock)
);
bind AxiSlave AxiSlave_Verification_Assert verification_Assert (
  .readIssued_valid           (readIssued_valid),
  .reset                      (reset),
  .readDataQueue_io_enq_ready (_readDataQueue_io_enq_ready),
  ._GEN                       (_addrNext_T_3),
  ._GEN_0                     (_addrNext_T_8),
  ._GEN_1                     (_addrNext_T_1),
  ._GEN_2                     (1'h1),
  .clock                      (clock)
);
bind DBus2AxiV2 DBus2AxiV2_Verification_Assert verification_Assert (
  .io_dbus_size  (io_dbus_size),
  ._GEN          (1'h1),
  .io_dbus_valid (io_dbus_valid),
  .reset         (reset),
  .clock         (clock)
);
`endif // layers_RvvCoreMiniAxi_Verification_Assert

// ----- 8< ----- FILE "verification/assert/Regfile_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Regfile_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        _GEN_3,
        _GEN_4,
        reset,
        _GEN_5,
        _GEN_6,
        _GEN_7,
        _GEN_8,
        _GEN_9,
        _GEN_10,
        _GEN_11,
        _GEN_12,
        _GEN_13,
        _GEN_14,
        _GEN_15,
        _GEN_16,
        _GEN_17,
        _GEN_18,
        _GEN_19,
        _GEN_20,
        _GEN_21,
        _GEN_22,
        _GEN_23,
        _GEN_24,
        _GEN_25,
        _GEN_26,
        _GEN_27,
        _GEN_28,
        _GEN_29,
        _GEN_30,
        _GEN_31,
        _GEN_32,
        _GEN_33,
        _GEN_34,
        _GEN_35,
        _GEN_36,
        _GEN_37,
        _GEN_38,
        _GEN_39,
        _GEN_40,
        _GEN_41,
        _GEN_42,
        _GEN_43,
        _GEN_44,
        _GEN_45,
        _GEN_46,
        _GEN_47,
        _GEN_48,
        _GEN_49,
        _GEN_50,
        _GEN_51,
        _GEN_52,
        _GEN_53,
        _GEN_54,
        _GEN_55,
        _GEN_56,
        _GEN_57,
        _GEN_58,
        _GEN_59,
        _GEN_60,
        _GEN_61,
        _GEN_62,
        _GEN_63,
        _GEN_64,
        _GEN_65,
        _GEN_66,
        _GEN_67,
        _GEN_68,
        _GEN_69,
        _GEN_70,
        _GEN_71,
        _GEN_72,
        _GEN_73,
        _GEN_74,
        _GEN_75,
        _GEN_76,
        _GEN_77,
        _GEN_78,
        _GEN_79,
        _GEN_80,
        _GEN_81,
        _GEN_82,
        _GEN_83,
        _GEN_84,
        _GEN_85,
        _GEN_86,
        _GEN_87,
        _GEN_88,
        _GEN_89,
        _GEN_90,
        _GEN_91,
        _GEN_92,
        _GEN_93,
        _GEN_94,
        _GEN_95,
        _GEN_96,
        _GEN_97,
        _GEN_98,
        _GEN_99,
        _GEN_100,
        _GEN_101,
        _GEN_102,
        _GEN_103,
        _GEN_104,
        _GEN_105,
        _GEN_106,
        _GEN_107,
        _GEN_108,
        _GEN_109,
        _GEN_110,
        _GEN_111,
        _GEN_112,
        _GEN_113,
        _GEN_114,
        _GEN_115,
        _GEN_116,
        _GEN_117,
        _GEN_118,
        _GEN_119,
        _GEN_120,
        _GEN_121,
        _GEN_122,
        _GEN_123,
        _GEN_124,
        _GEN_125,
        _GEN_126,
        _GEN_127,
        _GEN_128,
        _GEN_129,
        _GEN_130,
        _GEN_131,
        _GEN_132,
        _GEN_133,
        _GEN_134,
        _GEN_135,
        _GEN_136,
        _GEN_137,
        _GEN_138,
        _GEN_139,
        _GEN_140,
        _GEN_141,
        _GEN_142,
        _GEN_143,
        _GEN_144,
        _GEN_145,
        _GEN_146,
        _GEN_147,
        _GEN_148,
        _GEN_149,
        _GEN_150,
        _GEN_151,
        _GEN_152,
        _GEN_153,
        _GEN_154,
        _GEN_155,
        _GEN_156,
        _GEN_157,
        _GEN_158,
        _GEN_159,
        _GEN_160,
        _GEN_161,
        _GEN_162,
        _GEN_163,
        _GEN_164,
        _GEN_165,
        _GEN_166,
        _GEN_167,
        _GEN_168,
        _GEN_169,
        _GEN_170,
        _GEN_171,
        _GEN_172,
        _GEN_173,
        _GEN_174,
        _GEN_175,
        _GEN_176,
        _GEN_177,
        _GEN_178,
        _GEN_179,
        _GEN_180,
        _GEN_181,
        _GEN_182,
        _GEN_183,
        _GEN_184,
        _GEN_185,
        write_fail,
        write_fail_1,
        write_fail_2,
        write_fail_3,
        write_fail_4,
        write_fail_5,
        write_fail_6,
        write_fail_7,
        write_fail_8,
        write_fail_9,
        write_fail_10,
        write_fail_11,
        write_fail_12,
        write_fail_13,
        write_fail_14,
        scoreboard_error,
        clock
);

  `ifndef SYNTHESIS
    wire [2:0] _GEN_186 = {2'h0, _GEN_5};
    always @(posedge clock) begin
      if (~reset & {1'h0, {1'h0, _GEN_1} + {1'h0, _GEN} + {1'h0, _GEN_0}}
          + {1'h0, {1'h0, _GEN_4} + {1'h0, _GEN_2} + {1'h0, _GEN_3}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_8} + {1'h0, _GEN_6} + {1'h0, _GEN_7}}
          + {1'h0, {1'h0, _GEN_11} + {1'h0, _GEN_9} + {1'h0, _GEN_10}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_14} + {1'h0, _GEN_12} + {1'h0, _GEN_13}}
          + {1'h0, {1'h0, _GEN_17} + {1'h0, _GEN_15} + {1'h0, _GEN_16}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_20} + {1'h0, _GEN_18} + {1'h0, _GEN_19}}
          + {1'h0, {1'h0, _GEN_23} + {1'h0, _GEN_21} + {1'h0, _GEN_22}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_26} + {1'h0, _GEN_24} + {1'h0, _GEN_25}}
          + {1'h0, {1'h0, _GEN_29} + {1'h0, _GEN_27} + {1'h0, _GEN_28}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_32} + {1'h0, _GEN_30} + {1'h0, _GEN_31}}
          + {1'h0, {1'h0, _GEN_35} + {1'h0, _GEN_33} + {1'h0, _GEN_34}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_38} + {1'h0, _GEN_36} + {1'h0, _GEN_37}}
          + {1'h0, {1'h0, _GEN_41} + {1'h0, _GEN_39} + {1'h0, _GEN_40}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_44} + {1'h0, _GEN_42} + {1'h0, _GEN_43}}
          + {1'h0, {1'h0, _GEN_47} + {1'h0, _GEN_45} + {1'h0, _GEN_46}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_50} + {1'h0, _GEN_48} + {1'h0, _GEN_49}}
          + {1'h0, {1'h0, _GEN_53} + {1'h0, _GEN_51} + {1'h0, _GEN_52}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_56} + {1'h0, _GEN_54} + {1'h0, _GEN_55}}
          + {1'h0, {1'h0, _GEN_59} + {1'h0, _GEN_57} + {1'h0, _GEN_58}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_62} + {1'h0, _GEN_60} + {1'h0, _GEN_61}}
          + {1'h0, {1'h0, _GEN_65} + {1'h0, _GEN_63} + {1'h0, _GEN_64}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_68} + {1'h0, _GEN_66} + {1'h0, _GEN_67}}
          + {1'h0, {1'h0, _GEN_71} + {1'h0, _GEN_69} + {1'h0, _GEN_70}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_74} + {1'h0, _GEN_72} + {1'h0, _GEN_73}}
          + {1'h0, {1'h0, _GEN_77} + {1'h0, _GEN_75} + {1'h0, _GEN_76}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_80} + {1'h0, _GEN_78} + {1'h0, _GEN_79}}
          + {1'h0, {1'h0, _GEN_83} + {1'h0, _GEN_81} + {1'h0, _GEN_82}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_86} + {1'h0, _GEN_84} + {1'h0, _GEN_85}}
          + {1'h0, {1'h0, _GEN_89} + {1'h0, _GEN_87} + {1'h0, _GEN_88}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_92} + {1'h0, _GEN_90} + {1'h0, _GEN_91}}
          + {1'h0, {1'h0, _GEN_95} + {1'h0, _GEN_93} + {1'h0, _GEN_94}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_98} + {1'h0, _GEN_96} + {1'h0, _GEN_97}}
          + {1'h0,
             {1'h0, _GEN_101} + {1'h0, _GEN_99} + {1'h0, _GEN_100}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_104} + {1'h0, _GEN_102} + {1'h0, _GEN_103}}
          + {1'h0,
             {1'h0, _GEN_107} + {1'h0, _GEN_105} + {1'h0, _GEN_106}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_110} + {1'h0, _GEN_108} + {1'h0, _GEN_109}}
          + {1'h0,
             {1'h0, _GEN_113} + {1'h0, _GEN_111} + {1'h0, _GEN_112}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_116} + {1'h0, _GEN_114} + {1'h0, _GEN_115}}
          + {1'h0,
             {1'h0, _GEN_119} + {1'h0, _GEN_117} + {1'h0, _GEN_118}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_122} + {1'h0, _GEN_120} + {1'h0, _GEN_121}}
          + {1'h0,
             {1'h0, _GEN_125} + {1'h0, _GEN_123} + {1'h0, _GEN_124}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_128} + {1'h0, _GEN_126} + {1'h0, _GEN_127}}
          + {1'h0,
             {1'h0, _GEN_131} + {1'h0, _GEN_129} + {1'h0, _GEN_130}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_134} + {1'h0, _GEN_132} + {1'h0, _GEN_133}}
          + {1'h0,
             {1'h0, _GEN_137} + {1'h0, _GEN_135} + {1'h0, _GEN_136}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_140} + {1'h0, _GEN_138} + {1'h0, _GEN_139}}
          + {1'h0,
             {1'h0, _GEN_143} + {1'h0, _GEN_141} + {1'h0, _GEN_142}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_146} + {1'h0, _GEN_144} + {1'h0, _GEN_145}}
          + {1'h0,
             {1'h0, _GEN_149} + {1'h0, _GEN_147} + {1'h0, _GEN_148}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_152} + {1'h0, _GEN_150} + {1'h0, _GEN_151}}
          + {1'h0,
             {1'h0, _GEN_155} + {1'h0, _GEN_153} + {1'h0, _GEN_154}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_158} + {1'h0, _GEN_156} + {1'h0, _GEN_157}}
          + {1'h0,
             {1'h0, _GEN_161} + {1'h0, _GEN_159} + {1'h0, _GEN_160}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_164} + {1'h0, _GEN_162} + {1'h0, _GEN_163}}
          + {1'h0,
             {1'h0, _GEN_167} + {1'h0, _GEN_165} + {1'h0, _GEN_166}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_170} + {1'h0, _GEN_168} + {1'h0, _GEN_169}}
          + {1'h0,
             {1'h0, _GEN_173} + {1'h0, _GEN_171} + {1'h0, _GEN_172}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_176} + {1'h0, _GEN_174} + {1'h0, _GEN_175}}
          + {1'h0,
             {1'h0, _GEN_179} + {1'h0, _GEN_177} + {1'h0, _GEN_178}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_182} + {1'h0, _GEN_180} + {1'h0, _GEN_181}}
          + {1'h0,
             {1'h0, _GEN_185} + {1'h0, _GEN_183} + {1'h0, _GEN_184}} > _GEN_186) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:146\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_1) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_3) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_4) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_5) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_6) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_7) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_8) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_9) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_10) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_11) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_12) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_13) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & write_fail_14) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:230\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & scoreboard_error) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Regfile.scala:237\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FetchControl_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FetchControl_Verification_Assert(
  input predecode_firstJumpOH_2,
        predecode_firstJumpOH_3,
        predecode_firstJumpOH_0,
        predecode_firstJumpOH_1,
        reset,
        _GEN,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & {1'h0, {1'h0, predecode_firstJumpOH_0} + {1'h0, predecode_firstJumpOH_1}}
          + {1'h0,
             {1'h0, predecode_firstJumpOH_2}
               + {1'h0, predecode_firstJumpOH_3}} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/CircularBufferMulti_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module CircularBufferMulti_Verification_Assert(
  input [3:0] io_nEnqueued,
  input [2:0] io_enqValid,
              io_deqReady,
  input       reset,
  input [3:0] _GEN,
  input       clock
);

  `ifndef SYNTHESIS
    wire [4:0] _GEN_0 = {1'h0, io_nEnqueued};
    wire [4:0] _GEN_1 = {2'h0, io_enqValid};
    always @(posedge clock) begin
      if (~reset & {1'h0, _GEN_0 + _GEN_1} - {3'h0, io_deqReady} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:43\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 > {1'h0, _GEN} - _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:44\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_deqReady} > io_nEnqueued) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:46\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/InstructionBuffer_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module InstructionBuffer_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        reset,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & (~_GEN & _GEN_0 | ~_GEN_0 & _GEN_1 | ~_GEN_1 & _GEN_2)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed: OneHotInOrder - Instructions not dispatched in order.\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Csr_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Csr_Verification_Assert(
  input [11:0] csr_address,
  input        _GEN,
               _GEN_0,
               _GEN_1,
               _GEN_2,
               _GEN_3,
               _GEN_4,
               _GEN_5,
               _GEN_6,
               _GEN_7,
               _GEN_8,
               _GEN_9,
               _GEN_10,
               _GEN_11,
               _GEN_12,
               _GEN_13,
               _GEN_14,
               _GEN_15,
               _GEN_16,
               _GEN_17,
               _GEN_18,
               _GEN_19,
               _GEN_20,
               _GEN_21,
               _GEN_22,
               _GEN_23,
               _GEN_24,
               _GEN_25,
               _GEN_26,
               _GEN_27,
               _GEN_28,
               _GEN_29,
               _GEN_30,
               _GEN_31,
               _GEN_32,
               _GEN_33,
               _GEN_34,
               _GEN_35,
               req_valid,
               reset,
               io_halted,
               io_wfi,
               io_fault,
               _GEN_36,
               io_rs1_valid,
               clock
);

  `ifndef SYNTHESIS
    wire marchidEn = csr_address == 12'hF12;
    wire mimpidEn = csr_address == 12'hF13;
    wire mhartidEn = csr_address == 12'hF14;
    wire kisaEn = csr_address == 12'hFC0;
    always @(posedge clock) begin
      if (~reset & req_valid
          & ~(csr_address == 12'h0 | _GEN | _GEN_0 | _GEN_1 | _GEN_2 | _GEN_3 | _GEN_4
              | _GEN_5 | _GEN_6 | _GEN_7 | _GEN_8 | _GEN_9 | _GEN_10 | _GEN_11 | _GEN_12
              | csr_address == 12'h7A0 | csr_address == 12'h7A1 | csr_address == 12'h7A2
              | csr_address == 12'h7A4 | csr_address == 12'h7B0 | csr_address == 12'h7B1
              | csr_address == 12'h7B2 | csr_address == 12'h7B3 | _GEN_13 | _GEN_14
              | _GEN_15 | _GEN_16 | _GEN_17 | _GEN_18 | _GEN_19 | _GEN_20 | _GEN_21
              | _GEN_22 | _GEN_23 | _GEN_24 | _GEN_25 | _GEN_26 | _GEN_27 | _GEN_28
              | _GEN_29 | _GEN_30 | marchidEn | mimpidEn | mhartidEn | kisaEn | _GEN_31
              | _GEN_32 | _GEN_33 | _GEN_34 | _GEN_35)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:312\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & io_fault & ~io_halted & ~io_wfi) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:383\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, {1'h0, _GEN} + {1'h0, _GEN_0}}
                 + {1'h0, {1'h0, _GEN_1} + {1'h0, _GEN_5} + {1'h0, _GEN_6}}}
                + {1'h0,
                   {1'h0, {1'h0, _GEN_7} + {1'h0, _GEN_8}}
                     + {1'h0, {1'h0, _GEN_9} + {1'h0, _GEN_10} + {1'h0, _GEN_11}}}}
               + {1'h0,
                  {1'h0,
                   {1'h0, {1'h0, _GEN_12} + {1'h0, _GEN_13}}
                     + {1'h0, {1'h0, _GEN_14} + {1'h0, _GEN_15} + {1'h0, _GEN_16}}}
                    + {1'h0,
                       {1'h0, {1'h0, _GEN_17} + {1'h0, _GEN_18}}
                         + {1'h0, {1'h0, _GEN_19} + {1'h0, _GEN_20} + {1'h0, _GEN_21}}}}}
          + {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, {1'h0, _GEN_22} + {1'h0, _GEN_23}}
                 + {1'h0, {1'h0, _GEN_25} + {1'h0, _GEN_24} + {1'h0, _GEN_26}}}
                + {1'h0,
                   {1'h0, {1'h0, _GEN_30} + {1'h0, marchidEn}}
                     + {1'h0, {1'h0, mimpidEn} + {1'h0, mhartidEn} + {1'h0, kisaEn}}}}
               + {1'h0,
                  {1'h0,
                   {1'h0, {1'h0, _GEN_31} + {1'h0, _GEN_32}}
                     + {1'h0, {1'h0, _GEN_33} + {1'h0, _GEN_34} + {1'h0, _GEN_35}}}
                    + {1'h0,
                       {1'h0, {1'h0, _GEN_2} + {1'h0, _GEN_27} + {1'h0, _GEN_28}}
                         + {1'h0,
                            {1'h0, _GEN_4} + {1'h0, _GEN_3}
                              + {1'h0, _GEN_29}}}}} > {5'h0, _GEN_36}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & req_valid & ~io_rs1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Csr.scala:612\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/DispatchV2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module DispatchV2_Verification_Assert(
  input decodedInsts_0_sub,
        _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        _GEN_3,
        _GEN_4,
        _GEN_5,
        _GEN_6,
        _GEN_7,
        decodedInsts_0_orn,
        decodedInsts_0_xnor,
        decodedInsts_0_lui,
        decodedInsts_0_andn,
        decodedInsts_0_ctz,
        decodedInsts_0_cpop,
        decodedInsts_0_clz,
        decodedInsts_0_min,
        decodedInsts_0_minu,
        decodedInsts_0_max,
        decodedInsts_0_maxu,
        decodedInsts_0_rol,
        decodedInsts_0_ror,
        decodedInsts_0_sextb,
        decodedInsts_0_sexth,
        decodedInsts_0_zexth,
        decodedInsts_0_rori,
        decodedInsts_0_orcb,
        decodedInsts_0_rev8,
        reset,
        _GEN_8,
        decodedInsts_0_jalr,
        decodedInsts_0_beq,
        decodedInsts_0_jal,
        decodedInsts_0_blt,
        decodedInsts_0_bge,
        decodedInsts_0_bne,
        decodedInsts_0_bgeu,
        decodedInsts_0_ebreak,
        decodedInsts_0_bltu,
        decodedInsts_0_mret,
        decodedInsts_0_wfi,
        decodedInsts_0_ecall,
        decodedInsts_0_mpause,
        decodedInsts_0_mulhsu,
        decodedInsts_0_mulhu,
        decodedInsts_0_mul,
        decodedInsts_0_mulh,
        decodedInsts_0_rem,
        decodedInsts_0_remu,
        decodedInsts_0_div,
        decodedInsts_0_divu,
        decodedInsts_0_lbu,
        decodedInsts_0_lhu,
        decodedInsts_0_lw,
        decodedInsts_0_lb,
        decodedInsts_0_lh,
        decodedInsts_0_fencei,
        decodedInsts_0_sw,
        decodedInsts_0_sb,
        decodedInsts_0_sh,
        _GEN_9,
        _GEN_10,
        _GEN_11,
        decodedInsts_0_flushat,
        decodedInsts_0_flushall,
        _GEN_12,
        _GEN_13,
        _GEN_14,
        _GEN_15,
        _GEN_16,
        _GEN_17,
        decodedInsts_0_csrrs,
        decodedInsts_0_csrrc,
        decodedInsts_0_csrrw,
        decodedInsts_1_sub,
        _GEN_18,
        _GEN_19,
        _GEN_20,
        _GEN_21,
        _GEN_22,
        _GEN_23,
        _GEN_24,
        _GEN_25,
        _GEN_26,
        decodedInsts_1_orn,
        decodedInsts_1_xnor,
        decodedInsts_1_lui,
        decodedInsts_1_andn,
        decodedInsts_1_ctz,
        decodedInsts_1_cpop,
        decodedInsts_1_clz,
        decodedInsts_1_min,
        decodedInsts_1_minu,
        decodedInsts_1_max,
        decodedInsts_1_maxu,
        decodedInsts_1_rol,
        decodedInsts_1_ror,
        decodedInsts_1_sextb,
        decodedInsts_1_sexth,
        decodedInsts_1_zexth,
        decodedInsts_1_rori,
        decodedInsts_1_orcb,
        decodedInsts_1_rev8,
        decodedInsts_1_jalr,
        decodedInsts_1_beq,
        decodedInsts_1_jal,
        decodedInsts_1_blt,
        decodedInsts_1_bge,
        decodedInsts_1_bne,
        decodedInsts_1_bgeu,
        decodedInsts_1_bltu,
        decodedInsts_1_mulhsu,
        decodedInsts_1_mulhu,
        decodedInsts_1_mul,
        decodedInsts_1_mulh,
        decodedInsts_1_lbu,
        decodedInsts_1_lhu,
        decodedInsts_1_lw,
        decodedInsts_1_lb,
        decodedInsts_1_lh,
        decodedInsts_1_sw,
        decodedInsts_1_sb,
        decodedInsts_1_sh,
        _GEN_27,
        _GEN_28,
        _GEN_29,
        _GEN_30,
        _GEN_31,
        _GEN_32,
        _GEN_33,
        _GEN_34,
        decodedInsts_2_sub,
        _GEN_35,
        _GEN_36,
        _GEN_37,
        _GEN_38,
        _GEN_39,
        _GEN_40,
        _GEN_41,
        _GEN_42,
        _GEN_43,
        decodedInsts_2_orn,
        decodedInsts_2_xnor,
        decodedInsts_2_lui,
        decodedInsts_2_andn,
        decodedInsts_2_ctz,
        decodedInsts_2_cpop,
        decodedInsts_2_clz,
        decodedInsts_2_min,
        decodedInsts_2_minu,
        decodedInsts_2_max,
        decodedInsts_2_maxu,
        decodedInsts_2_rol,
        decodedInsts_2_ror,
        decodedInsts_2_sextb,
        decodedInsts_2_sexth,
        decodedInsts_2_zexth,
        decodedInsts_2_rori,
        decodedInsts_2_orcb,
        decodedInsts_2_rev8,
        decodedInsts_2_jalr,
        decodedInsts_2_beq,
        decodedInsts_2_jal,
        decodedInsts_2_blt,
        decodedInsts_2_bge,
        decodedInsts_2_bne,
        decodedInsts_2_bgeu,
        decodedInsts_2_bltu,
        decodedInsts_2_mulhsu,
        decodedInsts_2_mulhu,
        decodedInsts_2_mul,
        decodedInsts_2_mulh,
        decodedInsts_2_lbu,
        decodedInsts_2_lhu,
        decodedInsts_2_lw,
        decodedInsts_2_lb,
        decodedInsts_2_lh,
        decodedInsts_2_sw,
        decodedInsts_2_sb,
        decodedInsts_2_sh,
        _GEN_44,
        _GEN_45,
        _GEN_46,
        _GEN_47,
        _GEN_48,
        _GEN_49,
        _GEN_50,
        _GEN_51,
        decodedInsts_3_sub,
        _GEN_52,
        _GEN_53,
        _GEN_54,
        _GEN_55,
        _GEN_56,
        _GEN_57,
        _GEN_58,
        _GEN_59,
        _GEN_60,
        decodedInsts_3_orn,
        decodedInsts_3_xnor,
        decodedInsts_3_lui,
        decodedInsts_3_andn,
        decodedInsts_3_ctz,
        decodedInsts_3_cpop,
        decodedInsts_3_clz,
        decodedInsts_3_min,
        decodedInsts_3_minu,
        decodedInsts_3_max,
        decodedInsts_3_maxu,
        decodedInsts_3_rol,
        decodedInsts_3_ror,
        decodedInsts_3_sextb,
        decodedInsts_3_sexth,
        decodedInsts_3_zexth,
        decodedInsts_3_rori,
        decodedInsts_3_orcb,
        decodedInsts_3_rev8,
        decodedInsts_3_jalr,
        decodedInsts_3_beq,
        decodedInsts_3_jal,
        decodedInsts_3_blt,
        decodedInsts_3_bge,
        decodedInsts_3_bne,
        decodedInsts_3_bgeu,
        decodedInsts_3_bltu,
        decodedInsts_3_mulhsu,
        decodedInsts_3_mulhu,
        decodedInsts_3_mul,
        decodedInsts_3_mulh,
        decodedInsts_3_lbu,
        decodedInsts_3_lhu,
        decodedInsts_3_lw,
        decodedInsts_3_lb,
        decodedInsts_3_lh,
        decodedInsts_3_sw,
        decodedInsts_3_sb,
        decodedInsts_3_sh,
        _GEN_61,
        _GEN_62,
        _GEN_63,
        _GEN_64,
        _GEN_65,
        _GEN_66,
        _GEN_67,
        _GEN_68,
        clock
);

  `ifndef SYNTHESIS
    wire [4:0] _GEN_69 = {4'h0, _GEN_8};
    wire [1:0] _GEN_70 = {1'h0, decodedInsts_0_wfi};
    wire [3:0] _GEN_71 = {3'h0, _GEN_8};
    wire [2:0] _GEN_72 = {2'h0, _GEN_8};
    always @(posedge clock) begin
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, _GEN_0} + {1'h0, decodedInsts_0_sub} + {1'h0, _GEN}}
                + {1'h0, {1'h0, _GEN_3} + {1'h0, _GEN_4}}
                + {1'h0, {1'h0, _GEN_1} + {1'h0, _GEN_2}}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_7} + {1'h0, _GEN_5} + {1'h0, _GEN_6}}
                    + {1'h0, {1'h0, decodedInsts_0_lui} + {1'h0, decodedInsts_0_andn}}
                    + {1'h0, {1'h0, decodedInsts_0_orn} + {1'h0, decodedInsts_0_xnor}}}}
          + {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, decodedInsts_0_clz} + {1'h0, decodedInsts_0_ctz}
                 + {1'h0, decodedInsts_0_cpop}}
                + {1'h0, {1'h0, decodedInsts_0_max} + {1'h0, decodedInsts_0_maxu}}
                + {1'h0, {1'h0, decodedInsts_0_min} + {1'h0, decodedInsts_0_minu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_0_sextb} + {1'h0, decodedInsts_0_sexth}}
                    + {1'h0, {1'h0, decodedInsts_0_rol} + {1'h0, decodedInsts_0_ror}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_0_orcb} + {1'h0, decodedInsts_0_rev8}}
                    + {1'h0,
                       {1'h0, decodedInsts_0_zexth}
                         + {1'h0, decodedInsts_0_rori}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, decodedInsts_0_jal} + {1'h0, decodedInsts_0_jalr}
                + {1'h0, decodedInsts_0_beq}}
               + {1'h0,
                  {1'h0, decodedInsts_0_bne} + {1'h0, decodedInsts_0_blt}
                    + {1'h0, decodedInsts_0_bge}}}
          + {1'h0,
             {1'h0,
              {1'h0, decodedInsts_0_bltu} + {1'h0, decodedInsts_0_bgeu}
                + {1'h0, decodedInsts_0_ebreak}}
               + {1'h0, {1'h0, decodedInsts_0_ecall} + {1'h0, decodedInsts_0_mpause}}
               + {1'h0, {1'h0, decodedInsts_0_mret} + _GEN_70}} > _GEN_71) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, decodedInsts_0_mul} + {1'h0, decodedInsts_0_mulh}}
          + {1'h0,
             {1'h0, decodedInsts_0_mulhsu}
               + {1'h0, decodedInsts_0_mulhu}} > _GEN_72) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, decodedInsts_0_div} + {1'h0, decodedInsts_0_divu}}
          + {1'h0,
             {1'h0, decodedInsts_0_rem} + {1'h0, decodedInsts_0_remu}} > _GEN_72) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, decodedInsts_0_lb} + {1'h0, decodedInsts_0_lh}}
                + {1'h0,
                   {1'h0, decodedInsts_0_lw} + {1'h0, decodedInsts_0_lbu}
                     + {1'h0, decodedInsts_0_lhu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_0_sb} + {1'h0, decodedInsts_0_sh}}
                    + {1'h0,
                       {1'h0, decodedInsts_0_sw} + _GEN_70
                         + {1'h0, decodedInsts_0_fencei}}}}
          + {1'h0,
             {1'h0,
              {1'h0, {1'h0, decodedInsts_0_flushat} + {1'h0, decodedInsts_0_flushall}}
                + {1'h0, {1'h0, _GEN_11} + {1'h0, _GEN_9} + {1'h0, _GEN_10}}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_14} + {1'h0, _GEN_12} + {1'h0, _GEN_13}}
                    + {1'h0,
                       {1'h0, _GEN_17} + {1'h0, _GEN_15}
                         + {1'h0, _GEN_16}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, decodedInsts_0_csrrw} + {1'h0, decodedInsts_0_csrrs}
          + {1'h0, decodedInsts_0_csrrc} > {1'h0, _GEN_8}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, _GEN_19} + {1'h0, decodedInsts_1_sub} + {1'h0, _GEN_18}}
                + {1'h0, {1'h0, _GEN_22} + {1'h0, _GEN_23}}
                + {1'h0, {1'h0, _GEN_20} + {1'h0, _GEN_21}}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_26} + {1'h0, _GEN_24} + {1'h0, _GEN_25}}
                    + {1'h0, {1'h0, decodedInsts_1_lui} + {1'h0, decodedInsts_1_andn}}
                    + {1'h0, {1'h0, decodedInsts_1_orn} + {1'h0, decodedInsts_1_xnor}}}}
          + {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, decodedInsts_1_clz} + {1'h0, decodedInsts_1_ctz}
                 + {1'h0, decodedInsts_1_cpop}}
                + {1'h0, {1'h0, decodedInsts_1_max} + {1'h0, decodedInsts_1_maxu}}
                + {1'h0, {1'h0, decodedInsts_1_min} + {1'h0, decodedInsts_1_minu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_1_sextb} + {1'h0, decodedInsts_1_sexth}}
                    + {1'h0, {1'h0, decodedInsts_1_rol} + {1'h0, decodedInsts_1_ror}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_1_orcb} + {1'h0, decodedInsts_1_rev8}}
                    + {1'h0,
                       {1'h0, decodedInsts_1_zexth}
                         + {1'h0, decodedInsts_1_rori}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, decodedInsts_1_jal} + {1'h0, decodedInsts_1_jalr}
                + {1'h0, decodedInsts_1_beq}}
               + {1'h0,
                  {1'h0, decodedInsts_1_bne} + {1'h0, decodedInsts_1_blt}
                    + {1'h0, decodedInsts_1_bge}}}
          + {2'h0,
             {1'h0, decodedInsts_1_bgeu} + {1'h0, decodedInsts_1_bltu}} > _GEN_71) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, decodedInsts_1_mul} + {1'h0, decodedInsts_1_mulh}}
          + {1'h0,
             {1'h0, decodedInsts_1_mulhsu}
               + {1'h0, decodedInsts_1_mulhu}} > _GEN_72) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, decodedInsts_1_lb} + {1'h0, decodedInsts_1_lh}}
                + {1'h0,
                   {1'h0, decodedInsts_1_lw} + {1'h0, decodedInsts_1_lbu}
                     + {1'h0, decodedInsts_1_lhu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_1_sb} + {1'h0, decodedInsts_1_sh}}
                    + {2'h0, decodedInsts_1_sw}}}
          + {1'h0,
             {2'h0, {1'h0, _GEN_33} + {1'h0, _GEN_34}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_29} + {1'h0, _GEN_27} + {1'h0, _GEN_28}}
                    + {1'h0,
                       {1'h0, _GEN_32} + {1'h0, _GEN_30}
                         + {1'h0, _GEN_31}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, _GEN_36} + {1'h0, decodedInsts_2_sub} + {1'h0, _GEN_35}}
                + {1'h0, {1'h0, _GEN_39} + {1'h0, _GEN_40}}
                + {1'h0, {1'h0, _GEN_37} + {1'h0, _GEN_38}}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_43} + {1'h0, _GEN_41} + {1'h0, _GEN_42}}
                    + {1'h0, {1'h0, decodedInsts_2_lui} + {1'h0, decodedInsts_2_andn}}
                    + {1'h0, {1'h0, decodedInsts_2_orn} + {1'h0, decodedInsts_2_xnor}}}}
          + {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, decodedInsts_2_clz} + {1'h0, decodedInsts_2_ctz}
                 + {1'h0, decodedInsts_2_cpop}}
                + {1'h0, {1'h0, decodedInsts_2_max} + {1'h0, decodedInsts_2_maxu}}
                + {1'h0, {1'h0, decodedInsts_2_min} + {1'h0, decodedInsts_2_minu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_2_sextb} + {1'h0, decodedInsts_2_sexth}}
                    + {1'h0, {1'h0, decodedInsts_2_rol} + {1'h0, decodedInsts_2_ror}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_2_orcb} + {1'h0, decodedInsts_2_rev8}}
                    + {1'h0,
                       {1'h0, decodedInsts_2_zexth}
                         + {1'h0, decodedInsts_2_rori}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, decodedInsts_2_jal} + {1'h0, decodedInsts_2_jalr}
                + {1'h0, decodedInsts_2_beq}}
               + {1'h0,
                  {1'h0, decodedInsts_2_bne} + {1'h0, decodedInsts_2_blt}
                    + {1'h0, decodedInsts_2_bge}}}
          + {2'h0,
             {1'h0, decodedInsts_2_bgeu} + {1'h0, decodedInsts_2_bltu}} > _GEN_71) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, decodedInsts_2_mul} + {1'h0, decodedInsts_2_mulh}}
          + {1'h0,
             {1'h0, decodedInsts_2_mulhsu}
               + {1'h0, decodedInsts_2_mulhu}} > _GEN_72) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, decodedInsts_2_lb} + {1'h0, decodedInsts_2_lh}}
                + {1'h0,
                   {1'h0, decodedInsts_2_lw} + {1'h0, decodedInsts_2_lbu}
                     + {1'h0, decodedInsts_2_lhu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_2_sb} + {1'h0, decodedInsts_2_sh}}
                    + {2'h0, decodedInsts_2_sw}}}
          + {1'h0,
             {2'h0, {1'h0, _GEN_50} + {1'h0, _GEN_51}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_46} + {1'h0, _GEN_44} + {1'h0, _GEN_45}}
                    + {1'h0,
                       {1'h0, _GEN_49} + {1'h0, _GEN_47}
                         + {1'h0, _GEN_48}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, _GEN_53} + {1'h0, decodedInsts_3_sub} + {1'h0, _GEN_52}}
                + {1'h0, {1'h0, _GEN_56} + {1'h0, _GEN_57}}
                + {1'h0, {1'h0, _GEN_54} + {1'h0, _GEN_55}}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_60} + {1'h0, _GEN_58} + {1'h0, _GEN_59}}
                    + {1'h0, {1'h0, decodedInsts_3_lui} + {1'h0, decodedInsts_3_andn}}
                    + {1'h0, {1'h0, decodedInsts_3_orn} + {1'h0, decodedInsts_3_xnor}}}}
          + {1'h0,
             {1'h0,
              {1'h0,
               {1'h0, decodedInsts_3_clz} + {1'h0, decodedInsts_3_ctz}
                 + {1'h0, decodedInsts_3_cpop}}
                + {1'h0, {1'h0, decodedInsts_3_max} + {1'h0, decodedInsts_3_maxu}}
                + {1'h0, {1'h0, decodedInsts_3_min} + {1'h0, decodedInsts_3_minu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_3_sextb} + {1'h0, decodedInsts_3_sexth}}
                    + {1'h0, {1'h0, decodedInsts_3_rol} + {1'h0, decodedInsts_3_ror}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_3_orcb} + {1'h0, decodedInsts_3_rev8}}
                    + {1'h0,
                       {1'h0, decodedInsts_3_zexth}
                         + {1'h0, decodedInsts_3_rori}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, decodedInsts_3_jal} + {1'h0, decodedInsts_3_jalr}
                + {1'h0, decodedInsts_3_beq}}
               + {1'h0,
                  {1'h0, decodedInsts_3_bne} + {1'h0, decodedInsts_3_blt}
                    + {1'h0, decodedInsts_3_bge}}}
          + {2'h0,
             {1'h0, decodedInsts_3_bgeu} + {1'h0, decodedInsts_3_bltu}} > _GEN_71) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, decodedInsts_3_mul} + {1'h0, decodedInsts_3_mulh}}
          + {1'h0,
             {1'h0, decodedInsts_3_mulhsu}
               + {1'h0, decodedInsts_3_mulhu}} > _GEN_72) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0,
              {1'h0, {1'h0, decodedInsts_3_lb} + {1'h0, decodedInsts_3_lh}}
                + {1'h0,
                   {1'h0, decodedInsts_3_lw} + {1'h0, decodedInsts_3_lbu}
                     + {1'h0, decodedInsts_3_lhu}}}
               + {1'h0,
                  {1'h0, {1'h0, decodedInsts_3_sb} + {1'h0, decodedInsts_3_sh}}
                    + {2'h0, decodedInsts_3_sw}}}
          + {1'h0,
             {2'h0, {1'h0, _GEN_67} + {1'h0, _GEN_68}}
               + {1'h0,
                  {1'h0, {1'h0, _GEN_63} + {1'h0, _GEN_61} + {1'h0, _GEN_62}}
                    + {1'h0,
                       {1'h0, _GEN_66} + {1'h0, _GEN_64}
                         + {1'h0, _GEN_65}}}} > _GEN_69) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/CircularBufferMulti_1_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module CircularBufferMulti_1_Verification_Assert(
  input [2:0] io_nEnqueued,
              io_enqValid,
              io_deqReady,
  input       reset,
  input [2:0] _GEN,
  input       clock
);

  `ifndef SYNTHESIS
    wire [3:0] _GEN_0 = {1'h0, io_nEnqueued};
    wire [3:0] _GEN_1 = {1'h0, io_enqValid};
    always @(posedge clock) begin
      if (~reset & {1'h0, _GEN_0 + _GEN_1} - {2'h0, io_deqReady} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:43\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 > {1'h0, _GEN} - _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:44\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & io_deqReady > io_nEnqueued) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:46\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/LsuV2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module LsuV2_Verification_Assert(
  input       _GEN,
              _GEN_0,
              _GEN_1,
              _GEN_2,
              reset,
              _GEN_3,
  input [2:0] io_req_0_bits_nfields,
  input       _GEN_4,
              _GEN_5,
              _GEN_6,
              _GEN_7,
              _GEN_8,
              _GEN_9,
              _GEN_10,
              _GEN_11,
              _GEN_12,
  input [2:0] io_req_1_bits_nfields,
  input       _GEN_13,
              _GEN_14,
              _GEN_15,
              _GEN_16,
              _GEN_17,
              _GEN_18,
              _GEN_19,
              _GEN_20,
              _GEN_21,
  input [2:0] io_req_2_bits_nfields,
  input       _GEN_22,
              _GEN_23,
              _GEN_24,
              _GEN_25,
              _GEN_26,
              _GEN_27,
              _GEN_28,
              _GEN_29,
              _GEN_30,
  input [2:0] io_req_3_bits_nfields,
  input       _GEN_31,
              _GEN_32,
              _GEN_33,
              _GEN_34,
              _GEN_35,
  input [2:0] opQueue_io_enqValid,
              opQueue_io_nSpace,
  input       _GEN_36,
              _GEN_37,
              _GEN_38,
              _GEN_39,
              _GEN_40,
              _GEN_41,
              _GEN_42,
              _GEN_43,
              _GEN_44,
              _nextSlot_active_WIRE_3_5,
              _nextSlot_active_WIRE_3_4,
              _nextSlot_active_WIRE_3_7,
              _nextSlot_active_WIRE_3_6,
              _nextSlot_active_WIRE_3_1,
              _nextSlot_active_WIRE_3_0,
              _nextSlot_active_WIRE_3_3,
              _nextSlot_active_WIRE_3_2,
              _GEN_45,
              _GEN_46,
              _GEN_47,
              _GEN_48,
              _GEN_49,
              _GEN_50,
              _GEN_51,
              _GEN_52,
              _GEN_53,
              _GEN_54,
              _GEN_55,
              _GEN_56,
              _GEN_57,
              _GEN_58,
              _GEN_59,
              _GEN_60,
              _GEN_61,
              _GEN_62,
              _GEN_63,
              _GEN_64,
              _GEN_65,
              _GEN_66,
              lineActive_0,
              lineActive_1,
              wactive_1,
              wactive_0,
              lineActive_2,
              lineActive_3,
              wactive_3,
              wactive_2,
              lineActive_4,
              lineActive_5,
              wactive_5,
              wactive_4,
              lineActive_6,
              lineActive_7,
              wactive_7,
              wactive_6,
              lineActive_8,
              lineActive_9,
              wactive_9,
              wactive_8,
              lineActive_10,
              lineActive_11,
              wactive_11,
              wactive_10,
              lineActive_12,
              lineActive_13,
              wactive_13,
              wactive_12,
              lineActive_14,
              lineActive_15,
              wactive_15,
              wactive_14,
              _GEN_67,
              _GEN_68,
              _GEN_69,
              _GEN_70,
              _GEN_71,
              _GEN_72,
              _GEN_73,
              io_dbus_valid,
              _GEN_74,
              _GEN_75,
              io_rd_flt_valid,
              _GEN_76,
              io_rd_valid,
  input [2:0] slot_vectorLoop_subvector_curr,
              slot_vectorLoop_subvector_max,
  input       _GEN_77,
              _GEN_78,
              slot_active_2,
              slot_active_3,
              slot_active_4,
              slot_active_5,
              slot_active_6,
              slot_active_7,
              slot_active_8,
              slot_active_9,
              slot_active_10,
              slot_active_11,
              slot_active_12,
              slot_active_13,
              slot_active_14,
              slot_active_15,
              slot_pendingWriteback,
              faultReg_valid,
              _GEN_79,
              clock
);

  `ifndef SYNTHESIS
    wire [2:0] _GEN_80 = {2'h0, _GEN_3};
    wire [1:0] _GEN_81 = {1'h0, _GEN_3};
    wire [1:0] _GEN_82 = {1'h0, _GEN_48};
    wire [1:0] _GEN_83 = {1'h0, _GEN_49};
    wire [1:0] _GEN_84 = {1'h0, _GEN_50};
    wire [1:0] _GEN_85 = {1'h0, _GEN_58};
    wire [1:0] _GEN_86 = {1'h0, _GEN_59};
    wire [1:0] _GEN_87 = {1'h0, _GEN_60};
    always @(posedge clock) begin
      if (~reset & {1'h0, {1'h0, _GEN_1} + {1'h0, _GEN_2}}
          + {1'h0, {1'h0, _GEN} + {1'h0, _GEN_0}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, io_req_0_bits_nfields == 3'h0} + {1'h0, _GEN_6}}
          + {1'h0, {1'h0, _GEN_4} + {1'h0, _GEN_5}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_7} + {1'h0, _GEN_8} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_11} + {1'h0, _GEN_12}}
          + {1'h0, {1'h0, _GEN_9} + {1'h0, _GEN_10}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, io_req_1_bits_nfields == 3'h0} + {1'h0, _GEN_15}}
          + {1'h0, {1'h0, _GEN_13} + {1'h0, _GEN_14}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_16} + {1'h0, _GEN_17} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_20} + {1'h0, _GEN_21}}
          + {1'h0, {1'h0, _GEN_18} + {1'h0, _GEN_19}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, io_req_2_bits_nfields == 3'h0} + {1'h0, _GEN_24}}
          + {1'h0, {1'h0, _GEN_22} + {1'h0, _GEN_23}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_25} + {1'h0, _GEN_26} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_29} + {1'h0, _GEN_30}}
          + {1'h0, {1'h0, _GEN_27} + {1'h0, _GEN_28}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, io_req_3_bits_nfields == 3'h0} + {1'h0, _GEN_33}}
          + {1'h0, {1'h0, _GEN_31} + {1'h0, _GEN_32}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_34} + {1'h0, _GEN_35} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & opQueue_io_enqValid > opQueue_io_nSpace) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:874\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_38} + {1'h0, _GEN_36} + {1'h0, _GEN_37} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_41} + {1'h0, _GEN_39} + {1'h0, _GEN_40} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_44} + {1'h0, _GEN_42} + {1'h0, _GEN_43} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_46} + {1'h0, _GEN_47}}
          + {1'h0,
             {1'h0, _GEN_45}
               + {1'h0,
                  |{_nextSlot_active_WIRE_3_7,
                    _nextSlot_active_WIRE_3_6,
                    _nextSlot_active_WIRE_3_5,
                    _nextSlot_active_WIRE_3_4,
                    _nextSlot_active_WIRE_3_3,
                    _nextSlot_active_WIRE_3_2,
                    _nextSlot_active_WIRE_3_1,
                    _nextSlot_active_WIRE_3_0}}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_84 + _GEN_82 + _GEN_83 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_53} + {1'h0, _GEN_51} + {1'h0, _GEN_52} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_84 + _GEN_82 + _GEN_83 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_56} + {1'h0, _GEN_57}}
          + {1'h0, {1'h0, _GEN_54} + {1'h0, _GEN_55}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_87 + _GEN_85 + _GEN_86 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_87 + _GEN_85 + _GEN_86 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_87 + _GEN_85 + _GEN_86 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_63} + {1'h0, _GEN_61} + {1'h0, _GEN_62} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_66} + {1'h0, _GEN_64} + {1'h0, _GEN_65} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & (|({1'h0,
                {1'h0,
                 {1'h0,
                  {1'h0, wactive_0 & ~lineActive_0} + {1'h0, wactive_1 & ~lineActive_1}}
                   + {1'h0,
                      {1'h0, wactive_2 & ~lineActive_2}
                        + {1'h0, wactive_3 & ~lineActive_3}}}
                  + {1'h0,
                     {1'h0,
                      {1'h0, wactive_4 & ~lineActive_4}
                        + {1'h0, wactive_5 & ~lineActive_5}}
                       + {1'h0,
                          {1'h0, wactive_6 & ~lineActive_6}
                            + {1'h0, wactive_7 & ~lineActive_7}}}}
               + {1'h0,
                  {1'h0,
                   {1'h0,
                    {1'h0, wactive_8 & ~lineActive_8} + {1'h0, wactive_9 & ~lineActive_9}}
                     + {1'h0,
                        {1'h0, wactive_10 & ~lineActive_10}
                          + {1'h0, wactive_11 & ~lineActive_11}}}
                    + {1'h0,
                       {1'h0,
                        {1'h0, wactive_12 & ~lineActive_12}
                          + {1'h0, wactive_13 & ~lineActive_13}}
                         + {1'h0,
                            {1'h0, wactive_14 & ~lineActive_14}
                              + {1'h0, wactive_15 & ~lineActive_15}}}}))) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at ScatterGather.scala:94\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, {1'h0, _GEN_69} + {1'h0, _GEN_70}}
          + {1'h0, {1'h0, _GEN_67} + {1'h0, _GEN_68}} > _GEN_80) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_73} + {1'h0, _GEN_71} + {1'h0, _GEN_72} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_75} + {1'h0, io_dbus_valid}
          + {1'h0, _GEN_74} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:958\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_rd_valid} + {1'h0, io_rd_flt_valid}
          + {1'h0, _GEN_76} > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:1051\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_87 + _GEN_85 + _GEN_86 > _GEN_81) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & ~(~_GEN_77
              | slot_vectorLoop_subvector_curr != slot_vectorLoop_subvector_max)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:1063\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & ~(~_GEN_79 | slot_vectorLoop_subvector_curr == slot_vectorLoop_subvector_max
              & ~(_GEN_78 | slot_active_2 | slot_active_3 | slot_active_4 | slot_active_5
                  | slot_active_6 | slot_active_7 | slot_active_8 | slot_active_9
                  | slot_active_10 | slot_active_11 | slot_active_12 | slot_active_13
                  | slot_active_14 | slot_active_15) & slot_pendingWriteback
              | faultReg_valid)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Lsu.scala:1064\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/CircularBufferMulti_2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module CircularBufferMulti_2_Verification_Assert(
  input [3:0] io_nEnqueued,
              io_enqValid,
              io_deqReady,
  input       reset,
  input [3:0] _GEN,
  input       clock
);

  `ifndef SYNTHESIS
    wire [4:0] _GEN_0 = {1'h0, io_nEnqueued};
    wire [4:0] _GEN_1 = {1'h0, io_enqValid};
    always @(posedge clock) begin
      if (~reset & {1'h0, _GEN_0 + _GEN_1} - {2'h0, io_deqReady} > {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:43\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_1 > {1'h0, _GEN} - _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:44\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & io_deqReady > io_nEnqueued) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at CircularBufferMulti.scala:46\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/RetirementBuffer_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module RetirementBuffer_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        reset,
        clock
);

  `ifndef SYNTHESIS
    wire seenFalseV_1 = ~_GEN_0 | ~_GEN;
    wire seenFalseV_2 = seenFalseV_1 | ~_GEN_1;
    always @(posedge clock) begin
      if (~reset
          & (seenFalseV_1 & _GEN | seenFalseV_2 & _GEN_1 | (seenFalseV_2 | ~_GEN_2)
             & _GEN_2)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at RetirementBuffer.scala:85\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Alu_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Alu_Verification_Assert(
  input io_rs1_valid,
        _GEN,
        valid,
        reset,
        io_rs2_valid,
        _rs1Only_WIRE_5,
        _rs1Only_WIRE_4,
        _rs1Only_WIRE_7,
        _rs1Only_WIRE_6,
        _rs1Only_WIRE_1,
        _rs1Only_WIRE_0,
        _rs1Only_WIRE_3,
        _rs1Only_WIRE_2,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & valid & ~io_rs1_valid & ~_GEN) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Alu.scala:159\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & valid & ~io_rs2_valid
          & {_rs1Only_WIRE_7,
             _rs1Only_WIRE_6,
             _rs1Only_WIRE_5,
             _rs1Only_WIRE_4,
             _rs1Only_WIRE_3,
             _rs1Only_WIRE_2,
             _rs1Only_WIRE_1,
             _rs1Only_WIRE_0} == 8'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Alu.scala:160\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Bru_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Bru_Verification_Assert(
  input io_rs1_valid,
        stateReg_valid,
        _ignore_WIRE_5,
        _ignore_WIRE_4,
        _ignore_WIRE_7,
        _ignore_WIRE_6,
        _ignore_WIRE_1,
        _ignore_WIRE_0,
        _ignore_WIRE_3,
        _ignore_WIRE_2,
        reset,
        io_rs2_valid,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & {~(stateReg_valid & ~io_rs1_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:289\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs2_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:290\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Bru_1_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Bru_1_Verification_Assert(
  input _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        _GEN_3,
        reset,
        io_rs1_valid,
        stateReg_valid,
        _ignore_WIRE_5,
        _ignore_WIRE_4,
        _ignore_WIRE_7,
        _ignore_WIRE_6,
        _ignore_WIRE_1,
        _ignore_WIRE_0,
        _ignore_WIRE_3,
        _ignore_WIRE_2,
        io_rs2_valid,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & (|{_GEN, _GEN_0, _GEN_3, _GEN_1, _GEN_2})) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:168\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs1_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:289\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {~(stateReg_valid & ~io_rs2_valid),
             _ignore_WIRE_7,
             _ignore_WIRE_6,
             _ignore_WIRE_5,
             _ignore_WIRE_4,
             _ignore_WIRE_3,
             _ignore_WIRE_2,
             _ignore_WIRE_1,
             _ignore_WIRE_0} == 9'h0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Bru.scala:290\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/Mlu_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module Mlu_Verification_Assert(
  input io_rs1_0_valid,
        stage2Input_q_io_deq_valid,
        _GEN,
        reset,
        io_rs2_0_valid,
        io_rs1_1_valid,
        _GEN_0,
        io_rs2_1_valid,
        io_rs1_2_valid,
        _GEN_1,
        io_rs2_2_valid,
        io_rs1_3_valid,
        _GEN_2,
        io_rs2_3_valid,
        clock
);

  `ifndef SYNTHESIS
    wire _GEN_3 = stage2Input_q_io_deq_valid & _GEN;
    wire _GEN_4 = stage2Input_q_io_deq_valid & _GEN_0;
    wire _GEN_5 = stage2Input_q_io_deq_valid & _GEN_1;
    wire _GEN_6 = stage2Input_q_io_deq_valid & _GEN_2;
    always @(posedge clock) begin
      if (~reset & _GEN_3 & ~io_rs1_0_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:122\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_3 & ~io_rs2_0_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:123\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_4 & ~io_rs1_1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:122\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_4 & ~io_rs2_1_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:123\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_5 & ~io_rs1_2_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:122\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_5 & ~io_rs2_2_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:123\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_6 & ~io_rs1_3_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:122\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & _GEN_6 & ~io_rs2_3_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Mlu.scala:123\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FRegfile_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FRegfile_Verification_Assert(
  input reset,
        scoreboard_error,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & scoreboard_error) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at FRegfile.scala:47\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/SCore_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module SCore_Verification_Assert(
  input csr_io_rd_valid,
        alu_0_io_rd_valid,
        bru_0_io_rd_valid,
        io_rvvcore_rd_0_valid,
        reset,
        _GEN,
        alu_1_io_rd_valid,
        bru_1_io_rd_valid,
        io_rvvcore_rd_1_valid,
        alu_2_io_rd_valid,
        bru_2_io_rd_valid,
        io_rvvcore_rd_2_valid,
        alu_3_io_rd_valid,
        bru_3_io_rd_valid,
        io_rvvcore_rd_3_valid,
        clock
);

  `ifndef SYNTHESIS
    wire [3:0] _GEN_0 = {3'h0, _GEN};
    always @(posedge clock) begin
      if (~reset
          & {1'h0,
             {1'h0, {1'h0, csr_io_rd_valid} + {1'h0, alu_0_io_rd_valid}}
               + {2'h0, bru_0_io_rd_valid}}
          + {3'h0, io_rvvcore_rd_0_valid} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:315\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0, {1'h0, alu_1_io_rd_valid} + {1'h0, bru_1_io_rd_valid}}
               + {2'h0, io_rvvcore_rd_1_valid}} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:315\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0, {1'h0, alu_2_io_rd_valid} + {1'h0, bru_2_io_rd_valid}}
               + {2'h0, io_rvvcore_rd_2_valid}} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:315\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset
          & {1'h0,
             {1'h0, {1'h0, alu_3_io_rd_valid} + {1'h0, bru_3_io_rd_valid}}
               + {2'h0, io_rvvcore_rd_3_valid}} > _GEN_0) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at SCore.scala:315\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/SRAM_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module SRAM_Verification_Assert(
  input io_fabric_writeDataAddr_valid,
        io_fabric_readDataAddr_valid,
        reset,
        _GEN,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & {1'h0, io_fabric_writeDataAddr_valid}
          + {1'h0, io_fabric_readDataAddr_valid} > {1'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FabricArbiter_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FabricArbiter_Verification_Assert(
  input io_source_1_readDataAddr_valid,
        io_source_1_writeDataAddr_valid,
        io_source_0_readDataAddr_valid,
        io_source_0_writeDataAddr_valid,
        reset,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset
          & (io_source_0_readDataAddr_valid & io_source_0_writeDataAddr_valid
             | io_source_1_readDataAddr_valid & io_source_1_writeDataAddr_valid)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:31\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/SRAM_1_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module SRAM_1_Verification_Assert(
  input io_fabric_writeDataAddr_valid,
        io_fabric_readDataAddr_valid,
        reset,
        _GEN,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & {1'h0, io_fabric_writeDataAddr_valid}
          + {1'h0, io_fabric_readDataAddr_valid} > {1'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/FabricMux_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module FabricMux_Verification_Assert(
  input io_source_readDataAddr_valid,
        io_source_writeDataAddr_valid,
        reset,
        _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        _GEN_3,
        _GEN_4,
        _GEN_5,
        _GEN_6,
        _GEN_7,
        _GEN_8,
        _GEN_9,
        _GEN_10,
        _GEN_11,
        _GEN_12,
        _GEN_13,
        _GEN_14,
        _GEN_15,
        clock
);

  `ifndef SYNTHESIS
    wire [1:0] _GEN_16 = {1'h0, _GEN};
    always @(posedge clock) begin
      if (~reset & io_source_readDataAddr_valid & io_source_writeDataAddr_valid) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:72\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, io_source_readDataAddr_valid}
          + {1'h0, io_source_writeDataAddr_valid} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_2} + {1'h0, _GEN_0} + {1'h0, _GEN_1} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Fabric.scala:88\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_6} + {1'h0, _GEN_5}
          + {1'h0, _GEN_3 & _GEN_4} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_9} + {1'h0, _GEN_7} + {1'h0, _GEN_8} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_12} + {1'h0, _GEN_10} + {1'h0, _GEN_11} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_15} + {1'h0, _GEN_13} + {1'h0, _GEN_14} > _GEN_16) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/AxiSlave_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module AxiSlave_Verification_Assert(
  input readIssued_valid,
        reset,
        readDataQueue_io_enq_ready,
        _GEN,
        _GEN_0,
        _GEN_1,
        _GEN_2,
        clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~(~readIssued_valid | readDataQueue_io_enq_ready)) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at AxiSlave.scala:130\n");
        if (`STOP_COND_)
          $fatal;
      end
      if (~reset & {1'h0, _GEN_1} + {1'h0, _GEN} + {1'h0, _GEN_0} > {1'h0, _GEN_2}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed at Library.scala:234\n");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "verification/assert/DBus2AxiV2_Verification_Assert.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifndef STOP_COND_
  `ifdef STOP_COND
    `define STOP_COND_ (`STOP_COND)
  `else  // STOP_COND
    `define STOP_COND_ 1
  `endif // STOP_COND
`endif // not def STOP_COND_

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifndef ASSERT_VERBOSE_COND_
  `ifdef ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
  `else  // ASSERT_VERBOSE_COND
    `define ASSERT_VERBOSE_COND_ 1
  `endif // ASSERT_VERBOSE_COND
`endif // not def ASSERT_VERBOSE_COND_
module DBus2AxiV2_Verification_Assert(
  input [4:0] io_dbus_size,
  input       _GEN,
              io_dbus_valid,
              reset,
              clock
);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & io_dbus_valid
          & {1'h0, {1'h0, io_dbus_size[0]} + {1'h0, io_dbus_size[1]}}
          + {1'h0,
             {1'h0, io_dbus_size[2]} + {1'h0, io_dbus_size[3]}
               + {1'h0, io_dbus_size[4]}} != {2'h0, _GEN}) begin
        if (`ASSERT_VERBOSE_COND_)
          $error("Assertion failed: Invalid dbus size=%d\n", io_dbus_size);
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule


// ----- 8< ----- FILE "./RstSync.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A module for synchronizing Asynchronous external reset to
// an internal synchronous deassert reset
// Clock is disabled while reset is asserted to prevent a race
// between clock and reset.
module RstSync
    (
        // Input clock
        input clk_i,
        // Input active-low async reset
        input rstn_i,
        // Functional clock gate enable. clk_o is enabled when clk_en
        // is 1, and we are out of reset
        // clk_en is assumed to be synchronous to clk_o or clk_i
        input clk_en,
        input te,

        // Output clock
        output clk_o,
        // Output reset active low
        output rstn_o);

  localparam RST_DELAY = 2;
  localparam CLK_DELAY = 2;

  logic [RST_DELAY + CLK_DELAY - 1 : 0] rst_delay_reg;
  always_ff @(posedge clk_i or negedge rstn_i) begin
    if (~rstn_i)
      rst_delay_reg <= '0;
    else
      rst_delay_reg <= {rst_delay_reg[RST_DELAY + CLK_DELAY - 2 : 0], 1'b1};
  end

  assign rstn_o = rst_delay_reg[RST_DELAY - 1];

  logic clk_en_int;
  assign clk_en_int = clk_en & rst_delay_reg[CLK_DELAY + RST_DELAY - 1];

  ClockGate icg(.clk_i(clk_i),
                .enable(clk_en_int),
                .te(te),
                .clk_o(clk_o));

`ifndef SYNTHESIS
  initial begin
    assert (RST_DELAY >= 2);
    assert (CLK_DELAY >= 2);
  end
`endif
endmodule
// ----- 8< ----- FILE "./ClockGate.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A ClockGate module. The underlying implementation varies based on
// preprocessor.
// Default: ASIC implementation
// USE_GENERIC default: Verilator implementation (adapted from OpenTitan)
// USE_GENERIC and FPGA_XILINX: UltraScale Plus specific clockgate.
module ClockGate(
  input         clk_i,
  input         enable,  // '1' passthrough, '0' disable.
  input         te,      // test enable
  output        clk_o
);

///////////////////////////
/// ClockGate Selection ///
///////////////////////////
`ifdef USE_TSMC12FFC
  // TSMC12FFC Specific ClockGate
  CKLNQD10BWP6T20P96CPDLVT u_cg(
    .TE(te),
    .E(enable),
    .CP(clk_i),
    .Q(clk_o)
  );
`elsif USE_GF22
  // GF22 Specific ClockGate
  SC7P5T_CKGPRELATNX8_CSC36L u_cg (
    .CLK(clk_i),
    .E(enable),
    .TE(te),
    .Z(clk_o)
  );

`elsif FPGA_XILINX
  // Xilinx FPGA Specific ClockGate
  BUFGCE #(
    .SIM_DEVICE("ULTRASCALE_PLUS")
  ) u_bufgce (
    .I (clk_i),
    .CE(enable | te),
    .O (clk_o)
  );
`else
  // Default: Verilator implementation
  logic en_latch /* verilator clock_enable */;
  always_latch begin
    if (!clk_i) begin
      en_latch = enable | te;
    end
  end
  assign clk_o = en_latch & clk_i;
`endif

endmodule  // ClockGate
// ----- 8< ----- FILE "./Aligner.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A module that moves valid inputs to the front of the output.
// Example:
// valid_in = [0, 1, 0, 1], data_in = [A, B, C, D]
// valid_out = [1, 1, 0, 0], data_out = [B, D, X, X]
module Aligner#(type T=logic [7:0], parameter N = 8)
(
  // Command input.
  input logic [N-1:0] valid_in,
  input T [N-1:0] data_in,

  // Command output.
  output logic [N-1:0] valid_out,
  output T [N-1:0] data_out
);
/* verilator lint_off WIDTHEXPAND */
/* verilator lint_off WIDTHTRUNC */
  localparam COUNTBITS = $clog2(N);
  typedef logic [COUNTBITS-1:0] count_t;

  // Build count
  count_t valid_count [N-1:0];
  always_comb begin
    valid_count[0] = 0;
    for (int i = 0; i < N-1; i++) begin
        valid_count[i+1] = valid_count[i] + valid_in[i];
    end
  end

  logic [N-1:0][N-1:0] output_valid_map;
  count_t valid_idx [N-1:0];
  always_comb begin
    
    for (int o = 0; o < N; o++) begin
      valid_idx[o] = 0;
      for (int i = 0; i < N; i++) begin
        output_valid_map[o][i] = (valid_count[i] == o) && valid_in[i];
        valid_idx[o] = valid_idx[o] | (output_valid_map[o][i] ? i : 0);
      end

      // Assign outputs
      valid_out[o] = |output_valid_map[o];
      data_out[o] = data_in[valid_idx[o]];
    end
  end
/* verilator lint_on WIDTHTRUNC */
/* verilator lint_on WIDTHEXPAND */

endmodule
// ----- 8< ----- FILE "./Aligner_119_4.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module Aligner_119_4(
  input logic in_0_valid,
  input logic in_1_valid,
  input logic in_2_valid,
  input logic in_3_valid,
  input logic [119-1:0] in_0_bits,
  input logic [119-1:0] in_1_bits,
  input logic [119-1:0] in_2_bits,
  input logic [119-1:0] in_3_bits,
  output logic out_0_valid,
  output logic out_1_valid,
  output logic out_2_valid,
  output logic out_3_valid,
  output logic [119-1:0] out_0_bits,
  output logic [119-1:0] out_1_bits,
  output logic [119-1:0] out_2_bits,
  output logic [119-1:0] out_3_bits);

  logic [4-1:0] valid_in;
  assign valid_in[0] = in_0_valid;
  assign valid_in[1] = in_1_valid;
  assign valid_in[2] = in_2_valid;
  assign valid_in[3] = in_3_valid;
  logic [4-1:0][119-1:0] data_in;
  assign data_in[0] = in_0_bits;
  assign data_in[1] = in_1_bits;
  assign data_in[2] = in_2_bits;
  assign data_in[3] = in_3_bits;
  logic [4-1:0] valid_out;
  assign out_0_valid = valid_out[0];
  assign out_1_valid = valid_out[1];
  assign out_2_valid = valid_out[2];
  assign out_3_valid = valid_out[3];
  logic [4-1:0][119-1:0] data_out;
  assign out_0_bits = data_out[0];
  assign out_1_bits = data_out[1];
  assign out_2_bits = data_out[2];
  assign out_3_bits = data_out[3];

  Aligner#(.T (logic [119-1:0]), .N(4)) aligner(
    valid_in,
    data_in,
    valid_out,
    data_out
  );
endmodule
// ----- 8< ----- FILE "./registers.svh" ----- 8< -----

// Copyright 2018 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// Common register defines for RTL designs
`ifndef COMMON_CELLS_REGISTERS_SVH_
`define COMMON_CELLS_REGISTERS_SVH_

// Abridged Summary of available FF macros:
// `FF:      asynchronous active-low reset (implicit clock and reset)
// `FFAR:    asynchronous active-high reset
// `FFARN:   asynchronous active-low reset
// `FFSR:    synchronous active-high reset
// `FFSRN:   synchronous active-low reset
// `FFNR:    without reset
// `FFL:     load-enable and asynchronous active-low reset (implicit clock and reset)
// `FFLAR:   load-enable and asynchronous active-high reset
// `FFLARN:  load-enable and asynchronous active-low reset
// `FFLARNC: load-enable and asynchronous active-low reset and synchronous active-high clear
// `FFLSR:   load-enable and synchronous active-high reset
// `FFLSRN:  load-enable and synchronous active-low reset
// `FFLNR:   load-enable without reset


// Flip-Flop with asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FF(__q, __d, __reset_value)                  \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__d);                                  \
    end                                              \
  end

// Flip-Flop with asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFAR(__q, __d, __reset_value, __clk, __arst)     \
  always_ff @(posedge (__clk) or posedge (__arst)) begin \
    if (__arst) begin                                    \
      __q <= (__reset_value);                            \
    end else begin                                       \
      __q <= (__d);                                      \
    end                                                  \
  end

// Flip-Flop with asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFARN(__q, __d, __reset_value, __clk, __arst_n)    \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin \
    if (!__arst_n) begin                                   \
      __q <= (__reset_value);                              \
    end else begin                                         \
      __q <= (__d);                                        \
    end                                                    \
  end

// Flip-Flop with synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFSR(__q, __d, __reset_value, __clk, __reset_clk) \
  `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                      \
    __q <= (__reset_clk) ? (__reset_value) : (__d);       \
  end

// Flip-Flop with synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFSRN(__q, __d, __reset_value, __clk, __reset_n_clk) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/        \
    `endif                        \
  always_ff @(posedge (__clk)) begin                         \
    __q <= (!__reset_n_clk) ? (__reset_value) : (__d);       \
  end

// Always-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __clk: clock input
`define FFNR(__q, __d, __clk)        \
  always_ff @(posedge (__clk)) begin \
    __q <= (__d);                    \
  end

// Flip-Flop with load-enable and asynchronous active-low reset (implicit clock and reset)
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// Implicit:
// clk_i: clock input
// rst_ni: reset input (asynchronous, active low)
`define FFL(__q, __d, __load, __reset_value)         \
  always_ff @(posedge clk_i or negedge rst_ni) begin \
    if (!rst_ni) begin                               \
      __q <= (__reset_value);                        \
    end else begin                                   \
      __q <= (__load) ? (__d) : (__q);               \
    end                                              \
  end

// Flip-Flop with load-enable and asynchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst: asynchronous reset
`define FFLAR(__q, __d, __load, __reset_value, __clk, __arst) \
  always_ff @(posedge (__clk) or posedge (__arst)) begin      \
    if (__arst) begin                                         \
      __q <= (__reset_value);                                 \
    end else begin                                            \
      __q <= (__load) ? (__d) : (__q);                        \
    end                                                       \
  end

// Flip-Flop with load-enable and asynchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARN(__q, __d, __load, __reset_value, __clk, __arst_n) \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin       \
    if (!__arst_n) begin                                         \
      __q <= (__reset_value);                                    \
    end else begin                                               \
      __q <= (__load) ? (__d) : (__q);                           \
    end                                                          \
  end

// Flip-Flop with load-enable and synchronous active-high reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_clk: reset input
`define FFLSR(__q, __d, __load, __reset_value, __clk, __reset_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_clk`" *``/                      \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                     \
    __q <= (__reset_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and synchronous active-low reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __reset_n_clk: reset input
`define FFLSRN(__q, __d, __load, __reset_value, __clk, __reset_n_clk)       \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__reset_n_clk`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk)) begin                                        \
    __q <= (!__reset_n_clk) ? (__reset_value) : ((__load) ? (__d) : (__q)); \
  end

// Flip-Flop with load-enable and asynchronous active-low reset and synchronous clear
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clear: assign reset value into FF
// __reset_value: value assigned upon reset
// __clk: clock input
// __arst_n: asynchronous reset
`define FFLARNC(__q, __d, __load, __clear, __reset_value, __clk, __arst_n) \
    `ifndef VERILATOR                       \
  /``* synopsys sync_set_reset `"__clear`" *``/                       \
    `endif                        \
  always_ff @(posedge (__clk) or negedge (__arst_n)) begin                 \
    if (!__arst_n) begin                                                   \
      __q <= (__reset_value);                                              \
    end else begin                                                         \
      __q <= (__clear) ? (__reset_value) : (__load) ? (__d) : (__q);       \
    end                                                                    \
  end

// Load-enable Flip-Flop without reset
// __q: Q output of FF
// __d: D input of FF
// __load: load d value into FF
// __clk: clock input
`define FFLNR(__q, __d, __load, __clk) \
  always_ff @(posedge (__clk)) begin   \
    __q <= (__load) ? (__d) : (__q);   \
  end

`endif
// ----- 8< ----- FILE "./cf_math_pkg.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2016 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

/// cf_math_pkg: Constant Function Implementations of Mathematical Functions for HDL Elaboration
///
/// This package contains a collection of mathematical functions that are commonly used when defining
/// the value of constants in HDL code.  These functions are implemented as Verilog constants
/// functions.  Introduced in Verilog 2001 (IEEE Std 1364-2001), a constant function (?? 10.3.5) is a
/// function whose value can be evaluated at compile time or during elaboration.  A constant function
/// must be called with arguments that are constants.
package cf_math_pkg;

    /// Ceiled Division of Two Natural Numbers
    ///
    /// Returns the quotient of two natural numbers, rounded towards plus infinity.
    function automatic integer ceil_div (input longint dividend, input longint divisor);
        automatic longint remainder;

        // pragma translate_off
        `ifndef VERILATOR
        if (dividend < 0) begin
            $fatal(1, "Dividend %0d is not a natural number!", dividend);
        end

        if (divisor < 0) begin
            $fatal(1, "Divisor %0d is not a natural number!", divisor);
        end

        if (divisor == 0) begin
            $fatal(1, "Division by zero!");
        end
        `endif
        // pragma translate_on

        remainder = dividend;
        for (ceil_div = 0; remainder > 0; ceil_div++) begin
            remainder = remainder - divisor;
        end
    endfunction

    /// Index width required to be able to represent up to `num_idx` indices as a binary
    /// encoded signal.
    /// Ensures that the minimum width if an index signal is `1`, regardless of parametrization.
    ///
    /// Sample usage in type definition:
    /// As parameter:
    ///   `parameter type idx_t = logic[cf_math_pkg::idx_width(NumIdx)-1:0]`
    /// As typedef:
    ///   `typedef logic [cf_math_pkg::idx_width(NumIdx)-1:0] idx_t`
    function automatic integer unsigned idx_width (input integer unsigned num_idx);
        return (num_idx > 32'd1) ? unsigned'($clog2(num_idx)) : 32'd1;
    endfunction

endpackage
// ----- 8< ----- FILE "./lzc.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright (c) 2018 - 2019 ETH Zurich, University of Bologna
// All rights reserved.
//
// This code is under development and not yet released to the public.
// Until it is released, the code is under the copyright of ETH Zurich and
// the University of Bologna, and may contain confidential and/or unpublished
// work. Any reuse/redistribution is strictly forbidden without written
// permission from ETH Zurich.
//
// Bug fixes and contributions will eventually be released under the
// SolderPad open hardware license in the context of the PULP platform
// (http://www.pulp-platform.org), under the copyright of ETH Zurich and the
// University of Bologna.

/// A trailing zero counter / leading zero counter.
/// Set MODE to 0 for trailing zero counter => cnt_o is the number of trailing zeros (from the LSB)
/// Set MODE to 1 for leading zero counter  => cnt_o is the number of leading zeros  (from the MSB)
/// If the input does not contain a zero, `empty_o` is asserted. Additionally `cnt_o` contains
/// the maximum number of zeros - 1. For example:
///   in_i = 000_0000, empty_o = 1, cnt_o = 6 (mode = 0)
///   in_i = 000_0001, empty_o = 0, cnt_o = 0 (mode = 0)
///   in_i = 000_1000, empty_o = 0, cnt_o = 3 (mode = 0)
/// Furthermore, this unit contains a more efficient implementation for Verilator (simulation only).
/// This speeds up simulation significantly.
module lzc #(
  /// The width of the input vector.
  parameter int unsigned WIDTH = 2,
  /// Mode selection: 0 -> trailing zero, 1 -> leading zero
  parameter bit          MODE  = 1'b0,
  /// Dependent parameter. Do **not** change!
  ///
  /// Width of the output signal with the zero count.
  parameter int unsigned CNT_WIDTH = cf_math_pkg::idx_width(WIDTH)
) (
  /// Input vector to be counted.
  input  logic [WIDTH-1:0]     in_i,
  /// Count of the leading / trailing zeros.
  output logic [CNT_WIDTH-1:0] cnt_o,
  /// Counter is empty: Asserted if all bits in in_i are zero.
  output logic                 empty_o
);

  if (WIDTH == 1) begin : gen_degenerate_lzc

    assign cnt_o[0] = !in_i[0];
    assign empty_o = !in_i[0];

  end else begin : gen_lzc

    localparam int unsigned NumLevels = $clog2(WIDTH);

    // pragma translate_off
    initial begin
      assert(WIDTH > 0) else $fatal(1, "input must be at least one bit wide");
    end
    // pragma translate_on

    logic [WIDTH-1:0][NumLevels-1:0] index_lut;
    logic [2**NumLevels-1:0] sel_nodes;
    logic [2**NumLevels-1:0][NumLevels-1:0] index_nodes;

    logic [WIDTH-1:0] in_tmp;

    // reverse vector if required
    always_comb begin : flip_vector
      for (int unsigned i = 0; i < WIDTH; i++) begin
        in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];
      end
    end

    for (genvar j = 0; unsigned'(j) < WIDTH; j++) begin : g_index_lut
      assign index_lut[j] = (NumLevels)'(unsigned'(j));
    end

    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : g_levels
      if (unsigned'(level) == NumLevels - 1) begin : g_last_level
        for (genvar k = 0; k < 2 ** level; k++) begin : g_level
          // if two successive indices are still in the vector...
          if (unsigned'(k) * 2 < WIDTH - 1) begin : g_reduce
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2] | in_tmp[k * 2 + 1];
            assign index_nodes[2 ** level - 1 + k] = (in_tmp[k * 2] == 1'b1)
              ? index_lut[k * 2] :
                index_lut[k * 2 + 1];
          end
          // if only the first index is still in the vector...
          if (unsigned'(k) * 2 == WIDTH - 1) begin : g_base
            assign sel_nodes[2 ** level - 1 + k] = in_tmp[k * 2];
            assign index_nodes[2 ** level - 1 + k] = index_lut[k * 2];
          end
          // if index is out of range
          if (unsigned'(k) * 2 > WIDTH - 1) begin : g_out_of_range
            assign sel_nodes[2 ** level - 1 + k] = 1'b0;
            assign index_nodes[2 ** level - 1 + k] = '0;
          end
        end
      end else begin : g_not_last_level
        for (genvar l = 0; l < 2 ** level; l++) begin : g_level
          assign sel_nodes[2 ** level - 1 + l] =
              sel_nodes[2 ** (level + 1) - 1 + l * 2] | sel_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
          assign index_nodes[2 ** level - 1 + l] = (sel_nodes[2 ** (level + 1) - 1 + l * 2] == 1'b1)
            ? index_nodes[2 ** (level + 1) - 1 + l * 2] :
              index_nodes[2 ** (level + 1) - 1 + l * 2 + 1];
        end
      end
    end

    assign cnt_o = NumLevels > unsigned'(0) ? index_nodes[0] : {($clog2(WIDTH)) {1'b0}};
    assign empty_o = NumLevels > unsigned'(0) ? ~sel_nodes[0] : ~(|in_i);

  end : gen_lzc

endmodule : lzc
// ----- 8< ----- FILE "./rr_arb_tree.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich
//         Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>, ETH Zurich
// Date: 02.04.2019
// Description: logarithmic arbitration tree with round robin arbitration scheme.

/// The rr_arb_tree employs non-starving round robin-arbitration - i.e., the priorities
/// rotate each cycle.
///
/// ## Fair vs. unfair Arbitration
///
/// This refers to fair throughput distribution when not all inputs have active requests.
/// This module has an internal state `rr_q` which defines the highest priority input. (When
/// `ExtPrio` is `1'b1` this state is provided from the outside.) The arbitration tree will
/// choose the input with the same index as currently defined by the state if it has an active
/// request. Otherwise a *random* other active input is selected. The parameter `FairArb` is used
/// to distinguish between two methods of calculating the next state.
/// * `1'b0`: The next state is calculated by advancing the current state by one. This leads to the
///           state being calculated without the context of the active request. Leading to an
///           unfair throughput distribution if not all inputs have active requests.
/// * `1'b1`: The next state jumps to the next unserved request with higher index.
///           This is achieved by using two trailing-zero-counters (`lzc`). The upper has the masked
///           `req_i` signal with all indices which will have a higher priority in the next state.
///           The trailing zero count defines the input index with the next highest priority after
///           the current one is served. When the upper is empty the lower `lzc` provides the
///           wrapped index if there are outstanding requests with lower or same priority.
/// The implication of throughput fairness on the module timing are:
/// * The trailing zero counter (`lzc`) has a loglog relation of input to output timing. This means
///   that in this module the input to register path scales with Log(Log(`NumIn`)).
/// * The `rr_arb_tree` data multiplexing scales with Log(`NumIn`). This means that the input to output
///   timing path of this module also scales scales with Log(`NumIn`).
/// This implies that in this module the input to output path is always longer than the input to
/// register path. As the output data usually also terminates in a register the parameter `FairArb`
/// only has implications on the area. When it is `1'b0` a static plus one adder is instantiated.
/// If it is `1'b1` two `lzc`, a masking logic stage and a two input multiplexer are instantiated.
/// However these are small in respect of the data multiplexers needed, as the width of the `req_i`
/// signal is usually less as than `DataWidth`.
module rr_arb_tree #(
  /// Number of inputs to be arbitrated.
  parameter int unsigned NumIn      = 64,
  /// Data width of the payload in bits. Not needed if `DataType` is overwritten.
  parameter int unsigned DataWidth  = 32,
  /// Data type of the payload, can be overwritten with custom type. Only use of `DataWidth`.
  parameter type         DataType   = logic [DataWidth-1:0],
  /// The `ExtPrio` option allows to override the internal round robin counter via the
  /// `rr_i` signal. This can be useful in case multiple arbiters need to have
  /// rotating priorities that are operating in lock-step. If static priority arbitration
  /// is needed, just connect `rr_i` to '0.
  ///
  /// Set to 1'b1 to enable.
  parameter bit          ExtPrio    = 1'b0,
  /// If `AxiVldRdy` is set, the req/gnt signals are compliant with the AXI style vld/rdy
  /// handshake. Namely, upstream vld (req) must not depend on rdy (gnt), as it can be deasserted
  /// again even though vld is asserted. Enabling `AxiVldRdy` leads to a reduction of arbiter
  /// delay and area.
  ///
  /// Set to `1'b1` to treat req/gnt as vld/rdy.
  parameter bit          AxiVldRdy  = 1'b0,
  /// The `LockIn` option prevents the arbiter from changing the arbitration
  /// decision when the arbiter is disabled. I.e., the index of the first request
  /// that wins the arbitration will be locked in case the destination is not
  /// able to grant the request in the same cycle.
  ///
  /// Set to `1'b1` to enable.
  parameter bit          LockIn     = 1'b0,
  /// When set, ensures that throughput gets distributed evenly between all inputs.
  ///
  /// Set to `1'b0` to disable.
  parameter bit          FairArb    = 1'b1,
  /// Dependent parameter, do **not** overwrite.
  /// Width of the arbitration priority signal and the arbitrated index.
  parameter int unsigned IdxWidth   = (NumIn > 32'd1) ? unsigned'($clog2(NumIn)) : 32'd1,
  /// Dependent parameter, do **not** overwrite.
  /// Type for defining the arbitration priority and arbitrated index signal.
  parameter type         idx_t      = logic [IdxWidth-1:0]
) (
  /// Clock, positive edge triggered.
  input  logic                clk_i,
  /// Asynchronous reset, active low.
  input  logic                rst_ni,
  /// Clears the arbiter state. Only used if `ExtPrio` is `1'b0` or `LockIn` is `1'b1`.
  input  logic                flush_i,
  /// External round-robin priority. Only used if `ExtPrio` is `1'b1.`
  input  idx_t                rr_i,
  /// Input requests arbitration.
  input  logic    [NumIn-1:0] req_i,
  /* verilator lint_off UNOPTFLAT */
  /// Input request is granted.
  output logic    [NumIn-1:0] gnt_o,
  /* verilator lint_on UNOPTFLAT */
  /// Input data for arbitration.
  input  DataType [NumIn-1:0] data_i,
  /// Output request is valid.
  output logic                req_o,
  /// Output request is granted.
  input  logic                gnt_i,
  /// Output data.
  output DataType             data_o,
  /// Index from which input the data came from.
  output idx_t                idx_o
);

  // pragma translate_off
  `ifndef VERILATOR
  `ifndef XSIM
  // Default SVA reset
  default disable iff (!rst_ni || flush_i);
  `endif
  `endif
  // pragma translate_on

  // just pass through in this corner case
  if (NumIn == unsigned'(1)) begin : gen_pass_through
    assign req_o    = req_i[0];
    assign gnt_o[0] = gnt_i;
    assign data_o   = data_i[0];
    assign idx_o    = '0;
  // non-degenerate cases
  end else begin : gen_arbiter
    localparam int unsigned NumLevels = unsigned'($clog2(NumIn));

    /* verilator lint_off UNOPTFLAT */
    idx_t    [2**NumLevels-2:0] index_nodes; // used to propagate the indices
    DataType [2**NumLevels-2:0] data_nodes;  // used to propagate the data
    logic    [2**NumLevels-2:0] gnt_nodes;   // used to propagate the grant to masters
    logic    [2**NumLevels-2:0] req_nodes;   // used to propagate the requests to slave
    /* lint_off */
    idx_t                       rr_q;
    logic [NumIn-1:0]           req_d;

    // the final arbitration decision can be taken from the root of the tree
    assign req_o        = req_nodes[0];
    assign data_o       = data_nodes[0];
    assign idx_o        = index_nodes[0];

    if (ExtPrio) begin : gen_ext_rr
      assign rr_q       = rr_i;
      assign req_d      = req_i;
    end else begin : gen_int_rr
      idx_t rr_d;

      // lock arbiter decision in case we got at least one req and no acknowledge
      if (LockIn) begin : gen_lock
        logic  lock_d, lock_q;
        logic [NumIn-1:0] req_q;

        assign lock_d     = req_o & ~gnt_i;
        assign req_d      = (lock_q) ? req_q : req_i;

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_lock_reg
          if (!rst_ni) begin
            lock_q <= '0;
          end else begin
            if (flush_i) begin
              lock_q <= '0;
            end else begin
              lock_q <= lock_d;
            end
          end
        end

        // pragma translate_off
        `ifndef VERILATOR
          lock: assert property(
            @(posedge clk_i) LockIn |-> req_o && !gnt_i |=> idx_o == $past(idx_o)) else
                $fatal (1, "Lock implies same arbiter decision in next cycle if output is not \
                            ready.");

          logic [NumIn-1:0] req_tmp;
          assign req_tmp = req_q & req_i;
          lock_req: assume property(
            @(posedge clk_i) LockIn |-> lock_d |=> req_tmp == req_q) else
                $fatal (1, "It is disallowed to deassert unserved request signals when LockIn is \
                            enabled.");
        `endif
        // pragma translate_on

        always_ff @(posedge clk_i or negedge rst_ni) begin : p_req_regs
          if (!rst_ni) begin
            req_q  <= '0;
          end else begin
            if (flush_i) begin
              req_q  <= '0;
            end else begin
              req_q  <= req_d;
            end
          end
        end
      end else begin : gen_no_lock
        assign req_d = req_i;
      end

      if (FairArb) begin : gen_fair_arb
        logic [NumIn-1:0] upper_mask,  lower_mask;
        idx_t             upper_idx,   lower_idx,   next_idx;
        logic             upper_empty, lower_empty;

        for (genvar i = 0; i < NumIn; i++) begin : gen_mask
          assign upper_mask[i] = (i >  rr_q) ? req_d[i] : 1'b0;
          assign lower_mask[i] = (i <= rr_q) ? req_d[i] : 1'b0;
        end

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_upper (
          .in_i    ( upper_mask  ),
          .cnt_o   ( upper_idx   ),
          .empty_o ( upper_empty )
        );

        lzc #(
          .WIDTH ( NumIn ),
          .MODE  ( 1'b0  )
        ) i_lzc_lower (
          .in_i    ( lower_mask  ),
          .cnt_o   ( lower_idx   ),
          .empty_o ( /*unused*/  )
        );

        assign next_idx = upper_empty      ? lower_idx : upper_idx;
        assign rr_d     = (gnt_i && req_o) ? next_idx  : rr_q;

      end else begin : gen_unfair_arb
        assign rr_d = (gnt_i && req_o) ? ((rr_q == idx_t'(NumIn-1)) ? '0 : rr_q + 1'b1) : rr_q;
      end

      // this holds the highest priority
      always_ff @(posedge clk_i or negedge rst_ni) begin : p_rr_regs
        if (!rst_ni) begin
          rr_q   <= '0;
        end else begin
          if (flush_i) begin
            rr_q   <= '0;
          end else begin
            rr_q   <= rr_d;
          end
        end
      end
    end

    assign gnt_nodes[0] = gnt_i;

    // arbiter tree
    for (genvar level = 0; unsigned'(level) < NumLevels; level++) begin : gen_levels
      for (genvar l = 0; l < 2**level; l++) begin : gen_level
        // local select signal
        logic sel;
        // index calcs
        localparam int unsigned Idx0 = 2**level-1+l;// current node
        localparam int unsigned Idx1 = 2**(level+1)-1+l*2;
        //////////////////////////////////////////////////////////////
        // uppermost level where data is fed in from the inputs
        if (unsigned'(level) == NumLevels-1) begin : gen_first_level
          // if two successive indices are still in the vector...
          if (unsigned'(l) * 2 < NumIn-1) begin : gen_reduce
            assign req_nodes[Idx0]   = req_d[l*2] | req_d[l*2+1];

            // arbitration: round robin
            assign sel =  ~req_d[l*2] | req_d[l*2+1] & rr_q[NumLevels-1-level];

            assign index_nodes[Idx0] = idx_t'(sel);
            assign data_nodes[Idx0]  = (sel) ? data_i[l*2+1] : data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2])   & ~sel;
            assign gnt_o[l*2+1]      = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2+1]) & sel;
          end
          // if only the first index is still in the vector...
          if (unsigned'(l) * 2 == NumIn-1) begin : gen_first
            assign req_nodes[Idx0]   = req_d[l*2];
            assign index_nodes[Idx0] = '0;// always zero in this case
            assign data_nodes[Idx0]  = data_i[l*2];
            assign gnt_o[l*2]        = gnt_nodes[Idx0] & (AxiVldRdy | req_d[l*2]);
          end
          // if index is out of range, fill up with zeros (will get pruned)
          if (unsigned'(l) * 2 > NumIn-1) begin : gen_out_of_range
            assign req_nodes[Idx0]   = 1'b0;
            assign index_nodes[Idx0] = idx_t'('0);
            assign data_nodes[Idx0]  = DataType'('0);
          end
        //////////////////////////////////////////////////////////////
        // general case for other levels within the tree
        end else begin : gen_other_levels
          assign req_nodes[Idx0]   = req_nodes[Idx1] | req_nodes[Idx1+1];

          // arbitration: round robin
          assign sel =  ~req_nodes[Idx1] | req_nodes[Idx1+1] & rr_q[NumLevels-1-level];

          assign index_nodes[Idx0] = (sel) ?
            idx_t'({1'b1, index_nodes[Idx1+1][NumLevels-unsigned'(level)-2:0]}) :
            idx_t'({1'b0, index_nodes[Idx1][NumLevels-unsigned'(level)-2:0]});

          assign data_nodes[Idx0]  = (sel) ? data_nodes[Idx1+1] : data_nodes[Idx1];
          assign gnt_nodes[Idx1]   = gnt_nodes[Idx0] & ~sel;
          assign gnt_nodes[Idx1+1] = gnt_nodes[Idx0] & sel;
        end
        //////////////////////////////////////////////////////////////
      end
    end

    // pragma translate_off
    `ifndef VERILATOR
    `ifndef XSIM
    initial begin : p_assert
      assert(NumIn)
        else $fatal(1, "Input must be at least one element wide.");
      assert(!(LockIn && ExtPrio))
        else $fatal(1,"Cannot use LockIn feature together with external ExtPrio.");
    end

    hot_one : assert property(
      @(posedge clk_i) $onehot0(gnt_o))
        else $fatal (1, "Grant signal must be hot1 or zero.");

    gnt0 : assert property(
      @(posedge clk_i) |gnt_o |-> gnt_i)
        else $fatal (1, "Grant out implies grant in.");

    gnt1 : assert property(
      @(posedge clk_i) req_o |-> gnt_i |-> |gnt_o)
        else $fatal (1, "Req out and grant in implies grant out.");

    gnt_idx : assert property(
      @(posedge clk_i) req_o |->  gnt_i |-> gnt_o[idx_o])
        else $fatal (1, "Idx_o / gnt_o do not match.");

    req0 : assert property(
      @(posedge clk_i) |req_i |-> req_o)
        else $fatal (1, "Req in implies req out.");

    req1 : assert property(
      @(posedge clk_i) req_o |-> |req_i)
        else $fatal (1, "Req out implies req in.");
    `endif
    `endif
    // pragma translate_on
  end

endmodule : rr_arb_tree
// ----- 8< ----- FILE "./fpnew_pkg.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

package fpnew_pkg;

  // ---------
  // FP TYPES
  // ---------
  // | Enumerator | Format           | Width  | EXP_BITS | MAN_BITS
  // |:----------:|------------------|-------:|:--------:|:--------:
  // | FP32       | IEEE binary32    | 32 bit | 8        | 23
  // | FP64       | IEEE binary64    | 64 bit | 11       | 52
  // | FP16       | IEEE binary16    | 16 bit | 5        | 10
  // | FP8        | binary8          |  8 bit | 5        | 2
  // | FP16ALT    | binary16alt      | 16 bit | 8        | 7
  // *NOTE:* Add new formats only at the end of the enumeration for backwards compatibilty!

  // Encoding for a format
  typedef struct packed {
    int unsigned exp_bits;
    int unsigned man_bits;
  } fp_encoding_t;

  localparam int unsigned NUM_FP_FORMATS = 5; // change me to add formats
  localparam int unsigned FP_FORMAT_BITS = $clog2(NUM_FP_FORMATS);

  // FP formats
  typedef enum logic [FP_FORMAT_BITS-1:0] {
    FP32    = 'd0,
    FP64    = 'd1,
    FP16    = 'd2,
    FP8     = 'd3,
    FP16ALT = 'd4
    // add new formats here
  } fp_format_e;

  // Encodings for supported FP formats
  localparam fp_encoding_t [0:NUM_FP_FORMATS-1] FP_ENCODINGS  = '{
    '{8,  23}, // IEEE binary32 (single)
    '{11, 52}, // IEEE binary64 (double)
    '{5,  10}, // IEEE binary16 (half)
    '{5,  2},  // custom binary8
    '{8,  7}   // custom binary16alt
    // add new formats here
  };

  typedef logic [0:NUM_FP_FORMATS-1]       fmt_logic_t;    // Logic indexed by FP format (for masks)
  typedef logic [0:NUM_FP_FORMATS-1][31:0] fmt_unsigned_t; // Unsigned indexed by FP format

  localparam fmt_logic_t CPK_FORMATS = 5'b11000; // FP32 and FP64 can provide CPK only

  // ---------
  // INT TYPES
  // ---------
  // | Enumerator | Width  |
  // |:----------:|-------:|
  // | INT8       |  8 bit |
  // | INT16      | 16 bit |
  // | INT32      | 32 bit |
  // | INT64      | 64 bit |
  // *NOTE:* Add new formats only at the end of the enumeration for backwards compatibilty!

  localparam int unsigned NUM_INT_FORMATS = 4; // change me to add formats
  localparam int unsigned INT_FORMAT_BITS = $clog2(NUM_INT_FORMATS);

  // Int formats
  typedef enum logic [INT_FORMAT_BITS-1:0] {
    INT8,
    INT16,
    INT32,
    INT64
    // add new formats here
  } int_format_e;

  // Returns the width of an INT format by index
  function automatic int unsigned int_width(int_format_e ifmt);
    unique case (ifmt)
      INT8:  return 8;
      INT16: return 16;
      INT32: return 32;
      INT64: return 64;
      default: begin
        // pragma translate_off
        $fatal(1, "Invalid INT format supplied");
        // pragma translate_on
        // just return any integer to avoid any latches
        // hopefully this error is caught by simulation
        return INT8;
      end
    endcase
  endfunction

  typedef logic [0:NUM_INT_FORMATS-1] ifmt_logic_t; // Logic indexed by INT format (for masks)

  // --------------
  // FP OPERATIONS
  // --------------
  localparam int unsigned NUM_OPGROUPS = 4;

  // Each FP operation belongs to an operation group
  typedef enum logic [1:0] {
    ADDMUL, DIVSQRT, NONCOMP, CONV
  } opgroup_e;

  localparam int unsigned OP_BITS = 4;

  typedef enum logic [OP_BITS-1:0] {
    FMADD, FNMSUB, ADD, MUL,     // ADDMUL operation group
    DIV, SQRT,                   // DIVSQRT operation group
    SGNJ, MINMAX, CMP, CLASSIFY, // NONCOMP operation group
    F2F, F2I, I2F, CPKAB, CPKCD, // CONV operation group
    ADDS                         // ADDMUL operation group (ADDS is added here to preserve bit encoding of operations)
  } operation_e;

  // -------------
  // DIVSQRT UNIT
  // -------------
  typedef enum logic[1:0] {
    PULP,    // "PULP" instantiates the PULP DivSqrt unit supports FP64, FP32, FP16, FP16ALT, FP8 and SIMD operations
    TH32,    // "TH32" instantiates the E906 DivSqrt unit supports only FP32 (no SIMD support)
    THMULTI  // "THMULTI" instantiates the C910 DivSqrt unit supports FP64, FP32, FP16, FP16ALT and SIMD operations
  } divsqrt_unit_t;

  // -------------------
  // RISC-V FP-SPECIFIC
  // -------------------
  // Rounding modes
  typedef enum logic [2:0] {
    RNE = 3'b000,
    RTZ = 3'b001,
    RDN = 3'b010,
    RUP = 3'b011,
    RMM = 3'b100,
    ROD = 3'b101,  // This mode is not defined in RISC-V FP-SPEC
    DYN = 3'b111
  } roundmode_e;

  // Status flags
  typedef struct packed {
    logic NV; // Invalid
    logic DZ; // Divide by zero
    logic OF; // Overflow
    logic UF; // Underflow
    logic NX; // Inexact
  } status_t;

  // Information about a floating point value
  typedef struct packed {
    logic is_normal;     // is the value normal
    logic is_subnormal;  // is the value subnormal
    logic is_zero;       // is the value zero
    logic is_inf;        // is the value infinity
    logic is_nan;        // is the value NaN
    logic is_signalling; // is the value a signalling NaN
    logic is_quiet;      // is the value a quiet NaN
    logic is_boxed;      // is the value properly NaN-boxed (RISC-V specific)
  } fp_info_t;

  // Classification mask
  typedef enum logic [9:0] {
    NEGINF     = 10'b00_0000_0001,
    NEGNORM    = 10'b00_0000_0010,
    NEGSUBNORM = 10'b00_0000_0100,
    NEGZERO    = 10'b00_0000_1000,
    POSZERO    = 10'b00_0001_0000,
    POSSUBNORM = 10'b00_0010_0000,
    POSNORM    = 10'b00_0100_0000,
    POSINF     = 10'b00_1000_0000,
    SNAN       = 10'b01_0000_0000,
    QNAN       = 10'b10_0000_0000
  } classmask_e;

  // ------------------
  // FPU configuration
  // ------------------
  // Pipelining registers can be inserted (at elaboration time) into operational units
  typedef enum logic [1:0] {
    BEFORE,     // registers are inserted at the inputs of the unit
    AFTER,      // registers are inserted at the outputs of the unit
    INSIDE,     // registers are inserted at predetermined (suboptimal) locations in the unit
    DISTRIBUTED // registers are evenly distributed, INSIDE >= AFTER >= BEFORE
  } pipe_config_t;

  // Arithmetic units can be arranged in parallel (per format), merged (multi-format) or not at all.
  typedef enum logic [1:0] {
    DISABLED, // arithmetic units are not generated
    PARALLEL, // arithmetic units are generated in prallel slices, one for each format
    MERGED    // arithmetic units are contained within a merged unit holding multiple formats
  } unit_type_t;

  // Array of unit types indexed by format
  typedef unit_type_t [0:NUM_FP_FORMATS-1] fmt_unit_types_t;

  // Array of format-specific unit types by opgroup
  typedef fmt_unit_types_t [0:NUM_OPGROUPS-1] opgrp_fmt_unit_types_t;
  // same with unsigned
  typedef fmt_unsigned_t [0:NUM_OPGROUPS-1] opgrp_fmt_unsigned_t;

  // FPU configuration: features
  typedef struct packed {
    int unsigned Width;
    logic        EnableVectors;
    logic        EnableNanBox;
    fmt_logic_t  FpFmtMask;
    ifmt_logic_t IntFmtMask;
  } fpu_features_t;

  localparam fpu_features_t RV64D = '{
    Width:         64,
    EnableVectors: 1'b0,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11000,
    IntFmtMask:    4'b0011
  };

  localparam fpu_features_t RV32D = '{
    Width:         64,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11000,
    IntFmtMask:    4'b0010
  };

  localparam fpu_features_t RV32F = '{
    Width:         32,
    EnableVectors: 1'b0,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10000,
    IntFmtMask:    4'b0010
  };

  localparam fpu_features_t RV64D_Xsflt = '{
    Width:         64,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b11111,
    IntFmtMask:    4'b1111
  };

  localparam fpu_features_t RV32F_Xsflt = '{
    Width:         32,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10111,
    IntFmtMask:    4'b1110
  };

  localparam fpu_features_t RV32F_Xf16alt_Xfvec = '{
    Width:         32,
    EnableVectors: 1'b1,
    EnableNanBox:  1'b1,
    FpFmtMask:     5'b10001,
    IntFmtMask:    4'b0110
  };


  // FPU configuraion: implementation
  typedef struct packed {
    opgrp_fmt_unsigned_t   PipeRegs;
    opgrp_fmt_unit_types_t UnitTypes;
    pipe_config_t          PipeConfig;
  } fpu_implementation_t;

  localparam fpu_implementation_t DEFAULT_NOREGS = '{
    PipeRegs:   '{default: 0},
    UnitTypes:  '{'{default: PARALLEL}, // ADDMUL
                  '{default: MERGED},   // DIVSQRT
                  '{default: PARALLEL}, // NONCOMP
                  '{default: MERGED}},  // CONV
    PipeConfig: BEFORE
  };

  localparam fpu_implementation_t DEFAULT_SNITCH = '{
    PipeRegs:   '{default: 1},
    UnitTypes:  '{'{default: PARALLEL}, // ADDMUL
                  '{default: DISABLED}, // DIVSQRT
                  '{default: PARALLEL}, // NONCOMP
                  '{default: MERGED}},  // CONV
    PipeConfig: BEFORE
  };

  // -----------------------
  // Synthesis optimization
  // -----------------------
  localparam logic DONT_CARE = 1'b1; // the value to assign as don't care

  // -------------------------
  // General helper functions
  // -------------------------
  function automatic int minimum(int a, int b);
    return (a < b) ? a : b;
  endfunction

  function automatic int maximum(int a, int b);
    return (a > b) ? a : b;
  endfunction

  // -------------------------------------------
  // Helper functions for FP formats and values
  // -------------------------------------------
  // Returns the width of a FP format
  function automatic int unsigned fp_width(fp_format_e fmt);
    return FP_ENCODINGS[fmt].exp_bits + FP_ENCODINGS[fmt].man_bits + 1;
  endfunction

  // Returns the widest FP format present
  function automatic int unsigned max_fp_width(fmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i])
        res = unsigned'(maximum(res, fp_width(fp_format_e'(i))));
    return res;
  endfunction

  // Returns the narrowest FP format present
  function automatic int unsigned min_fp_width(fmt_logic_t cfg);
    automatic int unsigned res = max_fp_width(cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i])
        res = unsigned'(minimum(res, fp_width(fp_format_e'(i))));
    return res;
  endfunction

  // Returns the number of expoent bits for a format
  function automatic int unsigned exp_bits(fp_format_e fmt);
    return FP_ENCODINGS[fmt].exp_bits;
  endfunction

  // Returns the number of mantissa bits for a format
  function automatic int unsigned man_bits(fp_format_e fmt);
    return FP_ENCODINGS[fmt].man_bits;
  endfunction

  // Returns the bias value for a given format (as per IEEE 754-2008)
  function automatic int unsigned bias(fp_format_e fmt);
    return unsigned'(2**(FP_ENCODINGS[fmt].exp_bits-1)-1); // symmetrical bias
  endfunction

  function automatic fp_encoding_t super_format(fmt_logic_t cfg);
    automatic fp_encoding_t res;
    res = '0;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      if (cfg[fmt]) begin // only active format
        res.exp_bits = unsigned'(maximum(res.exp_bits, exp_bits(fp_format_e'(fmt))));
        res.man_bits = unsigned'(maximum(res.man_bits, man_bits(fp_format_e'(fmt))));
      end
    return res;
  endfunction

  // -------------------------------------------
  // Helper functions for INT formats and values
  // -------------------------------------------
  // Returns the widest INT format present
  function automatic int unsigned max_int_width(ifmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin
      if (cfg[ifmt]) res = maximum(res, int_width(int_format_e'(ifmt)));
    end
    return res;
  endfunction

  // --------------------------------------------------
  // Helper functions for operations and FPU structure
  // --------------------------------------------------
  // Returns the operation group of the given operation
  function automatic opgroup_e get_opgroup(operation_e op);
    unique case (op)
      FMADD, FNMSUB, ADD, ADDS, MUL: return ADDMUL;
      DIV, SQRT:                     return DIVSQRT;
      SGNJ, MINMAX, CMP, CLASSIFY:   return NONCOMP;
      F2F, F2I, I2F, CPKAB, CPKCD:   return CONV;
      default:                       return NONCOMP;
    endcase
  endfunction

  // Returns the number of operands by operation group
  function automatic int unsigned num_operands(opgroup_e grp);
    unique case (grp)
      ADDMUL:  return 3;
      DIVSQRT: return 2;
      NONCOMP: return 2;
      CONV:    return 3; // vectorial casts use 3 operands
      default: return 0;
    endcase
  endfunction

  // Returns the number of lanes according to width, format and vectors
  function automatic int unsigned num_lanes(int unsigned width, fp_format_e fmt, logic vec);
    return vec ? width / fp_width(fmt) : 1; // if no vectors, only one lane
  endfunction

  // Returns the maximum number of lanes in the FPU according to width, format config and vectors
  function automatic int unsigned max_num_lanes(int unsigned width, fmt_logic_t cfg, logic vec);
    // return vec ? width / min_fp_width(cfg) : 1; // if no vectors, only one lane
    if (vec) begin
      automatic int unsigned res = max_fp_width(cfg);
      for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
        if (cfg[i]) begin
          automatic int unsigned format_width = FP_ENCODINGS[i].exp_bits + FP_ENCODINGS[i].man_bits + 1;
          res = unsigned'(minimum(res, format_width));
        end
      end
      return width / res;
    end else begin
      return 1;
    end
  endfunction

    // Returns the maximum number of lanes in the FPU according to width, format config and vectors
  function automatic int unsigned num_divsqrt_lanes(int unsigned width, fmt_logic_t cfg, logic vec, divsqrt_unit_t DivSqrtSel);
    automatic fmt_logic_t cfg_tmp;
    cfg_tmp = (DivSqrtSel == THMULTI) ? cfg & 5'b11101 : cfg;
    return vec ? width / min_fp_width(cfg_tmp) : 1; // if no vectors, only one lane
  endfunction

  // Returns a mask of active FP formats that are present in lane lane_no of a multiformat slice
  function automatic fmt_logic_t get_lane_formats(int unsigned width,
                                                  fmt_logic_t cfg,
                                                  int unsigned lane_no);
    automatic fmt_logic_t res;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      // Mask active formats with the number of lanes for that format
      res[fmt] = cfg[fmt] & (width / fp_width(fp_format_e'(fmt)) > lane_no);
    return res;
  endfunction

  // Returns a mask of active INT formats that are present in lane lane_no of a multiformat slice
  function automatic ifmt_logic_t get_lane_int_formats(int unsigned width,
                                                       fmt_logic_t cfg,
                                                       ifmt_logic_t icfg,
                                                       int unsigned lane_no);
    automatic ifmt_logic_t res;
    automatic fmt_logic_t lanefmts;
    res = '0;
    lanefmts = get_lane_formats(width, cfg, lane_no);

    for (int unsigned ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++)
      for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
        // Mask active int formats with the width of the float formats
        if ((fp_width(fp_format_e'(fmt)) == int_width(int_format_e'(ifmt))))
          res[ifmt] |= icfg[ifmt] && lanefmts[fmt];
    return res;
  endfunction

  // Returns a mask of active FP formats that are present in lane lane_no of a CONV slice
  function automatic fmt_logic_t get_conv_lane_formats(int unsigned width,
                                                       fmt_logic_t cfg,
                                                       int unsigned lane_no);
    automatic fmt_logic_t res;
    for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
      // Mask active formats with the number of lanes for that format, CPK at least twice
      res[fmt] = cfg[fmt] && ((width / fp_width(fp_format_e'(fmt)) > lane_no) ||
                             (CPK_FORMATS[fmt] && (lane_no < 2)));
    return res;
  endfunction

  // Returns a mask of active INT formats that are present in lane lane_no of a CONV slice
  function automatic ifmt_logic_t get_conv_lane_int_formats(int unsigned width,
                                                            fmt_logic_t cfg,
                                                            ifmt_logic_t icfg,
                                                            int unsigned lane_no);
    automatic ifmt_logic_t res;
    automatic fmt_logic_t lanefmts;
    res = '0;
    lanefmts = get_conv_lane_formats(width, cfg, lane_no);

    for (int unsigned ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++)
      for (int unsigned fmt = 0; fmt < NUM_FP_FORMATS; fmt++)
        // Mask active int formats with the width of the float formats
        res[ifmt] |= icfg[ifmt] && lanefmts[fmt] &&
                     (fp_width(fp_format_e'(fmt)) == int_width(int_format_e'(ifmt)));
    return res;
  endfunction

  // Return whether any active format is set as MERGED
  function automatic logic any_enabled_multi(fmt_unit_types_t types, fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i] && types[i] == MERGED)
        return 1'b1;
      return 1'b0;
  endfunction

  // Return whether the given format is the first active one set as MERGED
  function automatic logic is_first_enabled_multi(fp_format_e fmt,
                                                  fmt_unit_types_t types,
                                                  fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
      if (cfg[i] && types[i] == MERGED) return (fp_format_e'(i) == fmt);
    end
    return 1'b0;
  endfunction

  // Returns the first format that is active and is set as MERGED
  function automatic fp_format_e get_first_enabled_multi(fmt_unit_types_t types, fmt_logic_t cfg);
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++)
      if (cfg[i] && types[i] == MERGED)
        return fp_format_e'(i);
      return fp_format_e'(0);
  endfunction

  // Returns the largest number of regs that is active and is set as MERGED
  function automatic int unsigned get_num_regs_multi(fmt_unsigned_t regs,
                                                     fmt_unit_types_t types,
                                                     fmt_logic_t cfg);
    automatic int unsigned res = 0;
    for (int unsigned i = 0; i < NUM_FP_FORMATS; i++) begin
      if (cfg[i] && types[i] == MERGED) res = maximum(res, regs[i]);
    end
    return res;
  endfunction

endpackage
// ----- 8< ----- FILE "./fpnew_cast_multi.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_cast_multi #(
  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig  = '1,
  parameter fpnew_pkg::ifmt_logic_t  IntFmtConfig = '1,
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::maximum(fpnew_pkg::max_fp_width(FpFmtConfig),
                                                     fpnew_pkg::max_int_width(IntFmtConfig)),
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                   clk_i,
  input  logic                   rst_ni,
  // Input signals
  input  logic [WIDTH-1:0]       operands_i, // 1 operand
  input  logic [NUM_FORMATS-1:0] is_boxed_i, // 1 operand
  input  fpnew_pkg::roundmode_e  rnd_mode_i,
  input  fpnew_pkg::operation_e  op_i,
  input  logic                   op_mod_i,
  input  fpnew_pkg::fp_format_e  src_fmt_i,
  input  fpnew_pkg::fp_format_e  dst_fmt_i,
  input  fpnew_pkg::int_format_e int_fmt_i,
  input  TagType                 tag_i,
  input  logic                   mask_i,
  input  AuxType                 aux_i,
  // Input Handshake
  input  logic                   in_valid_i,
  output logic                   in_ready_o,
  input  logic                   flush_i,
  // Output signals
  output logic [WIDTH-1:0]       result_o,
  output fpnew_pkg::status_t     status_o,
  output logic                   extension_bit_o,
  output TagType                 tag_o,
  output logic                   mask_o,
  output AuxType                 aux_o,
  // Output handshake
  output logic                   out_valid_o,
  input  logic                   out_ready_i,
  // Indication of valid data in flight
  output logic                   busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                   early_out_valid_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;
  localparam int unsigned MAX_INT_WIDTH   = fpnew_pkg::max_int_width(IntFmtConfig);

  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;
  localparam int unsigned SUPER_BIAS     = 2**(SUPER_EXP_BITS - 1) - 1;

  // The internal mantissa includes normal bit or an entire integer
  localparam int unsigned INT_MAN_WIDTH = fpnew_pkg::maximum(SUPER_MAN_BITS + 1, MAX_INT_WIDTH);
  // If needed, there will be a LZC for renormalization
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(INT_MAN_WIDTH);
  // The internal exponent must be able to represent the smallest denormal input value as signed
  // or the number of bits in an integer
  localparam int unsigned INT_EXP_WIDTH = fpnew_pkg::maximum($clog2(MAX_INT_WIDTH),
      fpnew_pkg::maximum(SUPER_EXP_BITS, $clog2(SUPER_BIAS + SUPER_MAN_BITS))) + 1;
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [WIDTH-1:0]       operands_q;
  logic [NUM_FORMATS-1:0] is_boxed_q;
  logic                   op_mod_q;
  fpnew_pkg::fp_format_e  src_fmt_q;
  fpnew_pkg::fp_format_e  dst_fmt_q;
  fpnew_pkg::int_format_e int_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                   [0:NUM_INP_REGS][WIDTH-1:0]       inp_pipe_operands_q;
  logic                   [0:NUM_INP_REGS][NUM_FORMATS-1:0] inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e  [0:NUM_INP_REGS]                  inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e  [0:NUM_INP_REGS]                  inp_pipe_op_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_op_mod_q;
  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e  [0:NUM_INP_REGS]                  inp_pipe_dst_fmt_q;
  fpnew_pkg::int_format_e [0:NUM_INP_REGS]                  inp_pipe_int_fmt_q;
  TagType                 [0:NUM_INP_REGS]                  inp_pipe_tag_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_mask_q;
  AuxType                 [0:NUM_INP_REGS]                  inp_pipe_aux_q;
  logic                   [0:NUM_INP_REGS]                  inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_int_fmt_q[0]  = int_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_int_fmt_q[i+1],  inp_pipe_int_fmt_q[i],  reg_ena, fpnew_pkg::int_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign is_boxed_q = inp_pipe_is_boxed_q[NUM_INP_REGS];
  assign op_mod_q   = inp_pipe_op_mod_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];
  assign int_fmt_q  = inp_pipe_int_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic src_is_int, dst_is_int; // if 0, it's a float

  assign src_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::I2F);
  assign dst_is_int = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::F2I);

  logic [INT_MAN_WIDTH-1:0] encoded_mant; // input mantissa with implicit bit

  logic        [NUM_FORMATS-1:0]                    fmt_sign;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][INT_MAN_WIDTH-1:0] fmt_mantissa;
  logic signed [NUM_FORMATS-1:0][INT_EXP_WIDTH-1:0] fmt_shift_compensation; // for LZC

  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0] info;

  logic [NUM_INT_FORMATS-1:0][INT_MAN_WIDTH-1:0] ifmt_input_val;
  logic                                          int_sign;
  logic [INT_MAN_WIDTH-1:0]                      int_value, int_mantissa;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      localparam fpnew_pkg::fp_format_e FpFormat = fpnew_pkg::fp_format_e'(fmt);

      // Classify input
      fpnew_classifier #(
        .FpFormat    ( FpFormat ),
        .NumOperands ( 1        )
      ) i_fpnew_classifier (
        .operands_i ( operands_q[FP_WIDTH-1:0] ),
        .is_boxed_i ( is_boxed_q[fmt]          ),
        .info_o     ( info[fmt]                )
      );

      assign fmt_sign[fmt]     = operands_q[FP_WIDTH-1];
      assign fmt_exponent[fmt] = signed'({1'b0, operands_q[MAN_BITS+:EXP_BITS]});
      assign fmt_mantissa[fmt] = {info[fmt].is_normal, operands_q[MAN_BITS-1:0]}; // zero pad
      // Compensation for the difference in mantissa widths used for leading-zero count
      assign fmt_shift_compensation[fmt] = signed'(INT_MAN_WIDTH - 1 - MAN_BITS);
    end else begin : inactive_format
      assign info[fmt]                   = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_shift_compensation[fmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  // Sign-extend INT input
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_sign_extend_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format // only active formats
      always_comb begin : sign_ext_input
        // sign-extend value only if it's signed
        ifmt_input_val[ifmt]                = '{default: operands_q[INT_WIDTH-1] & ~op_mod_q};
        ifmt_input_val[ifmt][INT_WIDTH-1:0] = operands_q[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_input_val[ifmt] = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  // Construct input mantissa from integer
  assign int_value    = ifmt_input_val[int_fmt_q];
  assign int_sign     = int_value[INT_MAN_WIDTH-1] & ~op_mod_q; // only signed ints are negative
  assign int_mantissa = int_sign ? unsigned'(-int_value) : int_value; // get magnitude of negative

  // select mantissa with source format
  assign encoded_mant = src_is_int ? int_mantissa : fmt_mantissa[src_fmt_q];

  // --------------
  // Normalization
  // --------------
  logic signed [INT_EXP_WIDTH-1:0] src_bias;      // src format bias
  logic signed [INT_EXP_WIDTH-1:0] src_exp;       // src format exponent (biased)
  logic signed [INT_EXP_WIDTH-1:0] src_subnormal; // src is subnormal
  logic signed [INT_EXP_WIDTH-1:0] src_offset;    // src offset within mantissa

  assign src_bias      = signed'(fpnew_pkg::bias(src_fmt_q));
  assign src_exp       = fmt_exponent[src_fmt_q];
  assign src_subnormal = signed'({1'b0, info[src_fmt_q].is_subnormal});
  assign src_offset    = fmt_shift_compensation[src_fmt_q];

  logic                            input_sign;   // input sign
  logic signed [INT_EXP_WIDTH-1:0] input_exp;    // unbiased true exponent
  logic        [INT_MAN_WIDTH-1:0] input_mant;   // normalized input mantissa
  logic                            mant_is_zero; // for integer zeroes

  logic signed [INT_EXP_WIDTH-1:0] fp_input_exp;
  logic signed [INT_EXP_WIDTH-1:0] int_input_exp;

  // Input mantissa needs to be normalized
  logic [LZC_RESULT_WIDTH-1:0] renorm_shamt;     // renormalization shift amount
  logic [LZC_RESULT_WIDTH:0]   renorm_shamt_sgn; // signed form for calculations

  // Leading-zero counter is needed for renormalization
  lzc #(
    .WIDTH ( INT_MAN_WIDTH ),
    .MODE  ( 1             ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( encoded_mant ),
    .cnt_o   ( renorm_shamt ),
    .empty_o ( mant_is_zero )
  );
  assign renorm_shamt_sgn = signed'({1'b0, renorm_shamt});

  // Get the sign from the proper source
  assign input_sign = src_is_int ? int_sign : fmt_sign[src_fmt_q];
  // Realign input mantissa, append zeroes if destination is wider
  assign input_mant = encoded_mant << renorm_shamt;
  // Unbias exponent and compensate for shift
  assign fp_input_exp  = signed'(src_exp + src_subnormal - src_bias -
                                 renorm_shamt_sgn + src_offset); // compensate for shift
  assign int_input_exp = signed'(INT_MAN_WIDTH - 1 - renorm_shamt_sgn);

  assign input_exp     = src_is_int ? int_input_exp : fp_input_exp;

  logic signed [INT_EXP_WIDTH-1:0] destination_exp;  // re-biased exponent for destination

  // Rebias the exponent
  assign destination_exp = input_exp + signed'(fpnew_pkg::bias(dst_fmt_q));

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                            input_sign_q;
  logic signed [INT_EXP_WIDTH-1:0] input_exp_q;
  logic [INT_MAN_WIDTH-1:0]        input_mant_q;
  logic signed [INT_EXP_WIDTH-1:0] destination_exp_q;
  logic                            src_is_int_q;
  logic                            dst_is_int_q;
  fpnew_pkg::fp_info_t             info_q;
  logic                            mant_is_zero_q;
  logic                            op_mod_q2;
  fpnew_pkg::roundmode_e           rnd_mode_q;
  fpnew_pkg::fp_format_e           src_fmt_q2;
  fpnew_pkg::fp_format_e           dst_fmt_q2;
  fpnew_pkg::int_format_e          int_fmt_q2;
  // Internal pipeline signals, index i holds signal after i register stages


  logic                   [0:NUM_MID_REGS]                    mid_pipe_input_sign_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_input_exp_q;
  logic                   [0:NUM_MID_REGS][INT_MAN_WIDTH-1:0] mid_pipe_input_mant_q;
  logic signed            [0:NUM_MID_REGS][INT_EXP_WIDTH-1:0] mid_pipe_dest_exp_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_src_is_int_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_dst_is_int_q;
  fpnew_pkg::fp_info_t    [0:NUM_MID_REGS]                    mid_pipe_info_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_mant_zero_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_op_mod_q;
  fpnew_pkg::roundmode_e  [0:NUM_MID_REGS]                    mid_pipe_rnd_mode_q;
  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e  [0:NUM_MID_REGS]                    mid_pipe_dst_fmt_q;
  fpnew_pkg::int_format_e [0:NUM_MID_REGS]                    mid_pipe_int_fmt_q;
  TagType                 [0:NUM_MID_REGS]                    mid_pipe_tag_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_mask_q;
  AuxType                 [0:NUM_MID_REGS]                    mid_pipe_aux_q;
  logic                   [0:NUM_MID_REGS]                    mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_input_sign_q[0] = input_sign;
  assign mid_pipe_input_exp_q[0]  = input_exp;
  assign mid_pipe_input_mant_q[0] = input_mant;
  assign mid_pipe_dest_exp_q[0]   = destination_exp;
  assign mid_pipe_src_is_int_q[0] = src_is_int;
  assign mid_pipe_dst_is_int_q[0] = dst_is_int;
  assign mid_pipe_info_q[0]       = info[src_fmt_q];
  assign mid_pipe_mant_zero_q[0]  = mant_is_zero;
  assign mid_pipe_op_mod_q[0]     = op_mod_q;
  assign mid_pipe_rnd_mode_q[0]   = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_src_fmt_q[0]    = src_fmt_q;
  assign mid_pipe_dst_fmt_q[0]    = dst_fmt_q;
  assign mid_pipe_int_fmt_q[0]    = int_fmt_q;
  assign mid_pipe_tag_q[0]        = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]       = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]        = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]      = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_input_sign_q[i+1], mid_pipe_input_sign_q[i], reg_ena, '0)
    `FFL(mid_pipe_input_exp_q[i+1],  mid_pipe_input_exp_q[i],  reg_ena, '0)
    `FFL(mid_pipe_input_mant_q[i+1], mid_pipe_input_mant_q[i], reg_ena, '0)
    `FFL(mid_pipe_dest_exp_q[i+1],   mid_pipe_dest_exp_q[i],   reg_ena, '0)
    `FFL(mid_pipe_src_is_int_q[i+1], mid_pipe_src_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_dst_is_int_q[i+1], mid_pipe_dst_is_int_q[i], reg_ena, '0)
    `FFL(mid_pipe_info_q[i+1],       mid_pipe_info_q[i],       reg_ena, '0)
    `FFL(mid_pipe_mant_zero_q[i+1],  mid_pipe_mant_zero_q[i],  reg_ena, '0)
    `FFL(mid_pipe_op_mod_q[i+1],     mid_pipe_op_mod_q[i],     reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],   mid_pipe_rnd_mode_q[i],   reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_src_fmt_q[i+1],    mid_pipe_src_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_dst_fmt_q[i+1],    mid_pipe_dst_fmt_q[i],    reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_int_fmt_q[i+1],    mid_pipe_int_fmt_q[i],    reg_ena, fpnew_pkg::int_format_e'(0))
    `FFL(mid_pipe_tag_q[i+1],        mid_pipe_tag_q[i],        reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],       mid_pipe_mask_q[i],       reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],        mid_pipe_aux_q[i],        reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign input_sign_q      = mid_pipe_input_sign_q[NUM_MID_REGS];
  assign input_exp_q       = mid_pipe_input_exp_q[NUM_MID_REGS];
  assign input_mant_q      = mid_pipe_input_mant_q[NUM_MID_REGS];
  assign destination_exp_q = mid_pipe_dest_exp_q[NUM_MID_REGS];
  assign src_is_int_q      = mid_pipe_src_is_int_q[NUM_MID_REGS];
  assign dst_is_int_q      = mid_pipe_dst_is_int_q[NUM_MID_REGS];
  assign info_q            = mid_pipe_info_q[NUM_MID_REGS];
  assign mant_is_zero_q    = mid_pipe_mant_zero_q[NUM_MID_REGS];
  assign op_mod_q2         = mid_pipe_op_mod_q[NUM_MID_REGS];
  assign rnd_mode_q        = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign src_fmt_q2        = mid_pipe_src_fmt_q[NUM_MID_REGS];
  assign dst_fmt_q2        = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign int_fmt_q2        = mid_pipe_int_fmt_q[NUM_MID_REGS];

  // --------
  // Casting
  // --------
  logic [INT_EXP_WIDTH-1:0] final_exp;        // after eventual adjustments

  logic [2*INT_MAN_WIDTH:0]  preshift_mant;    // mantissa before final shift
  logic [2*INT_MAN_WIDTH:0]  destination_mant; // mantissa from shifter, with rnd bit
  logic [SUPER_MAN_BITS-1:0] final_mant;       // mantissa after adjustments
  logic [MAX_INT_WIDTH-1:0]  final_int;        // integer shifted in position

  logic [$clog2(INT_MAN_WIDTH+1)-1:0] denorm_shamt; // shift amount for denormalization

  logic [1:0] fp_round_sticky_bits, int_round_sticky_bits, round_sticky_bits;
  logic       of_before_round, uf_before_round;


  // Perform adjustments to mantissa and exponent
  always_comb begin : cast_value
    // Default assignment
    final_exp       = unsigned'(destination_exp_q); // take exponent as is, only look at lower bits
    preshift_mant   = '0;  // initialize mantissa container with zeroes
    denorm_shamt    = SUPER_MAN_BITS - fpnew_pkg::man_bits(dst_fmt_q2); // right of mantissa
    of_before_round = 1'b0;
    uf_before_round = 1'b0;

    // Place mantissa to the left of the shifter
    preshift_mant = input_mant_q << (INT_MAN_WIDTH + 1);

    // Handle INT casts
    if (dst_is_int_q) begin
      // By default right shift mantissa to be an integer
      denorm_shamt = unsigned'(MAX_INT_WIDTH - 1 - input_exp_q);
      // overflow: when converting to unsigned the range is larger by one
      if ((input_exp_q >= signed'(fpnew_pkg::int_width(int_fmt_q2) - 1 + op_mod_q2))    // Exponent larger than max int range,
          && !(!op_mod_q2                                                               // unless cast to signed int
               && input_sign_q                                                          // and input value is larges negative int value
               && (input_exp_q == signed'(fpnew_pkg::int_width(int_fmt_q2) - 1))
               && (input_mant_q == {1'b1, {INT_MAN_WIDTH-1{1'b0}}}))) begin
        denorm_shamt    = '0; // prevent shifting
        of_before_round = 1'b1;
      // underflow
      end else if (input_exp_q < -1) begin
        denorm_shamt    = MAX_INT_WIDTH + 1; // all bits go to the sticky
        uf_before_round = 1'b1;
      end
    // Handle FP over-/underflows
    end else begin
      // Infinities
      if (~src_is_int_q && info_q.is_inf) begin
        final_exp       = unsigned'(2**fpnew_pkg::exp_bits(dst_fmt_q2)-1); // largest exponent
        preshift_mant   = '0;
      // Overflow (for proper rounding)
      end else if (destination_exp_q >= signed'(2**fpnew_pkg::exp_bits(dst_fmt_q2))-1) begin
        final_exp       = unsigned'(2**fpnew_pkg::exp_bits(dst_fmt_q2)-2); // largest normal value
        preshift_mant   = '1;                           // largest normal value and RS bits set
        of_before_round = 1'b1;
      // Denormalize underflowing values
      end else if (destination_exp_q < 1 &&
                   destination_exp_q >= -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 1 - destination_exp_q); // adjust right shifting
        uf_before_round = 1'b1;
      // Limit the shift to retain sticky bits
      end else if (destination_exp_q < -signed'(fpnew_pkg::man_bits(dst_fmt_q2))) begin
        final_exp       = '0; // denormal result
        denorm_shamt    = unsigned'(denorm_shamt + 2 + fpnew_pkg::man_bits(dst_fmt_q2)); // to sticky
        uf_before_round = 1'b1;
      end
    end
  end

  localparam NUM_FP_STICKY  = 2 * INT_MAN_WIDTH - SUPER_MAN_BITS - 1; // removed mantissa, 1. and R
  localparam NUM_INT_STICKY = 2 * INT_MAN_WIDTH - MAX_INT_WIDTH; // removed int and R

  // Mantissa adjustment shift
  assign destination_mant = preshift_mant >> denorm_shamt;
  // Extract final mantissa and round bit, discard the normal bit (for FP)
  assign {final_mant, fp_round_sticky_bits[1]} =
      destination_mant[2*INT_MAN_WIDTH-1-:SUPER_MAN_BITS+1];
  assign {final_int, int_round_sticky_bits[1]} = destination_mant[2*INT_MAN_WIDTH-:MAX_INT_WIDTH+1];
  // Collapse sticky bits
  assign fp_round_sticky_bits[0]  = (| {destination_mant[NUM_FP_STICKY-1:0]});
  assign int_round_sticky_bits[0] = (| {destination_mant[NUM_INT_STICKY-1:0]});

  // select RS bits for destination operation
  assign round_sticky_bits = dst_is_int_q ? int_round_sticky_bits : fp_round_sticky_bits;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic [WIDTH-1:0] pre_round_abs;  // absolute value of result before rnd
  logic             of_after_round; // overflow
  logic             uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0]            fmt_of_after_round;
  logic [NUM_FORMATS-1:0]            fmt_uf_after_round;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_pre_round_abs;      // per format
  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_rounded_signed_res; // per format
  logic [NUM_INT_FORMATS-1:0]            ifmt_of_after_round;

  logic             rounded_sign;
  logic [WIDTH-1:0] rounded_abs; // absolute value of result after rounding
  logic             result_true_zero;

  logic [WIDTH-1:0] rounded_uint_res;     // after possible inversion
  logic [WIDTH-1:0] rounded_int_res;      // sign-extended, after possible inversion
  logic             rounded_int_res_zero; // after rounding


  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : assemble_result
        fmt_pre_round_abs[fmt] = {final_exp[EXP_BITS-1:0], final_mant[MAN_BITS-1:0]}; // 0-extend
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Zero-extend integer result
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_res_zero_ext
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : assemble_result
        // zero-extend absolute value result
        ifmt_pre_round_abs[ifmt]                = '0;
        ifmt_pre_round_abs[ifmt][INT_WIDTH-1:0] = final_int[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_pre_round_abs[ifmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Select output with destination format and operation
  assign pre_round_abs = dst_is_int_q ? ifmt_pre_round_abs[int_fmt_q2] : fmt_pre_round_abs[dst_fmt_q2];

  fpnew_rounding #(
    .AbsWidth ( WIDTH )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs     ),
    .sign_i                  ( input_sign_q      ), // source format
    .round_sticky_bits_i     ( round_sticky_bits ),
    .rnd_mode_i              ( rnd_mode_q        ),
    .effective_subtraction_i ( 1'b0              ), // no operation happened
    .abs_rounded_o           ( rounded_abs       ),
    .sign_o                  ( rounded_sign      ),
    .exact_zero_o            ( result_true_zero  )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  // Detect overflows and inject sign
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0; // denormal
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones. Int zeroes need to be detected`
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = src_is_int_q & mant_is_zero_q
                                        ? '0
                                        : {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Negative integer result needs to be brought into two's complement
  assign rounded_uint_res      = rounded_sign ? unsigned'(-rounded_abs) : rounded_abs;

    // Sign-extend integer result
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_res_sign_ext
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : assemble_result
        // zero-extend absolute value result
        ifmt_rounded_signed_res[ifmt]                = '{default: rounded_uint_res[INT_WIDTH-1]};
        ifmt_rounded_signed_res[ifmt][INT_WIDTH-1:0] = rounded_uint_res[INT_WIDTH-1:0];
      end
    end else begin : inactive_format
      assign ifmt_rounded_signed_res[ifmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end
  
  assign rounded_int_res = ifmt_rounded_signed_res[int_fmt_q2];
  assign rounded_int_res_zero = (rounded_int_res == '0);

  // Detect integer overflows after rounding (only positives)
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_int_overflow
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : detect_overflow
        ifmt_of_after_round[ifmt] = 1'b0;
        // Int result can overflow if we're at the max exponent
        if (!rounded_sign && input_exp_q == signed'(INT_WIDTH - 2 + op_mod_q2)) begin
          // Check whether the rounded MSB differs from unrounded MSB
          ifmt_of_after_round[ifmt] = ~rounded_int_res[INT_WIDTH-2+op_mod_q2];
        end
      end
    end else begin : inactive_format
      assign ifmt_of_after_round[ifmt] = fpnew_pkg::DONT_CARE;
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = dst_is_int_q ? ifmt_of_after_round[int_fmt_q2] : fmt_of_after_round[dst_fmt_q2];

  // -------------------------
  // FP Special case handling
  // -------------------------
  logic [WIDTH-1:0]   fp_special_result;
  fpnew_pkg::status_t fp_special_status;
  logic               fp_result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_special_result;

  // Special result construction
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;
        special_res = info_q.is_zero
                      ? input_sign_q << FP_WIDTH-1 // signed zero
                      : {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN

        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign fp_result_is_special = ~src_is_int_q & (info_q.is_zero |
                                                 info_q.is_nan |
                                                 ~info_q.is_boxed);

  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign fp_special_status = '{NV: info_q.is_signalling, default: 1'b0};

  // Assemble result according to destination format
  assign fp_special_result = fmt_special_result[dst_fmt_q2]; // destination format

  // --------------------------
  // INT Special case handling
  // --------------------------
  logic [WIDTH-1:0]   int_special_result;
  fpnew_pkg::status_t int_special_status;
  logic               int_result_is_special;

  logic [NUM_INT_FORMATS-1:0][WIDTH-1:0] ifmt_special_result;

  // Special result construction
  for (genvar ifmt = 0; ifmt < int'(NUM_INT_FORMATS); ifmt++) begin : gen_special_results_int
    // Set up some constants
    localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));

    if (IntFmtConfig[ifmt]) begin : active_format
      always_comb begin : special_results
        automatic logic [INT_WIDTH-1:0] special_res;

        // Default is overflow to positive max, which is 2**INT_WIDTH-1 or 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-2:0] = '1;       // alone yields 2**(INT_WIDTH-1)-1
        special_res[INT_WIDTH-1]   = op_mod_q2; // for unsigned casts yields 2**INT_WIDTH-1

        // Negative special case (except for nans) tie to -max or 0
        if (input_sign_q && !info_q.is_nan)
          special_res = ~special_res;

        // Initialize special result with sign-extension
        ifmt_special_result[ifmt]                = '{default: special_res[INT_WIDTH-1]};
        ifmt_special_result[ifmt][INT_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign ifmt_special_result[ifmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Detect special case from source format (inf, nan, overflow, nan-boxing or negative unsigned)
  assign int_result_is_special = info_q.is_nan | info_q.is_inf |
                                 of_before_round | of_after_round | ~info_q.is_boxed |
                                 (input_sign_q & op_mod_q2 & ~rounded_int_res_zero);

  // All integer special cases are invalid
  assign int_special_status = '{NV: 1'b1, default: 1'b0};

  // Assemble result according to destination format
  assign int_special_result = ifmt_special_result[int_fmt_q2]; // destination format

  // -----------------
  // Result selection
  // -----------------
  fpnew_pkg::status_t int_regular_status, fp_regular_status;

  logic [WIDTH-1:0]   fp_result, int_result;
  fpnew_pkg::status_t fp_status, int_status;

  assign fp_regular_status.NV = 1'b0; // floating-point results are always valid
  assign fp_regular_status.DZ = 1'b0; // no divisions
  assign fp_regular_status.OF = (src_is_int_q | ~info_q.is_inf) & (of_before_round | of_after_round); // inf casts no OF
  assign fp_regular_status.UF = uf_after_round & fp_regular_status.NX;
  assign fp_regular_status.NX = (| fp_round_sticky_bits) | ((src_is_int_q | ~info_q.is_inf) & (of_before_round | of_after_round));
  assign int_regular_status = '{NV: of_before_round | of_after_round, // overflow is invalid for F2I casts
                                NX: (| int_round_sticky_bits), default: 1'b0};

  assign fp_result  = fp_result_is_special  ? fp_special_result  : fmt_result[dst_fmt_q2];
  assign fp_status  = fp_result_is_special  ? fp_special_status  : fp_regular_status;
  assign int_result = int_result_is_special ? int_special_result : rounded_int_res;
  assign int_status = int_result_is_special ? int_special_status : int_regular_status;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;
  logic               extension_bit;

  // Select output depending on special case detection
  assign result_d = dst_is_int_q ? int_result : fp_result;
  assign status_d = dst_is_int_q ? int_status : fp_status;

  // MSB of int result decides extension, otherwise NaN box
  assign extension_bit = dst_is_int_q ? int_result[WIDTH-1] : 1'b1;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_ext_bit_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]  = result_d;
  assign out_pipe_status_q[0]  = status_d;
  assign out_pipe_ext_bit_q[0] = extension_bit;
  assign out_pipe_tag_q[0]     = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]    = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]     = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]   = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],  out_pipe_result_q[i],  reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],  out_pipe_status_q[i],  reg_ena, '0)
    `FFL(out_pipe_ext_bit_q[i+1], out_pipe_ext_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],     out_pipe_tag_q[i],     reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],    out_pipe_mask_q[i],    reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],     out_pipe_aux_q[i],     reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_ext_bit_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});

  // Early valid_o signal. This is used for dispatching instructions for dual-issue processor.
  if (NUM_OUT_REGS > 0) begin
    assign early_out_valid_o = |{out_pipe_valid_q[NUM_OUT_REGS] & ~out_pipe_ready[NUM_OUT_REGS],
                                 out_pipe_valid_q[NUM_OUT_REGS-1]};
  end else if (NUM_MID_REGS > 0) begin
    assign early_out_valid_o = |{mid_pipe_valid_q[NUM_MID_REGS] & ~mid_pipe_ready[NUM_OUT_REGS],
                                 mid_pipe_valid_q[NUM_MID_REGS-1]};
  end else if (NUM_INP_REGS > 0) begin
    assign early_out_valid_o = |{inp_pipe_valid_q[NUM_INP_REGS] & ~inp_pipe_ready[NUM_INP_REGS],
                                 inp_pipe_valid_q[NUM_INP_REGS-1]};
  end else begin
    assign early_out_valid_o = 1'b0;
  end

endmodule
// ----- 8< ----- FILE "./fpnew_classifier.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_classifier #(
  parameter fpnew_pkg::fp_format_e   FpFormat = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumOperands = 1,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat)
) (
  input  logic                [NumOperands-1:0][WIDTH-1:0] operands_i,
  input  logic                [NumOperands-1:0]            is_boxed_i,
  output fpnew_pkg::fp_info_t [NumOperands-1:0]            info_o
);

  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);

  // Type definition
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // Iterate through all operands
  for (genvar op = 0; op < int'(NumOperands); op++) begin : gen_num_values

    fp_t value;
    logic is_boxed;
    logic is_normal;
    logic is_inf;
    logic is_nan;
    logic is_signalling;
    logic is_quiet;
    logic is_zero;
    logic is_subnormal;

    // ---------------
    // Classify Input
    // ---------------
    always_comb begin : classify_input
      value         = operands_i[op];
      is_boxed      = is_boxed_i[op];
      is_normal     = is_boxed && (value.exponent != '0) && (value.exponent != '1);
      is_zero       = is_boxed && (value.exponent == '0) && (value.mantissa == '0);
      is_subnormal  = is_boxed && (value.exponent == '0) && !is_zero;
      is_inf        = is_boxed && ((value.exponent == '1) && (value.mantissa == '0));
      is_nan        = !is_boxed || ((value.exponent == '1) && (value.mantissa != '0));
      is_signalling = is_boxed && is_nan && (value.mantissa[MAN_BITS-1] == 1'b0);
      is_quiet      = is_nan && !is_signalling;
      // Assign output for current input
      info_o[op].is_normal     = is_normal;
      info_o[op].is_subnormal  = is_subnormal;
      info_o[op].is_zero       = is_zero;
      info_o[op].is_inf        = is_inf;
      info_o[op].is_nan        = is_nan;
      info_o[op].is_signalling = is_signalling;
      info_o[op].is_quiet      = is_quiet;
      info_o[op].is_boxed      = is_boxed;
    end
  end
endmodule
// ----- 8< ----- FILE "./gated_clk_cell.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module gated_clk_cell(
  clk_in,
  global_en,
  module_en,
  local_en,
  external_en,
  pad_yy_icg_scan_en,
  clk_out
);

input  clk_in;
input  global_en;
input  module_en;
input  local_en;
input  external_en;
input  pad_yy_icg_scan_en;
output clk_out;

wire   clk_en_bf_latch;
wire   SE;

assign clk_en_bf_latch = (global_en && (module_en || local_en)) || external_en ;

// SE driven from primary input, held constant
assign SE	       = pad_yy_icg_scan_en;
 
// //   &Connect(    .clk_in           (clk_in), @50
// //                .SE               (SE), @51
// //                .external_en      (clk_en_bf_latch), @52
// //                .clk_out          (clk_out) @53
// //                ) ; @54

assign clk_out = clk_in;

endmodule   
// ----- 8< ----- FILE "./pa_fdsu_ctrl.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_ctrl(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  ex1_div,
  ex1_expnt_adder_op0,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op1_id_vld,
  ex1_op1_norm,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_result_sign,
  ex1_rm,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex1_sqrt,
  ex1_srt_skip,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_expnt_adjust_result,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex1_sel,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_wb_vld,
  fdsu_yy_div,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  fdsu_yy_sqrt,
  fdsu_yy_uf,
  fdsu_yy_wb_freg,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush,
  srt_remainder_zero,
  srt_sm_on
);

// &Ports; @24
input           cp0_fpu_icg_en;         
input           cp0_yy_clk_en;          
input           cpurst_b;               
input           ctrl_fdsu_ex1_sel;      
input           ctrl_xx_ex1_cmplt_dp;   
input           ctrl_xx_ex1_inst_vld;   
input           ctrl_xx_ex1_stall;      
input           ctrl_xx_ex1_warm_up;    
input           ctrl_xx_ex2_warm_up;    
input           ctrl_xx_ex3_warm_up;    
input           ex1_div;                
input   [12:0]  ex1_expnt_adder_op0;    
input           ex1_of_result_lfn;      
input           ex1_op0_id;             
input           ex1_op0_norm;           
input           ex1_op1_id_vld;         
input           ex1_op1_norm;           
input   [12:0]  ex1_oper_id_expnt;      
input           ex1_result_sign;        
input   [2 :0]  ex1_rm;                 
input           ex1_sqrt;               
input           ex1_srt_skip;           
input           ex2_of;                 
input           ex2_potnt_of;           
input           ex2_potnt_uf;           
input           ex2_result_inf;         
input           ex2_result_lfn;         
input           ex2_rslt_denorm;        
input   [9 :0]  ex2_srt_expnt_rst;      
input           ex2_uf;                 
input           ex2_uf_srt_skip;        
input   [9 :0]  ex3_expnt_adjust_result; 
input           ex3_rslt_denorm;        
input           forever_cpuclk;         
input           frbus_fdsu_wb_grant;    
input   [4 :0]  idu_fpu_ex1_dst_freg;   
input   [2 :0]  idu_fpu_ex1_eu_sel;     
input           pad_yy_icg_scan_en;     
input           rtu_xx_ex1_cancel;      
input           rtu_xx_ex2_cancel;      
input           rtu_yy_xx_async_flush;  
input           rtu_yy_xx_flush;        
input           srt_remainder_zero;     
output          ex1_op1_sel;            
output  [12:0]  ex1_oper_id_expnt_f;    
output          ex1_pipedown;           
output          ex1_pipedown_gate;      
output          ex1_save_op0;           
output          ex1_save_op0_gate;      
output  [9 :0]  ex2_expnt_adder_op0;    
output          ex2_pipe_clk;           
output          ex2_pipedown;           
output          ex2_srt_first_round;    
output          ex3_pipedown;           
output          fdsu_ex1_sel;           
output  [4 :0]  fdsu_fpu_debug_info;    
output          fdsu_fpu_ex1_cmplt;     
output          fdsu_fpu_ex1_cmplt_dp;  
output          fdsu_fpu_ex1_stall;     
output          fdsu_fpu_no_op;         
output          fdsu_frbus_wb_vld;      
output          fdsu_yy_div;            
output  [9 :0]  fdsu_yy_expnt_rst;      
output          fdsu_yy_of;             
output          fdsu_yy_of_rm_lfn;      
output          fdsu_yy_op0_norm;       
output          fdsu_yy_op1_norm;       
output          fdsu_yy_potnt_of;       
output          fdsu_yy_potnt_uf;       
output          fdsu_yy_result_inf;     
output          fdsu_yy_result_lfn;     
output          fdsu_yy_result_sign;    
output  [2 :0]  fdsu_yy_rm;             
output          fdsu_yy_rslt_denorm;    
output          fdsu_yy_sqrt;           
output          fdsu_yy_uf;             
output  [4 :0]  fdsu_yy_wb_freg;        
output          srt_sm_on;              

// &Regs; @25
reg             ex2_srt_first_round;    
reg     [2 :0]  fdsu_cur_state;         
reg             fdsu_div;               
reg     [9 :0]  fdsu_expnt_rst;         
reg     [2 :0]  fdsu_next_state;        
reg             fdsu_of;                
reg             fdsu_of_rm_lfn;         
reg             fdsu_potnt_of;          
reg             fdsu_potnt_uf;          
reg             fdsu_result_inf;        
reg             fdsu_result_lfn;        
reg             fdsu_result_sign;       
reg     [2 :0]  fdsu_rm;                
reg             fdsu_sqrt;              
reg             fdsu_uf;                
reg     [4 :0]  fdsu_wb_freg;           
reg             fdsu_yy_rslt_denorm;    
reg     [4 :0]  srt_cnt;                
reg     [1 :0]  wb_cur_state;           
reg     [1 :0]  wb_nxt_state;           

// &Wires; @26
wire            cp0_fpu_icg_en;         
wire            cp0_yy_clk_en;          
wire            cpurst_b;               
wire            ctrl_fdsu_ex1_sel;      
wire            ctrl_fdsu_ex1_stall;    
wire            ctrl_fdsu_wb_vld;       
wire            ctrl_iter_start;        
wire            ctrl_iter_start_gate;   
wire            ctrl_pack;              
wire            ctrl_result_vld;        
wire            ctrl_round;             
wire            ctrl_sm_cmplt;          
wire            ctrl_sm_ex1;            
wire            ctrl_sm_idle;           
wire            ctrl_sm_start;          
wire            ctrl_sm_start_gate;     
wire            ctrl_srt_idle;          
wire            ctrl_srt_itering;       
wire            ctrl_wb_idle;           
wire            ctrl_wb_sm_cmplt;       
wire            ctrl_wb_sm_ex2;         
wire            ctrl_wb_sm_idle;        
wire            ctrl_wfi2;              
wire            ctrl_wfwb;              
wire            ctrl_xx_ex1_cmplt_dp;   
wire            ctrl_xx_ex1_inst_vld;   
wire            ctrl_xx_ex1_stall;      
wire            ctrl_xx_ex1_warm_up;    
wire            ctrl_xx_ex2_warm_up;    
wire            ctrl_xx_ex3_warm_up;    
wire            ex1_div;                
wire    [12:0]  ex1_expnt_adder_op0;    
wire            ex1_of_result_lfn;      
wire            ex1_op0_id;             
wire            ex1_op1_id_vld;         
wire            ex1_op1_sel;            
wire    [12:0]  ex1_oper_id_expnt;      
wire    [12:0]  ex1_oper_id_expnt_f;    
wire            ex1_pipe_clk;           
wire            ex1_pipe_clk_en;        
wire            ex1_pipedown;           
wire            ex1_pipedown_gate;      
wire            ex1_result_sign;        
wire    [2 :0]  ex1_rm;                 
wire            ex1_save_op0;           
wire            ex1_save_op0_gate;      
wire            ex1_sqrt;               
wire            ex1_srt_skip;           
wire    [4 :0]  ex1_wb_freg;            
wire    [9 :0]  ex2_expnt_adder_op0;    
wire            ex2_of;                 
wire            ex2_pipe_clk;           
wire            ex2_pipe_clk_en;        
wire            ex2_pipedown;           
wire            ex2_potnt_of;           
wire            ex2_potnt_uf;           
wire            ex2_result_inf;         
wire            ex2_result_lfn;         
wire            ex2_rslt_denorm;        
wire    [9 :0]  ex2_srt_expnt_rst;      
wire            ex2_uf;                 
wire            ex2_uf_srt_skip;        
wire    [9 :0]  ex3_expnt_adjust_result; 
wire            ex3_pipedown;           
wire            ex3_rslt_denorm;        
wire            expnt_rst_clk;          
wire            expnt_rst_clk_en;       
wire            fdsu_busy;              
wire            fdsu_clk;               
wire            fdsu_clk_en;            
wire            fdsu_dn_stall;          
wire            fdsu_ex1_inst_vld;      
wire            fdsu_ex1_res_vld;       
wire            fdsu_ex1_sel;           
wire            fdsu_flush;             
wire    [4 :0]  fdsu_fpu_debug_info;    
wire            fdsu_fpu_ex1_cmplt;     
wire            fdsu_fpu_ex1_cmplt_dp;  
wire            fdsu_fpu_ex1_stall;     
wire            fdsu_fpu_no_op;         
wire            fdsu_frbus_wb_vld;      
wire            fdsu_op0_norm;          
wire            fdsu_op1_norm;          
wire            fdsu_wb_grant;          
wire            fdsu_yy_div;            
wire    [9 :0]  fdsu_yy_expnt_rst;      
wire            fdsu_yy_of;             
wire            fdsu_yy_of_rm_lfn;      
wire            fdsu_yy_op0_norm;       
wire            fdsu_yy_op1_norm;       
wire            fdsu_yy_potnt_of;       
wire            fdsu_yy_potnt_uf;       
wire            fdsu_yy_result_inf;     
wire            fdsu_yy_result_lfn;     
wire            fdsu_yy_result_sign;    
wire    [2 :0]  fdsu_yy_rm;             
wire            fdsu_yy_sqrt;           
wire            fdsu_yy_uf;             
wire    [4 :0]  fdsu_yy_wb_freg;        
wire            forever_cpuclk;         
wire            frbus_fdsu_wb_grant;    
wire    [4 :0]  idu_fpu_ex1_dst_freg;   
wire    [2 :0]  idu_fpu_ex1_eu_sel;     
wire            pad_yy_icg_scan_en;     
wire            rtu_xx_ex1_cancel;      
wire            rtu_xx_ex2_cancel;      
wire            rtu_yy_xx_async_flush;  
wire            rtu_yy_xx_flush;        
wire    [4 :0]  srt_cnt_ini;            
wire            srt_cnt_zero;           
wire            srt_last_round;         
wire            srt_remainder_zero;     
wire            srt_skip;               
wire            srt_sm_on;              


//==========================================================
//                       Input Signal
//==========================================================
assign ex1_wb_freg[4:0] = idu_fpu_ex1_dst_freg[4:0];
assign fdsu_ex1_inst_vld = ctrl_xx_ex1_inst_vld && ctrl_fdsu_ex1_sel;
assign fdsu_ex1_sel      = idu_fpu_ex1_eu_sel[2];
// &Force("input", "idu_fpu_ex1_eu_sel"); &Force("bus", "idu_fpu_ex1_eu_sel", 2, 0); @34

//==========================================================
//                 FDSU Main State Machine
//==========================================================
assign fdsu_ex1_res_vld  = fdsu_ex1_inst_vld && ex1_srt_skip;
assign fdsu_wb_grant = frbus_fdsu_wb_grant;

assign ctrl_iter_start = ctrl_sm_start && !fdsu_dn_stall
                      || ctrl_wfi2;
assign ctrl_iter_start_gate = ctrl_sm_start_gate && !fdsu_dn_stall
                           || ctrl_wfi2;
assign ctrl_sm_start = fdsu_ex1_inst_vld && ctrl_srt_idle
                   && !ex1_srt_skip;
assign ctrl_sm_start_gate = fdsu_ex1_inst_vld && ctrl_srt_idle;

assign srt_last_round = (srt_skip ||
                         srt_remainder_zero ||
                         srt_cnt_zero)      &&
                         ctrl_srt_itering;
assign srt_skip       =  ex2_of ||
                         ex2_uf_srt_skip;
assign srt_cnt_zero   = ~|srt_cnt[4:0];
assign fdsu_dn_stall  = ctrl_sm_start && ex1_op1_id_vld;

parameter IDLE  = 3'b000;
parameter WFI2  = 3'b001;
parameter ITER  = 3'b010;
parameter RND   = 3'b011;
parameter PACK  = 3'b100;
parameter WFWB  = 3'b101;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    fdsu_cur_state[2:0] <= IDLE;
  else if (fdsu_flush)
    fdsu_cur_state[2:0] <= IDLE;
  else
    fdsu_cur_state[2:0] <= fdsu_next_state[2:0];
end

// &CombBeg; @76
always @( ctrl_sm_start
       or fdsu_dn_stall
       or srt_last_round
       or fdsu_cur_state[2:0]
       or fdsu_wb_grant)
begin
case (fdsu_cur_state[2:0])
  IDLE:
  begin
    if (ctrl_sm_start)
      if (fdsu_dn_stall)
        fdsu_next_state[2:0] = WFI2;
      else
        fdsu_next_state[2:0] = ITER;
    else
      fdsu_next_state[2:0] = IDLE;
  end
  WFI2:
    fdsu_next_state[2:0] = ITER;
  ITER:
  begin
    if (srt_last_round)
      fdsu_next_state[2:0] = RND;
    else
      fdsu_next_state[2:0] = ITER;
  end
  RND:
    fdsu_next_state[2:0] = PACK;
  PACK:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  WFWB:
  begin
    if (fdsu_wb_grant)
      if (ctrl_sm_start)
        if (fdsu_dn_stall)
          fdsu_next_state[2:0] = WFI2;
        else
          fdsu_next_state[2:0] = ITER;
      else
        fdsu_next_state[2:0] = IDLE;
    else
      fdsu_next_state[2:0] = WFWB;
  end
  default:
    fdsu_next_state[2:0] = IDLE;
endcase
// &CombEnd; @128
end

assign ctrl_sm_idle     = fdsu_cur_state[2:0] == IDLE;
assign ctrl_wfi2        = fdsu_cur_state[2:0] == WFI2;
assign ctrl_srt_itering = fdsu_cur_state[2:0] == ITER;
assign ctrl_round       = fdsu_cur_state[2:0] == RND;
assign ctrl_pack        = fdsu_cur_state[2:0] == PACK;
assign ctrl_wfwb        = fdsu_cur_state[2:0] == WFWB;

assign ctrl_sm_cmplt    = ctrl_pack || ctrl_wfwb;
assign ctrl_srt_idle     = ctrl_sm_idle
                       || fdsu_wb_grant;
assign ctrl_sm_ex1      = ctrl_srt_idle || ctrl_wfi2;

//==========================================================
//                    Iteration Counter
//==========================================================
always @ (posedge fdsu_clk)
begin
  if (fdsu_flush)
    srt_cnt[4:0] <= 5'b0;
  else if (ctrl_iter_start)
    srt_cnt[4:0] <= srt_cnt_ini[4:0];
  else if (ctrl_srt_itering)
    srt_cnt[4:0] <= srt_cnt[4:0] - 5'b1;
  else
    srt_cnt[4:0] <= srt_cnt[4:0];
end

//srt_cnt_ini[4:0]
//For Double, initial is 5'b11100('d28), calculate 29 round
//For Single, initial is 5'b01110('d14), calculate 15 round
assign srt_cnt_ini[4:0] = 5'b01110;

//fdsu srt first round signal 
//For srt calculate special use
always @(posedge fdsu_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ex2_srt_first_round <= 1'b0;
  else if(fdsu_flush)
    ex2_srt_first_round <= 1'b0;
  else if(ex1_pipedown)
    ex2_srt_first_round <= 1'b1;
  else
    ex2_srt_first_round <= 1'b0;
end

//==========================================================
//                 Write Back State Machine
//==========================================================
parameter WB_IDLE  = 2'b00,
          WB_EX2   = 2'b10,
          WB_CMPLT = 2'b01;

always @ (posedge fdsu_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    wb_cur_state[1:0] <= WB_IDLE;
  else if (fdsu_flush)
    wb_cur_state[1:0] <= WB_IDLE;
  else
    wb_cur_state[1:0] <= wb_nxt_state[1:0];
end

// &CombBeg; @215
always @( ctrl_fdsu_wb_vld
       or fdsu_dn_stall
       or ctrl_xx_ex1_stall
       or fdsu_ex1_inst_vld
       or ctrl_iter_start
       or fdsu_ex1_res_vld
       or wb_cur_state[1:0])
begin
  case(wb_cur_state[1:0])
    WB_IDLE:
      if (fdsu_ex1_inst_vld)
        if (ctrl_xx_ex1_stall || fdsu_ex1_res_vld || fdsu_dn_stall)
          wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_EX2;
      else
        wb_nxt_state[1:0] = WB_IDLE;
    WB_EX2:
      // if (ctrl_xx_ex2_stall)
      //   wb_nxt_state[1:0] = WB_EX2;
      // else
        if (ctrl_fdsu_wb_vld)
          if (ctrl_iter_start && !ctrl_xx_ex1_stall)
            wb_nxt_state[1:0] = WB_EX2;
          else
            wb_nxt_state[1:0] = WB_IDLE;
        else
          wb_nxt_state[1:0] = WB_CMPLT;
    WB_CMPLT:
      if (ctrl_fdsu_wb_vld)
        if (ctrl_iter_start && !ctrl_xx_ex1_stall)
          wb_nxt_state[1:0] = WB_EX2;
        else
          wb_nxt_state[1:0] = WB_IDLE;
      else
        wb_nxt_state[1:0] = WB_CMPLT;
    default:
      wb_nxt_state[1:0] = WB_IDLE;
  endcase
// &CombEnd; @247
end

assign ctrl_wb_idle  = wb_cur_state[1:0] == WB_IDLE
                       || wb_cur_state[1:0] == WB_CMPLT && ctrl_fdsu_wb_vld;
assign ctrl_wb_sm_idle  = wb_cur_state[1:0] == WB_IDLE;
assign ctrl_wb_sm_ex2   = wb_cur_state[1:0] == WB_EX2;
assign ctrl_wb_sm_cmplt = wb_cur_state[1:0] == WB_EX2
                       || wb_cur_state[1:0] == WB_CMPLT;

assign ctrl_result_vld  = ctrl_sm_cmplt && ctrl_wb_sm_cmplt;
assign ctrl_fdsu_wb_vld = ctrl_result_vld && frbus_fdsu_wb_grant;

assign ctrl_fdsu_ex1_stall = fdsu_ex1_inst_vld && !ctrl_sm_ex1 && !ctrl_wb_idle
                          || fdsu_ex1_inst_vld && fdsu_dn_stall;

//==========================================================
//                          Flops
//==========================================================
always @(posedge ex1_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_wb_freg[4:0]    <= ex1_wb_freg[4:0];
    fdsu_result_sign     <= ex1_result_sign;
    fdsu_of_rm_lfn       <= ex1_of_result_lfn;
    fdsu_div             <= ex1_div;
    fdsu_sqrt            <= ex1_sqrt;
    fdsu_rm[2:0]         <= ex1_rm[2:0];
  end
  else
  begin
    fdsu_wb_freg[4:0]    <= fdsu_wb_freg[4:0];
    fdsu_result_sign     <= fdsu_result_sign;
    fdsu_of_rm_lfn       <= fdsu_of_rm_lfn;
    fdsu_div             <= fdsu_div;
    fdsu_sqrt            <= fdsu_sqrt;
    fdsu_rm[2:0]         <= fdsu_rm[2:0];
  end
end

// In 906 FDSU, if one op0/1 is not norm, it will not enter EX2.
assign fdsu_op0_norm = 1'b1;
assign fdsu_op1_norm = 1'b1;
// &Force("input", "ex1_op0_norm"); @337
// &Force("input", "ex1_op1_norm"); @338

// fdsu_expnt_rst is used to save:
//  1. op0 denormal expnt;
//  2. op0 expnt;
//  3. result expnt.
// &Force("bus", "ex1_oper_id_expnt", 12, 0); @378
// &Force("bus", "ex1_expnt_adder_op0", 12, 0); @379


always @ (posedge expnt_rst_clk)
begin
  if (ex1_save_op0)
    fdsu_expnt_rst[9:0] <= ex1_oper_id_expnt[9:0];
  else if (ex1_pipedown)
    fdsu_expnt_rst[9:0] <= ex1_expnt_adder_op0[9:0];
  else if (ex2_pipedown)
    fdsu_expnt_rst[9:0] <= ex2_srt_expnt_rst[9:0];
  else if (ex3_pipedown)
    fdsu_expnt_rst[9:0] <= ex3_expnt_adjust_result[9:0];
  else
    fdsu_expnt_rst[9:0] <= fdsu_expnt_rst[9:0];
end

assign ex1_oper_id_expnt_f[12:0] = {3'b1, fdsu_expnt_rst[9:0]};

always @ (posedge expnt_rst_clk)
begin
  if (ex2_pipedown)
    fdsu_yy_rslt_denorm <= ex2_rslt_denorm;
  else if (ex3_pipedown)
    fdsu_yy_rslt_denorm <= ex3_rslt_denorm;
  else
    fdsu_yy_rslt_denorm <= fdsu_yy_rslt_denorm;
end
// &Force("output", "fdsu_yy_rslt_denorm"); @440

// EX2 signal used in EX3 & EX4
always @ (posedge ex2_pipe_clk)
begin
  if (ex2_pipedown)
  begin
    fdsu_result_inf <= ex2_result_inf;
    fdsu_result_lfn <= ex2_result_lfn;
    fdsu_of         <= ex2_of;
    fdsu_uf         <= ex2_uf;
    fdsu_potnt_of   <= ex2_potnt_of;
    fdsu_potnt_uf   <= ex2_potnt_uf;
  end
  else
  begin
    fdsu_result_inf <= fdsu_result_inf;
    fdsu_result_lfn <= fdsu_result_lfn;
    fdsu_of         <= fdsu_of;
    fdsu_uf         <= fdsu_uf;
    fdsu_potnt_of   <= fdsu_potnt_of;
    fdsu_potnt_uf   <= fdsu_potnt_uf;
  end
end

//==========================================================
//                          Flush
//==========================================================
assign fdsu_flush = rtu_xx_ex1_cancel && ctrl_wb_idle
                 || rtu_xx_ex2_cancel && ctrl_wb_sm_ex2
                 || ctrl_xx_ex1_warm_up
                 || rtu_yy_xx_async_flush;

//==========================================================
//                           ICG
//==========================================================
assign fdsu_busy = fdsu_ex1_inst_vld
                || !ctrl_sm_idle
                || !ctrl_wb_sm_idle;
assign fdsu_clk_en = fdsu_busy
                  || !ctrl_sm_idle
                  || rtu_yy_xx_flush;
// &Instance("gated_clk_cell", "x_fdsu_clk"); @514
gated_clk_cell  x_fdsu_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (fdsu_clk          ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (fdsu_clk_en       ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @515
//          .external_en (1'b0), @516
//          .global_en   (cp0_yy_clk_en), @517
//          .module_en   (cp0_fpu_icg_en), @518
//          .local_en    (fdsu_clk_en), @519
//          .clk_out     (fdsu_clk)); @520

assign ex1_pipe_clk_en = ex1_pipedown_gate;
// &Instance("gated_clk_cell","x_ex1_pipe_clk"); @523
gated_clk_cell  x_ex1_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex1_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex1_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @524
//           .clk_out        (ex1_pipe_clk),//Out Clock @525
//           .external_en    (1'b0), @526
//           .global_en      (cp0_yy_clk_en), @527
//           .local_en       (ex1_pipe_clk_en),//Local Condition @528
//           .module_en      (cp0_fpu_icg_en) @529
//         ); @530

assign ex2_pipe_clk_en = ex2_pipedown;
// &Instance("gated_clk_cell","x_ex2_pipe_clk"); @533
gated_clk_cell  x_ex2_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @534
//           .clk_out        (ex2_pipe_clk),//Out Clock @535
//           .external_en    (1'b0), @536
//           .global_en      (cp0_yy_clk_en), @537
//           .local_en       (ex2_pipe_clk_en),//Local Condition @538
//           .module_en      (cp0_fpu_icg_en) @539
//         ); @540
// &Force("output", "ex2_pipe_clk"); @541

assign expnt_rst_clk_en = ex1_save_op0_gate
                       || ex1_pipedown_gate
                       || ex2_pipedown
                       || ex3_pipedown;
// &Instance("gated_clk_cell", "x_expnt_rst_clk"); @547
gated_clk_cell  x_expnt_rst_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (expnt_rst_clk     ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (expnt_rst_clk_en  ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect(.clk_in      (forever_cpuclk), @548
//          .external_en (1'b0), @549
//          .global_en   (cp0_yy_clk_en), @550
//          .module_en   (cp0_fpu_icg_en), @551
//          .local_en    (expnt_rst_clk_en), @552
//          .clk_out     (expnt_rst_clk)); @553

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_yy_wb_freg[4:0]    = fdsu_wb_freg[4:0];
assign fdsu_yy_result_sign     = fdsu_result_sign;
assign fdsu_yy_op0_norm        = fdsu_op0_norm;
assign fdsu_yy_op1_norm        = fdsu_op1_norm;
assign fdsu_yy_of_rm_lfn       = fdsu_of_rm_lfn;
assign fdsu_yy_div             = fdsu_div;
assign fdsu_yy_sqrt            = fdsu_sqrt;
assign fdsu_yy_rm[2:0]         = fdsu_rm[2:0];

assign fdsu_yy_expnt_rst[9:0] = fdsu_expnt_rst[9:0];
assign ex2_expnt_adder_op0[9:0] = fdsu_expnt_rst[9:0];

assign fdsu_yy_result_inf = fdsu_result_inf;
assign fdsu_yy_result_lfn = fdsu_result_lfn;
assign fdsu_yy_of         = fdsu_of;
assign fdsu_yy_uf         = fdsu_uf;
assign fdsu_yy_potnt_of   = fdsu_potnt_of;
assign fdsu_yy_potnt_uf   = fdsu_potnt_uf;

assign ex1_pipedown = ctrl_iter_start || ctrl_xx_ex1_warm_up;
assign ex1_pipedown_gate = ctrl_iter_start_gate || ctrl_xx_ex1_warm_up;
assign ex2_pipedown = ctrl_srt_itering && srt_last_round || ctrl_xx_ex2_warm_up;
assign ex3_pipedown = ctrl_round || ctrl_xx_ex3_warm_up;
// &Force("output", "ex1_pipedown"); @589
// &Force("output", "ex1_pipedown_gate"); @590
// &Force("output", "ex2_pipedown"); @591
// &Force("output", "ex3_pipedown"); @592

assign srt_sm_on = ctrl_srt_itering;

assign fdsu_fpu_ex1_cmplt = fdsu_ex1_inst_vld;
assign fdsu_fpu_ex1_cmplt_dp =  ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel[2];
assign fdsu_fpu_ex1_stall = ctrl_fdsu_ex1_stall;
assign fdsu_frbus_wb_vld  = ctrl_result_vld;
// &Force("bus","idu_fpu_ex1_eu_sel",2,0); @600
assign fdsu_fpu_no_op = !fdsu_busy;
assign ex1_op1_sel = ctrl_wfi2;
assign ex1_save_op0 = ctrl_sm_start && ex1_op0_id && ex1_op1_id_vld;
assign ex1_save_op0_gate = ctrl_sm_start_gate && ex1_op0_id && ex1_op1_id_vld;
// &Force("output", "ex1_save_op0"); @605
// &Force("output", "ex1_save_op0_gate"); @606

assign fdsu_fpu_debug_info[4:0] = {wb_cur_state[1:0], fdsu_cur_state[2:0]};

// &ModuleEnd; @610
endmodule



// ----- 8< ----- FILE "./pa_fdsu_ff1.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_ff1(
  fanc_shift_num,
  frac_bin_val,
  frac_num
);

// &Ports; @24
input   [51:0]  frac_num;      
output  [51:0]  fanc_shift_num; 
output  [12:0]  frac_bin_val;  

// &Regs; @25
reg     [51:0]  fanc_shift_num; 
reg     [12:0]  frac_bin_val;  

// &Wires; @26
wire    [51:0]  frac_num;      


// &CombBeg; @28
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h0;
  52'b01??????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1fff;
  52'b001?????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffe;
  52'b0001????????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffd;
  52'b00001???????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffc;
  52'b000001??????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffb;
  52'b0000001?????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ffa;
  52'b00000001????????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff9;
  52'b000000001???????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff8;
  52'b0000000001??????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff7;
  52'b00000000001?????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff6;
  52'b000000000001????????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff5;
  52'b0000000000001???????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff4;
  52'b00000000000001??????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff3;
  52'b000000000000001?????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff2;
  52'b0000000000000001????????????????????????????????????: frac_bin_val[12:0] = 13'h1ff1;
  52'b00000000000000001???????????????????????????????????: frac_bin_val[12:0] = 13'h1ff0;
  52'b000000000000000001??????????????????????????????????: frac_bin_val[12:0] = 13'h1fef;
  52'b0000000000000000001?????????????????????????????????: frac_bin_val[12:0] = 13'h1fee;
  52'b00000000000000000001????????????????????????????????: frac_bin_val[12:0] = 13'h1fed;
  52'b000000000000000000001???????????????????????????????: frac_bin_val[12:0] = 13'h1fec;
  52'b0000000000000000000001??????????????????????????????: frac_bin_val[12:0] = 13'h1feb;
  52'b00000000000000000000001?????????????????????????????: frac_bin_val[12:0] = 13'h1fea;
  52'b000000000000000000000001????????????????????????????: frac_bin_val[12:0] = 13'h1fe9;
  52'b0000000000000000000000001???????????????????????????: frac_bin_val[12:0] = 13'h1fe8;
  52'b00000000000000000000000001??????????????????????????: frac_bin_val[12:0] = 13'h1fe7;
  52'b000000000000000000000000001?????????????????????????: frac_bin_val[12:0] = 13'h1fe6;
  52'b0000000000000000000000000001????????????????????????: frac_bin_val[12:0] = 13'h1fe5;
  52'b00000000000000000000000000001???????????????????????: frac_bin_val[12:0] = 13'h1fe4;
  52'b000000000000000000000000000001??????????????????????: frac_bin_val[12:0] = 13'h1fe3;
  52'b0000000000000000000000000000001?????????????????????: frac_bin_val[12:0] = 13'h1fe2;
  52'b00000000000000000000000000000001????????????????????: frac_bin_val[12:0] = 13'h1fe1;
  52'b000000000000000000000000000000001???????????????????: frac_bin_val[12:0] = 13'h1fe0;
  52'b0000000000000000000000000000000001??????????????????: frac_bin_val[12:0] = 13'h1fdf;
  52'b00000000000000000000000000000000001?????????????????: frac_bin_val[12:0] = 13'h1fde;
  52'b000000000000000000000000000000000001????????????????: frac_bin_val[12:0] = 13'h1fdd;
  52'b0000000000000000000000000000000000001???????????????: frac_bin_val[12:0] = 13'h1fdc;
  52'b00000000000000000000000000000000000001??????????????: frac_bin_val[12:0] = 13'h1fdb;
  52'b000000000000000000000000000000000000001?????????????: frac_bin_val[12:0] = 13'h1fda;
  52'b0000000000000000000000000000000000000001????????????: frac_bin_val[12:0] = 13'h1fd9;
  52'b00000000000000000000000000000000000000001???????????: frac_bin_val[12:0] = 13'h1fd8;
  52'b000000000000000000000000000000000000000001??????????: frac_bin_val[12:0] = 13'h1fd7;
  52'b0000000000000000000000000000000000000000001?????????: frac_bin_val[12:0] = 13'h1fd6;
  52'b00000000000000000000000000000000000000000001????????: frac_bin_val[12:0] = 13'h1fd5;
  52'b000000000000000000000000000000000000000000001???????: frac_bin_val[12:0] = 13'h1fd4;
  52'b0000000000000000000000000000000000000000000001??????: frac_bin_val[12:0] = 13'h1fd3;
  52'b00000000000000000000000000000000000000000000001?????: frac_bin_val[12:0] = 13'h1fd2;
  52'b000000000000000000000000000000000000000000000001????: frac_bin_val[12:0] = 13'h1fd1;
  52'b0000000000000000000000000000000000000000000000001???: frac_bin_val[12:0] = 13'h1fd0;
  52'b00000000000000000000000000000000000000000000000001??: frac_bin_val[12:0] = 13'h1fcf;
  52'b000000000000000000000000000000000000000000000000001?: frac_bin_val[12:0] = 13'h1fce;
  52'b0000000000000000000000000000000000000000000000000001: frac_bin_val[12:0] = 13'h1fcd;
  52'b0000000000000000000000000000000000000000000000000000: frac_bin_val[12:0] = 13'h1fcc;
  default                                                 : frac_bin_val[12:0] = 13'h000;
endcase
// &CombEnd; @85
end

// &CombBeg; @87
always @( frac_num[51:0])
begin
casez(frac_num[51:0])
  52'b1???????????????????????????????????????????????????: fanc_shift_num[51:0] = frac_num[51:0];
  52'b01??????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[50:0],1'b0};
  52'b001?????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[49:0],2'b0};
  52'b0001????????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[48:0],3'b0};
  52'b00001???????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[47:0],4'b0};
  52'b000001??????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[46:0],5'b0};
  52'b0000001?????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[45:0],6'b0};
  52'b00000001????????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[44:0],7'b0};
  52'b000000001???????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[43:0],8'b0};
  52'b0000000001??????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[42:0],9'b0};
  52'b00000000001?????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[41:0],10'b0};
  52'b000000000001????????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[40:0],11'b0};
  52'b0000000000001???????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[39:0],12'b0};
  52'b00000000000001??????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[38:0],13'b0};
  52'b000000000000001?????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[37:0],14'b0};
  52'b0000000000000001????????????????????????????????????: fanc_shift_num[51:0] = {frac_num[36:0],15'b0};
  52'b00000000000000001???????????????????????????????????: fanc_shift_num[51:0] = {frac_num[35:0],16'b0};
  52'b000000000000000001??????????????????????????????????: fanc_shift_num[51:0] = {frac_num[34:0],17'b0};
  52'b0000000000000000001?????????????????????????????????: fanc_shift_num[51:0] = {frac_num[33:0],18'b0};
  52'b00000000000000000001????????????????????????????????: fanc_shift_num[51:0] = {frac_num[32:0],19'b0};
  52'b000000000000000000001???????????????????????????????: fanc_shift_num[51:0] = {frac_num[31:0],20'b0};
  52'b0000000000000000000001??????????????????????????????: fanc_shift_num[51:0] = {frac_num[30:0],21'b0};
  52'b00000000000000000000001?????????????????????????????: fanc_shift_num[51:0] = {frac_num[29:0],22'b0};
  52'b000000000000000000000001????????????????????????????: fanc_shift_num[51:0] = {frac_num[28:0],23'b0};
  52'b0000000000000000000000001???????????????????????????: fanc_shift_num[51:0] = {frac_num[27:0],24'b0};
  52'b00000000000000000000000001??????????????????????????: fanc_shift_num[51:0] = {frac_num[26:0],25'b0};
  52'b000000000000000000000000001?????????????????????????: fanc_shift_num[51:0] = {frac_num[25:0],26'b0};
  52'b0000000000000000000000000001????????????????????????: fanc_shift_num[51:0] = {frac_num[24:0],27'b0};
  52'b00000000000000000000000000001???????????????????????: fanc_shift_num[51:0] = {frac_num[23:0],28'b0};
  52'b000000000000000000000000000001??????????????????????: fanc_shift_num[51:0] = {frac_num[22:0],29'b0};
  52'b0000000000000000000000000000001?????????????????????: fanc_shift_num[51:0] = {frac_num[21:0],30'b0};
  52'b00000000000000000000000000000001????????????????????: fanc_shift_num[51:0] = {frac_num[20:0],31'b0};
  52'b000000000000000000000000000000001???????????????????: fanc_shift_num[51:0] = {frac_num[19:0],32'b0};
  52'b0000000000000000000000000000000001??????????????????: fanc_shift_num[51:0] = {frac_num[18:0],33'b0};
  52'b00000000000000000000000000000000001?????????????????: fanc_shift_num[51:0] = {frac_num[17:0],34'b0};
  52'b000000000000000000000000000000000001????????????????: fanc_shift_num[51:0] = {frac_num[16:0],35'b0};
  52'b0000000000000000000000000000000000001???????????????: fanc_shift_num[51:0] = {frac_num[15:0],36'b0};
  52'b00000000000000000000000000000000000001??????????????: fanc_shift_num[51:0] = {frac_num[14:0],37'b0};
  52'b000000000000000000000000000000000000001?????????????: fanc_shift_num[51:0] = {frac_num[13:0],38'b0};
  52'b0000000000000000000000000000000000000001????????????: fanc_shift_num[51:0] = {frac_num[12:0],39'b0};
  52'b00000000000000000000000000000000000000001???????????: fanc_shift_num[51:0] = {frac_num[11:0],40'b0};
  52'b000000000000000000000000000000000000000001??????????: fanc_shift_num[51:0] = {frac_num[10:0],41'b0};
  52'b0000000000000000000000000000000000000000001?????????: fanc_shift_num[51:0] = {frac_num[9:0],42'b0};
  52'b00000000000000000000000000000000000000000001????????: fanc_shift_num[51:0] = {frac_num[8:0],43'b0};
  52'b000000000000000000000000000000000000000000001???????: fanc_shift_num[51:0] = {frac_num[7:0],44'b0};
  52'b0000000000000000000000000000000000000000000001??????: fanc_shift_num[51:0] = {frac_num[6:0],45'b0};
  52'b00000000000000000000000000000000000000000000001?????: fanc_shift_num[51:0] = {frac_num[5:0],46'b0};
  52'b000000000000000000000000000000000000000000000001????: fanc_shift_num[51:0] = {frac_num[4:0],47'b0};
  52'b0000000000000000000000000000000000000000000000001???: fanc_shift_num[51:0] = {frac_num[3:0],48'b0};
  52'b00000000000000000000000000000000000000000000000001??: fanc_shift_num[51:0] = {frac_num[2:0],49'b0};
  52'b000000000000000000000000000000000000000000000000001?: fanc_shift_num[51:0] = {frac_num[1:0],50'b0};
  52'b0000000000000000000000000000000000000000000000000001: fanc_shift_num[51:0] = {frac_num[0:0],51'b0};
  52'b0000000000000000000000000000000000000000000000000000: fanc_shift_num[51:0] = {52'b0};
  default                                                 : fanc_shift_num[51:0] = {52'b0};
endcase
// &CombEnd; @144
end

// &ModuleEnd; @146
endmodule


// ----- 8< ----- FILE "./pa_fdsu_pack_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_pack_single(
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_yy_expnt_rst,
  fdsu_yy_of,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_potnt_of,
  fdsu_yy_potnt_uf,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rslt_denorm,
  fdsu_yy_uf,
  fdsu_yy_wb_freg
);

// &Ports; @24
input           fdsu_ex4_denorm_to_tiny_frac; 
input   [25:0]  fdsu_ex4_frac;               
input           fdsu_ex4_nx;                 
input   [1 :0]  fdsu_ex4_potnt_norm;         
input           fdsu_ex4_result_nor;         
input   [9 :0]  fdsu_yy_expnt_rst;           
input           fdsu_yy_of;                  
input           fdsu_yy_of_rm_lfn;           
input           fdsu_yy_potnt_of;            
input           fdsu_yy_potnt_uf;            
input           fdsu_yy_result_inf;          
input           fdsu_yy_result_lfn;          
input           fdsu_yy_result_sign;         
input           fdsu_yy_rslt_denorm;         
input           fdsu_yy_uf;                  
input   [4 :0]  fdsu_yy_wb_freg;             
output  [31:0]  fdsu_frbus_data;             
output  [4 :0]  fdsu_frbus_fflags;           
output  [4 :0]  fdsu_frbus_freg;             

// &Regs; @25
reg     [22:0]  ex4_frac_23;                 
reg     [31:0]  ex4_result;                  
reg     [22:0]  ex4_single_denorm_frac;      
reg     [9 :0]  expnt_add_op1;               

// &Wires; @26
wire            ex4_cor_nx;                  
wire            ex4_cor_uf;                  
wire            ex4_denorm_potnt_norm;       
wire    [31:0]  ex4_denorm_result;           
wire    [9 :0]  ex4_expnt_rst;               
wire    [4 :0]  ex4_expt;                    
wire            ex4_final_rst_norm;          
wire    [25:0]  ex4_frac;                    
wire            ex4_of_plus;                 
wire            ex4_result_inf;              
wire            ex4_result_lfn;              
wire            ex4_rslt_denorm;             
wire    [31:0]  ex4_rst_inf;                 
wire    [31:0]  ex4_rst_lfn;                 
wire            ex4_rst_nor;                 
wire    [31:0]  ex4_rst_norm;                
wire            ex4_uf_plus;                 
wire            fdsu_ex4_denorm_to_tiny_frac; 
wire            fdsu_ex4_dz;                 
wire    [9 :0]  fdsu_ex4_expnt_rst;          
wire    [25:0]  fdsu_ex4_frac;               
wire            fdsu_ex4_nv;                 
wire            fdsu_ex4_nx;                 
wire            fdsu_ex4_of;                 
wire            fdsu_ex4_of_rst_lfn;         
wire    [1 :0]  fdsu_ex4_potnt_norm;         
wire            fdsu_ex4_potnt_of;           
wire            fdsu_ex4_potnt_uf;           
wire            fdsu_ex4_result_inf;         
wire            fdsu_ex4_result_lfn;         
wire            fdsu_ex4_result_nor;         
wire            fdsu_ex4_result_sign;        
wire            fdsu_ex4_rslt_denorm;        
wire            fdsu_ex4_uf;                 
wire    [31:0]  fdsu_frbus_data;             
wire    [4 :0]  fdsu_frbus_fflags;           
wire    [4 :0]  fdsu_frbus_freg;             
wire    [9 :0]  fdsu_yy_expnt_rst;           
wire            fdsu_yy_of;                  
wire            fdsu_yy_of_rm_lfn;           
wire            fdsu_yy_potnt_of;            
wire            fdsu_yy_potnt_uf;            
wire            fdsu_yy_result_inf;          
wire            fdsu_yy_result_lfn;          
wire            fdsu_yy_result_sign;         
wire            fdsu_yy_rslt_denorm;         
wire            fdsu_yy_uf;                  
wire    [4 :0]  fdsu_yy_wb_freg;             


assign fdsu_ex4_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex4_of_rst_lfn      = fdsu_yy_of_rm_lfn;
assign fdsu_ex4_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex4_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex4_of              = fdsu_yy_of;
assign fdsu_ex4_uf              = fdsu_yy_uf;
assign fdsu_ex4_potnt_of        = fdsu_yy_potnt_of;
assign fdsu_ex4_potnt_uf        = fdsu_yy_potnt_uf;
assign fdsu_ex4_nv              = 1'b0;
assign fdsu_ex4_dz              = 1'b0;
assign fdsu_ex4_expnt_rst[9:0] = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex4_rslt_denorm     = fdsu_yy_rslt_denorm;
//============================EX4 STAGE=====================
assign ex4_frac[25:0] = fdsu_ex4_frac[25:0];
//exponent adder
// &CombBeg; @43
always @( ex4_frac[25:24])
begin
casez(ex4_frac[25:24])
  2'b00   : expnt_add_op1[9:0] = 10'h1ff;  //the expnt sub 1
  2'b01   : expnt_add_op1[9:0] = 10'h0;    //the expnt stay the origi
  2'b1?   : expnt_add_op1[9:0] = 10'h1;    // the exptn add 1
  default : expnt_add_op1[9:0] = 10'b0;  
endcase
// &CombEnd; @50
end
assign ex4_expnt_rst[9:0] = fdsu_ex4_expnt_rst[9:0] + 
                             expnt_add_op1[9:0];

//==========================Result Pack=====================

// result denormal pack 
// shift to the denormal number
// &CombBeg; @58
always @( fdsu_ex4_expnt_rst[9:0]
       or fdsu_ex4_denorm_to_tiny_frac
       or ex4_frac[25:1])
begin
case(fdsu_ex4_expnt_rst[9:0])
  10'h1:   ex4_single_denorm_frac[22:0] = {      ex4_frac[23:1]}; //-1022 1
  10'h0:   ex4_single_denorm_frac[22:0] = {      ex4_frac[24:2]}; //-1023 0
  10'h3ff:ex4_single_denorm_frac[22:0] = {      ex4_frac[25:3]}; //-1024 -1
  10'h3fe:ex4_single_denorm_frac[22:0] = {1'b0, ex4_frac[25:4]}; //-1025 -2
  10'h3fd:ex4_single_denorm_frac[22:0] = {2'b0, ex4_frac[25:5]}; //-1026 -3
  10'h3fc:ex4_single_denorm_frac[22:0] = {3'b0, ex4_frac[25:6]}; //-1027 -4
  10'h3fb:ex4_single_denorm_frac[22:0] = {4'b0, ex4_frac[25:7]}; //-1028 -5
  10'h3fa:ex4_single_denorm_frac[22:0] = {5'b0, ex4_frac[25:8]}; //-1029 -6
  10'h3f9:ex4_single_denorm_frac[22:0] = {6'b0, ex4_frac[25:9]}; //-1030 -7
  10'h3f8:ex4_single_denorm_frac[22:0] = {7'b0, ex4_frac[25:10]}; //-1031 -8
  10'h3f7:ex4_single_denorm_frac[22:0] = {8'b0, ex4_frac[25:11]}; //-1032 -9
  10'h3f6:ex4_single_denorm_frac[22:0] = {9'b0, ex4_frac[25:12]}; //-1033 -10
  10'h3f5:ex4_single_denorm_frac[22:0] = {10'b0,ex4_frac[25:13]}; //-1034 -11
  10'h3f4:ex4_single_denorm_frac[22:0] = {11'b0,ex4_frac[25:14]}; //-1035 -12
  10'h3f3:ex4_single_denorm_frac[22:0] = {12'b0,ex4_frac[25:15]}; //-1036 -13  
  10'h3f2:ex4_single_denorm_frac[22:0] = {13'b0,ex4_frac[25:16]}; // -1037
  10'h3f1:ex4_single_denorm_frac[22:0] = {14'b0,ex4_frac[25:17]}; //-1038
  10'h3f0:ex4_single_denorm_frac[22:0] = {15'b0,ex4_frac[25:18]}; //-1039
  10'h3ef:ex4_single_denorm_frac[22:0] = {16'b0,ex4_frac[25:19]}; //-1040
  10'h3ee:ex4_single_denorm_frac[22:0] = {17'b0,ex4_frac[25:20]}; //-1041
  10'h3ed:ex4_single_denorm_frac[22:0] = {18'b0,ex4_frac[25:21]}; //-1042
  10'h3ec:ex4_single_denorm_frac[22:0] = {19'b0,ex4_frac[25:22]}; //-1043
  10'h3eb:ex4_single_denorm_frac[22:0] = {20'b0,ex4_frac[25:23]}; //-1044
  10'h3ea:ex4_single_denorm_frac[22:0] = {21'b0,ex4_frac[25:24]}; //-1044
  default :ex4_single_denorm_frac[22:0] = fdsu_ex4_denorm_to_tiny_frac ? 23'b1 : 23'b0; //-1045
endcase                                                                  
// &CombEnd; @86
end
//here when denormal number round to add1, it will become normal number
assign ex4_denorm_potnt_norm    = (fdsu_ex4_potnt_norm[1] && ex4_frac[24]) || 
                                  (fdsu_ex4_potnt_norm[0] && ex4_frac[25]) ;
assign ex4_rslt_denorm          = fdsu_ex4_rslt_denorm && !ex4_denorm_potnt_norm;
assign ex4_denorm_result[31:0]  = {fdsu_ex4_result_sign,
                                        8'h0,ex4_single_denorm_frac[22:0]};
                                   
                                                              
//ex4 overflow/underflow plus                                 
assign ex4_rst_nor = fdsu_ex4_result_nor;                    
assign ex4_of_plus = fdsu_ex4_potnt_of  && 
                     (|ex4_frac[25:24])  && 
                     ex4_rst_nor;
assign ex4_uf_plus = fdsu_ex4_potnt_uf  && 
                     (~|ex4_frac[25:24]) && 
                     ex4_rst_nor;
//ex4 overflow round result
assign ex4_result_lfn = (ex4_of_plus &&  fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_lfn;
assign ex4_result_inf = (ex4_of_plus && !fdsu_ex4_of_rst_lfn) ||
                        fdsu_ex4_result_inf;
//Special Result Form
// result largest finity number
assign ex4_rst_lfn[31:0]      = {fdsu_ex4_result_sign,8'hfe,{23{1'b1}}};
//result infinity
assign ex4_rst_inf[31:0]  = {fdsu_ex4_result_sign,8'hff,23'b0};
//result normal
// &CombBeg; @114
always @( ex4_frac[25:0])
begin
casez(ex4_frac[25:24])
  2'b00   : ex4_frac_23[22:0]  = ex4_frac[22:0];
  2'b01   : ex4_frac_23[22:0]  = ex4_frac[23:1];
  2'b1?   : ex4_frac_23[22:0]  = ex4_frac[24:2];
  default : ex4_frac_23[22:0]  = 23'b0;
endcase
// &CombEnd; @121
end
assign ex4_rst_norm[31:0] = {fdsu_ex4_result_sign,
                                  ex4_expnt_rst[7:0],
                                  ex4_frac_23[22:0]};
assign ex4_cor_uf            = (fdsu_ex4_uf || ex4_denorm_potnt_norm || ex4_uf_plus)
                               && fdsu_ex4_nx;
assign ex4_cor_nx            =  fdsu_ex4_nx 
                                || fdsu_ex4_of 
                                || ex4_of_plus;
                                        
assign ex4_expt[4:0]           = {
                                  fdsu_ex4_nv,
                                  fdsu_ex4_dz,
                                  fdsu_ex4_of | ex4_of_plus,
                                  ex4_cor_uf,
                                  ex4_cor_nx};

assign ex4_final_rst_norm      = !ex4_result_inf        &&
                                 !ex4_result_lfn        && 
                                 !ex4_rslt_denorm; 
// &CombBeg; @141
always @( ex4_denorm_result[31:0]
       or ex4_result_lfn
       or ex4_result_inf
       or ex4_final_rst_norm
       or ex4_rst_norm[31:0]
       or ex4_rst_lfn[31:0]
       or ex4_rst_inf[31:0]
       or ex4_rslt_denorm)
begin
case({ex4_rslt_denorm,
      ex4_result_inf,
      ex4_result_lfn,
      ex4_final_rst_norm})
  4'b1000 : ex4_result[31:0]  = ex4_denorm_result[31:0];
  4'b0100 : ex4_result[31:0]  = ex4_rst_inf[31:0];
  4'b0010 : ex4_result[31:0]  = ex4_rst_lfn[31:0];
  4'b0001 : ex4_result[31:0]  = ex4_rst_norm[31:0];
  default   : ex4_result[31:0]  = 32'b0;
endcase
// &CombEnd; @152
end

//==========================================================
//                     Result Generate
//==========================================================
assign fdsu_frbus_freg[4:0]   = fdsu_yy_wb_freg[4:0];
assign fdsu_frbus_data[31:0]  = ex4_result[31:0];
assign fdsu_frbus_fflags[4:0] = ex4_expt[4:0];

// &ModuleEnd; @161
endmodule



// ----- 8< ----- FILE "./pa_fdsu_prepare.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_prepare(
  dp_xx_ex1_rm,
  ex1_div,
  ex1_divisor,
  ex1_expnt_adder_op0,
  ex1_expnt_adder_op1,
  ex1_of_result_lfn,
  ex1_op0_id,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_id_vld,
  ex1_op1_sel,
  ex1_oper_id_expnt,
  ex1_oper_id_expnt_f,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_remainder,
  ex1_result_sign,
  ex1_rm,
  ex1_sqrt,
  fdsu_ex1_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1
);

// &Ports; @24
input   [2 :0]  dp_xx_ex1_rm;            
input           ex1_op0_id;              
input           ex1_op1_id;              
input           ex1_op1_sel;             
input   [12:0]  ex1_oper_id_expnt_f;     
input   [51:0]  ex1_oper_id_frac_f;      
input           fdsu_ex1_sel;            
input   [9 :0]  idu_fpu_ex1_func;        
input   [31:0]  idu_fpu_ex1_srcf0;       
input   [31:0]  idu_fpu_ex1_srcf1;       
output          ex1_div;                 
output  [23:0]  ex1_divisor;             
output  [12:0]  ex1_expnt_adder_op0;     
output  [12:0]  ex1_expnt_adder_op1;     
output          ex1_of_result_lfn;       
output          ex1_op0_sign;            
output          ex1_op1_id_vld;          
output  [12:0]  ex1_oper_id_expnt;       
output  [51:0]  ex1_oper_id_frac;        
output  [31:0]  ex1_remainder;           
output          ex1_result_sign;         
output  [2 :0]  ex1_rm;                  
output          ex1_sqrt;                

// &Regs; @25
reg     [12:0]  ex1_expnt_adder_op1;     
reg             ex1_of_result_lfn;       

// &Wires; @26
wire            div_sign;                
wire    [2 :0]  dp_xx_ex1_rm;            
wire            ex1_div;                 
wire    [52:0]  ex1_div_noid_nor_srt_op0; 
wire    [52:0]  ex1_div_noid_nor_srt_op1; 
wire    [52:0]  ex1_div_nor_srt_op0;     
wire    [52:0]  ex1_div_nor_srt_op1;     
wire    [12:0]  ex1_div_op0_expnt;       
wire    [12:0]  ex1_div_op1_expnt;       
wire    [52:0]  ex1_div_srt_op0;         
wire    [52:0]  ex1_div_srt_op1;         
wire    [23:0]  ex1_divisor;             
wire            ex1_double;              
wire    [12:0]  ex1_expnt_adder_op0;     
wire            ex1_op0_id;              
wire            ex1_op0_id_nor;          
wire            ex1_op0_sign;            
wire            ex1_op1_id;              
wire            ex1_op1_id_nor;          
wire            ex1_op1_id_vld;          
wire            ex1_op1_sel;             
wire            ex1_op1_sign;            
wire    [63:0]  ex1_oper0;               
wire    [51:0]  ex1_oper0_frac;          
wire    [12:0]  ex1_oper0_id_expnt;      
wire    [51:0]  ex1_oper0_id_frac;       
wire    [63:0]  ex1_oper1;               
wire    [51:0]  ex1_oper1_frac;          
wire    [12:0]  ex1_oper1_id_expnt;      
wire    [51:0]  ex1_oper1_id_frac;       
wire    [51:0]  ex1_oper_frac;           
wire    [12:0]  ex1_oper_id_expnt;       
wire    [12:0]  ex1_oper_id_expnt_f;     
wire    [51:0]  ex1_oper_id_frac;        
wire    [51:0]  ex1_oper_id_frac_f;      
wire    [31:0]  ex1_remainder;           
wire            ex1_result_sign;         
wire    [2 :0]  ex1_rm;                  
wire            ex1_single;              
wire            ex1_sqrt;                
wire            ex1_sqrt_expnt_odd;      
wire            ex1_sqrt_op0_expnt_0;    
wire    [12:0]  ex1_sqrt_op1_expnt;      
wire    [52:0]  ex1_sqrt_srt_op0;        
wire            fdsu_ex1_sel;            
wire    [9 :0]  idu_fpu_ex1_func;        
wire    [31:0]  idu_fpu_ex1_srcf0;       
wire    [31:0]  idu_fpu_ex1_srcf1;       
wire    [59:0]  sqrt_remainder;          
wire            sqrt_sign;               


assign ex1_sqrt                    = idu_fpu_ex1_func[0];
assign ex1_div                     = idu_fpu_ex1_func[1];
assign ex1_oper0[63:0]             = {32'b0, idu_fpu_ex1_srcf0[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_oper1[63:0]             = {32'b0, idu_fpu_ex1_srcf1[31:0] & {32{fdsu_ex1_sel}}};
assign ex1_double                  = 1'b0;
assign ex1_single                  = 1'b1;
// &Force("bus", "idu_fpu_ex1_func", 9, 0); @43
assign ex1_op0_id_nor              = ex1_op0_id;
assign ex1_op1_id_nor              = ex1_op1_id;

//Sign bit prepare
assign ex1_op0_sign                = ex1_double && ex1_oper0[63]
                                  || ex1_single && ex1_oper0[31];
assign ex1_op1_sign                = ex1_double && ex1_oper1[63]
                                  || ex1_single && ex1_oper1[31];
assign div_sign                    = ex1_op0_sign ^ ex1_op1_sign;
assign sqrt_sign                   = ex1_op0_sign;
assign ex1_result_sign             = (ex1_div)
                                   ? div_sign
                                   : sqrt_sign;

//=====================find first one=======================
// this is for the denormal number
assign ex1_oper_frac[51:0] = ex1_op1_sel ? ex1_oper1_frac[51:0]
                                         : ex1_oper0_frac[51:0];

// &Instance("pa_fdsu_ff1", "x_frac_expnt"); @63
pa_fdsu_ff1  x_frac_expnt (
  .fanc_shift_num          (ex1_oper_id_frac[51:0] ),
  .frac_bin_val            (ex1_oper_id_expnt[12:0]),
  .frac_num                (ex1_oper_frac[51:0]    )
);

// &Connect(.frac_num(ex1_oper_frac[51:0])); @64
// &Connect(.frac_bin_val(ex1_oper_id_expnt[12:0])); @65
// &Connect(.fanc_shift_num(ex1_oper_id_frac[51:0])); @66
// &Force("output", "ex1_oper_id_expnt"); &Force("bus", "ex1_oper_id_expnt", 12, 0); @67
// &Force("output", "ex1_oper_id_frac"); &Force("bus", "ex1_oper_id_frac", 51, 0); @68

assign ex1_oper0_id_expnt[12:0] = ex1_op1_sel ? ex1_oper_id_expnt_f[12:0]
                                              : ex1_oper_id_expnt[12:0];
assign ex1_oper0_id_frac[51:0]  = ex1_op1_sel ? ex1_oper_id_frac_f[51:0]
                                              : ex1_oper_id_frac[51:0];
assign ex1_oper1_id_expnt[12:0] = ex1_oper_id_expnt[12:0];
assign ex1_oper1_id_frac[51:0]  = ex1_oper_id_frac[51:0];

assign ex1_oper0_frac[51:0] = {52{ex1_double}} & ex1_oper0[51:0]
                            | {52{ex1_single}} & {ex1_oper0[22:0],29'b0};
assign ex1_oper1_frac[51:0] = {52{ex1_double}} & ex1_oper1[51:0]
                            | {52{ex1_single}} & {ex1_oper1[22:0],29'b0};

//=====================exponent add=========================
//exponent number 0
assign ex1_div_op0_expnt[12:0]     = {13{ex1_double}} & {2'b0,ex1_oper0[62:52]}
                                   | {13{ex1_single}} & {5'b0,ex1_oper0[30:23]};
assign ex1_expnt_adder_op0[12:0]   = ex1_op0_id_nor ? ex1_oper0_id_expnt[12:0]
                                                : ex1_div_op0_expnt[12:0];
//exponent number 1
assign ex1_div_op1_expnt[12:0]  = {13{ex1_double}} & {2'b0,ex1_oper1[62:52]}
                                | {13{ex1_single}} & {5'b0,ex1_oper1[30:23]};
assign ex1_sqrt_op1_expnt[12:0] = {13{ex1_double}} & {3'b0,{10{1'b1}}} //'d1023
                                | {13{ex1_single}} & {6'b0,{7{1'b1}}}; //'d127
// &CombBeg; @93
always @( ex1_oper1_id_expnt[12:0]
       or ex1_div
       or ex1_op1_id_nor
       or ex1_sqrt_op1_expnt[12:0]
       or ex1_sqrt
       or ex1_div_op1_expnt[12:0])
begin
case({ex1_div,ex1_sqrt})
  2'b10:   ex1_expnt_adder_op1[12:0] = ex1_op1_id_nor ? ex1_oper1_id_expnt[12:0]
                                                  : ex1_div_op1_expnt[12:0];
  2'b01:   ex1_expnt_adder_op1[12:0] = ex1_sqrt_op1_expnt[12:0];
  default: ex1_expnt_adder_op1[12:0] = 13'b0;
endcase
// &CombEnd; @100
end

//ex1_sqrt_expnt_odd
//fraction will shift left by 1
// adder_op0/1 timing is bad.
// assign ex1_sqrt_expnt_odd          = ex1_expnt_adder_op0[0] ^ ex1_expnt_adder_op1[0];

// sqrt_odd is only used when is sqrt.
assign ex1_sqrt_op0_expnt_0        = ex1_op0_id_nor ? ex1_oper_id_expnt[0]
                                                    : ex1_div_op0_expnt[0];
// ex1_expnt_adder_op1 is always 1'b1, so adder_op0[0] should be 0.
assign ex1_sqrt_expnt_odd          = !ex1_sqrt_op0_expnt_0;

assign ex1_rm[2:0]       = dp_xx_ex1_rm[2:0];
//RNE : Always inc 1 because round to nearest of 1.111...11
//RTZ : Always not inc 1
//RUP : Always not inc 1 when posetive
//RDN : Always not inc 1 when negative
//RMM : Always inc 1 because round to max magnitude
// &CombBeg; @119
always @( ex1_rm[2:0]
       or ex1_result_sign)
begin
case(ex1_rm[2:0])
  3'b000  : ex1_of_result_lfn = 1'b0;
  3'b001  : ex1_of_result_lfn = 1'b1;
  3'b010  : ex1_of_result_lfn = !ex1_result_sign;
  3'b011  : ex1_of_result_lfn = ex1_result_sign;
  3'b100  : ex1_of_result_lfn = 1'b0;
  default: ex1_of_result_lfn = 1'b0;
endcase
// &CombEnd; @128
end

//EX1 Remainder
//div  : 1/8  <= x < 1/4
//sqrt : 1/16 <= x < 1/4
assign ex1_remainder[31:0] = {32{ex1_div }} & {5'b0,ex1_div_srt_op0[52:28],2'b0} |
                             {32{ex1_sqrt}} & sqrt_remainder[59:28];

//EX1 Divisor
//1/2 <= y < 1
assign ex1_divisor[23:0]   = ex1_div_srt_op1[52:29];

//ex1_div_srt_op0
assign ex1_div_srt_op0[52:0]     = ex1_div_nor_srt_op0[52:0];
//ex1_div_srt_op1
assign ex1_div_srt_op1[52:0]     =  ex1_div_nor_srt_op1[52:0];
//ex1_div_nor_srt_op0
assign ex1_div_noid_nor_srt_op0[52:0] = {53{ex1_double}} & {1'b1,ex1_oper0[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper0[22:0],29'b0};
assign ex1_div_nor_srt_op0[52:0] = ex1_op0_id_nor ? {ex1_oper0_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op0[52:0];
//ex1_div_nor_srt_op1
assign ex1_div_noid_nor_srt_op1[52:0] = {53{ex1_double}} & {1'b1,ex1_oper1[51:0]}
                                      | {53{ex1_single}} & {1'b1,ex1_oper1[22:0],29'b0};
assign ex1_div_nor_srt_op1[52:0] = ex1_op1_id_nor ? {ex1_oper1_id_frac[51:0],1'b0}
                                                  : ex1_div_noid_nor_srt_op1[52:0];
//sqrt_remainder
assign sqrt_remainder[59:0]      = (ex1_sqrt_expnt_odd)
                                 ? {5'b0,ex1_sqrt_srt_op0[52:0],2'b0}
                                 : {6'b0,ex1_sqrt_srt_op0[52:0],1'b0};
//ex1_sqrt_srt_op0
assign ex1_sqrt_srt_op0[52:0]    = ex1_div_srt_op0[52:0];

//========================Pipe to EX2=======================
//exponent register cal result
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @173
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @174
// &Force("output", "ex1_double"); @175
// &Force("output", "ex1_expnt_adder_op0"); &Force("bus", "ex1_expnt_adder_op0", 12, 0); @177
// &Force("output", "ex1_expnt_adder_op1"); &Force("bus", "ex1_expnt_adder_op1", 12, 0); @178
// &Force("output", "ex1_result_sign"); @180
// &Force("output", "ex1_div"); @181
// &Force("output", "ex1_sqrt"); @182
// &Force("output", "ex1_rm"); &Force("bus", "ex1_rm", 2, 0); @183
// &Force("output", "ex1_op0_sign"); @184

assign ex1_op1_id_vld = ex1_op1_id_nor && ex1_div;

// &ModuleEnd; @188
endmodule



// ----- 8< ----- FILE "./pa_fdsu_round_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_round_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex3_expnt_adjust_result,
  ex3_frac_final_rst,
  ex3_pipedown,
  ex3_rslt_denorm,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_denorm_to_tiny_frac,
  fdsu_ex4_nx,
  fdsu_ex4_potnt_norm,
  fdsu_ex4_result_nor,
  fdsu_yy_expnt_rst,
  fdsu_yy_result_inf,
  fdsu_yy_result_lfn,
  fdsu_yy_result_sign,
  fdsu_yy_rm,
  fdsu_yy_rslt_denorm,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input           ex3_pipedown;                        
input           fdsu_ex3_id_srt_skip;                
input           fdsu_ex3_rem_sign;                   
input           fdsu_ex3_rem_zero;                   
input   [23:0]  fdsu_ex3_result_denorm_round_add_num; 
input   [9 :0]  fdsu_yy_expnt_rst;                   
input           fdsu_yy_result_inf;                  
input           fdsu_yy_result_lfn;                  
input           fdsu_yy_result_sign;                 
input   [2 :0]  fdsu_yy_rm;                          
input           fdsu_yy_rslt_denorm;                 
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input   [29:0]  total_qt_rt_30;                      
output  [9 :0]  ex3_expnt_adjust_result;             
output  [25:0]  ex3_frac_final_rst;                  
output          ex3_rslt_denorm;                     
output          fdsu_ex4_denorm_to_tiny_frac;        
output          fdsu_ex4_nx;                         
output  [1 :0]  fdsu_ex4_potnt_norm;                 
output          fdsu_ex4_result_nor;                 

// &Regs; @25
reg             denorm_to_tiny_frac;                 
reg             fdsu_ex4_denorm_to_tiny_frac;        
reg             fdsu_ex4_nx;                         
reg     [1 :0]  fdsu_ex4_potnt_norm;                 
reg             fdsu_ex4_result_nor;                 
reg     [25:0]  frac_add1_op1;                       
reg             frac_add_1;                          
reg             frac_orig;                           
reg     [25:0]  frac_sub1_op1;                       
reg             frac_sub_1;                          
reg     [27:0]  qt_result_single_denorm_for_round;   
reg             single_denorm_lst_frac;              

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire            ex3_denorm_eq;                       
wire            ex3_denorm_gr;                       
wire            ex3_denorm_lst_frac;                 
wire            ex3_denorm_nx;                       
wire            ex3_denorm_plus;                     
wire            ex3_denorm_potnt_norm;               
wire            ex3_denorm_zero;                     
wire    [9 :0]  ex3_expnt_adjst;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_nx;                              
wire            ex3_pipe_clk;                        
wire            ex3_pipe_clk_en;                     
wire            ex3_pipedown;                        
wire    [1 :0]  ex3_potnt_norm;                      
wire            ex3_qt_eq;                           
wire            ex3_qt_gr;                           
wire            ex3_qt_sing_lo3_not0;                
wire            ex3_qt_sing_lo4_not0;                
wire            ex3_qt_zero;                         
wire            ex3_rslt_denorm;                     
wire            ex3_rst_eq_1;                        
wire            ex3_rst_nor;                         
wire            ex3_single_denorm_eq;                
wire            ex3_single_denorm_gr;                
wire            ex3_single_denorm_zero;              
wire            ex3_single_low_not_zero;             
wire    [9 :0]  fdsu_ex3_expnt_rst;                  
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex3_result_inf;                 
wire            fdsu_ex3_result_lfn;                 
wire            fdsu_ex3_result_sign;                
wire    [2 :0]  fdsu_ex3_rm;                         
wire            fdsu_ex3_rslt_denorm;                
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            forever_cpuclk;                      
wire    [25:0]  frac_add1_op1_with_denorm;           
wire    [25:0]  frac_add1_rst;                       
wire            frac_denorm_rdn_add_1;               
wire            frac_denorm_rdn_sub_1;               
wire            frac_denorm_rmm_add_1;               
wire            frac_denorm_rne_add_1;               
wire            frac_denorm_rtz_sub_1;               
wire            frac_denorm_rup_add_1;               
wire            frac_denorm_rup_sub_1;               
wire    [25:0]  frac_final_rst;                      
wire            frac_rdn_add_1;                      
wire            frac_rdn_sub_1;                      
wire            frac_rmm_add_1;                      
wire            frac_rne_add_1;                      
wire            frac_rtz_sub_1;                      
wire            frac_rup_add_1;                      
wire            frac_rup_sub_1;                      
wire    [25:0]  frac_sub1_op1_with_denorm;           
wire    [25:0]  frac_sub1_rst;                       
wire            pad_yy_icg_scan_en;                  
wire    [29:0]  total_qt_rt_30;                      


assign fdsu_ex3_result_sign     = fdsu_yy_result_sign;
assign fdsu_ex3_expnt_rst[9:0]  = fdsu_yy_expnt_rst[9:0];
assign fdsu_ex3_result_inf      = fdsu_yy_result_inf;
assign fdsu_ex3_result_lfn      = fdsu_yy_result_lfn;
assign fdsu_ex3_rm[2:0]         = fdsu_yy_rm[2:0];
assign fdsu_ex3_rslt_denorm     = fdsu_yy_rslt_denorm;
//=======================Round Rule=========================
//1/8 <= x < 1/4, 1/2 <= y < 1, => 1/8 < z < 1/2
//q[29:0] represent the fraction part result of quotient, q[29] for 1/2
//Thus the first "1" in 30 bit quotient will be in q[28] or q[27]
//For Single Float
//15 round to get 30 bit quotient, 23+1 bit as valid result, other for round
//if q[28] is 1, q[28:5] as 1.xxxx valid result, [4:0] for round
//if q[28] is 0, q[27:4] as 1.xxxx valid result, [3:0] for round
// &Force("bus","total_qt_rt_30",29,0); @42
assign ex3_qt_sing_lo4_not0 = |total_qt_rt_30[3:0];
assign ex3_qt_sing_lo3_not0 = |total_qt_rt_30[2:0];
//the quotient round bits great than "10000"(ronnd bits 10..0)
assign ex3_qt_gr          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && ex3_qt_sing_lo3_not0;

//the quotient round bits is equal to "10000"(ronnd bits 10..0)
assign ex3_qt_eq          = (total_qt_rt_30[28])
                            ?  total_qt_rt_30[4] && !ex3_qt_sing_lo4_not0
                            :  total_qt_rt_30[3] && !ex3_qt_sing_lo3_not0;
//the quotient round bits is zero
assign ex3_qt_zero        = (total_qt_rt_30[28])
                            ? ~|total_qt_rt_30[4:0]
                            : ~|total_qt_rt_30[3:0];
//quotient is 1.00000..00 need special dealt with in the following
assign ex3_rst_eq_1    = total_qt_rt_30[28] && ~|total_qt_rt_30[27:5];
// for denormal result, first select the quotation num for rounding
//  specially for the result e=-126 and e=-1022,the denorm depends on the
//  MSB of the quotient
assign ex3_denorm_plus       = !total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h382);
assign ex3_denorm_potnt_norm = total_qt_rt_30[28] && (fdsu_ex3_expnt_rst[9:0] == 10'h381);
assign ex3_rslt_denorm            = ex3_denorm_plus || fdsu_ex3_rslt_denorm;
// &Force("output", "ex3_rslt_denorm"); @66

//denomal result, check for rounding further optimization can be done in
//future
// &CombBeg; @70
always @( total_qt_rt_30[28:0]
       or fdsu_ex3_expnt_rst[9:0])
begin
case(fdsu_ex3_expnt_rst[9:0])
  10'h382:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[4:0],23'b0}; //-126 1
                single_denorm_lst_frac =  total_qt_rt_30[5];
			 		end//-1022 1
  10'h381:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[5:0],22'b0}; //-127 0
                single_denorm_lst_frac =  total_qt_rt_30[6];
			 		end//-1022 1
  10'h380:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[6:0],21'b0}; //-128 -1
                single_denorm_lst_frac =  total_qt_rt_30[7];
			 		end//-1022 1
  10'h37f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[7:0],20'b0}; //-129 -2
                single_denorm_lst_frac =  total_qt_rt_30[8];
			 		end//-1022 1
  10'h37e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[8:0],19'b0}; //-130 -3
                single_denorm_lst_frac =  total_qt_rt_30[9];
			 		end//-1022 1
  10'h37d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[9:0],18'b0}; //-131 -4
                single_denorm_lst_frac =  total_qt_rt_30[10];
			 		end//-1022 1
  10'h37c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[10:0],17'b0}; //-132 -5
                single_denorm_lst_frac =  total_qt_rt_30[11];
			 		end//-1022 1
  10'h37b:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[11:0],16'b0}; //-133 -6
                single_denorm_lst_frac =  total_qt_rt_30[12];
			 		end//-1022 1
  10'h37a:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[12:0],15'b0}; //-134 -7
                single_denorm_lst_frac =  total_qt_rt_30[13];
			 		end//-1022 1
  10'h379:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[13:0],14'b0}; //-135 -8
                single_denorm_lst_frac =  total_qt_rt_30[14];
			 		end//-1022 1
  10'h378:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[14:0],13'b0}; //-136 -9
                single_denorm_lst_frac =  total_qt_rt_30[15];
			 		end//-1022 1
  10'h377:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[15:0],12'b0}; //-137 -10
                single_denorm_lst_frac =  total_qt_rt_30[16];
			 		end//-1022 1
  10'h376:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[16:0],11'b0}; //-138 -11
                single_denorm_lst_frac =  total_qt_rt_30[17];
			 		end//-1022 1
  10'h375:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[17:0],10'b0}; //-139 -12
                single_denorm_lst_frac =  total_qt_rt_30[18];
			 		end//-1022 1
  10'h374:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[18:0],9'b0}; //-140 -13
                single_denorm_lst_frac =  total_qt_rt_30[19];
			 		end//-1022 1
  10'h373:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[19:0],8'b0}; // -141
                single_denorm_lst_frac =  total_qt_rt_30[20];
			 		end//-1022 1
  10'h372:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[20:0],7'b0};//-142
                single_denorm_lst_frac =  total_qt_rt_30[21];
			 		end//-1022 1
  10'h371:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[21:0],6'b0};//-143
                single_denorm_lst_frac =  total_qt_rt_30[22];
			 		end//-1022 1
  10'h370:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[22:0],5'b0}; //-144
                single_denorm_lst_frac =  total_qt_rt_30[23];
			 		end//-1022 1
  10'h36f:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[23:0],4'b0}; //-145
                single_denorm_lst_frac =  total_qt_rt_30[24];
			 		end//-1022 1
  10'h36e:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[24:0],3'b0}; //-146
                single_denorm_lst_frac =  total_qt_rt_30[25];
			 		end//-1022 1
  10'h36d:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[25:0],2'b0}; //-147
                single_denorm_lst_frac =  total_qt_rt_30[26];
			 		end//-1022 1
  10'h36c:begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[26:0],1'b0}; //-148
                single_denorm_lst_frac =  total_qt_rt_30[27];
			 		end//-1022 1
  10'h36b: begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[27:0]};
                 single_denorm_lst_frac = total_qt_rt_30[28] ;
						end//-1022 1
  default:  begin qt_result_single_denorm_for_round[27:0] = {total_qt_rt_30[28:1]};
                 single_denorm_lst_frac = 1'b0;
						end//-1022 1
endcase
// &CombEnd; @148
end
//rounding evaluation for single denormalize number
assign ex3_single_denorm_eq      = qt_result_single_denorm_for_round[27]
                                   &&  !ex3_single_low_not_zero;
assign ex3_single_low_not_zero   = |qt_result_single_denorm_for_round[26:0];
assign ex3_single_denorm_gr      = qt_result_single_denorm_for_round[27]
                                   &&  ex3_single_low_not_zero;
assign ex3_single_denorm_zero    = !qt_result_single_denorm_for_round[27]
                                   && !ex3_single_low_not_zero;

//rounding check fo denormalize result
assign ex3_denorm_eq             = ex3_single_denorm_eq;
assign ex3_denorm_gr             = ex3_single_denorm_gr;
assign ex3_denorm_zero           = ex3_single_denorm_zero;
assign ex3_denorm_lst_frac       = single_denorm_lst_frac;
//Different Round Mode with different rounding rule
//Here we call rounding bit as "rb", remainder as "rem"
//RNE :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
//RTZ :
//  1.+1 : Never occur
//  2. 0 : Rest Condition
//  3.-1 : rb=10000 && rem<0
//RDN :
//  1.+1 : Q>0 Never occur   ; Q<0 Rest condition
//  2. 0 : Q>0 Rest condition; Q<0 Rem<0 && rb=0
//  3.-1 : Q>0 Rem<0 && rb=0 ; Q<0 Never occur
//RUP :
//  1.+1 : Q>0 Rest Condition; Q<0 Never occur
//  2. 0 : Q>0 Rem<0 && rb=0 ; Q<0 Rest condition
//  3.-1 : Q>0 Never occur   ; Q<0 Rem<0 && rb=0
//RMM :
//  1.+1 : rb>10000 || rb==10000 && rem>0
//  2. 0 : Rest Condition
//  3.-1 : Never occur
assign frac_rne_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
assign frac_rtz_sub_1 = ex3_qt_zero && fdsu_ex3_rem_sign;
assign frac_rup_add_1 = !fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_qt_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_qt_zero && fdsu_ex3_rem_sign);
assign frac_rmm_add_1 = ex3_qt_gr ||
                       (ex3_qt_eq && !fdsu_ex3_rem_sign);
//denormal result
assign frac_denorm_rne_add_1 = ex3_denorm_gr ||
                               (ex3_denorm_eq &&
                               ((fdsu_ex3_rem_zero &&
                                ex3_denorm_lst_frac) ||
                               (!fdsu_ex3_rem_zero &&
                                !fdsu_ex3_rem_sign)));
assign frac_denorm_rtz_sub_1 = ex3_denorm_zero && fdsu_ex3_rem_sign;
assign frac_denorm_rup_add_1 = !fdsu_ex3_result_sign &&
                               (!ex3_denorm_zero ||
                               (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rup_sub_1 = fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rdn_add_1 = fdsu_ex3_result_sign &&
                       (!ex3_denorm_zero ||
                       (!fdsu_ex3_rem_sign && !fdsu_ex3_rem_zero));
assign frac_denorm_rdn_sub_1 = !fdsu_ex3_result_sign &&
                       (ex3_denorm_zero && fdsu_ex3_rem_sign);
assign frac_denorm_rmm_add_1 = ex3_denorm_gr ||
                       (ex3_denorm_eq && !fdsu_ex3_rem_sign);

//RM select
// &CombBeg; @222
always @( fdsu_ex3_rm[2:0]
       or frac_denorm_rdn_add_1
       or frac_rne_add_1
       or frac_denorm_rdn_sub_1
       or fdsu_ex3_result_sign
       or frac_rup_add_1
       or frac_denorm_rup_sub_1
       or frac_rdn_sub_1
       or frac_rtz_sub_1
       or frac_rdn_add_1
       or fdsu_ex3_id_srt_skip
       or frac_denorm_rtz_sub_1
       or ex3_rslt_denorm
       or frac_rup_sub_1
       or frac_denorm_rmm_add_1
       or frac_denorm_rup_add_1
       or frac_denorm_rne_add_1
       or frac_rmm_add_1)
begin
case(fdsu_ex3_rm[2:0])
  3'b000://round to nearst,ties to even
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rne_add_1 : frac_rne_add_1;
    frac_sub_1          =  1'b0;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rne_add_1 : !frac_rne_add_1;
    denorm_to_tiny_frac =  fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rne_add_1;
  end
  3'b001:// round to 0
  begin
    frac_add_1           =  1'b0;
    frac_sub_1           =  ex3_rslt_denorm ? frac_denorm_rtz_sub_1 : frac_rtz_sub_1;
    frac_orig            =  ex3_rslt_denorm ? !frac_denorm_rtz_sub_1 : !frac_rtz_sub_1;
    denorm_to_tiny_frac  = 1'b0;
  end
  3'b010://round to -inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rdn_add_1 : frac_rdn_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rdn_sub_1 : frac_rdn_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rdn_add_1 && !frac_denorm_rdn_sub_1
                                           : !frac_rdn_add_1 && !frac_rdn_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? fdsu_ex3_result_sign
                                                : frac_denorm_rdn_add_1;
  end
  3'b011://round to +inf
  begin
    frac_add_1          =  ex3_rslt_denorm ? frac_denorm_rup_add_1 : frac_rup_add_1;
    frac_sub_1          =  ex3_rslt_denorm ? frac_denorm_rup_sub_1 : frac_rup_sub_1;
    frac_orig           =  ex3_rslt_denorm ? !frac_denorm_rup_add_1 && !frac_denorm_rup_sub_1
                                           : !frac_rup_add_1 && !frac_rup_sub_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? !fdsu_ex3_result_sign
                                                : frac_denorm_rup_add_1;
  end
  3'b100://round to nearest,ties to max magnitude
  begin
    frac_add_1          = ex3_rslt_denorm ? frac_denorm_rmm_add_1 : frac_rmm_add_1;
    frac_sub_1          = 1'b0;
    frac_orig           = ex3_rslt_denorm ? !frac_denorm_rmm_add_1 : !frac_rmm_add_1;
    denorm_to_tiny_frac = fdsu_ex3_id_srt_skip ? 1'b0 : frac_denorm_rmm_add_1;
  end
  default:
  begin
    frac_add_1          = 1'b0;
    frac_sub_1          = 1'b0;
    frac_orig           = 1'b0;
    denorm_to_tiny_frac = 1'b0;
  end
endcase
// &CombEnd; @271
end
//Add 1 or Sub 1 constant
// &CombBeg; @273
always @( total_qt_rt_30[28])
begin
case(total_qt_rt_30[28])
  1'b0:
  begin
    frac_add1_op1[25:0] = {2'b0,24'b1};
    frac_sub1_op1[25:0] = {2'b11,{24{1'b1}}};
  end
  1'b1:
  begin
    frac_add1_op1[25:0] = {25'b1,1'b0};
    frac_sub1_op1[25:0] = {{25{1'b1}},1'b0};
  end
  default:
  begin
    frac_add1_op1[25:0] = 26'b0;
    frac_sub1_op1[25:0] = 26'b0;
  end
endcase
// &CombEnd; @291
end

//Add 1 or Sub1 final result
//Conner case when quotient is 0.010000...00 and remainder is negative,
//The real quotient is actually 0.00fff..ff,
//The final result will need to sub 1 when
//RN : Never occur
//RP : sign of quotient is -
//RM : sign of quotient is +
assign frac_add1_rst[25:0]             = {1'b0,total_qt_rt_30[28:4]} +
                                         frac_add1_op1_with_denorm[25:0];
assign frac_add1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                  {1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                  frac_add1_op1[25:0];
assign frac_sub1_rst[25:0]             = (ex3_rst_eq_1)
                                       ? {3'b0,{23{1'b1}}}
                                       : {1'b0,total_qt_rt_30[28:4]} +
                                         frac_sub1_op1_with_denorm[25:0] + {25'b0, ex3_rslt_denorm};
assign frac_sub1_op1_with_denorm[25:0] = ex3_rslt_denorm ?
                                ~{1'b0,fdsu_ex3_result_denorm_round_add_num[23:0],1'b0} :
                                frac_sub1_op1[25:0];
assign frac_final_rst[25:0]           = (frac_add1_rst[25:0]         & {26{frac_add_1}}) |
                                        (frac_sub1_rst[25:0]         & {26{frac_sub_1}}) |
                                        ({1'b0,total_qt_rt_30[28:4]} & {26{frac_orig}});

//===============Pipe down signal prepare===================
// assign ex3_rst_nor = !fdsu_ex3_result_zero &&
//                      !fdsu_ex3_result_qnan &&
//                      !fdsu_ex3_result_inf  &&
//                      !fdsu_ex3_result_lfn;
assign ex3_rst_nor = !fdsu_ex3_result_inf  &&
                     !fdsu_ex3_result_lfn;
assign ex3_nx      = ex3_rst_nor &&
                    (!ex3_qt_zero || !fdsu_ex3_rem_zero || ex3_denorm_nx);
assign ex3_denorm_nx = ex3_rslt_denorm && (!ex3_denorm_zero ||  !fdsu_ex3_rem_zero);
//Adjust expnt
//Div:Actural expnt should plus 1 when op0 is id, sub 1 when op1 id
assign ex3_expnt_adjst[9:0] = 10'h7f;

assign ex3_expnt_adjust_result[9:0] = fdsu_ex3_expnt_rst[9:0] +
                                       ex3_expnt_adjst[9:0];
//this information is for the packing, which determin the result is normal
//numer or not;
assign ex3_potnt_norm[1:0]    = {ex3_denorm_plus,ex3_denorm_potnt_norm};
//=======================Pipe to EX4========================
//gate clk
// &Instance("gated_clk_cell","x_ex3_pipe_clk"); @337
gated_clk_cell  x_ex3_pipe_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex3_pipe_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex3_pipe_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @338
//           .clk_out        (ex3_pipe_clk),//Out Clock @339
//           .external_en    (1'b0), @340
//           .global_en      (cp0_yy_clk_en), @341
//           .local_en       (ex3_pipe_clk_en),//Local Condition @342
//           .module_en      (cp0_fpu_icg_en) @343
//         ); @344
assign ex3_pipe_clk_en = ex3_pipedown;

always @(posedge ex3_pipe_clk)
begin
  if(ex3_pipedown)
  begin
    fdsu_ex4_result_nor      <= ex3_rst_nor;
    fdsu_ex4_nx              <= ex3_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= ex3_potnt_norm[1:0];
  end
  else
  begin
    fdsu_ex4_result_nor      <= fdsu_ex4_result_nor;
    fdsu_ex4_nx              <= fdsu_ex4_nx;
    fdsu_ex4_denorm_to_tiny_frac
                              <= fdsu_ex4_denorm_to_tiny_frac;
    fdsu_ex4_potnt_norm[1:0] <= fdsu_ex4_potnt_norm[1:0];
  end
end

// ex3_frac Pipedown to ex4 use srt_divisor.
assign ex3_frac_final_rst[25:0] = frac_final_rst[25:0];
// &Force("output","fdsu_ex4_result_nor"); @397
// &Force("output","fdsu_ex4_nx"); @398
// &Force("output","fdsu_ex4_denorm_to_tiny_frac"); @399
// &Force("output","fdsu_ex4_potnt_norm"); @400


// &ModuleEnd; @403
endmodule



// ----- 8< ----- FILE "./pa_fdsu_special.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_special(
  cp0_fpu_xx_dqnan,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex1_div,
  ex1_op0_id,
  ex1_op0_norm,
  ex1_op0_sign,
  ex1_op1_id,
  ex1_op1_norm,
  ex1_result_sign,
  ex1_sqrt,
  ex1_srt_skip,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign
);

// &Ports; @24
input          cp0_fpu_xx_dqnan;         
input   [2:0]  dp_xx_ex1_cnan;           
input   [2:0]  dp_xx_ex1_id;             
input   [2:0]  dp_xx_ex1_inf;            
input   [2:0]  dp_xx_ex1_qnan;           
input   [2:0]  dp_xx_ex1_snan;           
input   [2:0]  dp_xx_ex1_zero;           
input          ex1_div;                  
input          ex1_op0_sign;             
input          ex1_result_sign;          
input          ex1_sqrt;                 
output         ex1_op0_id;               
output         ex1_op0_norm;             
output         ex1_op1_id;               
output         ex1_op1_norm;             
output         ex1_srt_skip;             
output  [4:0]  fdsu_fpu_ex1_fflags;      
output  [7:0]  fdsu_fpu_ex1_special_sel; 
output  [3:0]  fdsu_fpu_ex1_special_sign; 

// &Regs; @25
reg            ex1_result_cnan;          
reg            ex1_result_qnan_op0;      
reg            ex1_result_qnan_op1;      

// &Wires; @26
wire           cp0_fpu_xx_dqnan;         
wire    [2:0]  dp_xx_ex1_cnan;           
wire    [2:0]  dp_xx_ex1_id;             
wire    [2:0]  dp_xx_ex1_inf;            
wire    [2:0]  dp_xx_ex1_qnan;           
wire    [2:0]  dp_xx_ex1_snan;           
wire    [2:0]  dp_xx_ex1_zero;           
wire           ex1_div;                  
wire           ex1_div_dz;               
wire           ex1_div_nv;               
wire           ex1_div_rst_inf;          
wire           ex1_div_rst_qnan;         
wire           ex1_div_rst_zero;         
wire           ex1_dz;                   
wire    [4:0]  ex1_fflags;               
wire           ex1_nv;                   
wire           ex1_op0_cnan;             
wire           ex1_op0_id;               
wire           ex1_op0_inf;              
wire           ex1_op0_is_qnan;          
wire           ex1_op0_is_snan;          
wire           ex1_op0_norm;             
wire           ex1_op0_qnan;             
wire           ex1_op0_sign;             
wire           ex1_op0_snan;             
wire           ex1_op0_tt_zero;          
wire           ex1_op0_zero;             
wire           ex1_op1_cnan;             
wire           ex1_op1_id;               
wire           ex1_op1_inf;              
wire           ex1_op1_is_qnan;          
wire           ex1_op1_is_snan;          
wire           ex1_op1_norm;             
wire           ex1_op1_qnan;             
wire           ex1_op1_snan;             
wire           ex1_op1_tt_zero;          
wire           ex1_op1_zero;             
wire           ex1_result_inf;           
wire           ex1_result_lfn;           
wire           ex1_result_qnan;          
wire           ex1_result_sign;          
wire           ex1_result_zero;          
wire           ex1_rst_default_qnan;     
wire    [7:0]  ex1_special_sel;          
wire    [3:0]  ex1_special_sign;         
wire           ex1_sqrt;                 
wire           ex1_sqrt_nv;              
wire           ex1_sqrt_rst_inf;         
wire           ex1_sqrt_rst_qnan;        
wire           ex1_sqrt_rst_zero;        
wire           ex1_srt_skip;             
wire    [4:0]  fdsu_fpu_ex1_fflags;      
wire    [7:0]  fdsu_fpu_ex1_special_sel; 
wire    [3:0]  fdsu_fpu_ex1_special_sign; 


//infinity number
// &Force("bus", "dp_xx_ex1_inf", 2, 0); @29
assign  ex1_op0_inf                = dp_xx_ex1_inf[0];
assign  ex1_op1_inf                = dp_xx_ex1_inf[1];

//zero
// &Force("bus", "dp_xx_ex1_zero", 2, 0); @34
assign ex1_op0_zero                = dp_xx_ex1_zero[0];
assign ex1_op1_zero                = dp_xx_ex1_zero[1];

//denormalize number
// &Force("bus", "dp_xx_ex1_id", 2, 0); @39
assign ex1_op0_id                  = dp_xx_ex1_id[0];
assign ex1_op1_id                  = dp_xx_ex1_id[1];

//cNaN
// &Force("bus", "dp_xx_ex1_cnan", 2, 0); @44
assign ex1_op0_cnan                = dp_xx_ex1_cnan[0];
assign ex1_op1_cnan                = dp_xx_ex1_cnan[1];

//sNaN
// &Force("bus", "dp_xx_ex1_snan", 2, 0); @49
assign ex1_op0_snan                = dp_xx_ex1_snan[0];
assign ex1_op1_snan                = dp_xx_ex1_snan[1];

//qNaN
// &Force("bus", "dp_xx_ex1_qnan", 2, 0); @54
assign ex1_op0_qnan                = dp_xx_ex1_qnan[0];
assign ex1_op1_qnan                = dp_xx_ex1_qnan[1];


//======================EX1 expt detect=====================
//ex1_id_detect
//any opration is zero
// no input denormalize exception anymore
//
//ex1_nv_detect
//div_nv
//  1.any operation is sNaN
//  2.0/0(include DN flush to zero)
//  3.inf/inf
//sqrt_nv
//  1.any operation is sNaN
//  2.operation sign is 1 && operation is not zero/qNaN
assign ex1_nv      = ex1_div  && ex1_div_nv  ||
                     ex1_sqrt && ex1_sqrt_nv;
//ex1_div_nv
assign ex1_div_nv  = ex1_op0_snan ||
                     ex1_op1_snan ||
                    (ex1_op0_tt_zero && ex1_op1_tt_zero)||
                    (ex1_op0_inf && ex1_op1_inf);
assign ex1_op0_tt_zero = ex1_op0_zero;
assign ex1_op1_tt_zero = ex1_op1_zero;
//ex1_sqrt_nv
assign ex1_sqrt_nv = ex1_op0_snan ||
                     ex1_op0_sign &&
                    (ex1_op0_norm ||
                     ex1_op0_inf );

// This 'norm' also include denorm.
assign ex1_op0_norm = !ex1_op0_inf && !ex1_op0_zero && !ex1_op0_snan && !ex1_op0_qnan && !ex1_op0_cnan;
assign ex1_op1_norm = !ex1_op1_inf && !ex1_op1_zero && !ex1_op1_snan && !ex1_op1_qnan && !ex1_op1_cnan;

//ex1_of_detect
//div_of
//  1.only detect id overflow case
//assign ex1_of      = ex1_div && ex1_div_of;
//assign ex1_div_of  = ex1_op1_id_fm1 &&
//                     ex1_op0_norm &&
//                     ex1_div_id_of;
//
////ex1_uf_detect
////div_uf
////  1.only detect id underflow case
//assign ex1_uf      = ex1_div && ex1_div_uf;
//assign ex1_div_uf  = ex1_op0_id &&
//                     ex1_op1_norm &&
//                     ex1_div_id_uf;
//ex1_dz_detect
//div_dz
//  1.op0 is normal && op1 zero
assign ex1_dz      = ex1_div && ex1_div_dz;
assign ex1_div_dz  = ex1_op1_tt_zero && ex1_op0_norm;

//===================special cal result=====================
//ex1 result is zero
//div_zero
//  1.op0 is zero && op1 is normal
//  2.op0 is zero/normal && op1 is inf
//sqrt_zero
//  1.op0 is zero
assign ex1_result_zero   = ex1_div_rst_zero  && ex1_div  ||
                           ex1_sqrt_rst_zero && ex1_sqrt;
assign ex1_div_rst_zero  = (ex1_op0_tt_zero && ex1_op1_norm ) ||
                           // (!ex1_expnt0_max && !ex1_op0_cnan && ex1_op1_inf);
                           (!ex1_op0_inf && !ex1_op0_qnan && !ex1_op0_snan && !ex1_op0_cnan && ex1_op1_inf);
assign ex1_sqrt_rst_zero = ex1_op0_tt_zero;

//ex1 result is qNaN
//ex1_nv
//div_qnan
//  1.op0 is qnan || op1 is qnan
//sqrt_qnan
//  1.op0 is qnan
assign ex1_result_qnan   = ex1_div_rst_qnan  && ex1_div  ||
                           ex1_sqrt_rst_qnan && ex1_sqrt ||
                           ex1_nv;
assign ex1_div_rst_qnan  = ex1_op0_qnan ||
                           ex1_op1_qnan;
assign ex1_sqrt_rst_qnan = ex1_op0_qnan;

//ex1_rst_default_qnan
//0/0, inf/inf, sqrt negative should get default qNaN
assign ex1_rst_default_qnan = (ex1_div && ex1_op0_zero && ex1_op1_zero) ||
                              (ex1_div && ex1_op0_inf  && ex1_op1_inf)  ||
                              (ex1_sqrt&& ex1_op0_sign && (ex1_op0_norm || ex1_op0_inf));

//ex1 result is inf
//ex1_dz
//
//div_inf
//  1.op0 is inf && op1 is normal/zero
//sqrt_inf
//  1.op0 is inf
assign ex1_result_inf    = ex1_div_rst_inf  && ex1_div  ||
                           ex1_sqrt_rst_inf && ex1_sqrt ||
                           ex1_dz ;
// assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_expnt1_max && !ex1_op1_cnan;
assign ex1_div_rst_inf   = ex1_op0_inf && !ex1_op1_inf && !ex1_op1_qnan && !ex1_op1_snan && !ex1_op1_cnan;
assign ex1_sqrt_rst_inf  = ex1_op0_inf && !ex1_op0_sign;

//ex1 result is lfn
//ex1_of && round result toward not inc 1
assign ex1_result_lfn = 1'b0;

//Default_qnan/Standard_qnan Select
assign ex1_op0_is_snan      = ex1_op0_snan;
assign ex1_op1_is_snan      = ex1_op1_snan && ex1_div;
assign ex1_op0_is_qnan      = ex1_op0_qnan;
assign ex1_op1_is_qnan      = ex1_op1_qnan && ex1_div;

// &CombBeg; @169
always @( ex1_op0_is_snan
       or ex1_op0_cnan
       or ex1_result_qnan
       or ex1_op0_is_qnan
       or ex1_rst_default_qnan
       or cp0_fpu_xx_dqnan
       or ex1_op1_cnan
       or ex1_op1_is_qnan
       or ex1_op1_is_snan)
begin
if(ex1_rst_default_qnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
else if(ex1_op0_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op1_is_snan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan;
  ex1_result_cnan      = 1'b0;
end
else if(ex1_op0_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = ex1_result_qnan && !ex1_op0_cnan;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op0_cnan;
end
else if(ex1_op1_is_qnan && cp0_fpu_xx_dqnan)
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = ex1_result_qnan && !ex1_op1_cnan;
  ex1_result_cnan      = ex1_result_qnan &&  ex1_op1_cnan;
end
else
begin
  ex1_result_qnan_op0  = 1'b0;
  ex1_result_qnan_op1  = 1'b0;
  ex1_result_cnan      = ex1_result_qnan;
end
// &CombEnd; @206
end


//Special result should skip SRT logic
assign ex1_srt_skip = ex1_result_zero ||
                      ex1_result_qnan ||
                      ex1_result_lfn  ||
                      ex1_result_inf;
// fflags:
// NV, DZ, OF, UF, NX
assign ex1_fflags[4:0] = {ex1_nv, ex1_dz, 3'b0};
// Special Sel[7:0]:
// qnan_src2, qnan_src1, qnan_src0, cnan, lfn, inf, zero, src2
assign ex1_special_sel[7:0] = {1'b0, ex1_result_qnan_op1, ex1_result_qnan_op0,
                               ex1_result_cnan, ex1_result_lfn, ex1_result_inf,
                               ex1_result_zero, 1'b0};
// Special Sign[3:0]
// lfn, inf, zero, src2
assign ex1_special_sign[3:0] = {ex1_result_sign, ex1_result_sign, ex1_result_sign, 1'b0};

//==========================================================
//                      Output Signal
//==========================================================
assign fdsu_fpu_ex1_fflags[4:0]       = ex1_fflags[4:0];
assign fdsu_fpu_ex1_special_sel[7:0]  = ex1_special_sel[7:0];
assign fdsu_fpu_ex1_special_sign[3:0] = ex1_special_sign[3:0];

// &Force("output", "ex1_op0_norm"); @233
// &Force("output", "ex1_op1_norm"); @234

// &ModuleEnd; @236
endmodule



// ----- 8< ----- FILE "./pa_fdsu_srt_single.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_srt_single(
  cp0_fpu_icg_en,
  cp0_yy_clk_en,
  ex1_divisor,
  ex1_expnt_adder_op1,
  ex1_oper_id_frac,
  ex1_oper_id_frac_f,
  ex1_pipedown,
  ex1_pipedown_gate,
  ex1_remainder,
  ex1_save_op0,
  ex1_save_op0_gate,
  ex2_expnt_adder_op0,
  ex2_of,
  ex2_pipe_clk,
  ex2_pipedown,
  ex2_potnt_of,
  ex2_potnt_uf,
  ex2_result_inf,
  ex2_result_lfn,
  ex2_rslt_denorm,
  ex2_srt_expnt_rst,
  ex2_srt_first_round,
  ex2_uf,
  ex2_uf_srt_skip,
  ex3_frac_final_rst,
  ex3_pipedown,
  fdsu_ex3_id_srt_skip,
  fdsu_ex3_rem_sign,
  fdsu_ex3_rem_zero,
  fdsu_ex3_result_denorm_round_add_num,
  fdsu_ex4_frac,
  fdsu_yy_div,
  fdsu_yy_of_rm_lfn,
  fdsu_yy_op0_norm,
  fdsu_yy_op1_norm,
  fdsu_yy_sqrt,
  forever_cpuclk,
  pad_yy_icg_scan_en,
  srt_remainder_zero,
  srt_sm_on,
  total_qt_rt_30
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_yy_clk_en;                       
input   [23:0]  ex1_divisor;                         
input   [12:0]  ex1_expnt_adder_op1;                 
input   [51:0]  ex1_oper_id_frac;                    
input           ex1_pipedown;                        
input           ex1_pipedown_gate;                   
input   [31:0]  ex1_remainder;                       
input           ex1_save_op0;                        
input           ex1_save_op0_gate;                   
input   [9 :0]  ex2_expnt_adder_op0;                 
input           ex2_pipe_clk;                        
input           ex2_pipedown;                        
input           ex2_srt_first_round;                 
input   [25:0]  ex3_frac_final_rst;                  
input           ex3_pipedown;                        
input           fdsu_yy_div;                         
input           fdsu_yy_of_rm_lfn;                   
input           fdsu_yy_op0_norm;                    
input           fdsu_yy_op1_norm;                    
input           fdsu_yy_sqrt;                        
input           forever_cpuclk;                      
input           pad_yy_icg_scan_en;                  
input           srt_sm_on;                           
output  [51:0]  ex1_oper_id_frac_f;                  
output          ex2_of;                              
output          ex2_potnt_of;                        
output          ex2_potnt_uf;                        
output          ex2_result_inf;                      
output          ex2_result_lfn;                      
output          ex2_rslt_denorm;                     
output  [9 :0]  ex2_srt_expnt_rst;                   
output          ex2_uf;                              
output          ex2_uf_srt_skip;                     
output          fdsu_ex3_id_srt_skip;                
output          fdsu_ex3_rem_sign;                   
output          fdsu_ex3_rem_zero;                   
output  [23:0]  fdsu_ex3_result_denorm_round_add_num; 
output  [25:0]  fdsu_ex4_frac;                       
output          srt_remainder_zero;                  
output  [29:0]  total_qt_rt_30;                      

// &Regs; @25
reg     [31:0]  cur_rem;                             
reg     [7 :0]  digit_bound_1;                       
reg     [7 :0]  digit_bound_2;                       
reg     [23:0]  ex2_result_denorm_round_add_num;     
reg             fdsu_ex3_id_srt_skip;                
reg             fdsu_ex3_rem_sign;                   
reg             fdsu_ex3_rem_zero;                   
reg     [23:0]  fdsu_ex3_result_denorm_round_add_num; 
reg     [29:0]  qt_rt_const_shift_std;               
reg     [7 :0]  qtrt_sel_rem;                        
reg     [31:0]  rem_add1_op1;                        
reg     [31:0]  rem_add2_op1;                        
reg     [25:0]  srt_divisor;                         
reg     [31:0]  srt_remainder;                       
reg     [29:0]  total_qt_rt_30;                      
reg     [29:0]  total_qt_rt_30_next;                 
reg     [29:0]  total_qt_rt_minus_30;                
reg     [29:0]  total_qt_rt_minus_30_next;           

// &Wires; @26
wire    [7 :0]  bound1_cmp_result;                   
wire            bound1_cmp_sign;                     
wire    [7 :0]  bound2_cmp_result;                   
wire            bound2_cmp_sign;                     
wire    [3 :0]  bound_sel;                           
wire            cp0_fpu_icg_en;                      
wire            cp0_yy_clk_en;                       
wire    [31:0]  cur_doub_rem_1;                      
wire    [31:0]  cur_doub_rem_2;                      
wire    [31:0]  cur_rem_1;                           
wire    [31:0]  cur_rem_2;                           
wire    [31:0]  div_qt_1_rem_add_op1;                
wire    [31:0]  div_qt_2_rem_add_op1;                
wire    [31:0]  div_qt_r1_rem_add_op1;               
wire    [31:0]  div_qt_r2_rem_add_op1;               
wire    [23:0]  ex1_divisor;                         
wire            ex1_ex2_pipe_clk;                    
wire            ex1_ex2_pipe_clk_en;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex2_div_of;                          
wire            ex2_div_uf;                          
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire    [9 :0]  ex2_expnt_adder_op1;                 
wire            ex2_expnt_of;                        
wire    [9 :0]  ex2_expnt_result;                    
wire            ex2_expnt_uf;                        
wire            ex2_id_nor_srt_skip;                 
wire            ex2_of;                              
wire            ex2_of_plus;                         
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_of_pre;                    
wire            ex2_potnt_uf;                        
wire            ex2_potnt_uf_pre;                    
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_sqrt_expnt_result;               
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_plus;                         
wire            ex2_uf_srt_skip;                     
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            fdsu_ex2_div;                        
wire    [9 :0]  fdsu_ex2_expnt_rst;                  
wire            fdsu_ex2_of_rm_lfn;                  
wire            fdsu_ex2_op0_norm;                   
wire            fdsu_ex2_op1_norm;                   
wire            fdsu_ex2_result_lfn;                 
wire            fdsu_ex2_sqrt;                       
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_yy_div;                         
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_sqrt;                        
wire            forever_cpuclk;                      
wire            pad_yy_icg_scan_en;                  
wire            qt_clk;                              
wire            qt_clk_en;                           
wire    [29:0]  qt_rt_const_pre_sel_q1;              
wire    [29:0]  qt_rt_const_pre_sel_q2;              
wire    [29:0]  qt_rt_const_q1;                      
wire    [29:0]  qt_rt_const_q2;                      
wire    [29:0]  qt_rt_const_q3;                      
wire    [29:0]  qt_rt_const_shift_std_next;          
wire    [29:0]  qt_rt_mins_const_pre_sel_q1;         
wire    [29:0]  qt_rt_mins_const_pre_sel_q2;         
wire            rem_sign;                            
wire    [31:0]  sqrt_qt_1_rem_add_op1;               
wire    [31:0]  sqrt_qt_2_rem_add_op1;               
wire    [31:0]  sqrt_qt_r1_rem_add_op1;              
wire    [31:0]  sqrt_qt_r2_rem_add_op1;              
wire            srt_div_clk;                         
wire            srt_div_clk_en;                      
wire    [31:0]  srt_remainder_nxt;                   
wire    [31:0]  srt_remainder_shift;                 
wire            srt_remainder_sign;                  
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_pre_sel;                 


assign fdsu_ex2_div             = fdsu_yy_div;
assign fdsu_ex2_sqrt            = fdsu_yy_sqrt;
assign fdsu_ex2_op0_norm        = fdsu_yy_op0_norm;
assign fdsu_ex2_op1_norm        = fdsu_yy_op1_norm;
assign fdsu_ex2_of_rm_lfn       = fdsu_yy_of_rm_lfn;
assign fdsu_ex2_result_lfn      = 1'b0;

//==========================================================
//                    EX2 Expnt Generate
//==========================================================
//expnt0 sub expnt1
assign ex2_expnt_result[9:0] =  ex2_expnt_adder_op0[9:0] -
                                 ex2_expnt_adder_op1[9:0];

//===================sqrt exponent prepare==================
//sqrt exponent prepare
//afert E sub, div E by 2
assign ex2_sqrt_expnt_result[9:0] = {ex2_expnt_result[9],
                                      ex2_expnt_result[9:1]};

assign ex2_srt_expnt_rst[9:0] = (fdsu_ex2_sqrt)
                               ? ex2_sqrt_expnt_result[9:0]
                               : ex2_expnt_result[9:0];
// &Force("output", "ex2_srt_expnt_rst"); &Force("bus", "ex2_srt_expnt_rst", 9, 0); @51
assign fdsu_ex2_expnt_rst[9:0] = ex2_srt_expnt_rst[9:0];


//====================EX2 Expt info=========================
//EX1 only detect of/uf under id condition
//EX2 will deal with other condition

//When input is normal, overflow when E1-E2 > 128/1024
assign ex2_expnt_of = ~fdsu_ex2_expnt_rst[9] && (fdsu_ex2_expnt_rst[8]
                                                      || (fdsu_ex2_expnt_rst[7]  &&
                                                          |fdsu_ex2_expnt_rst[6:0]));
//potential overflow when E1-E2 = 128/1024
assign ex2_potnt_of_pre = ~fdsu_ex2_expnt_rst[9]  &&
                           ~fdsu_ex2_expnt_rst[8]  &&
                            fdsu_ex2_expnt_rst[7]  &&
                          ~|fdsu_ex2_expnt_rst[6:0];
assign ex2_potnt_of      = ex2_potnt_of_pre &&
                           fdsu_ex2_op0_norm &&
                           fdsu_ex2_op1_norm &&
                           fdsu_ex2_div;

//When input is normal, underflow when E1-E2 <= -127/-1023
assign ex2_expnt_uf = fdsu_ex2_expnt_rst[9] &&(fdsu_ex2_expnt_rst[8:0] <= 9'h181);
//potential underflow when E1-E2 = -126/-1022
assign ex2_potnt_uf_pre = &fdsu_ex2_expnt_rst[9:7]   &&
                          ~|fdsu_ex2_expnt_rst[6:2]   &&
                            fdsu_ex2_expnt_rst[1]     &&
                           !fdsu_ex2_expnt_rst[0];
assign ex2_potnt_uf      = (ex2_potnt_uf_pre &&
                            fdsu_ex2_op0_norm &&
                            fdsu_ex2_op1_norm &&
                            fdsu_ex2_div)     ||
                           (ex2_potnt_uf_pre   &&
                            fdsu_ex2_op0_norm);

//========================EX2 Overflow======================
//ex2 overflow when
//  1.op0 & op1 both norm && expnt overflow
//  2.ex1_id_of
// &Force("output","ex2_of"); @91
assign ex2_of      = ex2_of_plus;
assign ex2_of_plus = ex2_div_of  && fdsu_ex2_div;
assign ex2_div_of  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_of;

//=======================EX2 Underflow======================
//ex2 underflow when
//  1.op0 & op1 both norm && expnt underflow
//  2.ex1_id_uf
//  and detect when to skip the srt, here, we have further optmization
assign ex2_uf      = ex2_uf_plus;
assign ex2_uf_plus = ex2_div_uf  && fdsu_ex2_div;
assign ex2_div_uf  = fdsu_ex2_op0_norm &&
                     fdsu_ex2_op1_norm &&
                     ex2_expnt_uf;
assign ex2_id_nor_srt_skip =  fdsu_ex2_expnt_rst[9]
                                     && (fdsu_ex2_expnt_rst[8:0]<9'h16a);
assign ex2_uf_srt_skip            = ex2_id_nor_srt_skip;
assign ex2_rslt_denorm            = ex2_uf;
//===============ex2 round prepare for denormal round======
// &CombBeg; @113
always @( fdsu_ex2_expnt_rst[9:0])
begin
case(fdsu_ex2_expnt_rst[9:0])
  10'h382:ex2_result_denorm_round_add_num[23:0] = 24'h1; //-126 1
  10'h381:ex2_result_denorm_round_add_num[23:0] = 24'h2; //-127 0
  10'h380:ex2_result_denorm_round_add_num[23:0] = 24'h4; //-128 -1
  10'h37f:ex2_result_denorm_round_add_num[23:0] = 24'h8; //-129 -2
  10'h37e:ex2_result_denorm_round_add_num[23:0] = 24'h10; //-130 -3
  10'h37d:ex2_result_denorm_round_add_num[23:0] = 24'h20; //-131 -4
  10'h37c:ex2_result_denorm_round_add_num[23:0] = 24'h40; //-132 -5
  10'h37b:ex2_result_denorm_round_add_num[23:0] = 24'h80; //-133 -6
  10'h37a:ex2_result_denorm_round_add_num[23:0] = 24'h100; //-134 -7
  10'h379:ex2_result_denorm_round_add_num[23:0] = 24'h200; //-135 -8
  10'h378:ex2_result_denorm_round_add_num[23:0] = 24'h400; //-136 -9
  10'h377:ex2_result_denorm_round_add_num[23:0] = 24'h800; //-137 -10
  10'h376:ex2_result_denorm_round_add_num[23:0] = 24'h1000; //-138 -11
  10'h375:ex2_result_denorm_round_add_num[23:0] = 24'h2000; //-139 -12
  10'h374:ex2_result_denorm_round_add_num[23:0] = 24'h4000; //-140 -13
  10'h373:ex2_result_denorm_round_add_num[23:0] = 24'h8000; // -141 -14
  10'h372:ex2_result_denorm_round_add_num[23:0] = 24'h10000;//-142  -15
  10'h371:ex2_result_denorm_round_add_num[23:0] = 24'h20000;//-143 -16
  10'h370:ex2_result_denorm_round_add_num[23:0] = 24'h40000; //-144 -17
  10'h36f:ex2_result_denorm_round_add_num[23:0] = 24'h80000; //-145 -18
  10'h36e:ex2_result_denorm_round_add_num[23:0] = 24'h100000; //-146 -19
  10'h36d:ex2_result_denorm_round_add_num[23:0] = 24'h200000; //-147 -20
  10'h36c:ex2_result_denorm_round_add_num[23:0] = 24'h400000; //-148 -21
  10'h36b:ex2_result_denorm_round_add_num[23:0] = 24'h800000; //-148 -22
  default: ex2_result_denorm_round_add_num[23:0] = 24'h0;  // -23
endcase
// &CombEnd; @141
end

//===================special result========================
assign ex2_result_inf  = ex2_of_plus && !fdsu_ex2_of_rm_lfn;
assign ex2_result_lfn  = fdsu_ex2_result_lfn ||
                         ex2_of_plus &&  fdsu_ex2_of_rm_lfn;



//====================Pipe to EX3===========================
always @(posedge ex1_ex2_pipe_clk)
begin
  if(ex1_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= {14'b0, ex1_expnt_adder_op1[9:0]};
  end
  else if(ex2_pipedown)
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= ex2_result_denorm_round_add_num[23:0];
  end
  else
  begin
    fdsu_ex3_result_denorm_round_add_num[23:0]
                              <= fdsu_ex3_result_denorm_round_add_num[23:0];
  end
end
assign ex2_expnt_adder_op1 = fdsu_ex3_result_denorm_round_add_num[9:0];
// &Force("bus", "ex1_expnt_adder_op1", 12, 0); @193

assign ex1_ex2_pipe_clk_en = ex1_pipedown_gate || ex2_pipedown;
// &Instance("gated_clk_cell", "x_ex1_ex2_pipe_clk"); @196
gated_clk_cell  x_ex1_ex2_pipe_clk (
  .clk_in              (forever_cpuclk     ),
  .clk_out             (ex1_ex2_pipe_clk   ),
  .external_en         (1'b0               ),
  .global_en           (cp0_yy_clk_en      ),
  .local_en            (ex1_ex2_pipe_clk_en),
  .module_en           (cp0_fpu_icg_en     ),
  .pad_yy_icg_scan_en  (pad_yy_icg_scan_en )
);

// &Connect(.clk_in      (forever_cpuclk), @197
//          .external_en (1'b0), @198
//          .global_en   (cp0_yy_clk_en), @199
//          .module_en   (cp0_fpu_icg_en), @200
//          .local_en    (ex1_ex2_pipe_clk_en), @201
//          .clk_out     (ex1_ex2_pipe_clk)); @202

always @(posedge ex2_pipe_clk)
begin
  if(ex2_pipedown)
  begin
    fdsu_ex3_rem_sign        <= srt_remainder_sign;
    fdsu_ex3_rem_zero        <= srt_remainder_zero;
    fdsu_ex3_id_srt_skip     <= ex2_id_nor_srt_skip;
  end
  else
  begin
    fdsu_ex3_rem_sign        <= fdsu_ex3_rem_sign;
    fdsu_ex3_rem_zero        <= fdsu_ex3_rem_zero;
    fdsu_ex3_id_srt_skip    <=  fdsu_ex3_id_srt_skip;
  end
end

// &Force("output","fdsu_ex3_rem_sign"); @243
// &Force("output","fdsu_ex3_rem_zero"); @244
// &Force("output","fdsu_ex3_result_denorm_round_add_num"); @245
// &Force("output","fdsu_ex3_id_srt_skip"); @246

//==========================================================
//    SRT Remainder & Divisor for Quotient/Root Generate
//==========================================================

//===================Remainder Generate=====================
//gate clk
// &Instance("gated_clk_cell","x_srt_rem_clk");
// // &Connect( .clk_in         (forever_cpuclk), @255
// //           .clk_out        (srt_rem_clk),//Out Clock @256
// //           .external_en    (1'b0), @257
// //           .global_en      (cp0_yy_clk_en), @258
// //           .local_en       (srt_rem_clk_en),//Local Condition @259
// //           .module_en      (cp0_fpu_icg_en) @260
// //         ); @261
// assign srt_rem_clk_en = ex1_pipedown ||
//                         srt_sm_on;

always @(posedge qt_clk)
begin
  if (ex1_pipedown)
    srt_remainder[31:0] <= ex1_remainder[31:0];
  else if (srt_sm_on)
    srt_remainder[31:0] <= srt_remainder_nxt[31:0];
  else
    srt_remainder[31:0] <= srt_remainder[31:0];
end

//=====================Divisor Generate=====================
//gate clk
// &Instance("gated_clk_cell","x_srt_div_clk"); @291
gated_clk_cell  x_srt_div_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (srt_div_clk       ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (srt_div_clk_en    ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @292
//           .clk_out        (srt_div_clk),//Out Clock @293
//           .external_en    (1'b0), @294
//           .global_en      (cp0_yy_clk_en), @295
//           .local_en       (srt_div_clk_en),//Local Condition @296
//           .module_en      (cp0_fpu_icg_en) @297
//         ); @298
assign srt_div_clk_en = ex1_pipedown_gate
                     || ex1_save_op0_gate
                     || ex3_pipedown;
// final_rst saved in srt_divisor.
// srt_divisor is 26 bits, final_rst is 24 bits.
always @(posedge srt_div_clk)
begin
  if (ex1_save_op0)
    srt_divisor[25:0] <= {3'b0, {ex1_oper_id_frac[51:29]}};
  else if (ex1_pipedown)
    srt_divisor[25:0] <= {2'b0, ex1_divisor[23:0]};
  else if (ex3_pipedown)
    srt_divisor[25:0] <= ex3_frac_final_rst[25:0];
  else
    srt_divisor[25:0] <= srt_divisor[25:0];
end
assign ex1_oper_id_frac_f[51:0] = {srt_divisor[22:0], 29'b0};
// &Force("bus", "ex1_oper_id_frac", 51, 0); @332
assign fdsu_ex4_frac[25:0] = srt_divisor[25:0];

//=======================Bound Select=======================
//---------------------------------------+
// K   | 8 | 9 | 10| 11| 12| 13| 14|15,16|
//---------------------------------------+
//32S1 | 7 | 7 | 8 | 9 | 9 | 10| 11|  12 |
//---------------------------------------+
//32S2 | 25| 28| 31| 33| 36| 39| 41|  47 |
//---------------------------------------+

//bound_sel[3:0]
//For div,  use divisor high four bit as K
//For sqrt, use 2qi high four bit as K next round and
//          use 1010 as K first round
assign bound_sel[3:0] = (fdsu_ex2_div)
                      ? srt_divisor[23:20]
                      : (ex2_srt_first_round)
                        ? 4'b1010
                        : total_qt_rt_30[28:25];
//Select bound as look up table
//   K = bound_sel[3:0]
//32S1 = digit_bound_1[7:0]
//32s2 = digit_bound_2[7:0]
// &CombBeg; @357
always @( bound_sel[3:0])
begin
case(bound_sel[3:0])
4'b0000:       //when first interation get "10", choose k=16
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
4'b1000:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
4'b1001:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100100;//-28
   end
4'b1010:
   begin
     digit_bound_1[7:0] = 8'b11111000;//-8
     digit_bound_2[7:0] = 8'b11100001;//-31
   end
4'b1011:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011111;//-33
   end
4'b1100:
   begin
     digit_bound_1[7:0] = 8'b11110111;//-9
     digit_bound_2[7:0] = 8'b11011100;//-36
   end
4'b1101:
   begin
     digit_bound_1[7:0] = 8'b11110110;//-10
     digit_bound_2[7:0] = 8'b11011001;//-39
   end
4'b1110:
   begin
     digit_bound_1[7:0] = 8'b11110101;//-11
     digit_bound_2[7:0] = 8'b11010111;//-41
   end
4'b1111:
   begin
     digit_bound_1[7:0] = 8'b11110100;//-12
     digit_bound_2[7:0] = 8'b11010001;//-47
   end
default:
   begin
     digit_bound_1[7:0] = 8'b11111001;//-7
     digit_bound_2[7:0] = 8'b11100111;//-25
   end
endcase
// &CombEnd; @410
end

//==============Prepare for quotient generate===============
assign bound1_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_1[7:0];
assign bound2_cmp_result[7:0] = qtrt_sel_rem[7:0] + digit_bound_2[7:0];
assign bound1_cmp_sign        = bound1_cmp_result[7];
assign bound2_cmp_sign        = bound2_cmp_result[7];
assign rem_sign               = srt_remainder[29];

//qtrt_sel_rem is use to select quotient
//Only when sqrt first round use 8R0 select quotient(special rule)
//4R0 is used to select quotient on other condition
//For negative remaider, we use ~rem not (~rem + 1)
//Because  bound1 <=  rem   <   bound2, when positive rem
//        -bound2 <=  rem   <  -bound1, when negative rem
//Thus     bound1 <  -rem   <=  bound2, when negative rem
//Thus     bound1 <= -rem-1 <   bound2, when negative rem
//Thus     bound1 <= ~rem   <   bound2, when negative rem
//srt_remainder[29] used as sign bit
// &CombBeg; @429
always @( ex2_srt_first_round
       or fdsu_ex2_sqrt
       or srt_remainder[29:21])
begin
if(ex2_srt_first_round && fdsu_ex2_sqrt)
  qtrt_sel_rem[7:0] = {srt_remainder[29],   srt_remainder[27:21]};
else
  qtrt_sel_rem[7:0] =  srt_remainder[29] ? ~srt_remainder[29:22]
                                         :  srt_remainder[29:22];
// &CombEnd; @435
end

//==========================================================
//     on fly round method to generate total quotient
//==========================================================
//gate clk
// &Instance("gated_clk_cell","x_qt_clk"); @441
gated_clk_cell  x_qt_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (qt_clk            ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (qt_clk_en         ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

// &Connect( .clk_in         (forever_cpuclk), @442
//           .clk_out        (qt_clk),//Out Clock @443
//           .external_en    (1'b0), @444
//           .global_en      (cp0_yy_clk_en), @445
//           .local_en       (qt_clk_en),//Local Condition @446
//           .module_en      (cp0_fpu_icg_en) @447
//         ); @448
assign qt_clk_en = srt_sm_on ||
                   ex1_pipedown_gate;

//qt_rt_const_shift_std[29:0] is const data for on fly round
//                which is used to record the times of round
//
//total_qt_rt[29:0]       is total quotient
//total_qt_rt_minus[29:0] is total quotient minus
//                which is used to generate quotient rapidly
always @(posedge qt_clk)
begin
  if(ex1_pipedown)
  begin
    qt_rt_const_shift_std[29:0] <= {1'b0,1'b1,28'b0};
    total_qt_rt_30[29:0]        <= 30'b0;
    total_qt_rt_minus_30[29:0]  <= 30'b0;
  end
  else if(srt_sm_on)
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std_next[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30_next[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30_next[29:0];
  end
  else
  begin
    qt_rt_const_shift_std[29:0] <= qt_rt_const_shift_std[29:0];
    total_qt_rt_30[29:0]        <= total_qt_rt_30[29:0];
    total_qt_rt_minus_30[29:0]  <= total_qt_rt_minus_30[29:0];
  end
end
// &Force("output","total_qt_rt_30"); @508

//qt_rt_const_q1/q2/q3 for shift 1/2/3 in
assign qt_rt_const_q1[29:0] =  qt_rt_const_shift_std[29:0];
assign qt_rt_const_q2[29:0] = {qt_rt_const_shift_std[28:0],1'b0};
assign qt_rt_const_q3[29:0] =  qt_rt_const_q1[29:0] |
                               qt_rt_const_q2[29:0];
//qt_rt_const update value
assign qt_rt_const_shift_std_next[29:0] = {2'b0, qt_rt_const_shift_std[29:2]};

//========total_qt_rt & total_qt_rt_minus update value======
//q(i+1) is the total quotient/root after the (i+1) digit
//is calculated
//                 q(i+1)             qm(i+1)
//d(i+1)=-2     qm(i)+2*shift      qm(i)+1*shift
//d(i+1)=-1     qm(i)+3*shift      qm(i)+2*shift
//d(i+1)=0      q(i)               qm(i)+3*shift
//d(i+1)=1      q(i)+1*shift       q(i)
//d(i+1)=2      q(i)+2*shift       q(i)+1*shift
//Note:
//shift = 4^(-i-1), qm(i+1)=q(i+1)-shift

//pre select for quotient
assign total_qt_rt_pre_sel[29:0]         = (rem_sign) ?
                                           total_qt_rt_minus_30[29:0] :
                                           total_qt_rt_30[29:0];
//when the quotient is 2 or -2
assign qt_rt_const_pre_sel_q2[29:0]      = qt_rt_const_q2[29:0];
assign qt_rt_mins_const_pre_sel_q2[29:0] = qt_rt_const_q1[29:0];
//when the quotient is 1 or -1
assign qt_rt_const_pre_sel_q1[29:0]      = (rem_sign) ?
                                           qt_rt_const_q3[29:0] ://-1
                                           qt_rt_const_q1[29:0]; //1
assign qt_rt_mins_const_pre_sel_q1[29:0] = (rem_sign) ?
                                           qt_rt_const_q2[29:0] : //-1
                                           30'b0;

//After bound compare, the final selection
// &CombBeg; @546
always @( qt_rt_const_q3[29:0]
       or qt_rt_mins_const_pre_sel_q1[29:0]
       or bound1_cmp_sign
       or total_qt_rt_30[29:0]
       or qt_rt_mins_const_pre_sel_q2[29:0]
       or total_qt_rt_minus_30[29:0]
       or bound2_cmp_sign
       or qt_rt_const_pre_sel_q2[29:0]
       or qt_rt_const_pre_sel_q1[29:0]
       or total_qt_rt_pre_sel[29:0])
begin
casez({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:// the quotient is -2 or 2
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q2[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q2[29:0];
  end
  2'b01:// quotient is -1 or 1
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_const_pre_sel_q1[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_pre_sel[29:0] |
                                      qt_rt_mins_const_pre_sel_q1[29:0];
  end
  2'b1?: // quotient is 0
  begin
    total_qt_rt_30_next[29:0]       = total_qt_rt_30[29:0];
    total_qt_rt_minus_30_next[29:0] = total_qt_rt_minus_30[29:0] |
                                      qt_rt_const_q3[29:0];
  end
  default:
  begin
    total_qt_rt_30_next[29:0]       = 30'b0;
    total_qt_rt_minus_30_next[29:0] = 30'b0;
  end
endcase
// &CombEnd; @574
end

//==========================================================
//      on fly round method to generate cur remainder
//==========================================================
//Division emainder add value
//Quoit 1
assign div_qt_1_rem_add_op1[31:0]   = ~{3'b0,srt_divisor[23:0],5'b0};
//Quoit 2
assign div_qt_2_rem_add_op1[31:0]   = ~{2'b0,srt_divisor[23:0],6'b0};
//Quoit -1
assign div_qt_r1_rem_add_op1[31:0]  =  {3'b0,srt_divisor[23:0],5'b0};
//Quoit -2
assign div_qt_r2_rem_add_op1[31:0]  =  {2'b0,srt_divisor[23:0],6'b0};

//Sqrt remainder add value op1
//Quoit 1
assign sqrt_qt_1_rem_add_op1[31:0]  = ~({2'b0,total_qt_rt_30[29:0]} |
                                        {3'b0,qt_rt_const_q1[29:1]});
//Quoit 2
assign sqrt_qt_2_rem_add_op1[31:0]  = ~({1'b0,total_qt_rt_30[29:0],1'b0} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0});
//Quoit -1
assign sqrt_qt_r1_rem_add_op1[31:0] =   {2'b0,total_qt_rt_minus_30[29:0]} |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0}  |
                                        {2'b0,qt_rt_const_q1[29:0]}       |
                                        {3'b0,qt_rt_const_q1[29:1]};
//Quoit -2
assign sqrt_qt_r2_rem_add_op1[31:0] =   {1'b0,
                                         total_qt_rt_minus_30[29:0],1'b0} |
                                        {qt_rt_const_q1[29:0],2'b0}       |
                                        {1'b0,qt_rt_const_q1[29:0],1'b0};
//Remainder Adder select logic
// &CombBeg; @607
always @( div_qt_2_rem_add_op1[31:0]
       or sqrt_qt_r2_rem_add_op1[31:0]
       or sqrt_qt_r1_rem_add_op1[31:0]
       or rem_sign
       or div_qt_r2_rem_add_op1[31:0]
       or div_qt_1_rem_add_op1[31:0]
       or sqrt_qt_2_rem_add_op1[31:0]
       or fdsu_ex2_sqrt
       or div_qt_r1_rem_add_op1[31:0]
       or sqrt_qt_1_rem_add_op1[31:0])
begin
case({rem_sign,fdsu_ex2_sqrt})
  2'b01:
  begin
        rem_add1_op1[31:0] = sqrt_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_2_rem_add_op1[31:0];
  end
  2'b00:
  begin
        rem_add1_op1[31:0] = div_qt_1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_2_rem_add_op1[31:0];
  end
  2'b11:
  begin
        rem_add1_op1[31:0] = sqrt_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = sqrt_qt_r2_rem_add_op1[31:0];
  end
  2'b10:
  begin
        rem_add1_op1[31:0] = div_qt_r1_rem_add_op1[31:0];
        rem_add2_op1[31:0] = div_qt_r2_rem_add_op1[31:0];
  end
  default :
  begin
        rem_add1_op1[31:0] = 32'b0;
        rem_add2_op1[31:0] = 32'b0;
  end
  endcase
// &CombEnd; @635
end
assign srt_remainder_shift[31:0] = {srt_remainder[31],
                                    srt_remainder[28:0],2'b0};
//Remainder add
assign cur_doub_rem_1[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add1_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_doub_rem_2[31:0]      = srt_remainder_shift[31:0] +
                                   rem_add2_op1[31:0]    +
                                   {31'b0, ~rem_sign};
assign cur_rem_1[31:0]           = cur_doub_rem_1[31:0];
assign cur_rem_2[31:0]           = cur_doub_rem_2[31:0];
//Generate srt remainder update value
// &CombBeg; @648
always @( cur_rem_2[31:0]
       or bound1_cmp_sign
       or srt_remainder_shift[31:0]
       or bound2_cmp_sign
       or cur_rem_1[31:0])
begin
case({bound1_cmp_sign,bound2_cmp_sign})
  2'b00:   cur_rem[31:0]         = cur_rem_2[31:0];  //+-2
  2'b01:   cur_rem[31:0]         = cur_rem_1[31:0];  //+-1
  default: cur_rem[31:0]         = srt_remainder_shift[31:0]; //0
endcase
// &CombEnd; @654
end
assign srt_remainder_nxt[31:0]   = cur_rem[31:0];

//Remainder is zero signal in EX3
assign srt_remainder_zero        = ~|srt_remainder[31:0];
// &Force("output","srt_remainder_zero"); @659
assign srt_remainder_sign        =   srt_remainder[31];

// &Force("output", "ex2_uf"); @662
// &ModuleEnd; @663
endmodule



// ----- 8< ----- FILE "./pa_fdsu_top.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module pa_fdsu_top(
  cp0_fpu_icg_en,
  cp0_fpu_xx_dqnan,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_fdsu_ex1_sel,
  ctrl_xx_ex1_cmplt_dp,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  ctrl_xx_ex2_warm_up,
  ctrl_xx_ex3_warm_up,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_qnan,
  dp_xx_ex1_rm,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  fdsu_fpu_debug_info,
  fdsu_fpu_ex1_cmplt,
  fdsu_fpu_ex1_cmplt_dp,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  fdsu_fpu_ex1_stall,
  fdsu_fpu_no_op,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_freg,
  fdsu_frbus_wb_vld,
  forever_cpuclk,
  frbus_fdsu_wb_grant,
  idu_fpu_ex1_dst_freg,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  pad_yy_icg_scan_en,
  rtu_xx_ex1_cancel,
  rtu_xx_ex2_cancel,
  rtu_yy_xx_async_flush,
  rtu_yy_xx_flush
);

// &Ports; @24
input           cp0_fpu_icg_en;                      
input           cp0_fpu_xx_dqnan;                    
input           cp0_yy_clk_en;                       
input           cpurst_b;                            
input           ctrl_fdsu_ex1_sel;                   
input           ctrl_xx_ex1_cmplt_dp;                
input           ctrl_xx_ex1_inst_vld;                
input           ctrl_xx_ex1_stall;                   
input           ctrl_xx_ex1_warm_up;                 
input           ctrl_xx_ex2_warm_up;                 
input           ctrl_xx_ex3_warm_up;                 
input   [2 :0]  dp_xx_ex1_cnan;                      
input   [2 :0]  dp_xx_ex1_id;                        
input   [2 :0]  dp_xx_ex1_inf;                       
input   [2 :0]  dp_xx_ex1_qnan;                      
input   [2 :0]  dp_xx_ex1_rm;                        
input   [2 :0]  dp_xx_ex1_snan;                      
input   [2 :0]  dp_xx_ex1_zero;                      
input           forever_cpuclk;                      
input           frbus_fdsu_wb_grant;                 
input   [4 :0]  idu_fpu_ex1_dst_freg;                
input   [2 :0]  idu_fpu_ex1_eu_sel;                  
input   [9 :0]  idu_fpu_ex1_func;                    
input   [31:0]  idu_fpu_ex1_srcf0;                   
input   [31:0]  idu_fpu_ex1_srcf1;                   
input           pad_yy_icg_scan_en;                  
input           rtu_xx_ex1_cancel;                   
input           rtu_xx_ex2_cancel;                   
input           rtu_yy_xx_async_flush;               
input           rtu_yy_xx_flush;                     
output  [4 :0]  fdsu_fpu_debug_info;                 
output          fdsu_fpu_ex1_cmplt;                  
output          fdsu_fpu_ex1_cmplt_dp;               
output  [4 :0]  fdsu_fpu_ex1_fflags;                 
output  [7 :0]  fdsu_fpu_ex1_special_sel;            
output  [3 :0]  fdsu_fpu_ex1_special_sign;           
output          fdsu_fpu_ex1_stall;                  
output          fdsu_fpu_no_op;                      
output  [31:0]  fdsu_frbus_data;                     
output  [4 :0]  fdsu_frbus_fflags;                   
output  [4 :0]  fdsu_frbus_freg;                     
output          fdsu_frbus_wb_vld;                   

// &Regs; @25

// &Wires; @26
wire            cp0_fpu_icg_en;                      
wire            cp0_fpu_xx_dqnan;                    
wire            cp0_yy_clk_en;                       
wire            cpurst_b;                            
wire            ctrl_fdsu_ex1_sel;                   
wire            ctrl_xx_ex1_cmplt_dp;                
wire            ctrl_xx_ex1_inst_vld;                
wire            ctrl_xx_ex1_stall;                   
wire            ctrl_xx_ex1_warm_up;                 
wire            ctrl_xx_ex2_warm_up;                 
wire            ctrl_xx_ex3_warm_up;                 
wire    [2 :0]  dp_xx_ex1_cnan;                      
wire    [2 :0]  dp_xx_ex1_id;                        
wire    [2 :0]  dp_xx_ex1_inf;                       
wire    [2 :0]  dp_xx_ex1_qnan;                      
wire    [2 :0]  dp_xx_ex1_rm;                        
wire    [2 :0]  dp_xx_ex1_snan;                      
wire    [2 :0]  dp_xx_ex1_zero;                      
wire            ex1_div;                             
wire    [23:0]  ex1_divisor;                         
wire    [12:0]  ex1_expnt_adder_op0;                 
wire    [12:0]  ex1_expnt_adder_op1;                 
wire            ex1_of_result_lfn;                   
wire            ex1_op0_id;                          
wire            ex1_op0_norm;                        
wire            ex1_op0_sign;                        
wire            ex1_op1_id;                          
wire            ex1_op1_id_vld;                      
wire            ex1_op1_norm;                        
wire            ex1_op1_sel;                         
wire    [12:0]  ex1_oper_id_expnt;                   
wire    [12:0]  ex1_oper_id_expnt_f;                 
wire    [51:0]  ex1_oper_id_frac;                    
wire    [51:0]  ex1_oper_id_frac_f;                  
wire            ex1_pipedown;                        
wire            ex1_pipedown_gate;                   
wire    [31:0]  ex1_remainder;                       
wire            ex1_result_sign;                     
wire    [2 :0]  ex1_rm;                              
wire            ex1_save_op0;                        
wire            ex1_save_op0_gate;                   
wire            ex1_sqrt;                            
wire            ex1_srt_skip;                        
wire    [9 :0]  ex2_expnt_adder_op0;                 
wire            ex2_of;                              
wire            ex2_pipe_clk;                        
wire            ex2_pipedown;                        
wire            ex2_potnt_of;                        
wire            ex2_potnt_uf;                        
wire            ex2_result_inf;                      
wire            ex2_result_lfn;                      
wire            ex2_rslt_denorm;                     
wire    [9 :0]  ex2_srt_expnt_rst;                   
wire            ex2_srt_first_round;                 
wire            ex2_uf;                              
wire            ex2_uf_srt_skip;                     
wire    [9 :0]  ex3_expnt_adjust_result;             
wire    [25:0]  ex3_frac_final_rst;                  
wire            ex3_pipedown;                        
wire            ex3_rslt_denorm;                     
wire            fdsu_ex1_sel;                        
wire            fdsu_ex3_id_srt_skip;                
wire            fdsu_ex3_rem_sign;                   
wire            fdsu_ex3_rem_zero;                   
wire    [23:0]  fdsu_ex3_result_denorm_round_add_num; 
wire            fdsu_ex4_denorm_to_tiny_frac;        
wire    [25:0]  fdsu_ex4_frac;                       
wire            fdsu_ex4_nx;                         
wire    [1 :0]  fdsu_ex4_potnt_norm;                 
wire            fdsu_ex4_result_nor;                 
wire    [4 :0]  fdsu_fpu_debug_info;                 
wire            fdsu_fpu_ex1_cmplt;                  
wire            fdsu_fpu_ex1_cmplt_dp;               
wire    [4 :0]  fdsu_fpu_ex1_fflags;                 
wire    [7 :0]  fdsu_fpu_ex1_special_sel;            
wire    [3 :0]  fdsu_fpu_ex1_special_sign;           
wire            fdsu_fpu_ex1_stall;                  
wire            fdsu_fpu_no_op;                      
wire    [31:0]  fdsu_frbus_data;                     
wire    [4 :0]  fdsu_frbus_fflags;                   
wire    [4 :0]  fdsu_frbus_freg;                     
wire            fdsu_frbus_wb_vld;                   
wire            fdsu_yy_div;                         
wire    [9 :0]  fdsu_yy_expnt_rst;                   
wire            fdsu_yy_of;                          
wire            fdsu_yy_of_rm_lfn;                   
wire            fdsu_yy_op0_norm;                    
wire            fdsu_yy_op1_norm;                    
wire            fdsu_yy_potnt_of;                    
wire            fdsu_yy_potnt_uf;                    
wire            fdsu_yy_result_inf;                  
wire            fdsu_yy_result_lfn;                  
wire            fdsu_yy_result_sign;                 
wire    [2 :0]  fdsu_yy_rm;                          
wire            fdsu_yy_rslt_denorm;                 
wire            fdsu_yy_sqrt;                        
wire            fdsu_yy_uf;                          
wire    [4 :0]  fdsu_yy_wb_freg;                     
wire            forever_cpuclk;                      
wire            frbus_fdsu_wb_grant;                 
wire    [4 :0]  idu_fpu_ex1_dst_freg;                
wire    [2 :0]  idu_fpu_ex1_eu_sel;                  
wire    [9 :0]  idu_fpu_ex1_func;                    
wire    [31:0]  idu_fpu_ex1_srcf0;                   
wire    [31:0]  idu_fpu_ex1_srcf1;                   
wire            pad_yy_icg_scan_en;                  
wire            rtu_xx_ex1_cancel;                   
wire            rtu_xx_ex2_cancel;                   
wire            rtu_yy_xx_async_flush;               
wire            rtu_yy_xx_flush;                     
wire            srt_remainder_zero;                  
wire            srt_sm_on;                           
wire    [29:0]  total_qt_rt_30;                      



// &Instance("pa_fdsu_special"); @29
pa_fdsu_special  x_pa_fdsu_special (
  .cp0_fpu_xx_dqnan          (cp0_fpu_xx_dqnan         ),
  .dp_xx_ex1_cnan            (dp_xx_ex1_cnan           ),
  .dp_xx_ex1_id              (dp_xx_ex1_id             ),
  .dp_xx_ex1_inf             (dp_xx_ex1_inf            ),
  .dp_xx_ex1_qnan            (dp_xx_ex1_qnan           ),
  .dp_xx_ex1_snan            (dp_xx_ex1_snan           ),
  .dp_xx_ex1_zero            (dp_xx_ex1_zero           ),
  .ex1_div                   (ex1_div                  ),
  .ex1_op0_id                (ex1_op0_id               ),
  .ex1_op0_norm              (ex1_op0_norm             ),
  .ex1_op0_sign              (ex1_op0_sign             ),
  .ex1_op1_id                (ex1_op1_id               ),
  .ex1_op1_norm              (ex1_op1_norm             ),
  .ex1_result_sign           (ex1_result_sign          ),
  .ex1_sqrt                  (ex1_sqrt                 ),
  .ex1_srt_skip              (ex1_srt_skip             ),
  .fdsu_fpu_ex1_fflags       (fdsu_fpu_ex1_fflags      ),
  .fdsu_fpu_ex1_special_sel  (fdsu_fpu_ex1_special_sel ),
  .fdsu_fpu_ex1_special_sign (fdsu_fpu_ex1_special_sign)
);

// &Instance("pa_fdsu_prepare"); @30
pa_fdsu_prepare  x_pa_fdsu_prepare (
  .dp_xx_ex1_rm        (dp_xx_ex1_rm       ),
  .ex1_div             (ex1_div            ),
  .ex1_divisor         (ex1_divisor        ),
  .ex1_expnt_adder_op0 (ex1_expnt_adder_op0),
  .ex1_expnt_adder_op1 (ex1_expnt_adder_op1),
  .ex1_of_result_lfn   (ex1_of_result_lfn  ),
  .ex1_op0_id          (ex1_op0_id         ),
  .ex1_op0_sign        (ex1_op0_sign       ),
  .ex1_op1_id          (ex1_op1_id         ),
  .ex1_op1_id_vld      (ex1_op1_id_vld     ),
  .ex1_op1_sel         (ex1_op1_sel        ),
  .ex1_oper_id_expnt   (ex1_oper_id_expnt  ),
  .ex1_oper_id_expnt_f (ex1_oper_id_expnt_f),
  .ex1_oper_id_frac    (ex1_oper_id_frac   ),
  .ex1_oper_id_frac_f  (ex1_oper_id_frac_f ),
  .ex1_remainder       (ex1_remainder      ),
  .ex1_result_sign     (ex1_result_sign    ),
  .ex1_rm              (ex1_rm             ),
  .ex1_sqrt            (ex1_sqrt           ),
  .fdsu_ex1_sel        (fdsu_ex1_sel       ),
  .idu_fpu_ex1_func    (idu_fpu_ex1_func   ),
  .idu_fpu_ex1_srcf0   (idu_fpu_ex1_srcf0  ),
  .idu_fpu_ex1_srcf1   (idu_fpu_ex1_srcf1  )
);

// &Instance("pa_fdsu_srt"); @32
// &Instance("pa_fdsu_round"); @33
// &Instance("pa_fdsu_pack"); @34
// &Instance("pa_fdsu_srt_single", "x_pa_fdsu_srt"); @36
pa_fdsu_srt_single  x_pa_fdsu_srt (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex1_divisor                          (ex1_divisor                         ),
  .ex1_expnt_adder_op1                  (ex1_expnt_adder_op1                 ),
  .ex1_oper_id_frac                     (ex1_oper_id_frac                    ),
  .ex1_oper_id_frac_f                   (ex1_oper_id_frac_f                  ),
  .ex1_pipedown                         (ex1_pipedown                        ),
  .ex1_pipedown_gate                    (ex1_pipedown_gate                   ),
  .ex1_remainder                        (ex1_remainder                       ),
  .ex1_save_op0                         (ex1_save_op0                        ),
  .ex1_save_op0_gate                    (ex1_save_op0_gate                   ),
  .ex2_expnt_adder_op0                  (ex2_expnt_adder_op0                 ),
  .ex2_of                               (ex2_of                              ),
  .ex2_pipe_clk                         (ex2_pipe_clk                        ),
  .ex2_pipedown                         (ex2_pipedown                        ),
  .ex2_potnt_of                         (ex2_potnt_of                        ),
  .ex2_potnt_uf                         (ex2_potnt_uf                        ),
  .ex2_result_inf                       (ex2_result_inf                      ),
  .ex2_result_lfn                       (ex2_result_lfn                      ),
  .ex2_rslt_denorm                      (ex2_rslt_denorm                     ),
  .ex2_srt_expnt_rst                    (ex2_srt_expnt_rst                   ),
  .ex2_srt_first_round                  (ex2_srt_first_round                 ),
  .ex2_uf                               (ex2_uf                              ),
  .ex2_uf_srt_skip                      (ex2_uf_srt_skip                     ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_frac                        (fdsu_ex4_frac                       ),
  .fdsu_yy_div                          (fdsu_yy_div                         ),
  .fdsu_yy_of_rm_lfn                    (fdsu_yy_of_rm_lfn                   ),
  .fdsu_yy_op0_norm                     (fdsu_yy_op0_norm                    ),
  .fdsu_yy_op1_norm                     (fdsu_yy_op1_norm                    ),
  .fdsu_yy_sqrt                         (fdsu_yy_sqrt                        ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .srt_remainder_zero                   (srt_remainder_zero                  ),
  .srt_sm_on                            (srt_sm_on                           ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("pa_fdsu_round_single", "x_pa_fdsu_round"); @37
pa_fdsu_round_single  x_pa_fdsu_round (
  .cp0_fpu_icg_en                       (cp0_fpu_icg_en                      ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .ex3_expnt_adjust_result              (ex3_expnt_adjust_result             ),
  .ex3_frac_final_rst                   (ex3_frac_final_rst                  ),
  .ex3_pipedown                         (ex3_pipedown                        ),
  .ex3_rslt_denorm                      (ex3_rslt_denorm                     ),
  .fdsu_ex3_id_srt_skip                 (fdsu_ex3_id_srt_skip                ),
  .fdsu_ex3_rem_sign                    (fdsu_ex3_rem_sign                   ),
  .fdsu_ex3_rem_zero                    (fdsu_ex3_rem_zero                   ),
  .fdsu_ex3_result_denorm_round_add_num (fdsu_ex3_result_denorm_round_add_num),
  .fdsu_ex4_denorm_to_tiny_frac         (fdsu_ex4_denorm_to_tiny_frac        ),
  .fdsu_ex4_nx                          (fdsu_ex4_nx                         ),
  .fdsu_ex4_potnt_norm                  (fdsu_ex4_potnt_norm                 ),
  .fdsu_ex4_result_nor                  (fdsu_ex4_result_nor                 ),
  .fdsu_yy_expnt_rst                    (fdsu_yy_expnt_rst                   ),
  .fdsu_yy_result_inf                   (fdsu_yy_result_inf                  ),
  .fdsu_yy_result_lfn                   (fdsu_yy_result_lfn                  ),
  .fdsu_yy_result_sign                  (fdsu_yy_result_sign                 ),
  .fdsu_yy_rm                           (fdsu_yy_rm                          ),
  .fdsu_yy_rslt_denorm                  (fdsu_yy_rslt_denorm                 ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .pad_yy_icg_scan_en                   (pad_yy_icg_scan_en                  ),
  .total_qt_rt_30                       (total_qt_rt_30                      )
);

// &Instance("pa_fdsu_pack_single", "x_pa_fdsu_pack"); @38
pa_fdsu_pack_single  x_pa_fdsu_pack (
  .fdsu_ex4_denorm_to_tiny_frac (fdsu_ex4_denorm_to_tiny_frac),
  .fdsu_ex4_frac                (fdsu_ex4_frac               ),
  .fdsu_ex4_nx                  (fdsu_ex4_nx                 ),
  .fdsu_ex4_potnt_norm          (fdsu_ex4_potnt_norm         ),
  .fdsu_ex4_result_nor          (fdsu_ex4_result_nor         ),
  .fdsu_frbus_data              (fdsu_frbus_data             ),
  .fdsu_frbus_fflags            (fdsu_frbus_fflags           ),
  .fdsu_frbus_freg              (fdsu_frbus_freg             ),
  .fdsu_yy_expnt_rst            (fdsu_yy_expnt_rst           ),
  .fdsu_yy_of                   (fdsu_yy_of                  ),
  .fdsu_yy_of_rm_lfn            (fdsu_yy_of_rm_lfn           ),
  .fdsu_yy_potnt_of             (fdsu_yy_potnt_of            ),
  .fdsu_yy_potnt_uf             (fdsu_yy_potnt_uf            ),
  .fdsu_yy_result_inf           (fdsu_yy_result_inf          ),
  .fdsu_yy_result_lfn           (fdsu_yy_result_lfn          ),
  .fdsu_yy_result_sign          (fdsu_yy_result_sign         ),
  .fdsu_yy_rslt_denorm          (fdsu_yy_rslt_denorm         ),
  .fdsu_yy_uf                   (fdsu_yy_uf                  ),
  .fdsu_yy_wb_freg              (fdsu_yy_wb_freg             )
);


// &Instance("pa_fdsu_ctrl"); @41
pa_fdsu_ctrl  x_pa_fdsu_ctrl (
  .cp0_fpu_icg_en          (cp0_fpu_icg_en         ),
  .cp0_yy_clk_en           (cp0_yy_clk_en          ),
  .cpurst_b                (cpurst_b               ),
  .ctrl_fdsu_ex1_sel       (ctrl_fdsu_ex1_sel      ),
  .ctrl_xx_ex1_cmplt_dp    (ctrl_xx_ex1_cmplt_dp   ),
  .ctrl_xx_ex1_inst_vld    (ctrl_xx_ex1_inst_vld   ),
  .ctrl_xx_ex1_stall       (ctrl_xx_ex1_stall      ),
  .ctrl_xx_ex1_warm_up     (ctrl_xx_ex1_warm_up    ),
  .ctrl_xx_ex2_warm_up     (ctrl_xx_ex2_warm_up    ),
  .ctrl_xx_ex3_warm_up     (ctrl_xx_ex3_warm_up    ),
  .ex1_div                 (ex1_div                ),
  .ex1_expnt_adder_op0     (ex1_expnt_adder_op0    ),
  .ex1_of_result_lfn       (ex1_of_result_lfn      ),
  .ex1_op0_id              (ex1_op0_id             ),
  .ex1_op0_norm            (ex1_op0_norm           ),
  .ex1_op1_id_vld          (ex1_op1_id_vld         ),
  .ex1_op1_norm            (ex1_op1_norm           ),
  .ex1_op1_sel             (ex1_op1_sel            ),
  .ex1_oper_id_expnt       (ex1_oper_id_expnt      ),
  .ex1_oper_id_expnt_f     (ex1_oper_id_expnt_f    ),
  .ex1_pipedown            (ex1_pipedown           ),
  .ex1_pipedown_gate       (ex1_pipedown_gate      ),
  .ex1_result_sign         (ex1_result_sign        ),
  .ex1_rm                  (ex1_rm                 ),
  .ex1_save_op0            (ex1_save_op0           ),
  .ex1_save_op0_gate       (ex1_save_op0_gate      ),
  .ex1_sqrt                (ex1_sqrt               ),
  .ex1_srt_skip            (ex1_srt_skip           ),
  .ex2_expnt_adder_op0     (ex2_expnt_adder_op0    ),
  .ex2_of                  (ex2_of                 ),
  .ex2_pipe_clk            (ex2_pipe_clk           ),
  .ex2_pipedown            (ex2_pipedown           ),
  .ex2_potnt_of            (ex2_potnt_of           ),
  .ex2_potnt_uf            (ex2_potnt_uf           ),
  .ex2_result_inf          (ex2_result_inf         ),
  .ex2_result_lfn          (ex2_result_lfn         ),
  .ex2_rslt_denorm         (ex2_rslt_denorm        ),
  .ex2_srt_expnt_rst       (ex2_srt_expnt_rst      ),
  .ex2_srt_first_round     (ex2_srt_first_round    ),
  .ex2_uf                  (ex2_uf                 ),
  .ex2_uf_srt_skip         (ex2_uf_srt_skip        ),
  .ex3_expnt_adjust_result (ex3_expnt_adjust_result),
  .ex3_pipedown            (ex3_pipedown           ),
  .ex3_rslt_denorm         (ex3_rslt_denorm        ),
  .fdsu_ex1_sel            (fdsu_ex1_sel           ),
  .fdsu_fpu_debug_info     (fdsu_fpu_debug_info    ),
  .fdsu_fpu_ex1_cmplt      (fdsu_fpu_ex1_cmplt     ),
  .fdsu_fpu_ex1_cmplt_dp   (fdsu_fpu_ex1_cmplt_dp  ),
  .fdsu_fpu_ex1_stall      (fdsu_fpu_ex1_stall     ),
  .fdsu_fpu_no_op          (fdsu_fpu_no_op         ),
  .fdsu_frbus_wb_vld       (fdsu_frbus_wb_vld      ),
  .fdsu_yy_div             (fdsu_yy_div            ),
  .fdsu_yy_expnt_rst       (fdsu_yy_expnt_rst      ),
  .fdsu_yy_of              (fdsu_yy_of             ),
  .fdsu_yy_of_rm_lfn       (fdsu_yy_of_rm_lfn      ),
  .fdsu_yy_op0_norm        (fdsu_yy_op0_norm       ),
  .fdsu_yy_op1_norm        (fdsu_yy_op1_norm       ),
  .fdsu_yy_potnt_of        (fdsu_yy_potnt_of       ),
  .fdsu_yy_potnt_uf        (fdsu_yy_potnt_uf       ),
  .fdsu_yy_result_inf      (fdsu_yy_result_inf     ),
  .fdsu_yy_result_lfn      (fdsu_yy_result_lfn     ),
  .fdsu_yy_result_sign     (fdsu_yy_result_sign    ),
  .fdsu_yy_rm              (fdsu_yy_rm             ),
  .fdsu_yy_rslt_denorm     (fdsu_yy_rslt_denorm    ),
  .fdsu_yy_sqrt            (fdsu_yy_sqrt           ),
  .fdsu_yy_uf              (fdsu_yy_uf             ),
  .fdsu_yy_wb_freg         (fdsu_yy_wb_freg        ),
  .forever_cpuclk          (forever_cpuclk         ),
  .frbus_fdsu_wb_grant     (frbus_fdsu_wb_grant    ),
  .idu_fpu_ex1_dst_freg    (idu_fpu_ex1_dst_freg   ),
  .idu_fpu_ex1_eu_sel      (idu_fpu_ex1_eu_sel     ),
  .pad_yy_icg_scan_en      (pad_yy_icg_scan_en     ),
  .rtu_xx_ex1_cancel       (rtu_xx_ex1_cancel      ),
  .rtu_xx_ex2_cancel       (rtu_xx_ex2_cancel      ),
  .rtu_yy_xx_async_flush   (rtu_yy_xx_async_flush  ),
  .rtu_yy_xx_flush         (rtu_yy_xx_flush        ),
  .srt_remainder_zero      (srt_remainder_zero     ),
  .srt_sm_on               (srt_sm_on              )
);



// &ModuleEnd; @44
endmodule


// ----- 8< ----- FILE "./pa_fpu_dp.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module pa_fpu_dp(
  cp0_fpu_icg_en,
  cp0_fpu_xx_rm,
  cp0_yy_clk_en,
  ctrl_xx_ex1_inst_vld,
  ctrl_xx_ex1_stall,
  ctrl_xx_ex1_warm_up,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  dp_xx_ex1_cnan,
  dp_xx_ex1_id,
  dp_xx_ex1_inf,
  dp_xx_ex1_norm,
  dp_xx_ex1_qnan,
  dp_xx_ex1_snan,
  dp_xx_ex1_zero,
  ex2_inst_wb,
  fdsu_fpu_ex1_fflags,
  fdsu_fpu_ex1_special_sel,
  fdsu_fpu_ex1_special_sign,
  forever_cpuclk,
  idu_fpu_ex1_eu_sel,
  idu_fpu_ex1_func,
  idu_fpu_ex1_gateclk_vld,
  idu_fpu_ex1_rm,
  idu_fpu_ex1_srcf0,
  idu_fpu_ex1_srcf1,
  idu_fpu_ex1_srcf2,
  pad_yy_icg_scan_en
);

input           cp0_fpu_icg_en;             
input   [2 :0]  cp0_fpu_xx_rm;              
input           cp0_yy_clk_en;              
input           ctrl_xx_ex1_inst_vld;       
input           ctrl_xx_ex1_stall;          
input           ctrl_xx_ex1_warm_up;
input   [4 :0]  fdsu_fpu_ex1_fflags;        
input   [7 :0]  fdsu_fpu_ex1_special_sel;   
input   [3 :0]  fdsu_fpu_ex1_special_sign;
input           forever_cpuclk;
input   [2 :0]  idu_fpu_ex1_eu_sel;         
input   [9 :0]  idu_fpu_ex1_func;           
input           idu_fpu_ex1_gateclk_vld;    
input   [2 :0]  idu_fpu_ex1_rm;             
input   [31:0]  idu_fpu_ex1_srcf0;          
input   [31:0]  idu_fpu_ex1_srcf1;          
input   [31:0]  idu_fpu_ex1_srcf2;          
input           pad_yy_icg_scan_en;         
output  [31:0]  dp_frbus_ex2_data;          
output  [4 :0]  dp_frbus_ex2_fflags;
output  [2 :0]  dp_xx_ex1_cnan;             
output  [2 :0]  dp_xx_ex1_id;               
output  [2 :0]  dp_xx_ex1_inf;              
output  [2 :0]  dp_xx_ex1_norm;             
output  [2 :0]  dp_xx_ex1_qnan;
output  [2 :0]  dp_xx_ex1_snan;
output  [2 :0]  dp_xx_ex1_zero;
output          ex2_inst_wb;                

reg     [4 :0]  ex1_fflags;                 
reg     [31:0]  ex1_special_data;           
reg     [8 :0]  ex1_special_sel;            
reg     [3 :0]  ex1_special_sign;           
reg     [4 :0]  ex2_fflags;
reg     [31:0]  ex2_result;
reg     [31:0]  ex2_special_data;           
reg     [6 :0]  ex2_special_sel;            
reg     [3 :0]  ex2_special_sign;

wire            cp0_fpu_icg_en;             
wire    [2 :0]  cp0_fpu_xx_rm;              
wire            cp0_yy_clk_en;              
wire            ctrl_xx_ex1_inst_vld;       
wire            ctrl_xx_ex1_stall;          
wire            ctrl_xx_ex1_warm_up;
wire    [31:0]  dp_frbus_ex2_data;          
wire    [4 :0]  dp_frbus_ex2_fflags;
wire    [2 :0]  dp_xx_ex1_cnan;             
wire    [2 :0]  dp_xx_ex1_id;               
wire    [2 :0]  dp_xx_ex1_inf;              
wire    [2 :0]  dp_xx_ex1_norm;             
wire    [2 :0]  dp_xx_ex1_qnan;
wire    [2 :0]  dp_xx_ex1_snan;
wire    [2 :0]  dp_xx_ex1_zero;
wire    [2 :0]  ex1_decode_rm;              
wire            ex1_double;                 
wire    [2 :0]  ex1_eu_sel;
wire    [9 :0]  ex1_func;                   
wire    [2 :0]  ex1_global_rm;              
wire    [2 :0]  ex1_rm;                     
wire            ex1_single;                 
wire    [31:0]  ex1_special_data_final;     
wire    [63:0]  ex1_src0;                   
wire    [63:0]  ex1_src1;                   
wire    [63:0]  ex1_src2;                   
wire            ex1_src2_vld;               
wire    [2 :0]  ex1_src_cnan;               
wire    [2 :0]  ex1_src_id;                 
wire    [2 :0]  ex1_src_inf;                
wire    [2 :0]  ex1_src_norm;               
wire    [2 :0]  ex1_src_qnan;               
wire    [2 :0]  ex1_src_snan;               
wire    [2 :0]  ex1_src_zero;               
wire            ex2_data_clk;               
wire            ex2_data_clk_en;            
wire            ex2_inst_wb;
wire    [4 :0]  fdsu_fpu_ex1_fflags;        
wire    [7 :0]  fdsu_fpu_ex1_special_sel;   
wire    [3 :0]  fdsu_fpu_ex1_special_sign;
wire            forever_cpuclk;
wire    [2 :0]  idu_fpu_ex1_eu_sel;         
wire    [9 :0]  idu_fpu_ex1_func;           
wire            idu_fpu_ex1_gateclk_vld;    
wire    [2 :0]  idu_fpu_ex1_rm;             
wire    [31:0]  idu_fpu_ex1_srcf0;          
wire    [31:0]  idu_fpu_ex1_srcf1;          
wire    [31:0]  idu_fpu_ex1_srcf2;          
wire            pad_yy_icg_scan_en;         


parameter DOUBLE_WIDTH =64;
parameter SINGLE_WIDTH =32;
parameter FUNC_WIDTH   =10;
//==========================================================
//                     EX1 special data path
//==========================================================
assign ex1_eu_sel[2:0]            = idu_fpu_ex1_eu_sel[2:0];  //3'h4
assign ex1_func[FUNC_WIDTH-1:0]   = idu_fpu_ex1_func[FUNC_WIDTH-1:0];
assign ex1_global_rm[2:0]         = cp0_fpu_xx_rm[2:0];
assign ex1_decode_rm[2:0]         = idu_fpu_ex1_rm[2:0];

assign ex1_rm[2:0]                = (ex1_decode_rm[2:0]==3'b111) 
                                  ?  ex1_global_rm[2:0] : ex1_decode_rm[2:0]; 

assign ex1_src2_vld               = idu_fpu_ex1_eu_sel[1] && ex1_func[0];

assign ex1_src0[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf0[SINGLE_WIDTH-1:0]};
assign ex1_src1[DOUBLE_WIDTH-1:0] = { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf1[SINGLE_WIDTH-1:0]};
assign ex1_src2[DOUBLE_WIDTH-1:0] = ex1_src2_vld ? { {SINGLE_WIDTH{1'b1}},idu_fpu_ex1_srcf2[SINGLE_WIDTH-1:0]}
                                                 : { {SINGLE_WIDTH{1'b1}},{SINGLE_WIDTH{1'b0}} };

assign ex1_double = 1'b0;
assign ex1_single = 1'b1;

//==========================================================
//                EX1 special src data judge
//==========================================================
pa_fpu_src_type  x_pa_fpu_ex1_srcf0_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[0]),
  .src_id          (ex1_src_id[0]  ),
  .src_in          (ex1_src0       ),
  .src_inf         (ex1_src_inf[0] ),
  .src_norm        (ex1_src_norm[0]),
  .src_qnan        (ex1_src_qnan[0]),
  .src_snan        (ex1_src_snan[0]),
  .src_zero        (ex1_src_zero[0])
);

pa_fpu_src_type  x_pa_fpu_ex1_srcf1_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[1]),
  .src_id          (ex1_src_id[1]  ),
  .src_in          (ex1_src1       ),
  .src_inf         (ex1_src_inf[1] ),
  .src_norm        (ex1_src_norm[1]),
  .src_qnan        (ex1_src_qnan[1]),
  .src_snan        (ex1_src_snan[1]),
  .src_zero        (ex1_src_zero[1])
);

pa_fpu_src_type  x_pa_fpu_ex1_srcf2_type (
  .inst_double     (ex1_double     ),
  .inst_single     (ex1_single     ),
  .src_cnan        (ex1_src_cnan[2]),
  .src_id          (ex1_src_id[2]  ),
  .src_in          (ex1_src2       ),
  .src_inf         (ex1_src_inf[2] ),
  .src_norm        (ex1_src_norm[2]),
  .src_qnan        (ex1_src_qnan[2]),
  .src_snan        (ex1_src_snan[2]),
  .src_zero        (ex1_src_zero[2])
);

assign dp_xx_ex1_cnan[2:0] = ex1_src_cnan[2:0];
assign dp_xx_ex1_snan[2:0] = ex1_src_snan[2:0];
assign dp_xx_ex1_qnan[2:0] = ex1_src_qnan[2:0];
assign dp_xx_ex1_norm[2:0] = ex1_src_norm[2:0];
assign dp_xx_ex1_zero[2:0] = ex1_src_zero[2:0];
assign dp_xx_ex1_inf[2:0]  = ex1_src_inf[2:0];
assign dp_xx_ex1_id[2:0]   = ex1_src_id[2:0];

//==========================================================
//                EX1 special result judge
//==========================================================

always @( fdsu_fpu_ex1_special_sign[3:0]
       or fdsu_fpu_ex1_fflags[4:0]
       or ex1_eu_sel[2:0]
       or fdsu_fpu_ex1_special_sel[7:0])
begin
case(ex1_eu_sel[2:0])  //3'h4
   3'b100: begin//FDSU
         ex1_fflags[4:0]       = fdsu_fpu_ex1_fflags[4:0];
         ex1_special_sel[8:0]  ={1'b0,fdsu_fpu_ex1_special_sel[7:0]};
         ex1_special_sign[3:0] = fdsu_fpu_ex1_special_sign[3:0];
         end
default: begin//FDSU
         ex1_fflags[4:0]       = {5{1'b0}};
         ex1_special_sel[8:0]  = {9{1'b0}};
         ex1_special_sign[3:0] = {4{1'b0}};
         end
endcase
end

always @( ex1_special_sel[8:5]
       or ex1_src0[31:0]
       or ex1_src1[31:0]
       or ex1_src2[31:0])
begin
case(ex1_special_sel[8:5])
  4'b0001: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src0[SINGLE_WIDTH-1:0];
  4'b0010: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src1[SINGLE_WIDTH-1:0];
  4'b0100: ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
default  : ex1_special_data[SINGLE_WIDTH-1:0] = ex1_src2[SINGLE_WIDTH-1:0];
endcase
end

assign ex1_special_data_final[SINGLE_WIDTH-1:0] = ex1_special_data[SINGLE_WIDTH-1:0];

//==========================================================
//                     EX1-EX2 data pipedown
//==========================================================
assign ex2_data_clk_en = idu_fpu_ex1_gateclk_vld || ctrl_xx_ex1_warm_up;

gated_clk_cell  x_fpu_data_ex2_gated_clk (
  .clk_in             (forever_cpuclk    ),
  .clk_out            (ex2_data_clk      ),
  .external_en        (1'b0              ),
  .global_en          (cp0_yy_clk_en     ),
  .local_en           (ex2_data_clk_en   ),
  .module_en          (cp0_fpu_icg_en    ),
  .pad_yy_icg_scan_en (pad_yy_icg_scan_en)
);

always @(posedge ex2_data_clk)
begin
  if(ctrl_xx_ex1_inst_vld && !ctrl_xx_ex1_stall || ctrl_xx_ex1_warm_up)
  begin
    ex2_fflags[4:0]       <= ex1_fflags[4:0];
    ex2_special_sign[3:0] <= ex1_special_sign[3:0];
    ex2_special_sel[6:0]  <={ex1_special_sel[8],|ex1_special_sel[7:5],ex1_special_sel[4:0]};
    ex2_special_data[SINGLE_WIDTH-1:0] <= ex1_special_data_final[SINGLE_WIDTH-1:0];
  end
end

assign ex2_inst_wb = (|ex2_special_sel[6:0]);

always @( ex2_special_sel[6:0]
       or ex2_special_data[31:0]
       or ex2_special_sign[3:0])
begin
case(ex2_special_sel[6:0])
  7'b0000_001: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[0],ex2_special_data[SINGLE_WIDTH-2:0]};//src2
  7'b0000_010: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[1], {31{1'b0}} };//zero
  7'b0000_100: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[2], {8{1'b1}},{23{1'b0}} };//inf
  7'b0001_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_sign[3], {7{1'b1}},1'b0,{23{1'b1}} };//lfn
  7'b0010_000: ex2_result[SINGLE_WIDTH-1:0]  = { 1'b0, {8{1'b1}},1'b1, {22{1'b0}} };//cnan
  7'b0100_000: ex2_result[SINGLE_WIDTH-1:0]  = { ex2_special_data[31],{8{1'b1}}, 1'b1, ex2_special_data[21:0]};//propagate qnan
  7'b1000_000: ex2_result[SINGLE_WIDTH-1:0]  = ex2_special_data[SINGLE_WIDTH-1:0]; //ex1 falu special result
      default: ex2_result[SINGLE_WIDTH-1:0]  = {SINGLE_WIDTH{1'b0}};
endcase
end

assign dp_frbus_ex2_data[SINGLE_WIDTH-1:0]  = ex2_result[SINGLE_WIDTH-1:0];
assign dp_frbus_ex2_fflags[4:0] = ex2_fflags[4:0];

endmodule



// ----- 8< ----- FILE "./pa_fpu_frbus.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module pa_fpu_frbus(
  ctrl_frbus_ex2_wb_req,
  dp_frbus_ex2_data,
  dp_frbus_ex2_fflags,
  fdsu_frbus_data,
  fdsu_frbus_fflags,
  fdsu_frbus_wb_vld,
  fpu_idu_fwd_data,
  fpu_idu_fwd_fflags,
  fpu_idu_fwd_vld
);

input           ctrl_frbus_ex2_wb_req;
input   [31:0]  dp_frbus_ex2_data;        
input   [4 :0]  dp_frbus_ex2_fflags;
input   [31:0]  fdsu_frbus_data;          
input   [4 :0]  fdsu_frbus_fflags;
input           fdsu_frbus_wb_vld;
output  [31:0]  fpu_idu_fwd_data;
output  [4 :0]  fpu_idu_fwd_fflags;
output          fpu_idu_fwd_vld;

reg     [31:0]  frbus_wb_data;            
reg     [4 :0]  frbus_wb_fflags;

wire            ctrl_frbus_ex2_wb_req;
wire    [31:0]  fdsu_frbus_data;          
wire    [4 :0]  fdsu_frbus_fflags;
wire            fdsu_frbus_wb_vld;
wire    [31:0]  fpu_idu_fwd_data;
wire    [4 :0]  fpu_idu_fwd_fflags;
wire            fpu_idu_fwd_vld;
wire            frbus_ex2_wb_vld;
wire            frbus_fdsu_wb_vld;
wire            frbus_wb_vld;
wire    [3 :0]  frbus_source_vld;


//==========================================================
//                   Input Signal Rename
//==========================================================
assign frbus_fdsu_wb_vld = fdsu_frbus_wb_vld;
assign frbus_ex2_wb_vld  = ctrl_frbus_ex2_wb_req;
assign frbus_source_vld[3:0]     = {1'b0, 1'b0, frbus_ex2_wb_vld, frbus_fdsu_wb_vld};
assign frbus_wb_vld = frbus_ex2_wb_vld | frbus_fdsu_wb_vld;

always @( frbus_source_vld[3:0]
       or fdsu_frbus_data[31:0]
       or dp_frbus_ex2_data[31:0]
       or fdsu_frbus_fflags[4:0]
       or dp_frbus_ex2_fflags[4:0])
begin
  case(frbus_source_vld[3:0])
    4'b0001: begin // DIV
      frbus_wb_data[31:0] = fdsu_frbus_data[31:0];
      frbus_wb_fflags[4:0]    = fdsu_frbus_fflags[4:0];
    end
    4'b0010: begin // EX2
      frbus_wb_data[31:0] = dp_frbus_ex2_data[31:0];
      frbus_wb_fflags[4:0]    = dp_frbus_ex2_fflags[4:0];
    end
    default: begin
      frbus_wb_data[31:0] = {31{1'b0}};
      frbus_wb_fflags[4:0]    = 5'b0;
    end
  endcase
end

assign fpu_idu_fwd_vld            = frbus_wb_vld;
assign fpu_idu_fwd_fflags[4:0]    = frbus_wb_fflags[4:0];
assign fpu_idu_fwd_data[31:0] = frbus_wb_data[31:0];

endmodule


// ----- 8< ----- FILE "./pa_fpu_src_type.v" ----- 8< -----

/*Copyright 2020-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module pa_fpu_src_type(
  inst_double,
  inst_single,
  src_cnan,
  src_id,
  src_in,
  src_inf,
  src_norm,
  src_qnan,
  src_snan,
  src_zero
);

// &Ports; @25
input           inst_double;  
input           inst_single;  
input   [63:0]  src_in;       
output          src_cnan;     
output          src_id;       
output          src_inf;      
output          src_norm;     
output          src_qnan;     
output          src_snan;     
output          src_zero;     

// &Regs; @26

// &Wires; @27
wire            inst_double;  
wire            inst_single;  
wire    [63:0]  src;          
wire            src_cnan;     
wire            src_expn_max; 
wire            src_expn_zero; 
wire            src_frac_msb; 
wire            src_frac_zero; 
wire            src_id;       
wire    [63:0]  src_in;       
wire            src_inf;      
wire            src_norm;     
wire            src_qnan;     
wire            src_snan;     
wire            src_zero;     


// &Depend("cpu_cfig.h"); @29
assign src[63:0] = src_in[63:0];

assign src_cnan  = !(&src[63:32]) && inst_single;

assign src_expn_zero = !(|src[62:52]) && inst_double ||
                       !(|src[30:23]) && inst_single;

assign src_expn_max  =  (&src[62:52]) && inst_double ||
                        (&src[30:23]) && inst_single;

assign src_frac_zero = !(|src[51:0]) && inst_double ||
                       !(|src[22:0]) && inst_single;

assign src_frac_msb  = src[51] && inst_double || src[22] && inst_single;

assign src_snan = src_expn_max  && !src_frac_msb && !src_frac_zero && !src_cnan;
assign src_qnan = src_expn_max  &&  src_frac_msb || src_cnan;
assign src_zero = src_expn_zero &&  src_frac_zero && !src_cnan;
assign src_id   = src_expn_zero && !src_frac_zero && !src_cnan;
assign src_inf  = src_expn_max  &&  src_frac_zero && !src_cnan;
assign src_norm =!(src_expn_zero && src_frac_zero) &&
                 ! src_expn_max  && !src_cnan;

// &Force("output","src_cnan"); @53

// &ModuleEnd; @55
endmodule



// ----- 8< ----- FILE "./fpnew_divsqrt_th_32.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019-2022 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Authors: Stefan Mach <smach@iis.ee.ethz.ch>
//          Luca Bertaccini <lbertaccini@iis.ee.ethz.ch>
//          Jiang Lannan <jiangl@ethz.ch>
//          Kexin Li <likexi@ethz.ch>



module fpnew_divsqrt_th_32 #(
  // FP32-only DivSqrt
  // FPU configuration
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = 32,
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [1:0][WIDTH-1:0]       operands_i, // 2 operands
  input  logic [NUM_FORMATS-1:0][1:0] is_boxed_i, // 2 operands
  input  fpnew_pkg::roundmode_e       rnd_mode_i,
  input  fpnew_pkg::operation_e       op_i,
  input  TagType                      tag_i,
  input  logic                        mask_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output fpnew_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output logic                        mask_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                        early_out_valid_o
);

  // ----------
  // Constants
  // ----------
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == fpnew_pkg::BEFORE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = (PipeConfig == fpnew_pkg::AFTER || PipeConfig == fpnew_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [1:0][WIDTH-1:0] operands_q;
  fpnew_pkg::roundmode_e rnd_mode_q;
  fpnew_pkg::operation_e op_q;
  logic                  in_valid_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0]       inp_pipe_operands_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign rnd_mode_q = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign op_q       = inp_pipe_op_q[NUM_INP_REGS];
  assign in_valid_q = inp_pipe_valid_q[NUM_INP_REGS];

  // ------------
  // Control FSM
  // ------------
  logic in_ready;               // input handshake with upstream
  logic div_op, sqrt_op;        // input signalling with unit
  logic unit_ready_q, unit_done;  // status signals from unit instance
  logic op_starting;            // high in the cycle a new operation starts
  logic out_valid, out_ready;   // output handshake with downstream
  logic hold_result;            // whether to put result into hold register
  logic data_is_held;           // data in hold register is valid
  logic unit_busy;              // valid data in flight
  // FSM states
  typedef enum logic [1:0] {IDLE, BUSY, HOLD, UNREACHABLE} fsm_state_e;
  fsm_state_e state_q, state_d;

  // Operations are gated by the FSM ready. Invalid input ops run a sqrt to not lose illegal instr.
  assign div_op   = in_valid_q & (op_q == fpnew_pkg::DIV) & in_ready & ~flush_i;  //in_ready delete, valid independent of ready
  assign sqrt_op  = in_valid_q & (op_q == fpnew_pkg::SQRT) & in_ready & ~flush_i;
  assign op_starting = div_op | sqrt_op;  //start computing or handshake, modify tb handshake right

  logic fdsu_fpu_ex1_stall, fdsu_fpu_ex1_stall_q;
  logic div_op_d, div_op_q;
  logic sqrt_op_d, sqrt_op_q;

  assign div_op_d  = (fdsu_fpu_ex1_stall) ? div_op  : 1'b0;
  assign sqrt_op_d = (fdsu_fpu_ex1_stall) ? sqrt_op : 1'b0;

  `FFL(fdsu_fpu_ex1_stall_q, fdsu_fpu_ex1_stall, 1'b1, '0)
  `FFL(div_op_q, div_op_d, 1'b1, '0)
  `FFL(sqrt_op_q, sqrt_op_d, 1'b1, '0)

  // FSM to safely apply and receive data from DIVSQRT unit
  always_comb begin : flag_fsm
    // Default assignments
    in_ready     = 1'b0;
    out_valid    = 1'b0;
    hold_result  = 1'b0;
    data_is_held = 1'b0;
    unit_busy    = 1'b0;
    state_d      = state_q;
    inp_pipe_ready[NUM_INP_REGS] = unit_ready_q;

    unique case (state_q)
      // Waiting for work
      IDLE: begin
        // in_ready = 1'b1; // we're ready
        in_ready = unit_ready_q;  //***
        if (in_valid_q && unit_ready_q) begin // New work arrives
          inp_pipe_ready[NUM_INP_REGS] = unit_ready_q && !fdsu_fpu_ex1_stall;
          state_d = BUSY; // go into processing state
        end
      end
      // Operation in progress
      BUSY: begin
        inp_pipe_ready[NUM_INP_REGS] = fdsu_fpu_ex1_stall_q;
        unit_busy = 1'b1; // data in flight
        // If the unit is done with processing
        if (unit_done) begin
          out_valid = 1'b1; // try to commit result downstream
          // If downstream accepts our result
          if (out_ready) begin
            state_d = IDLE; // we anticipate going back to idling..
            if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
              in_ready = 1'b1; // we acknowledge the instruction
              state_d  = BUSY; // and stay busy with it
            end
          // Otherwise if downstream is not ready for the result
          end else begin
            hold_result = 1'b1; // activate the hold register
            state_d     = HOLD; // wait for the pipeline to take the data
          end
        end
      end
      // Waiting with valid result for downstream
      HOLD: begin
        unit_busy    = 1'b1; // data in flight
        data_is_held = 1'b1; // data in hold register is valid
        out_valid    = 1'b1; // try to commit result downstream
        // If the result is accepted by downstream
        if (out_ready) begin
          state_d = IDLE; // go back to idle..
          if (in_valid_q && unit_ready_q) begin // ..unless new work comes in
            in_ready = 1'b1; // acknowledge the new transaction
            state_d  = BUSY; // will be busy with the next instruction
          end
        end
      end
      // fall into idle state otherwise
      default: state_d = IDLE;
    endcase

    // Flushing overrides the other actions
    if (flush_i) begin
      unit_busy = 1'b0; // data is invalidated
      out_valid = 1'b0; // cancel any valid data
      state_d   = IDLE; // go to default state
    end
  end

  // FSM status register (asynch active low reset)
  `FF(state_q, state_d, IDLE)

  // Hold additional information while the operation is in progress
  TagType result_tag_q;
  AuxType result_aux_q;
  logic   result_mask_q;

  // Fill the registers everytime a valid operation arrives (load FF, active low asynch rst)
  `FFL(result_tag_q,  inp_pipe_tag_q[NUM_INP_REGS],  op_starting, '0)
  `FFL(result_mask_q, inp_pipe_mask_q[NUM_INP_REGS], op_starting, '0)
  `FFL(result_aux_q,  inp_pipe_aux_q[NUM_INP_REGS],  op_starting, '0)

  // -----------------
  // DIVSQRT instance
  // -----------------
  logic [WIDTH-1:0]   unit_result, held_result_q;
  fpnew_pkg::status_t unit_status, held_status_q;

  // thead define fdsu module's input and output
  logic        ctrl_fdsu_ex1_sel;
  logic        fdsu_fpu_ex1_cmplt;
  logic  [4:0] fdsu_fpu_ex1_fflags;
  logic  [7:0] fdsu_fpu_ex1_special_sel;
  logic  [3:0] fdsu_fpu_ex1_special_sign;
  logic        fdsu_fpu_no_op;
  logic  [2:0] idu_fpu_ex1_eu_sel;
  logic [31:0] fdsu_frbus_data;
  logic  [4:0] fdsu_frbus_fflags;
  logic        fdsu_frbus_wb_vld;

  // dp
  logic [31:0] dp_frbus_ex2_data;
  logic  [4:0] dp_frbus_ex2_fflags;
  logic  [2:0] dp_xx_ex1_cnan;
  logic  [2:0] dp_xx_ex1_id;
  logic  [2:0] dp_xx_ex1_inf;
  logic  [2:0] dp_xx_ex1_norm;
  logic  [2:0] dp_xx_ex1_qnan;
  logic  [2:0] dp_xx_ex1_snan;
  logic  [2:0] dp_xx_ex1_zero;
  logic        ex2_inst_wb;
  logic        ex2_inst_wb_vld_d, ex2_inst_wb_vld_q;

  // frbus
  logic [31:0] fpu_idu_fwd_data;
  logic  [4:0] fpu_idu_fwd_fflags;
  logic        fpu_idu_fwd_vld;

  logic unit_ready_d;

  // unit_ready_q related to state machine, different under special and normal cases.
  always_comb begin
    if(op_starting && unit_ready_q) begin
      if(ex2_inst_wb && ex2_inst_wb_vld_q) begin
        unit_ready_d = 1'b1;
      end else begin
        unit_ready_d = 1'b0;
      end
    end else if(fpu_idu_fwd_vld | flush_i) begin
      unit_ready_d = 1'b1;
    end else begin
      unit_ready_d = unit_ready_q;
    end
  end

  `FFL(unit_ready_q, unit_ready_d, 1'b1, 1'b1)

  // determine input of time to select operands
  always_comb begin
    ctrl_fdsu_ex1_sel = 1'b0;
    idu_fpu_ex1_eu_sel = 3'h0;
    if (op_starting) begin  // time to start calculation
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else if (fdsu_fpu_ex1_stall_q) begin
      ctrl_fdsu_ex1_sel = 1'b1;  // time to select operands
      idu_fpu_ex1_eu_sel = 3'h4; // time to select operands, only idu_fpu_ex1_eu_sel_i[2] works in fdsu module
    end else begin
      ctrl_fdsu_ex1_sel = 1'b0;
      idu_fpu_ex1_eu_sel = 3'h0;
    end
  end

  pa_fdsu_top i_divsqrt_thead (
   .cp0_fpu_icg_en                ( 1'b0               ),  // input clock gate enable in gated_clk_cell, active 0.
   .cp0_fpu_xx_dqnan              ( 1'b0               ),  // When dqnan = 0, QNAN (0x7fc00000).
   .cp0_yy_clk_en                 ( 1'b1               ),  // clock enable in gated_clk_cell, active 1.
   .cpurst_b                      ( rst_ni             ),  // If negedge cpu reset, all state machines reset to IDLE.
   .ctrl_fdsu_ex1_sel             ( ctrl_fdsu_ex1_sel  ),  // select operands
   .ctrl_xx_ex1_cmplt_dp          ( ctrl_fdsu_ex1_sel  ),  // complete datapath
   .ctrl_xx_ex1_inst_vld          ( ctrl_fdsu_ex1_sel  ),  // instance valid
   .ctrl_xx_ex1_stall             ( fdsu_fpu_ex1_stall ),
   .ctrl_xx_ex1_warm_up           ( 1'b0               ),
   .ctrl_xx_ex2_warm_up           ( 1'b0               ),
   .ctrl_xx_ex3_warm_up           ( 1'b0               ),
   .dp_xx_ex1_cnan                ( dp_xx_ex1_cnan     ),  // Special input type determination
   .dp_xx_ex1_id                  ( dp_xx_ex1_id       ),
   .dp_xx_ex1_inf                 ( dp_xx_ex1_inf      ),
   .dp_xx_ex1_qnan                ( dp_xx_ex1_qnan     ),
   .dp_xx_ex1_rm                  ( rnd_mode_q         ),  // rounding mode
   .dp_xx_ex1_snan                ( dp_xx_ex1_snan     ),
   .dp_xx_ex1_zero                ( dp_xx_ex1_zero     ),
   .fdsu_fpu_debug_info           (                    ),  // output, not used
   .fdsu_fpu_ex1_cmplt            ( fdsu_fpu_ex1_cmplt ),  // output, ctrl_xx_ex1_cmplt_dp && idu_fpu_ex1_eu_sel_i[2]
   .fdsu_fpu_ex1_cmplt_dp         (                    ),  // output, not used
   .fdsu_fpu_ex1_fflags           ( fdsu_fpu_ex1_fflags       ),  // output, special case fflags
   .fdsu_fpu_ex1_special_sel      ( fdsu_fpu_ex1_special_sel  ),  // output, special case type selection
   .fdsu_fpu_ex1_special_sign     ( fdsu_fpu_ex1_special_sign ),  // output, special case sign determination
   .fdsu_fpu_ex1_stall            ( fdsu_fpu_ex1_stall        ),  // output, determine whether stall in ex1
   .fdsu_fpu_no_op                ( fdsu_fpu_no_op            ),  // output, if Write Back SM and fdsu SM no operation, fdsu_fpu_no_op = 1; Otherwise if busy, fdsu_fpu_no_op = 0. (not used)
   .fdsu_frbus_data               ( fdsu_frbus_data           ),  // output, normal case result
   .fdsu_frbus_fflags             ( fdsu_frbus_fflags         ),  // output, normal case fflags
   .fdsu_frbus_freg               (                           ),  // output, determined by input idu_fpu_ex1_dst_freg
   .fdsu_frbus_wb_vld             ( fdsu_frbus_wb_vld         ),  // output, determine whether write back valid
   .forever_cpuclk                ( clk_i                     ),
   .frbus_fdsu_wb_grant           ( fdsu_frbus_wb_vld         ),  // input is fdsu_frbus_wb_vld
   .idu_fpu_ex1_dst_freg          ( 5'h0f                     ),  // register index to write back (not used)
   .idu_fpu_ex1_eu_sel            ( idu_fpu_ex1_eu_sel        ),  // time to select operands
   .idu_fpu_ex1_func              ( {8'b0, div_op | div_op_q, sqrt_op | sqrt_op_q} ),
   .idu_fpu_ex1_srcf0             ( operands_q[0][31:0]       ),  // the first operand
   .idu_fpu_ex1_srcf1             ( operands_q[1][31:0]       ),  // the second operand
   .pad_yy_icg_scan_en            ( 1'b0                      ),  // input of core_top, set to 1'b0 from the beginning to end
   .rtu_xx_ex1_cancel             ( 1'b0                      ),
   .rtu_xx_ex2_cancel             ( 1'b0                      ),
   .rtu_yy_xx_async_flush         ( flush_i                   ),
   .rtu_yy_xx_flush               ( 1'b0                      )
  );

  pa_fpu_dp  x_pa_fpu_dp (
    .cp0_fpu_icg_en              ( 1'b0                       ),
    .cp0_fpu_xx_rm               ( rnd_mode_q                 ),
    .cp0_yy_clk_en               ( 1'b1                       ),
    .ctrl_xx_ex1_inst_vld        ( ctrl_fdsu_ex1_sel          ),
    .ctrl_xx_ex1_stall           ( 1'b0                       ),
    .ctrl_xx_ex1_warm_up         ( 1'b0                       ),
    .dp_frbus_ex2_data           ( dp_frbus_ex2_data          ),  // output
    .dp_frbus_ex2_fflags         ( dp_frbus_ex2_fflags        ),  // output
    .dp_xx_ex1_cnan              ( dp_xx_ex1_cnan             ),  // output
    .dp_xx_ex1_id                ( dp_xx_ex1_id               ),  // output
    .dp_xx_ex1_inf               ( dp_xx_ex1_inf              ),  // output
    .dp_xx_ex1_norm              ( dp_xx_ex1_norm             ),  // output
    .dp_xx_ex1_qnan              ( dp_xx_ex1_qnan             ),  // output
    .dp_xx_ex1_snan              ( dp_xx_ex1_snan             ),  // output
    .dp_xx_ex1_zero              ( dp_xx_ex1_zero             ),  // output
    .ex2_inst_wb                 ( ex2_inst_wb                ),  // output
    .fdsu_fpu_ex1_fflags         ( fdsu_fpu_ex1_fflags        ),
    .fdsu_fpu_ex1_special_sel    ( fdsu_fpu_ex1_special_sel   ),
    .fdsu_fpu_ex1_special_sign   ( fdsu_fpu_ex1_special_sign  ),
    .forever_cpuclk              ( clk_i                      ),
    .idu_fpu_ex1_eu_sel          ( idu_fpu_ex1_eu_sel         ),
    .idu_fpu_ex1_func            ( {8'b0, div_op, sqrt_op}    ),
    .idu_fpu_ex1_gateclk_vld     ( fdsu_fpu_ex1_cmplt         ),
    .idu_fpu_ex1_rm              ( rnd_mode_q                 ),
    .idu_fpu_ex1_srcf0           ( operands_q[0][31:0]        ),
    .idu_fpu_ex1_srcf1           ( operands_q[1][31:0]        ),
    .idu_fpu_ex1_srcf2           ( '0                         ),
    .pad_yy_icg_scan_en          ( 1'b0                       )
  );

  assign ex2_inst_wb_vld_d = ctrl_fdsu_ex1_sel;
  `FF(ex2_inst_wb_vld_q, ex2_inst_wb_vld_d, '0)

  pa_fpu_frbus x_pa_fpu_frbus (
    .ctrl_frbus_ex2_wb_req     ( ex2_inst_wb & ex2_inst_wb_vld_q ),
    .dp_frbus_ex2_data         ( dp_frbus_ex2_data   ),
    .dp_frbus_ex2_fflags       ( dp_frbus_ex2_fflags ),
    .fdsu_frbus_data           ( fdsu_frbus_data     ),
    .fdsu_frbus_fflags         ( fdsu_frbus_fflags   ),
    .fdsu_frbus_wb_vld         ( fdsu_frbus_wb_vld   ),
    .fpu_idu_fwd_data          ( fpu_idu_fwd_data    ),  // output
    .fpu_idu_fwd_fflags        ( fpu_idu_fwd_fflags  ),  // output
    .fpu_idu_fwd_vld           ( fpu_idu_fwd_vld     )   // output
  );

  always_comb begin
    unit_result[31:0] = fpu_idu_fwd_data[31:0];
    unit_status[4:0]  = fpu_idu_fwd_fflags[4:0];
    unit_done         = fpu_idu_fwd_vld;
  end

  // The Hold register (load, no reset)
  `FFLNR(held_result_q, unit_result, hold_result, clk_i)
  `FFLNR(held_status_q, unit_status, hold_result, clk_i)

  // --------------
  // Output Select
  // --------------
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;
  // Prioritize hold register data
  assign result_d = data_is_held ? held_result_q : unit_result;
  assign status_d = data_is_held ? held_status_q : unit_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = result_tag_q;
  assign out_pipe_mask_q[0]   = result_mask_q;
  assign out_pipe_aux_q[0]    = result_aux_q;
  assign out_pipe_valid_q[0]  = out_valid;
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign out_ready = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, unit_busy, out_pipe_valid_q});

  // Early valid_o signal. This is used for dispatching instructions for dual-issue processor.
  if (NUM_OUT_REGS > 0) begin
    assign early_out_valid_o = |{out_pipe_valid_q[NUM_OUT_REGS] & ~out_pipe_ready[NUM_OUT_REGS],
                                 out_pipe_valid_q[NUM_OUT_REGS-1]};
  end else if (NUM_INP_REGS > 0) begin
    assign early_out_valid_o = |{inp_pipe_valid_q[NUM_INP_REGS] & ~inp_pipe_ready[NUM_INP_REGS],
                                 inp_pipe_valid_q[NUM_INP_REGS-1]};
  end else begin
    assign early_out_valid_o = 1'b0;
  end
endmodule
// ----- 8< ----- FILE "./fpnew_fma.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_fma #(
  parameter fpnew_pkg::fp_format_e   FpFormat    = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat),
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                      clk_i,
  input logic                      rst_ni,
  // Input signals
  input logic [2:0][WIDTH-1:0]     operands_i, // 3 operands
  input logic [2:0]                is_boxed_i, // 3 operands
  input fpnew_pkg::roundmode_e     rnd_mode_i,
  input fpnew_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input logic                      mask_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output fpnew_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output TagType                   tag_o,
  output logic                     mask_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                     early_out_valid_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);
  localparam int unsigned BIAS     = fpnew_pkg::bias(FpFormat);
  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the LZC result.
  // In most reasonable FP formats the internal exponent will be wider than the LZC result.
  localparam int unsigned EXP_WIDTH = unsigned'(fpnew_pkg::maximum(EXP_BITS + 2, LZC_RESULT_WIDTH));
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][2:0]            inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // -----------------
  // Input processing
  // -----------------
  fpnew_pkg::fp_info_t [2:0] info_q;

  // Classify input
  fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 3        )
    ) i_class_inputs (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b, operand_c;
  fpnew_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD      | \c 0        | ADD: Set operand A to +1.0
  // | ADD      | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0 or -0.0 depending on the rounding mode
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
    operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
    operand_c = inp_pipe_operands_q[NUM_INP_REGS][2];
    info_a    = info_q[0];
    info_b    = info_q[1];
    info_c    = info_q[2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::FMADD:  ; // do nothing
      fpnew_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      fpnew_pkg::ADD,
      fpnew_pkg::ADDS: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: BIAS, mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      fpnew_pkg::MUL: begin // Set addend to +0 or -0, depending whether the rounding mode is RDN
        if (inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN)
          operand_c = '{sign: 1'b0, exponent: '0, mantissa: '0};
        else
          operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: fpnew_pkg::DONT_CARE};
        operand_b  = '{default: fpnew_pkg::DONT_CARE};
        operand_c  = '{default: fpnew_pkg::DONT_CARE};
        info_a     = '{default: fpnew_pkg::DONT_CARE};
        info_b     = '{default: fpnew_pkg::DONT_CARE};
        info_c     = '{default: fpnew_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  fp_t                special_result;
  fpnew_pkg::status_t special_status;
  logic               result_is_special;

  always_comb begin : special_cases
    // Default assignments
    special_result    = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    special_status    = '0;
    result_is_special = 1'b0;

    // Handle potentially mixed nan & infinity input => important for the case where infinity and
    // zero are multiplied and added to a qnan.
    // RISC-V mandates raising the NV exception in these cases:
    // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
    if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
      result_is_special = 1'b1; // bypass FMA, output is the canonical qNaN
      special_status.NV = 1'b1; // invalid operation
    // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
    end else if (any_operand_nan) begin
      result_is_special = 1'b1;           // bypass FMA, output is the canonical qNaN
      special_status.NV = signalling_nan; // raise the invalid operation flag if signalling
    // Special cases involving infinity
    end else if (any_operand_inf) begin
      result_is_special = 1'b1; // bypass FMA
      // Effective addition of opposite infinities (??inf - ??inf) is invalid!
      if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
        special_status.NV = 1'b1; // invalid operation
      // Handle cases where output will be inf because of inf product input
      else if (info_a.is_inf || info_b.is_inf) begin
        // Result is infinity with the sign of the product
        special_result    = '{sign: operand_a.sign ^ operand_b.sign, exponent: '1, mantissa: '0};
      // Handle cases where the addend is inf
      end else if (info_c.is_inf) begin
        // Result is inifinity with sign of the addend (= operand_c)
        special_result    = '{sign: operand_c.sign, exponent: '1, mantissa: '0};
      end
    end
  end

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents stay biased.
  assign exponent_addend = signed'(exponent_c + $signed({1'b0, ~info_c.is_normal})); // 0 as subnorm
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero)
                            ? 2 - signed'(BIAS) // in case the product is zero, set minimum exp.
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - signed'(BIAS));
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;
  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend : exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // ------------------
  // Product data path
  // ------------------
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  assign product = mantissa_a * mantissa_b;

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift

  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits
  // are shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);
  // assign addend_after_shift[0] = sticky_before_add;

  // In case of a subtraction, the addend is inverted
  assign addend_shifted  = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_pos, sum_neg; // added one bit for the carry
  logic                        sum_carry;        // observe carry bit from positive sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;              // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_pos = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_pos[3*PRECISION_BITS+4];

  // Parallel adder for negative sum (only used for effective subtractions).
  // Note: inject_carry_in is used to complete the negation of the addend in the positive sum but
  // for the negative sum the addend is not negated, so no carry needs to be injected.
  assign sum_neg = addend_after_shift - product_shifted;

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? sum_neg : sum_pos;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  fpnew_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  fpnew_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  fpnew_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  fpnew_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_mask_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]        = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],        mid_pipe_mask_q[i],        reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and LZC (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require LZC
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS) + 2 + exponent_product_q);
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                         pre_round_sign;
  logic [EXP_BITS-1:0]          pre_round_exponent;
  logic [MAN_BITS-1:0]          pre_round_mantissa;
  logic [EXP_BITS+MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                   round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow
  logic result_zero;

  logic                         rounded_sign;
  logic [EXP_BITS+MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(EXP_BITS)-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : unsigned'(final_exponent[EXP_BITS-1:0]);
  assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[MAN_BITS:1]; // bit 0 is R bit
  assign pre_round_abs      = {pre_round_exponent, pre_round_mantissa};

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = (of_before_round) ? 2'b11 : {final_mantissa[0], sticky_after_norm};

  // Perform the rounding
  fpnew_rounding #(
    .AbsWidth ( EXP_BITS + MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             )
  );

  // Classification after rounding
  assign uf_after_round = (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) // denormal
        || ((pre_round_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) && (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == 1) &&
           ((round_sticky_bits != 2'b11) || (!sum_sticky_bits[MAN_BITS*2 + 4] && ((rnd_mode_q == fpnew_pkg::RNE) || (rnd_mode_q == fpnew_pkg::RMM)))));
  assign of_after_round = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // exponent all ones

  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  fpnew_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result    = {rounded_sign, rounded_abs};
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  fp_t                result_d;
  fpnew_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                [0:NUM_OUT_REGS] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS] out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS] out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS] out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]   = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});

  // Early valid_o signal. This is used for dispatching instructions for dual-issue processor.
  if (NUM_OUT_REGS > 0) begin
    assign early_out_valid_o = |{out_pipe_valid_q[NUM_OUT_REGS] & ~out_pipe_ready[NUM_OUT_REGS],
                                 out_pipe_valid_q[NUM_OUT_REGS-1]};
  end else if (NUM_MID_REGS > 0) begin
    assign early_out_valid_o = |{mid_pipe_valid_q[NUM_MID_REGS] & ~mid_pipe_ready[NUM_OUT_REGS],
                                 mid_pipe_valid_q[NUM_MID_REGS-1]};
  end else if (NUM_INP_REGS > 0) begin
    assign early_out_valid_o = |{inp_pipe_valid_q[NUM_INP_REGS] & ~inp_pipe_ready[NUM_INP_REGS],
                                 inp_pipe_valid_q[NUM_INP_REGS-1]};
  end else begin
    assign early_out_valid_o = 1'b0;
  end
endmodule
// ----- 8< ----- FILE "./fpnew_fma_multi.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_fma_multi #(
  parameter fpnew_pkg::fmt_logic_t   FpFmtConfig = '1,
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH       = fpnew_pkg::max_fp_width(FpFmtConfig),
  localparam int unsigned NUM_FORMATS = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input  logic                        clk_i,
  input  logic                        rst_ni,
  // Input signals
  input  logic [2:0][WIDTH-1:0]       operands_i, // 3 operands
  input  logic [NUM_FORMATS-1:0][2:0] is_boxed_i, // 3 operands
  input  fpnew_pkg::roundmode_e       rnd_mode_i,
  input  fpnew_pkg::operation_e       op_i,
  input  logic                        op_mod_i,
  input  fpnew_pkg::fp_format_e       src_fmt_i,  // format of the multiplicands
  input  fpnew_pkg::fp_format_e       src2_fmt_i, // format of the addend
  input  fpnew_pkg::fp_format_e       dst_fmt_i,  // format of the result
  input  TagType                      tag_i,
  input  logic                        mask_i,
  input  AuxType                      aux_i,
  // Input Handshake
  input  logic                        in_valid_i,
  output logic                        in_ready_o,
  input  logic                        flush_i,
  // Output signals
  output logic [WIDTH-1:0]            result_o,
  output fpnew_pkg::status_t          status_o,
  output logic                        extension_bit_o,
  output TagType                      tag_o,
  output logic                        mask_o,
  output AuxType                      aux_o,
  // Output handshake
  output logic                        out_valid_o,
  input  logic                        out_ready_i,
  // Indication of valid data in flight
  output logic                        busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]   reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                        early_out_valid_o
);

  // ----------
  // Constants
  // ----------
  // The super-format that can hold all formats
  localparam fpnew_pkg::fp_encoding_t SUPER_FORMAT = fpnew_pkg::super_format(FpFmtConfig);

  localparam int unsigned SUPER_EXP_BITS = SUPER_FORMAT.exp_bits;
  localparam int unsigned SUPER_MAN_BITS = SUPER_FORMAT.man_bits;

  // Precision bits 'p' include the implicit bit
  localparam int unsigned PRECISION_BITS = SUPER_MAN_BITS + 1;
  // The lower 2p+3 bits of the internal FMA result will be needed for leading-zero detection
  localparam int unsigned LOWER_SUM_WIDTH  = 2 * PRECISION_BITS + 3;
  localparam int unsigned LZC_RESULT_WIDTH = $clog2(LOWER_SUM_WIDTH);
  // Internal exponent width of FMA must accomodate all meaningful exponent values in order to avoid
  // datapath leakage. This is either given by the exponent bits or the width of the LZC result.
  // In most reasonable FP formats the internal exponent will be wider than the LZC result.
  localparam int unsigned EXP_WIDTH = fpnew_pkg::maximum(SUPER_EXP_BITS + 2, LZC_RESULT_WIDTH);
  // Shift amount width: maximum internal mantissa size is 3p+4 bits
  localparam int unsigned SHIFT_AMOUNT_WIDTH = $clog2(3 * PRECISION_BITS + 5);
  // Pipelines
  localparam NUM_INP_REGS = PipeConfig == fpnew_pkg::BEFORE
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 3) // Second to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_MID_REGS = PipeConfig == fpnew_pkg::INSIDE
                          ? NumPipeRegs
                          : (PipeConfig == fpnew_pkg::DISTRIBUTED
                             ? ((NumPipeRegs + 2) / 3) // First to get distributed regs
                             : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 3) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                      sign;
    logic [SUPER_EXP_BITS-1:0] exponent;
    logic [SUPER_MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Selected pipeline output signals as non-arrays
  logic [2:0][WIDTH-1:0] operands_q;
  fpnew_pkg::fp_format_e src_fmt_q;
  fpnew_pkg::fp_format_e src2_fmt_q;
  fpnew_pkg::fp_format_e dst_fmt_q;

  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][2:0][WIDTH-1:0]       inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][NUM_FORMATS-1:0][2:0] inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                       inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                       inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_op_mod_q;
  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src_fmt_q;
  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_src2_fmt_q;
  fpnew_pkg::fp_format_e [0:NUM_INP_REGS]                       inp_pipe_dst_fmt_q;
  TagType                [0:NUM_INP_REGS]                       inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                       inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                       inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_src_fmt_q[0]  = src_fmt_i;
  assign inp_pipe_src2_fmt_q[0] = src2_fmt_i;
  assign inp_pipe_dst_fmt_q[0]  = dst_fmt_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_src_fmt_q[i+1],  inp_pipe_src_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_src2_fmt_q[i+1], inp_pipe_src2_fmt_q[i], reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_dst_fmt_q[i+1],  inp_pipe_dst_fmt_q[i],  reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign operands_q = inp_pipe_operands_q[NUM_INP_REGS];
  assign src_fmt_q  = inp_pipe_src_fmt_q[NUM_INP_REGS];
  assign src2_fmt_q = inp_pipe_src2_fmt_q[NUM_INP_REGS];
  assign dst_fmt_q  = inp_pipe_dst_fmt_q[NUM_INP_REGS];

  // -----------------
  // Input processing
  // -----------------
  logic        [NUM_FORMATS-1:0][2:0]                     fmt_sign;
  logic signed [NUM_FORMATS-1:0][2:0][SUPER_EXP_BITS-1:0] fmt_exponent;
  logic        [NUM_FORMATS-1:0][2:0][SUPER_MAN_BITS-1:0] fmt_mantissa;

  fpnew_pkg::fp_info_t [NUM_FORMATS-1:0][2:0] info_q;

  // FP Input initialization
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : fmt_init_inputs
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      localparam fpnew_pkg::fp_format_e FpFormat = fpnew_pkg::fp_format_e'(fmt);
      logic [2:0][FP_WIDTH-1:0] trimmed_ops;

      // Classify input
      fpnew_classifier #(
        .FpFormat    ( FpFormat ),
        .NumOperands ( 3        )
      ) i_fpnew_classifier (
        .operands_i ( trimmed_ops                            ),
        .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS][fmt] ),
        .info_o     ( info_q[fmt]                            )
      );
      for (genvar op = 0; op < 3; op++) begin : gen_operands
        assign trimmed_ops[op]       = operands_q[op][FP_WIDTH-1:0];
        assign fmt_sign[fmt][op]     = operands_q[op][FP_WIDTH-1];
        assign fmt_exponent[fmt][op] = signed'({1'b0, operands_q[op][MAN_BITS+:EXP_BITS]});
        assign fmt_mantissa[fmt][op] = {info_q[fmt][op].is_normal, operands_q[op][MAN_BITS-1:0]} <<
                                       (SUPER_MAN_BITS - MAN_BITS); // move to left of mantissa
      end
    end else begin : inactive_format
      assign info_q[fmt]                 = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_sign[fmt]               = fpnew_pkg::DONT_CARE;             // format disabled
      assign fmt_exponent[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
      assign fmt_mantissa[fmt]           = '{default: fpnew_pkg::DONT_CARE}; // format disabled
    end
  end

  fp_t                 operand_a, operand_b, operand_c;
  fpnew_pkg::fp_info_t info_a,    info_b,    info_c;

  // Operation selection and operand adjustment
  // | \c op_q  | \c op_mod_q | Operation Adjustment
  // |:--------:|:-----------:|---------------------
  // | FMADD    | \c 0        | FMADD: none
  // | FMADD    | \c 1        | FMSUB: Invert sign of operand C
  // | FNMSUB   | \c 0        | FNMSUB: Invert sign of operand A
  // | FNMSUB   | \c 1        | FNMADD: Invert sign of operands A and C
  // | ADD/ADDS | \c 0        | ADD: Set operand A to +1.0
  // | ADD/ADDS | \c 1        | SUB: Set operand A to +1.0, invert sign of operand C
  // | MUL      | \c 0        | MUL: Set operand C to +0.0 or -0.0 depending on the rounding mode
  // | *others* | \c -        | *invalid*
  // \note \c op_mod_q always inverts the sign of the addend.
  always_comb begin : op_select

    // Default assignments - packing-order-agnostic
    operand_a = {fmt_sign[src_fmt_q ][0], fmt_exponent[src_fmt_q ][0], fmt_mantissa[src_fmt_q ][0]};
    operand_b = {fmt_sign[src_fmt_q ][1], fmt_exponent[src_fmt_q ][1], fmt_mantissa[src_fmt_q ][1]};
    operand_c = {fmt_sign[src2_fmt_q][2], fmt_exponent[src2_fmt_q][2], fmt_mantissa[src2_fmt_q][2]};
    info_a    = info_q[src_fmt_q ][0];
    info_b    = info_q[src_fmt_q ][1];
    info_c    = info_q[src2_fmt_q][2];

    // op_mod_q inverts sign of operand C
    operand_c.sign = operand_c.sign ^ inp_pipe_op_mod_q[NUM_INP_REGS];

    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::FMADD:  ; // do nothing
      fpnew_pkg::FNMSUB: operand_a.sign = ~operand_a.sign; // invert sign of product
      fpnew_pkg::ADD,
      fpnew_pkg::ADDS: begin // Set multiplicand to +1
        operand_a = '{sign: 1'b0, exponent: fpnew_pkg::bias(src_fmt_q), mantissa: '0};
        info_a    = '{is_normal: 1'b1, is_boxed: 1'b1, default: 1'b0}; //normal, boxed value.
      end
      fpnew_pkg::MUL: begin // Set addend to +0 or -0, depending whether the rounding mode is RDN
        if (inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN)
          operand_c = '{sign: 1'b0, exponent: '0, mantissa: '0};
        else
          operand_c = '{sign: 1'b1, exponent: '0, mantissa: '0};
        info_c    = '{is_zero: 1'b1, is_boxed: 1'b1, default: 1'b0}; //zero, boxed value.
      end
      default: begin // propagate don't cares
        operand_a  = '{default: fpnew_pkg::DONT_CARE};
        operand_b  = '{default: fpnew_pkg::DONT_CARE};
        operand_c  = '{default: fpnew_pkg::DONT_CARE};
        info_a     = '{default: fpnew_pkg::DONT_CARE};
        info_b     = '{default: fpnew_pkg::DONT_CARE};
        info_c     = '{default: fpnew_pkg::DONT_CARE};
      end
    endcase
  end

  // ---------------------
  // Input classification
  // ---------------------
  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;
  logic effective_subtraction;
  logic tentative_sign;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf,        info_c.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan,        info_c.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling, info_c.is_signalling});
  // Effective subtraction in FMA occurs when product and addend signs differ
  assign effective_subtraction = operand_a.sign ^ operand_b.sign ^ operand_c.sign;
  // The tentative sign of the FMA shall be the sign of the product
  assign tentative_sign = operand_a.sign ^ operand_b.sign;

  // ----------------------
  // Special case handling
  // ----------------------
  logic [WIDTH-1:0]   special_result;
  fpnew_pkg::status_t special_status;
  logic               result_is_special;

  logic [NUM_FORMATS-1:0][WIDTH-1:0]    fmt_special_result;
  fpnew_pkg::status_t [NUM_FORMATS-1:0] fmt_special_status;
  logic [NUM_FORMATS-1:0]               fmt_result_is_special;


  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_special_results
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    localparam logic [EXP_BITS-1:0] QNAN_EXPONENT = '1;
    localparam logic [MAN_BITS-1:0] QNAN_MANTISSA = 2**(MAN_BITS-1);
    localparam logic [MAN_BITS-1:0] ZERO_MANTISSA = '0;

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : special_results
        logic [FP_WIDTH-1:0] special_res;

        // Default assignment
        special_res                = {1'b0, QNAN_EXPONENT, QNAN_MANTISSA}; // qNaN
        fmt_special_status[fmt]    = '0;
        fmt_result_is_special[fmt] = 1'b0;

        // Handle potentially mixed nan & infinity input => important for the case where infinity and
        // zero are multiplied and added to a qnan.
        // RISC-V mandates raising the NV exception in these cases:
        // (inf * 0) + c or (0 * inf) + c INVALID, no matter c (even quiet NaNs)
        if ((info_a.is_inf && info_b.is_zero) || (info_a.is_zero && info_b.is_inf)) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = 1'b1; // invalid operation
        // NaN Inputs cause canonical quiet NaN at the output and maybe invalid OP
        end else if (any_operand_nan) begin
          fmt_result_is_special[fmt] = 1'b1;           // bypass FMA, output is the canonical qNaN
          fmt_special_status[fmt].NV = signalling_nan; // raise the invalid operation flag if signalling
        // Special cases involving infinity
        end else if (any_operand_inf) begin
          fmt_result_is_special[fmt] = 1'b1; // bypass FMA
          // Effective addition of opposite infinities (??inf - ??inf) is invalid!
          if ((info_a.is_inf || info_b.is_inf) && info_c.is_inf && effective_subtraction)
            fmt_special_status[fmt].NV = 1'b1; // invalid operation
          // Handle cases where output will be inf because of inf product input
          else if (info_a.is_inf || info_b.is_inf) begin
            // Result is infinity with the sign of the product
            special_res = {operand_a.sign ^ operand_b.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          // Handle cases where the addend is inf
          end else if (info_c.is_inf) begin
            // Result is inifinity with sign of the addend (= operand_c)
            special_res = {operand_c.sign, QNAN_EXPONENT, ZERO_MANTISSA};
          end
        end
        // Initialize special result with ones (NaN-box)
        fmt_special_result[fmt]               = '1;
        fmt_special_result[fmt][FP_WIDTH-1:0] = special_res;
      end
    end else begin : inactive_format
      assign fmt_special_result[fmt] = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_special_status[fmt] = '0;
      assign fmt_result_is_special[fmt] = 1'b0;
    end
  end

  // Detect special case from source format, I2F casts don't produce a special result
  assign result_is_special = fmt_result_is_special[dst_fmt_q]; // they're all the same
  // Signalling input NaNs raise invalid flag, otherwise no flags set
  assign special_status = fmt_special_status[dst_fmt_q];
  // Assemble result according to destination format
  assign special_result = fmt_special_result[dst_fmt_q]; // destination format

  // ---------------------------
  // Initial exponent data path
  // ---------------------------
  logic signed [EXP_WIDTH-1:0] exponent_a, exponent_b, exponent_c;
  logic signed [EXP_WIDTH-1:0] exponent_addend, exponent_product, exponent_difference;
  logic signed [EXP_WIDTH-1:0] tentative_exponent;

  // Zero-extend exponents into signed container - implicit width extension
  assign exponent_a = signed'({1'b0, operand_a.exponent});
  assign exponent_b = signed'({1'b0, operand_b.exponent});
  assign exponent_c = signed'({1'b0, operand_c.exponent});

  // Calculate internal exponents from encoded values. Real exponents are (ex = Ex - bias + 1 - nx)
  // with Ex the encoded exponent and nx the implicit bit. Internal exponents are biased to dst fmt.
  assign exponent_addend = info_c.is_zero ? 1 // in case the addend is zero, set minimum exp
                           : signed'(exponent_c + $signed({1'b0, ~info_c.is_normal}) // 0 as subnorm
                                     - signed'(fpnew_pkg::bias(src2_fmt_q))
                                     + signed'(fpnew_pkg::bias(dst_fmt_q))); // rebias for dst fmt
  // Biased product exponent is the sum of encoded exponents minus the bias.
  assign exponent_product = (info_a.is_zero || info_b.is_zero) // in case the product is zero, set minimum exp.
                            ? 2 - signed'(fpnew_pkg::bias(dst_fmt_q))
                            : signed'(exponent_a + info_a.is_subnormal
                                      + exponent_b + info_b.is_subnormal
                                      - 2*signed'(fpnew_pkg::bias(src_fmt_q))
                                      + signed'(fpnew_pkg::bias(dst_fmt_q))); // rebias for dst fmt
  // Exponent difference is the addend exponent minus the product exponent
  assign exponent_difference = exponent_addend - exponent_product;

  // Shift amount for addend based on exponents (unsigned as only right shifts)
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt;

  always_comb begin : addend_shift_amount
    // Product-anchored case, saturated shift (addend is only in the sticky bit)
    if (exponent_difference <= signed'(-2 * PRECISION_BITS - 1))
      addend_shamt = 3 * PRECISION_BITS + 4;
    // Addend and product will have mutual bits to add
    else if (exponent_difference <= signed'(PRECISION_BITS + 2))
      addend_shamt = unsigned'(signed'(PRECISION_BITS) + 3 - exponent_difference);
    // Addend-anchored case, saturated shift (product is only in the sticky bit)
    else
      addend_shamt = 0;
  end

  // LZC for addend normalization
  logic        [$clog2(SUPER_MAN_BITS)-1:0] addend_lzc_count;
  logic        [$clog2(SUPER_MAN_BITS)  :0] addend_lzc_count_sgn;
  logic        [SHIFT_AMOUNT_WIDTH    -1:0] addend_normalize_shamt;

  // Leading zero counter for addend normalization
  lzc #(
    .WIDTH ( SUPER_MAN_BITS ),
    .MODE  ( 1              ) // MODE = 1 counts leading zeroes
  ) i_addend_lzc (
    .in_i    ( operand_c.mantissa ),
    .cnt_o   ( addend_lzc_count   ),
    .empty_o (                    )
  );

  assign addend_lzc_count_sgn = signed'({1'b0, addend_lzc_count});

  // Determine addend normalization shift amount (used for sum shifting in addend-ancored case)
  always_comb begin
    // normal or zero addend
    if (info_c.is_normal || info_c.is_zero) begin
      addend_normalize_shamt = 0;
    // subnormal and will still be subnormal in destination format (no positive rebias added to exponent)
    end else if (exponent_addend <= 1) begin
      addend_normalize_shamt = 0;
    // subnormal and will likely be normal in destination format in addend-anchored case
    end else if (addend_lzc_count_sgn + 1 < exponent_addend) begin
      addend_normalize_shamt = addend_lzc_count + 1;
    // subnormal and will still be subnormal in destination format (insufficient positive rebias added to exponent)
    end else begin
      addend_normalize_shamt = exponent_addend - 1;
    end
  end

  // The tentative exponent will be the larger of the product or addend exponent
  assign tentative_exponent = (exponent_difference > 0) ? exponent_addend - addend_normalize_shamt : exponent_product;

  // ------------------
  // Product data path
  // ------------------
  logic [PRECISION_BITS-1:0]   mantissa_a, mantissa_b, mantissa_c;
  logic [2*PRECISION_BITS-1:0] product;             // the p*p product is 2p bits wide
  logic [3*PRECISION_BITS+3:0] product_shifted;     // addends are 3p+4 bit wide (including G/R)

  // Add implicit bits to mantissae
  assign mantissa_a = {info_a.is_normal, operand_a.mantissa};
  assign mantissa_b = {info_b.is_normal, operand_b.mantissa};
  assign mantissa_c = {info_c.is_normal, operand_c.mantissa};

  // Mantissa multiplier (a*b)
  assign product = mantissa_a * mantissa_b;

  // Product is placed into a 3p+4 bit wide vector, padded with 2 bits for round and sticky:
  // | 000...000 | product | RS |
  //  <-  p+2  -> <-  2p -> < 2>
  assign product_shifted = product << 2; // constant shift

  // -----------------
  // Addend data path
  // -----------------
  logic [3*PRECISION_BITS+3:0] addend_after_shift;  // upper 3p+4 bits are needed to go on
  logic [PRECISION_BITS-1:0]   addend_sticky_bits;  // up to p bit of shifted addend are sticky
  logic                        sticky_before_add;   // they are compressed into a single sticky bit
  logic [3*PRECISION_BITS+3:0] addend_shifted;      // addends are 3p+4 bit wide (including G/R)
  logic                        inject_carry_in;     // inject carry for subtractions if needed

  // In parallel, the addend is right-shifted according to the exponent difference. Up to p bits are
  // shifted out and compressed into a sticky bit.
  // BEFORE THE SHIFT:
  // | mantissa_c | 000..000 |
  //  <-    p   -> <- 3p+4 ->
  // AFTER THE SHIFT:
  // | 000..........000 | mantissa_c | 000...............0GR |  sticky bits  |
  //  <- addend_shamt -> <-    p   -> <- 2p+4-addend_shamt -> <-  up to p  ->
  assign {addend_after_shift, addend_sticky_bits} =
      (mantissa_c << (3 * PRECISION_BITS + 4)) >> addend_shamt;

  assign sticky_before_add     = (| addend_sticky_bits);

  // In case of a subtraction, the addend is inverted
  assign addend_shifted = (effective_subtraction) ? ~addend_after_shift : addend_after_shift;
  assign inject_carry_in = effective_subtraction & ~sticky_before_add;

  // ------
  // Adder
  // ------
  logic [3*PRECISION_BITS+4:0] sum_pos, sum_neg; // added one bit for the carry
  logic                        sum_carry;        // observe carry bit from positive sum for sign fixing
  logic [3*PRECISION_BITS+3:0] sum;              // discard carry as sum won't overflow
  logic                        final_sign;

  //Mantissa adder (ab+c). In normal addition, it cannot overflow.
  assign sum_pos = product_shifted + addend_shifted + inject_carry_in;
  assign sum_carry = sum_pos[3*PRECISION_BITS+4];

  // Parallel adder for negative sum (only used for effective subtractions).
  // Note: inject_carry_in is used to complete the negation of the addend in the positive sum but
  // for the negative sum the addend is not negated, so no carry needs to be injected.
  assign sum_neg = addend_after_shift - product_shifted;

  // Complement negative sum (can only happen in subtraction -> overflows for positive results)
  assign sum        = (effective_subtraction && ~sum_carry) ? sum_neg : sum_pos;

  // In case of a mispredicted subtraction result, do a sign flip
  assign final_sign = (effective_subtraction && (sum_carry == tentative_sign))
                      ? 1'b1
                      : (effective_subtraction ? 1'b0 : tentative_sign);

  // ---------------
  // Internal pipeline
  // ---------------
  // Pipeline output signals as non-arrays
  logic                          effective_subtraction_q;
  logic signed [EXP_WIDTH-1:0]   exponent_product_q;
  logic signed [EXP_WIDTH-1:0]   exponent_difference_q;
  logic signed [EXP_WIDTH-1:0]   tentative_exponent_q;
  logic [SHIFT_AMOUNT_WIDTH-1:0] addend_shamt_q;
  logic                          sticky_before_add_q;
  logic [3*PRECISION_BITS+3:0]   sum_q;
  logic                          final_sign_q;
  fpnew_pkg::fp_format_e         dst_fmt_q2;
  fpnew_pkg::roundmode_e         rnd_mode_q;
  logic                          result_is_special_q;
  fp_t                           special_result_q;
  fpnew_pkg::status_t            special_status_q;
  // Internal pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_MID_REGS]                         mid_pipe_eff_sub_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_prod_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_exp_diff_q;
  logic signed           [0:NUM_MID_REGS][EXP_WIDTH-1:0]          mid_pipe_tent_exp_q;
  logic                  [0:NUM_MID_REGS][SHIFT_AMOUNT_WIDTH-1:0] mid_pipe_add_shamt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_sticky_q;
  logic                  [0:NUM_MID_REGS][3*PRECISION_BITS+3:0]   mid_pipe_sum_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_final_sign_q;
  fpnew_pkg::roundmode_e [0:NUM_MID_REGS]                         mid_pipe_rnd_mode_q;
  fpnew_pkg::fp_format_e [0:NUM_MID_REGS]                         mid_pipe_dst_fmt_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_res_is_spec_q;
  fp_t                   [0:NUM_MID_REGS]                         mid_pipe_spec_res_q;
  fpnew_pkg::status_t    [0:NUM_MID_REGS]                         mid_pipe_spec_stat_q;
  TagType                [0:NUM_MID_REGS]                         mid_pipe_tag_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_mask_q;
  AuxType                [0:NUM_MID_REGS]                         mid_pipe_aux_q;
  logic                  [0:NUM_MID_REGS]                         mid_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_MID_REGS] mid_pipe_ready;

  // Input stage: First element of pipeline is taken from upstream logic
  assign mid_pipe_eff_sub_q[0]     = effective_subtraction;
  assign mid_pipe_exp_prod_q[0]    = exponent_product;
  assign mid_pipe_exp_diff_q[0]    = exponent_difference;
  assign mid_pipe_tent_exp_q[0]    = tentative_exponent;
  assign mid_pipe_add_shamt_q[0]   = addend_shamt + addend_normalize_shamt;
  assign mid_pipe_sticky_q[0]      = sticky_before_add;
  assign mid_pipe_sum_q[0]         = sum;
  assign mid_pipe_final_sign_q[0]  = final_sign;
  assign mid_pipe_rnd_mode_q[0]    = inp_pipe_rnd_mode_q[NUM_INP_REGS];
  assign mid_pipe_dst_fmt_q[0]     = dst_fmt_q;
  assign mid_pipe_res_is_spec_q[0] = result_is_special;
  assign mid_pipe_spec_res_q[0]    = special_result;
  assign mid_pipe_spec_stat_q[0]   = special_status;
  assign mid_pipe_tag_q[0]         = inp_pipe_tag_q[NUM_INP_REGS];
  assign mid_pipe_mask_q[0]        = inp_pipe_mask_q[NUM_INP_REGS];
  assign mid_pipe_aux_q[0]         = inp_pipe_aux_q[NUM_INP_REGS];
  assign mid_pipe_valid_q[0]       = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to input pipe
  assign inp_pipe_ready[NUM_INP_REGS] = mid_pipe_ready[0];

  // Generate the register stages
  for (genvar i = 0; i < NUM_MID_REGS; i++) begin : gen_inside_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign mid_pipe_ready[i] = mid_pipe_ready[i+1] | ~mid_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(mid_pipe_valid_q[i+1], mid_pipe_valid_q[i], mid_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (mid_pipe_ready[i] & mid_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(mid_pipe_eff_sub_q[i+1],     mid_pipe_eff_sub_q[i],     reg_ena, '0)
    `FFL(mid_pipe_exp_prod_q[i+1],    mid_pipe_exp_prod_q[i],    reg_ena, '0)
    `FFL(mid_pipe_exp_diff_q[i+1],    mid_pipe_exp_diff_q[i],    reg_ena, '0)
    `FFL(mid_pipe_tent_exp_q[i+1],    mid_pipe_tent_exp_q[i],    reg_ena, '0)
    `FFL(mid_pipe_add_shamt_q[i+1],   mid_pipe_add_shamt_q[i],   reg_ena, '0)
    `FFL(mid_pipe_sticky_q[i+1],      mid_pipe_sticky_q[i],      reg_ena, '0)
    `FFL(mid_pipe_sum_q[i+1],         mid_pipe_sum_q[i],         reg_ena, '0)
    `FFL(mid_pipe_final_sign_q[i+1],  mid_pipe_final_sign_q[i],  reg_ena, '0)
    `FFL(mid_pipe_rnd_mode_q[i+1],    mid_pipe_rnd_mode_q[i],    reg_ena, fpnew_pkg::RNE)
    `FFL(mid_pipe_dst_fmt_q[i+1],     mid_pipe_dst_fmt_q[i],     reg_ena, fpnew_pkg::fp_format_e'(0))
    `FFL(mid_pipe_res_is_spec_q[i+1], mid_pipe_res_is_spec_q[i], reg_ena, '0)
    `FFL(mid_pipe_spec_res_q[i+1],    mid_pipe_spec_res_q[i],    reg_ena, '0)
    `FFL(mid_pipe_spec_stat_q[i+1],   mid_pipe_spec_stat_q[i],   reg_ena, '0)
    `FFL(mid_pipe_tag_q[i+1],         mid_pipe_tag_q[i],         reg_ena, TagType'('0))
    `FFL(mid_pipe_mask_q[i+1],        mid_pipe_mask_q[i],        reg_ena, '0)
    `FFL(mid_pipe_aux_q[i+1],         mid_pipe_aux_q[i],         reg_ena, AuxType'('0))
  end
  // Output stage: assign selected pipe outputs to signals for later use
  assign effective_subtraction_q = mid_pipe_eff_sub_q[NUM_MID_REGS];
  assign exponent_product_q      = mid_pipe_exp_prod_q[NUM_MID_REGS];
  assign exponent_difference_q   = mid_pipe_exp_diff_q[NUM_MID_REGS];
  assign tentative_exponent_q    = mid_pipe_tent_exp_q[NUM_MID_REGS];
  assign addend_shamt_q          = mid_pipe_add_shamt_q[NUM_MID_REGS];
  assign sticky_before_add_q     = mid_pipe_sticky_q[NUM_MID_REGS];
  assign sum_q                   = mid_pipe_sum_q[NUM_MID_REGS];
  assign final_sign_q            = mid_pipe_final_sign_q[NUM_MID_REGS];
  assign rnd_mode_q              = mid_pipe_rnd_mode_q[NUM_MID_REGS];
  assign dst_fmt_q2              = mid_pipe_dst_fmt_q[NUM_MID_REGS];
  assign result_is_special_q     = mid_pipe_res_is_spec_q[NUM_MID_REGS];
  assign special_result_q        = mid_pipe_spec_res_q[NUM_MID_REGS];
  assign special_status_q        = mid_pipe_spec_stat_q[NUM_MID_REGS];

  // --------------
  // Normalization
  // --------------
  logic        [LOWER_SUM_WIDTH-1:0]  sum_lower;              // lower 2p+3 bits of sum are searched
  logic        [LZC_RESULT_WIDTH-1:0] leading_zero_count;     // the number of leading zeroes
  logic signed [LZC_RESULT_WIDTH:0]   leading_zero_count_sgn; // signed leading-zero count
  logic                               lzc_zeroes;             // in case only zeroes found

  logic        [SHIFT_AMOUNT_WIDTH-1:0] norm_shamt; // Normalization shift amount
  logic signed [EXP_WIDTH-1:0]          normalized_exponent;

  logic [3*PRECISION_BITS+4:0] sum_shifted;       // result after first normalization shift
  logic [PRECISION_BITS:0]     final_mantissa;    // final mantissa before rounding with round bit
  logic [2*PRECISION_BITS+2:0] sum_sticky_bits;   // remaining 2p+3 sticky bits after normalization
  logic                        sticky_after_norm; // sticky bit after normalization

  logic signed [EXP_WIDTH-1:0] final_exponent;

  assign sum_lower = sum_q[LOWER_SUM_WIDTH-1:0];

  // Leading zero counter for cancellations
  lzc #(
    .WIDTH ( LOWER_SUM_WIDTH ),
    .MODE  ( 1               ) // MODE = 1 counts leading zeroes
  ) i_lzc (
    .in_i    ( sum_lower          ),
    .cnt_o   ( leading_zero_count ),
    .empty_o ( lzc_zeroes         )
  );

  assign leading_zero_count_sgn = signed'({1'b0, leading_zero_count});

  // Normalization shift amount based on exponents and LZC (unsigned as only left shifts)
  always_comb begin : norm_shift_amount
    // Product-anchored case or cancellations require LZC
    if ((exponent_difference_q <= 0) || (effective_subtraction_q && (exponent_difference_q <= 2))) begin
      // Normal result (biased exponent > 0 and not a zero)
      if ((exponent_product_q - leading_zero_count_sgn + 1 >= 0) && !lzc_zeroes) begin
        // Undo initial product shift, remove the counted zeroes
        norm_shamt          = PRECISION_BITS + 2 + leading_zero_count;
        normalized_exponent = exponent_product_q - leading_zero_count_sgn + 1; // account for shift
      // Subnormal result
      end else begin
        // Cap the shift distance to align mantissa with minimum exponent
        norm_shamt          = unsigned'(signed'(PRECISION_BITS + 2 + exponent_product_q));
        normalized_exponent = 0; // subnormals encoded as 0
      end
    // Addend-anchored case
    end else begin
      norm_shamt          = addend_shamt_q; // Undo the initial shift
      normalized_exponent = tentative_exponent_q;
    end
  end

  // Do the large normalization shift
  assign sum_shifted       = sum_q << norm_shamt;

  // The addend-anchored case needs a 1-bit normalization since the leading-one can be to the left
  // or right of the (non-carry) MSB of the sum.
  always_comb begin : small_norm
    // Default assignment, discarding carry bit
    {final_mantissa, sum_sticky_bits} = sum_shifted;
    final_exponent                    = normalized_exponent;

    // The normalized sum has overflown, align right and fix exponent
    if (sum_shifted[3*PRECISION_BITS+4]) begin // check the carry bit
      {final_mantissa, sum_sticky_bits} = sum_shifted >> 1;
      final_exponent                    = normalized_exponent + 1;
    // The normalized sum is normal, nothing to do
    end else if (sum_shifted[3*PRECISION_BITS+3]) begin // check the sum MSB
      // do nothing
    // The normalized sum is still denormal, align left - unless the result is not already subnormal
    end else if (normalized_exponent > 1) begin
      {final_mantissa, sum_sticky_bits} = sum_shifted << 1;
      final_exponent                    = normalized_exponent - 1;
    // Otherwise we're denormal
    end else begin
      final_exponent = '0;
    end
  end

  // Update the sticky bit with the shifted-out bits
  assign sticky_after_norm = (| {sum_sticky_bits}) | sticky_before_add_q;

  // ----------------------------
  // Rounding and classification
  // ----------------------------
  logic                                     pre_round_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] pre_round_abs; // absolute value of result before rounding
  logic [1:0]                               round_sticky_bits;

  logic of_before_round, of_after_round; // overflow
  logic uf_before_round, uf_after_round; // underflow

  logic [NUM_FORMATS-1:0][SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] fmt_pre_round_abs; // per format
  logic [NUM_FORMATS-1:0][1:0]                               fmt_round_sticky_bits;

  logic [NUM_FORMATS-1:0]                                    fmt_of_after_round;
  logic [NUM_FORMATS-1:0]                                    fmt_uf_after_round;

  logic                                     rounded_sign;
  logic [SUPER_EXP_BITS+SUPER_MAN_BITS-1:0] rounded_abs; // absolute value of result after rounding
  logic                                     result_zero;

  // Classification before round. RISC-V mandates checking underflow AFTER rounding!
  assign of_before_round = final_exponent >= 2**(fpnew_pkg::exp_bits(dst_fmt_q2))-1; // infinity exponent is all ones
  assign uf_before_round = final_exponent == 0;               // exponent for subnormals capped to 0

  // Pack exponent and mantissa into proper rounding form
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_res_assemble
    // Set up some constants
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    logic [EXP_BITS-1:0] pre_round_exponent;
    logic [MAN_BITS-1:0] pre_round_mantissa;

    if (FpFmtConfig[fmt]) begin : active_format

      assign pre_round_exponent = (of_before_round) ? 2**EXP_BITS-2 : final_exponent[EXP_BITS-1:0];
      assign pre_round_mantissa = (of_before_round) ? '1 : final_mantissa[SUPER_MAN_BITS-:MAN_BITS];
      // Assemble result before rounding. In case of overflow, the largest normal value is set.
      assign fmt_pre_round_abs[fmt] = {pre_round_exponent, pre_round_mantissa}; // 0-extend

      // Round bit is after mantissa (1 in case of overflow for rounding)
      assign fmt_round_sticky_bits[fmt][1] = final_mantissa[SUPER_MAN_BITS-MAN_BITS] |
                                             of_before_round;

      // remaining bits in mantissa to sticky (1 in case of overflow for rounding)
      if (MAN_BITS < SUPER_MAN_BITS) begin : narrow_sticky
        assign fmt_round_sticky_bits[fmt][0] = (| final_mantissa[SUPER_MAN_BITS-MAN_BITS-1:0]) |
                                               sticky_after_norm | of_before_round;
      end else begin : normal_sticky
        assign fmt_round_sticky_bits[fmt][0] = sticky_after_norm | of_before_round;
      end
    end else begin : inactive_format
      assign fmt_pre_round_abs[fmt] = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_round_sticky_bits[fmt] = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Assemble result before rounding. In case of overflow, the largest normal value is set.
  assign pre_round_sign     = final_sign_q;
  assign pre_round_abs      = fmt_pre_round_abs[dst_fmt_q2];

  // In case of overflow, the round and sticky bits are set for proper rounding
  assign round_sticky_bits  = fmt_round_sticky_bits[dst_fmt_q2];

  // Perform the rounding
  fpnew_rounding #(
    .AbsWidth ( SUPER_EXP_BITS + SUPER_MAN_BITS )
  ) i_fpnew_rounding (
    .abs_value_i             ( pre_round_abs           ),
    .sign_i                  ( pre_round_sign          ),
    .round_sticky_bits_i     ( round_sticky_bits       ),
    .rnd_mode_i              ( rnd_mode_q              ),
    .effective_subtraction_i ( effective_subtraction_q ),
    .abs_rounded_o           ( rounded_abs             ),
    .sign_o                  ( rounded_sign            ),
    .exact_zero_o            ( result_zero             )
  );

  logic [NUM_FORMATS-1:0][WIDTH-1:0] fmt_result;

  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_sign_inject
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(fpnew_pkg::fp_format_e'(fmt));
    localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(fpnew_pkg::fp_format_e'(fmt));

    if (FpFmtConfig[fmt]) begin : active_format
      always_comb begin : post_process
        // detect of / uf
        fmt_uf_after_round[fmt] = (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) // denormal
        || ((pre_round_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '0) && (rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == 1) &&
              ((round_sticky_bits != 2'b11) || (!sum_sticky_bits[MAN_BITS*2 + 4] && ((rnd_mode_q == fpnew_pkg::RNE) || (rnd_mode_q == fpnew_pkg::RMM)))));
        fmt_of_after_round[fmt] = rounded_abs[EXP_BITS+MAN_BITS-1:MAN_BITS] == '1; // inf exp.

        // Assemble regular result, nan box short ones.
        fmt_result[fmt]               = '1;
        fmt_result[fmt][FP_WIDTH-1:0] = {rounded_sign, rounded_abs[EXP_BITS+MAN_BITS-1:0]};
      end
    end else begin : inactive_format
      assign fmt_uf_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_of_after_round[fmt] = fpnew_pkg::DONT_CARE;
      assign fmt_result[fmt]         = '{default: fpnew_pkg::DONT_CARE};
    end
  end

  // Classification after rounding select by destination format
  assign uf_after_round = fmt_uf_after_round[dst_fmt_q2];
  assign of_after_round = fmt_of_after_round[dst_fmt_q2];


  // -----------------
  // Result selection
  // -----------------
  logic [WIDTH-1:0]     regular_result;
  fpnew_pkg::status_t   regular_status;

  // Assemble regular result
  assign regular_result = fmt_result[dst_fmt_q2];
  assign regular_status.NV = 1'b0; // only valid cases are handled in regular path
  assign regular_status.DZ = 1'b0; // no divisions
  assign regular_status.OF = of_before_round | of_after_round;   // rounding can introduce overflow
  assign regular_status.UF = uf_after_round & regular_status.NX; // only inexact results raise UF
  assign regular_status.NX = (| round_sticky_bits) | of_before_round | of_after_round;

  // Final results for output pipeline
  logic [WIDTH-1:0]   result_d;
  fpnew_pkg::status_t status_d;

  // Select output depending on special case detection
  assign result_d = result_is_special_q ? special_result_q : regular_result;
  assign status_d = result_is_special_q ? special_status_q : regular_status;

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  logic               [0:NUM_OUT_REGS][WIDTH-1:0] out_pipe_result_q;
  fpnew_pkg::status_t [0:NUM_OUT_REGS]            out_pipe_status_q;
  TagType             [0:NUM_OUT_REGS]            out_pipe_tag_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_mask_q;
  AuxType             [0:NUM_OUT_REGS]            out_pipe_aux_q;
  logic               [0:NUM_OUT_REGS]            out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0] = result_d;
  assign out_pipe_status_q[0] = status_d;
  assign out_pipe_tag_q[0]    = mid_pipe_tag_q[NUM_MID_REGS];
  assign out_pipe_mask_q[0]   = mid_pipe_mask_q[NUM_MID_REGS];
  assign out_pipe_aux_q[0]    = mid_pipe_aux_q[NUM_MID_REGS];
  assign out_pipe_valid_q[0]  = mid_pipe_valid_q[NUM_MID_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign mid_pipe_ready[NUM_MID_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + NUM_MID_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1], out_pipe_result_q[i], reg_ena, '0)
    `FFL(out_pipe_status_q[i+1], out_pipe_status_q[i], reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],    out_pipe_tag_q[i],    reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],   out_pipe_mask_q[i],   reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],    out_pipe_aux_q[i],    reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = 1'b1; // always NaN-Box result
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, mid_pipe_valid_q, out_pipe_valid_q});

  // Early valid_o signal. This is used for dispatching instructions for dual-issue processor.
  if (NUM_OUT_REGS > 0) begin
    assign early_out_valid_o = |{out_pipe_valid_q[NUM_OUT_REGS] & ~out_pipe_ready[NUM_OUT_REGS],
                                 out_pipe_valid_q[NUM_OUT_REGS-1]};
  end else if (NUM_MID_REGS > 0) begin
    assign early_out_valid_o = |{mid_pipe_valid_q[NUM_MID_REGS] & ~mid_pipe_ready[NUM_OUT_REGS],
                                 mid_pipe_valid_q[NUM_MID_REGS-1]};
  end else if (NUM_INP_REGS > 0) begin
    assign early_out_valid_o = |{inp_pipe_valid_q[NUM_INP_REGS] & ~inp_pipe_ready[NUM_INP_REGS],
                                 inp_pipe_valid_q[NUM_INP_REGS-1]};
  end else begin
    assign early_out_valid_o = 1'b0;
  end

endmodule
// ----- 8< ----- FILE "./fpnew_noncomp.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_noncomp #(
  parameter fpnew_pkg::fp_format_e   FpFormat    = fpnew_pkg::fp_format_e'(0),
  parameter int unsigned             NumPipeRegs = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig  = fpnew_pkg::BEFORE,
  parameter type                     TagType     = logic,
  parameter type                     AuxType     = logic,
  // Do not change
  localparam int unsigned WIDTH = fpnew_pkg::fp_width(FpFormat),
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                  clk_i,
  input logic                  rst_ni,
  // Input signals
  input logic [1:0][WIDTH-1:0]     operands_i, // 2 operands
  input logic [1:0]                is_boxed_i, // 2 operands
  input fpnew_pkg::roundmode_e     rnd_mode_i,
  input fpnew_pkg::operation_e     op_i,
  input logic                      op_mod_i,
  input TagType                    tag_i,
  input logic                      mask_i,
  input AuxType                    aux_i,
  // Input Handshake
  input  logic                     in_valid_i,
  output logic                     in_ready_o,
  input  logic                     flush_i,
  // Output signals
  output logic [WIDTH-1:0]         result_o,
  output fpnew_pkg::status_t       status_o,
  output logic                     extension_bit_o,
  output fpnew_pkg::classmask_e    class_mask_o,
  output logic                     is_class_o,
  output TagType                   tag_o,
  output logic                     mask_o,
  output AuxType                   aux_o,
  // Output handshake
  output logic                     out_valid_o,
  input  logic                     out_ready_i,
  // Indication of valid data in flight
  output logic                     busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0] reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                     early_out_valid_o
);

  // ----------
  // Constants
  // ----------
  localparam int unsigned EXP_BITS = fpnew_pkg::exp_bits(FpFormat);
  localparam int unsigned MAN_BITS = fpnew_pkg::man_bits(FpFormat);
  // Pipelines
  localparam NUM_INP_REGS = (PipeConfig == fpnew_pkg::BEFORE || PipeConfig == fpnew_pkg::INSIDE)
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? ((NumPipeRegs + 1) / 2) // First to get distributed regs
                               : 0); // no regs here otherwise
  localparam NUM_OUT_REGS = PipeConfig == fpnew_pkg::AFTER
                            ? NumPipeRegs
                            : (PipeConfig == fpnew_pkg::DISTRIBUTED
                               ? (NumPipeRegs / 2) // Last to get distributed regs
                               : 0); // no regs here otherwise

  // ----------------
  // Type definition
  // ----------------
  typedef struct packed {
    logic                sign;
    logic [EXP_BITS-1:0] exponent;
    logic [MAN_BITS-1:0] mantissa;
  } fp_t;

  // ---------------
  // Input pipeline
  // ---------------
  // Input pipeline signals, index i holds signal after i register stages
  logic                  [0:NUM_INP_REGS][1:0][WIDTH-1:0] inp_pipe_operands_q;
  logic                  [0:NUM_INP_REGS][1:0]            inp_pipe_is_boxed_q;
  fpnew_pkg::roundmode_e [0:NUM_INP_REGS]                 inp_pipe_rnd_mode_q;
  fpnew_pkg::operation_e [0:NUM_INP_REGS]                 inp_pipe_op_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_op_mod_q;
  TagType                [0:NUM_INP_REGS]                 inp_pipe_tag_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_mask_q;
  AuxType                [0:NUM_INP_REGS]                 inp_pipe_aux_q;
  logic                  [0:NUM_INP_REGS]                 inp_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_INP_REGS] inp_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign inp_pipe_operands_q[0] = operands_i;
  assign inp_pipe_is_boxed_q[0] = is_boxed_i;
  assign inp_pipe_rnd_mode_q[0] = rnd_mode_i;
  assign inp_pipe_op_q[0]       = op_i;
  assign inp_pipe_op_mod_q[0]   = op_mod_i;
  assign inp_pipe_tag_q[0]      = tag_i;
  assign inp_pipe_mask_q[0]     = mask_i;
  assign inp_pipe_aux_q[0]      = aux_i;
  assign inp_pipe_valid_q[0]    = in_valid_i;
  // Input stage: Propagate pipeline ready signal to updtream circuitry
  assign in_ready_o = inp_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_INP_REGS; i++) begin : gen_input_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign inp_pipe_ready[i] = inp_pipe_ready[i+1] | ~inp_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(inp_pipe_valid_q[i+1], inp_pipe_valid_q[i], inp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (inp_pipe_ready[i] & inp_pipe_valid_q[i]) | reg_ena_i[i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(inp_pipe_operands_q[i+1], inp_pipe_operands_q[i], reg_ena, '0)
    `FFL(inp_pipe_is_boxed_q[i+1], inp_pipe_is_boxed_q[i], reg_ena, '0)
    `FFL(inp_pipe_rnd_mode_q[i+1], inp_pipe_rnd_mode_q[i], reg_ena, fpnew_pkg::RNE)
    `FFL(inp_pipe_op_q[i+1],       inp_pipe_op_q[i],       reg_ena, fpnew_pkg::FMADD)
    `FFL(inp_pipe_op_mod_q[i+1],   inp_pipe_op_mod_q[i],   reg_ena, '0)
    `FFL(inp_pipe_tag_q[i+1],      inp_pipe_tag_q[i],      reg_ena, TagType'('0))
    `FFL(inp_pipe_mask_q[i+1],     inp_pipe_mask_q[i],     reg_ena, '0)
    `FFL(inp_pipe_aux_q[i+1],      inp_pipe_aux_q[i],      reg_ena, AuxType'('0))
  end

  // ---------------------
  // Input classification
  // ---------------------
  fpnew_pkg::fp_info_t [1:0] info_q;

  // Classify input
  fpnew_classifier #(
    .FpFormat    ( FpFormat ),
    .NumOperands ( 2        )
    ) i_class_a (
    .operands_i ( inp_pipe_operands_q[NUM_INP_REGS] ),
    .is_boxed_i ( inp_pipe_is_boxed_q[NUM_INP_REGS] ),
    .info_o     ( info_q                            )
  );

  fp_t                 operand_a, operand_b;
  fpnew_pkg::fp_info_t info_a,    info_b;

  // Packing-order-agnostic assignments
  assign operand_a = inp_pipe_operands_q[NUM_INP_REGS][0];
  assign operand_b = inp_pipe_operands_q[NUM_INP_REGS][1];
  assign info_a    = info_q[0];
  assign info_b    = info_q[1];

  logic any_operand_inf;
  logic any_operand_nan;
  logic signalling_nan;

  // Reduction for special case handling
  assign any_operand_inf = (| {info_a.is_inf,        info_b.is_inf});
  assign any_operand_nan = (| {info_a.is_nan,        info_b.is_nan});
  assign signalling_nan  = (| {info_a.is_signalling, info_b.is_signalling});

  logic operands_equal, operand_a_smaller;

  // Equality checks for zeroes too
  assign operands_equal    = (operand_a == operand_b) || (info_a.is_zero && info_b.is_zero);
  // Invert result if non-zero signs involved (unsigned comparison)
  assign operand_a_smaller = (operand_a < operand_b) ^ (operand_a.sign || operand_b.sign);

  // ---------------
  // Sign Injection
  // ---------------
  fp_t                sgnj_result;
  fpnew_pkg::status_t sgnj_status;
  logic               sgnj_extension_bit;

  // Sign Injection - operation is encoded in rnd_mode_q:
  // RNE = SGNJ, RTZ = SGNJN, RDN = SGNJX, RUP = Passthrough (no NaN-box check)
  always_comb begin : sign_injections
    logic sign_a, sign_b; // internal signs
    // Default assignment
    sgnj_result = operand_a; // result based on operand a

    // NaN-boxing check will treat invalid inputs as canonical NaNs
    if (!info_a.is_boxed) sgnj_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)};

    // Internal signs are treated as positive in case of non-NaN-boxed values
    sign_a = operand_a.sign & info_a.is_boxed;
    sign_b = operand_b.sign & info_b.is_boxed;

    // Do the sign injection based on rm field
    unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
      fpnew_pkg::RNE: sgnj_result.sign = sign_b;          // SGNJ
      fpnew_pkg::RTZ: sgnj_result.sign = ~sign_b;         // SGNJN
      fpnew_pkg::RDN: sgnj_result.sign = sign_a ^ sign_b; // SGNJX
      fpnew_pkg::RUP: sgnj_result      = operand_a;       // passthrough
      default: sgnj_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
    endcase
  end

  assign sgnj_status = '0;        // sign injections never raise exceptions

  // op_mod_q enables integer sign-extension of result (for storing to integer regfile)
  assign sgnj_extension_bit = inp_pipe_op_mod_q[NUM_INP_REGS] ? sgnj_result.sign : 1'b1;

  // ------------------
  // Minimum / Maximum
  // ------------------
  fp_t                minmax_result;
  fpnew_pkg::status_t minmax_status;
  logic               minmax_extension_bit;

  // Minimum/Maximum - operation is encoded in rnd_mode_q:
  // RNE = MIN, RTZ = MAX
  always_comb begin : min_max
    // Default assignment
    minmax_status = '0;

    // Min/Max use quiet comparisons - only sNaN are invalid
    minmax_status.NV = signalling_nan;

    // Both NaN inputs cause a NaN output
    if (info_a.is_nan && info_b.is_nan)
      minmax_result = '{sign: 1'b0, exponent: '1, mantissa: 2**(MAN_BITS-1)}; // canonical qNaN
    // If one operand is NaN, the non-NaN operand is returned
    else if (info_a.is_nan) minmax_result = operand_b;
    else if (info_b.is_nan) minmax_result = operand_a;
    // Otherwise decide according to the operation
    else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        fpnew_pkg::RNE: minmax_result = operand_a_smaller ? operand_a : operand_b; // MIN
        fpnew_pkg::RTZ: minmax_result = operand_a_smaller ? operand_b : operand_a; // MAX
        default: minmax_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign minmax_extension_bit = 1'b1; // NaN-box as result is always a float value

  // ------------
  // Comparisons
  // ------------
  fp_t                cmp_result;
  fpnew_pkg::status_t cmp_status;
  logic               cmp_extension_bit;

  // Comparisons - operation is encoded in rnd_mode_q:
  // RNE = LE, RTZ = LT, RDN = EQ
  // op_mod_q inverts boolean outputs
  always_comb begin : comparisons
    // Default assignment
    cmp_result = '0; // false
    cmp_status = '0; // no flags

    // Signalling NaNs always compare as false (except for "not equal" compares) and are illegal
    if (signalling_nan) begin
      cmp_status.NV = 1'b1; // invalid operation
      cmp_result    = inp_pipe_rnd_mode_q[NUM_INP_REGS] == fpnew_pkg::RDN && inp_pipe_op_mod_q[NUM_INP_REGS];
    // Otherwise do comparisons
    end else begin
      unique case (inp_pipe_rnd_mode_q[NUM_INP_REGS])
        fpnew_pkg::RNE: begin // Less than or equal
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller | operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        fpnew_pkg::RTZ: begin // Less than
          if (any_operand_nan) cmp_status.NV = 1'b1; // Signalling comparison: NaNs are invalid
          else cmp_result = (operand_a_smaller & ~operands_equal) ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        fpnew_pkg::RDN: begin // Equal
          if (any_operand_nan) cmp_result = inp_pipe_op_mod_q[NUM_INP_REGS]; // NaN always not equal
          else cmp_result = operands_equal ^ inp_pipe_op_mod_q[NUM_INP_REGS];
        end
        default: cmp_result = '{default: fpnew_pkg::DONT_CARE}; // don't care
      endcase
    end
  end

  assign cmp_extension_bit = 1'b0; // Comparisons always produce booleans in integer registers

  // ---------------
  // Classification
  // ---------------
  fpnew_pkg::status_t    class_status;
  logic                  class_extension_bit;
  fpnew_pkg::classmask_e class_mask_d; // the result is actually here

  // Classification - always return the classification mask on the dedicated port
  always_comb begin : classify
    if (info_a.is_normal) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGNORM    : fpnew_pkg::POSNORM;
    end else if (info_a.is_subnormal) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGSUBNORM : fpnew_pkg::POSSUBNORM;
    end else if (info_a.is_zero) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGZERO    : fpnew_pkg::POSZERO;
    end else if (info_a.is_inf) begin
      class_mask_d = operand_a.sign       ? fpnew_pkg::NEGINF     : fpnew_pkg::POSINF;
    end else if (info_a.is_nan) begin
      class_mask_d = info_a.is_signalling ? fpnew_pkg::SNAN       : fpnew_pkg::QNAN;
    end else begin
      class_mask_d = fpnew_pkg::QNAN; // default value
    end
  end

  assign class_status        = '0;   // classification does not set flags
  assign class_extension_bit = 1'b0; // classification always produces results in integer registers

  // -----------------
  // Result selection
  // -----------------
  fp_t                   result_d;
  fpnew_pkg::status_t    status_d;
  logic                  extension_bit_d;
  logic                  is_class_d;

  // Select result
  always_comb begin : select_result
    unique case (inp_pipe_op_q[NUM_INP_REGS])
      fpnew_pkg::SGNJ: begin
        result_d        = sgnj_result;
        status_d        = sgnj_status;
        extension_bit_d = sgnj_extension_bit;
      end
      fpnew_pkg::MINMAX: begin
        result_d        = minmax_result;
        status_d        = minmax_status;
        extension_bit_d = minmax_extension_bit;
      end
      fpnew_pkg::CMP: begin
        result_d        = cmp_result;
        status_d        = cmp_status;
        extension_bit_d = cmp_extension_bit;
      end
      fpnew_pkg::CLASSIFY: begin
        result_d        = '{default: fpnew_pkg::DONT_CARE}; // unused
        status_d        = class_status;
        extension_bit_d = class_extension_bit;
      end
      default: begin
        result_d        = '{default: fpnew_pkg::DONT_CARE}; // dont care
        status_d        = '{default: fpnew_pkg::DONT_CARE}; // dont care
        extension_bit_d = fpnew_pkg::DONT_CARE;             // dont care
      end
    endcase
  end

  assign is_class_d = (inp_pipe_op_q[NUM_INP_REGS] == fpnew_pkg::CLASSIFY);

  // ----------------
  // Output Pipeline
  // ----------------
  // Output pipeline signals, index i holds signal after i register stages
  fp_t                   [0:NUM_OUT_REGS] out_pipe_result_q;
  fpnew_pkg::status_t    [0:NUM_OUT_REGS] out_pipe_status_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_extension_bit_q;
  fpnew_pkg::classmask_e [0:NUM_OUT_REGS] out_pipe_class_mask_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_is_class_q;
  TagType                [0:NUM_OUT_REGS] out_pipe_tag_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_mask_q;
  AuxType                [0:NUM_OUT_REGS] out_pipe_aux_q;
  logic                  [0:NUM_OUT_REGS] out_pipe_valid_q;
  // Ready signal is combinatorial for all stages
  logic [0:NUM_OUT_REGS] out_pipe_ready;

  // Input stage: First element of pipeline is taken from inputs
  assign out_pipe_result_q[0]        = result_d;
  assign out_pipe_status_q[0]        = status_d;
  assign out_pipe_extension_bit_q[0] = extension_bit_d;
  assign out_pipe_class_mask_q[0]    = class_mask_d;
  assign out_pipe_is_class_q[0]      = is_class_d;
  assign out_pipe_tag_q[0]           = inp_pipe_tag_q[NUM_INP_REGS];
  assign out_pipe_mask_q[0]          = inp_pipe_mask_q[NUM_INP_REGS];
  assign out_pipe_aux_q[0]           = inp_pipe_aux_q[NUM_INP_REGS];
  assign out_pipe_valid_q[0]         = inp_pipe_valid_q[NUM_INP_REGS];
  // Input stage: Propagate pipeline ready signal to inside pipe
  assign inp_pipe_ready[NUM_INP_REGS] = out_pipe_ready[0];
  // Generate the register stages
  for (genvar i = 0; i < NUM_OUT_REGS; i++) begin : gen_output_pipeline
    // Internal register enable for this stage
    logic reg_ena;
    // Determine the ready signal of the current stage - advance the pipeline:
    // 1. if the next stage is ready for our data
    // 2. if the next stage only holds a bubble (not valid) -> we can pop it
    assign out_pipe_ready[i] = out_pipe_ready[i+1] | ~out_pipe_valid_q[i+1];
    // Valid: enabled by ready signal, synchronous clear with the flush signal
    `FFLARNC(out_pipe_valid_q[i+1], out_pipe_valid_q[i], out_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
    // Enable register if pipleine ready and a valid data item is present
    assign reg_ena = (out_pipe_ready[i] & out_pipe_valid_q[i]) | reg_ena_i[NUM_INP_REGS + i];
    // Generate the pipeline registers within the stages, use enable-registers
    `FFL(out_pipe_result_q[i+1],        out_pipe_result_q[i],        reg_ena, '0)
    `FFL(out_pipe_status_q[i+1],        out_pipe_status_q[i],        reg_ena, '0)
    `FFL(out_pipe_extension_bit_q[i+1], out_pipe_extension_bit_q[i], reg_ena, '0)
    `FFL(out_pipe_class_mask_q[i+1],    out_pipe_class_mask_q[i],    reg_ena, fpnew_pkg::QNAN)
    `FFL(out_pipe_is_class_q[i+1],      out_pipe_is_class_q[i],      reg_ena, '0)
    `FFL(out_pipe_tag_q[i+1],           out_pipe_tag_q[i],           reg_ena, TagType'('0))
    `FFL(out_pipe_mask_q[i+1],          out_pipe_mask_q[i],          reg_ena, '0)
    `FFL(out_pipe_aux_q[i+1],           out_pipe_aux_q[i],           reg_ena, AuxType'('0))
  end
  // Output stage: Ready travels backwards from output side, driven by downstream circuitry
  assign out_pipe_ready[NUM_OUT_REGS] = out_ready_i;
  // Output stage: assign module outputs
  assign result_o        = out_pipe_result_q[NUM_OUT_REGS];
  assign status_o        = out_pipe_status_q[NUM_OUT_REGS];
  assign extension_bit_o = out_pipe_extension_bit_q[NUM_OUT_REGS];
  assign class_mask_o    = out_pipe_class_mask_q[NUM_OUT_REGS];
  assign is_class_o      = out_pipe_is_class_q[NUM_OUT_REGS];
  assign tag_o           = out_pipe_tag_q[NUM_OUT_REGS];
  assign mask_o          = out_pipe_mask_q[NUM_OUT_REGS];
  assign aux_o           = out_pipe_aux_q[NUM_OUT_REGS];
  assign out_valid_o     = out_pipe_valid_q[NUM_OUT_REGS];
  assign busy_o          = (| {inp_pipe_valid_q, out_pipe_valid_q});

  // Early valid_o signal. This is used for dispatching instructions for dual-issue processor.
  if (NUM_OUT_REGS > 0) begin
    assign early_out_valid_o = |{out_pipe_valid_q[NUM_OUT_REGS] & ~out_pipe_ready[NUM_OUT_REGS],
                                 out_pipe_valid_q[NUM_OUT_REGS-1]};
  end else if (NUM_INP_REGS > 0) begin
    assign early_out_valid_o = |{inp_pipe_valid_q[NUM_INP_REGS] & ~inp_pipe_ready[NUM_INP_REGS],
                                 inp_pipe_valid_q[NUM_INP_REGS-1]};
  end else begin
    assign early_out_valid_o = 1'b0;
  end

endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_block.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_opgroup_block #(
  parameter fpnew_pkg::opgroup_e        OpGroup       = fpnew_pkg::ADDMUL,
  // FPU configuration
  parameter int unsigned                Width         = 32,
  parameter logic                       EnableVectors = 1'b1,
  parameter fpnew_pkg::divsqrt_unit_t   DivSqrtSel    = fpnew_pkg::THMULTI,
  parameter fpnew_pkg::fmt_logic_t      FpFmtMask     = '1,
  parameter fpnew_pkg::ifmt_logic_t     IntFmtMask    = '1,
  parameter fpnew_pkg::fmt_unsigned_t   FmtPipeRegs   = '{default: 0},
  parameter fpnew_pkg::fmt_unit_types_t FmtUnitTypes  = '{default: fpnew_pkg::PARALLEL},
  parameter fpnew_pkg::pipe_config_t    PipeConfig    = fpnew_pkg::BEFORE,
  parameter type                        TagType       = logic,
  parameter int unsigned                TrueSIMDClass = 0,
  // Do not change
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_LANES    = fpnew_pkg::max_num_lanes(Width, FpFmtMask, EnableVectors),
  localparam type         MaskType     = logic [NUM_LANES-1:0]
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input fpnew_pkg::roundmode_e                    rnd_mode_i,
  input fpnew_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input fpnew_pkg::fp_format_e                    src_fmt_i,
  input fpnew_pkg::fp_format_e                    dst_fmt_i,
  input fpnew_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  input MaskType                                  simd_mask_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output fpnew_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o,
  output logic                                    early_valid_o
);

  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [Width-1:0]   result;
    fpnew_pkg::status_t status;
    logic               ext_bit;
    TagType             tag;
  } output_t;

  // Handshake signals for the slices
  logic [NUM_FORMATS-1:0] fmt_in_ready, fmt_out_valid, fmt_out_ready, fmt_busy;
  logic [NUM_FORMATS-1:0] early_valid;
  output_t [NUM_FORMATS-1:0] fmt_outputs;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & fmt_in_ready[dst_fmt_i]; // Ready is given by selected format

  // -------------------------
  // Generate Parallel Slices
  // -------------------------
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_parallel_slices
    // Some constants for this format
    localparam logic ANY_MERGED = fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam logic IS_FIRST_MERGED =
        fpnew_pkg::is_first_enabled_multi(fpnew_pkg::fp_format_e'(fmt), FmtUnitTypes, FpFmtMask);

    // Generate slice only if format enabled
    if (FpFmtMask[fmt] && (FmtUnitTypes[fmt] == fpnew_pkg::PARALLEL)) begin : active_format
      localparam fpnew_pkg::fp_format_e FpFormat = fpnew_pkg::fp_format_e'(fmt);

      logic in_valid;

      assign in_valid = in_valid_i & (dst_fmt_i == fmt); // enable selected format

      // Forward masks related to the right SIMD lane
      localparam int unsigned INTERNAL_LANES = fpnew_pkg::num_lanes(Width, fpnew_pkg::fp_format_e'(fmt), EnableVectors);
      logic [INTERNAL_LANES-1:0] mask_slice;
      always_comb for (int b = 0; b < INTERNAL_LANES; b++) mask_slice[b] = simd_mask_i[(NUM_LANES/INTERNAL_LANES)*b];

      fpnew_opgroup_fmt_slice #(
        .OpGroup       ( OpGroup          ),
        .FpFormat      ( FpFormat         ),
        .Width         ( Width            ),
        .EnableVectors ( EnableVectors    ),
        .NumPipeRegs   ( FmtPipeRegs[fmt] ),
        .PipeConfig    ( PipeConfig       ),
        .TagType       ( TagType          ),
        .TrueSIMDClass ( TrueSIMDClass    )
      ) i_fmt_slice (
        .clk_i,
        .rst_ni,
        .operands_i       ( operands_i               ),
        .is_boxed_i       ( is_boxed_i[fmt]          ),
        .rnd_mode_i,
        .op_i,
        .op_mod_i,
        .vectorial_op_i,
        .tag_i,
        .simd_mask_i      ( mask_slice               ),
        .in_valid_i       ( in_valid                 ),
        .in_ready_o       ( fmt_in_ready[fmt]        ),
        .flush_i,
        .result_o         ( fmt_outputs[fmt].result  ),
        .status_o         ( fmt_outputs[fmt].status  ),
        .extension_bit_o  ( fmt_outputs[fmt].ext_bit ),
        .tag_o            ( fmt_outputs[fmt].tag     ),
        .out_valid_o      ( fmt_out_valid[fmt]       ),
        .out_ready_i      ( fmt_out_ready[fmt]       ),
        .busy_o           ( fmt_busy[fmt]            ),
        .reg_ena_i        ( '0                       ),
        .early_out_valid_o( early_valid[fmt]         )
      );
    // If the format wants to use merged ops, tie off the dangling ones not used here
    end else if (FpFmtMask[fmt] && ANY_MERGED && !IS_FIRST_MERGED) begin : merged_unused

      localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
      // Ready is split up into formats
      assign fmt_in_ready[fmt]  = fmt_in_ready[int'(FMT)];

      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);
      assign early_valid[fmt] = 1'b0;
    // Tie off disabled formats
    end else if (!FpFmtMask[fmt] || (FmtUnitTypes[fmt] == fpnew_pkg::DISABLED)) begin : disable_fmt
      assign fmt_in_ready[fmt]  = 1'b0; // don't accept operations
      assign fmt_out_valid[fmt] = 1'b0; // don't emit values
      assign fmt_busy[fmt]      = 1'b0; // never busy
      // Outputs are don't care
      assign fmt_outputs[fmt].result  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].status  = '{default: fpnew_pkg::DONT_CARE};
      assign fmt_outputs[fmt].ext_bit = fpnew_pkg::DONT_CARE;
      assign fmt_outputs[fmt].tag     = TagType'(fpnew_pkg::DONT_CARE);
      assign early_valid[fmt] = 1'b0;
    end
  end

  // ----------------------
  // Generate Merged Slice
  // ----------------------
  if (fpnew_pkg::any_enabled_multi(FmtUnitTypes, FpFmtMask)) begin : gen_merged_slice

    localparam FMT = fpnew_pkg::get_first_enabled_multi(FmtUnitTypes, FpFmtMask);
    localparam REG = fpnew_pkg::get_num_regs_multi(FmtPipeRegs, FmtUnitTypes, FpFmtMask);

    logic in_valid;

    assign in_valid = in_valid_i & (FmtUnitTypes[dst_fmt_i] == fpnew_pkg::MERGED);

    fpnew_opgroup_multifmt_slice #(
      .OpGroup       ( OpGroup          ),
      .Width         ( Width            ),
      .FpFmtConfig   ( FpFmtMask        ),
      .IntFmtConfig  ( IntFmtMask       ),
      .EnableVectors ( EnableVectors    ),
      .DivSqrtSel    ( DivSqrtSel       ),
      .NumPipeRegs   ( REG              ),
      .PipeConfig    ( PipeConfig       ),
      .TagType       ( TagType          )
    ) i_multifmt_slice (
      .clk_i,
      .rst_ni,
      .operands_i,
      .is_boxed_i,
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .simd_mask_i      ( simd_mask_i              ),
      .in_valid_i       ( in_valid                 ),
      .in_ready_o       ( fmt_in_ready[FMT]        ),
      .flush_i,
      .result_o         ( fmt_outputs[FMT].result  ),
      .status_o         ( fmt_outputs[FMT].status  ),
      .extension_bit_o  ( fmt_outputs[FMT].ext_bit ),
      .tag_o            ( fmt_outputs[FMT].tag     ),
      .out_valid_o      ( fmt_out_valid[FMT]       ),
      .out_ready_i      ( fmt_out_ready[FMT]       ),
      .busy_o           ( fmt_busy[FMT]            ),
      .reg_ena_i        ( '0                       ),
      .early_out_valid_o( early_valid[FMT]         )
    );

  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  rr_arb_tree #(
    .NumIn     ( NUM_FORMATS ),
    .DataType  ( output_t    ),
    .AxiVldRdy ( 1'b1        )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( fmt_out_valid  ),
    .gnt_o  ( fmt_out_ready  ),
    .data_i ( fmt_outputs    ),
    .gnt_i  ( out_ready_i    ),
    .req_o  ( out_valid_o    ),
    .data_o ( arbiter_output ),
    .idx_o  ( /* unused */   )
  );

  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign extension_bit_o = arbiter_output.ext_bit;
  assign tag_o           = arbiter_output.tag;

  assign early_valid_o   = |early_valid;

  assign busy_o = (| fmt_busy);

endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_fmt_slice.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_opgroup_fmt_slice #(
  parameter fpnew_pkg::opgroup_e     OpGroup       = fpnew_pkg::ADDMUL,
  parameter fpnew_pkg::fp_format_e   FpFormat      = fpnew_pkg::fp_format_e'(0),
  // FPU configuration
  parameter int unsigned             Width         = 32,
  parameter logic                    EnableVectors = 1'b1,
  parameter int unsigned             NumPipeRegs   = 0,
  parameter fpnew_pkg::pipe_config_t PipeConfig    = fpnew_pkg::BEFORE,
  parameter logic                    ExtRegEna     = 1'b0,
  parameter type                     TagType       = logic,
  parameter int unsigned             TrueSIMDClass = 0,
  // Do not change
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_LANES    = fpnew_pkg::num_lanes(Width, FpFormat, EnableVectors),
  localparam type         MaskType     = logic [NUM_LANES-1:0],
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0] operands_i,
  input logic [NUM_OPERANDS-1:0]            is_boxed_i,
  input fpnew_pkg::roundmode_e              rnd_mode_i,
  input fpnew_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  input MaskType                            simd_mask_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [Width-1:0]                  result_o,
  output fpnew_pkg::status_t                status_o,
  output logic                              extension_bit_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]         reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                              early_out_valid_o
);

  localparam int unsigned FP_WIDTH  = fpnew_pkg::fp_width(FpFormat);
  localparam int unsigned SIMD_WIDTH = unsigned'(Width/NUM_LANES);


  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid; // Handshake signals for the lanes
  logic                 vectorial_op;

  logic [NUM_LANES*FP_WIDTH-1:0] slice_result;
  logic [Width-1:0]              slice_regular_result, slice_class_result, slice_vec_class_result;

  fpnew_pkg::status_t    [NUM_LANES-1:0] lane_status;
  logic                  [NUM_LANES-1:0] lane_ext_bit; // only the first one is actually used
  fpnew_pkg::classmask_e [NUM_LANES-1:0] lane_class_mask;
  TagType                [NUM_LANES-1:0] lane_tags; // only the first one is actually used
  logic                  [NUM_LANES-1:0] lane_masks;
  logic                  [NUM_LANES-1:0] lane_vectorial, lane_busy, lane_is_class; // dito
  logic                  [NUM_LANES-1:0] lane_early_out_valid;

  logic result_is_vector, result_is_class;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    logic [FP_WIDTH-1:0] local_result; // lane-local results
    logic                local_sign;

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || EnableVectors) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][FP_WIDTH-1:0] local_operands; // lane-local operands
      logic [FP_WIDTH-1:0]                   op_result;      // lane-local results
      fpnew_pkg::status_t                    op_status;

      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors
      // Slice out the operands for this lane
      always_comb begin : prepare_input
        for (int i = 0; i < int'(NUM_OPERANDS); i++) begin
          local_operands[i] = operands_i[i][(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH];
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == fpnew_pkg::ADDMUL) begin : lane_instance
        fpnew_fma #(
          .FpFormat    ( FpFormat    ),
          .NumPipeRegs ( NumPipeRegs ),
          .PipeConfig  ( PipeConfig  ),
          .TagType     ( TagType     ),
          .AuxType     ( logic       )
        ) i_fma (
          .clk_i,
          .rst_ni,
          .operands_i       ( local_operands               ),
          .is_boxed_i       ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .mask_i           ( simd_mask_i[lane]    ),
          .aux_i            ( vectorial_op         ), // Remember whether operation was vectorial
          .in_valid_i       ( in_valid             ),
          .in_ready_o       ( lane_in_ready[lane]  ),
          .flush_i,
          .result_o         ( op_result            ),
          .status_o         ( op_status            ),
          .extension_bit_o  ( lane_ext_bit[lane]   ),
          .tag_o            ( lane_tags[lane]      ),
          .mask_o           ( lane_masks[lane]     ),
          .aux_o            ( lane_vectorial[lane] ),
          .out_valid_o      ( out_valid            ),
          .out_ready_i      ( out_ready            ),
          .busy_o           ( lane_busy[lane]      ),
          .reg_ena_i,
          .early_out_valid_o( lane_early_out_valid[lane] )
        );
        assign lane_is_class[lane]   = 1'b0;
        assign lane_class_mask[lane] = fpnew_pkg::NEGINF;
      end else if (OpGroup == fpnew_pkg::DIVSQRT) begin : lane_instance
        // fpnew_divsqrt #(
        //   .FpFormat   (FpFormat),
        //   .NumPipeRegs(NumPipeRegs),
        //   .PipeConfig (PipeConfig),
        //   .TagType    (TagType),
        //   .AuxType    (logic)
        // ) i_divsqrt (
        //   .clk_i,
        //   .rst_ni,
        //   .operands_i      ( local_operands               ),
        //   .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
        //   .rnd_mode_i,
        //   .op_i,
        //   .op_mod_i,
        //   .tag_i,
        //   .aux_i           ( vectorial_op         ), // Remember whether operation was vectorial
        //   .in_valid_i      ( in_valid             ),
        //   .in_ready_o      ( lane_in_ready[lane]  ),
        //   .flush_i,
        //   .result_o        ( op_result            ),
        //   .status_o        ( op_status            ),
        //   .extension_bit_o ( lane_ext_bit[lane]   ),
        //   .tag_o           ( lane_tags[lane]      ),
        //   .aux_o           ( lane_vectorial[lane] ),
        //   .out_valid_o     ( out_valid            ),
        //   .out_ready_i     ( out_ready            ),
        //   .busy_o          ( lane_busy[lane]      ),
        //   .reg_ena_i
        // );
        // assign lane_is_class[lane] = 1'b0;
      end else if (OpGroup == fpnew_pkg::NONCOMP) begin : lane_instance
        fpnew_noncomp #(
          .FpFormat   (FpFormat),
          .NumPipeRegs(NumPipeRegs),
          .PipeConfig (PipeConfig),
          .TagType    (TagType),
          .AuxType    (logic)
        ) i_noncomp (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands               ),
          .is_boxed_i      ( is_boxed_i[NUM_OPERANDS-1:0] ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .tag_i,
          .mask_i            ( simd_mask_i[lane]     ),
          .aux_i             ( vectorial_op          ), // Remember whether operation was vectorial
          .in_valid_i        ( in_valid              ),
          .in_ready_o        ( lane_in_ready[lane]   ),
          .flush_i,
          .result_o          ( op_result             ),
          .status_o          ( op_status             ),
          .extension_bit_o   ( lane_ext_bit[lane]    ),
          .class_mask_o      ( lane_class_mask[lane] ),
          .is_class_o        ( lane_is_class[lane]   ),
          .tag_o             ( lane_tags[lane]       ),
          .mask_o            ( lane_masks[lane]      ),
          .aux_o             ( lane_vectorial[lane]  ),
          .out_valid_o       ( out_valid             ),
          .out_ready_i       ( out_ready             ),
          .busy_o            ( lane_busy[lane]       ),
          .reg_ena_i,
          .early_out_valid_o ( lane_early_out_valid[lane] )
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid   & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = (lane_out_valid[lane] | ExtRegEna) ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = (lane_out_valid[lane] | ExtRegEna) ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign local_result         = '{default: lane_ext_bit[0]}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
      assign lane_is_class[lane]  = 1'b0;
    end

    // Insert lane result into slice result
    assign slice_result[(unsigned'(lane)+1)*FP_WIDTH-1:unsigned'(lane)*FP_WIDTH] = local_result;

    // Create Classification results
    if (TrueSIMDClass && SIMD_WIDTH >= 10) begin : vectorial_true_class // true vectorial class blocks are 10bits in size
      assign slice_vec_class_result[lane*SIMD_WIDTH +: 10] = lane_class_mask[lane];
      assign slice_vec_class_result[(lane+1)*SIMD_WIDTH-1 -: SIMD_WIDTH-10] = '0;
    end else if ((lane+1)*8 <= Width) begin : vectorial_class // vectorial class blocks are 8bits in size
      assign local_sign = (lane_class_mask[lane] == fpnew_pkg::NEGINF ||
                           lane_class_mask[lane] == fpnew_pkg::NEGNORM ||
                           lane_class_mask[lane] == fpnew_pkg::NEGSUBNORM ||
                           lane_class_mask[lane] == fpnew_pkg::NEGZERO);
      // Write the current block segment
      assign slice_vec_class_result[(lane+1)*8-1:lane*8] = {
        local_sign,  // BIT 7
        ~local_sign, // BIT 6
        lane_class_mask[lane] == fpnew_pkg::QNAN, // BIT 5
        lane_class_mask[lane] == fpnew_pkg::SNAN, // BIT 4
        lane_class_mask[lane] == fpnew_pkg::POSZERO
            || lane_class_mask[lane] == fpnew_pkg::NEGZERO, // BIT 3
        lane_class_mask[lane] == fpnew_pkg::POSSUBNORM
            || lane_class_mask[lane] == fpnew_pkg::NEGSUBNORM, // BIT 2
        lane_class_mask[lane] == fpnew_pkg::POSNORM
            || lane_class_mask[lane] == fpnew_pkg::NEGNORM, // BIT 1
        lane_class_mask[lane] == fpnew_pkg::POSINF
            || lane_class_mask[lane] == fpnew_pkg::NEGINF // BIT 0
      };
    end
  end

  // ------------
  // Output Side
  // ------------
  assign result_is_vector = lane_vectorial[0];
  assign result_is_class  = lane_is_class[0];

  assign slice_regular_result = $signed({extension_bit_o, slice_result});

  localparam int unsigned CLASS_VEC_BITS = (NUM_LANES*8 > Width) ? 8 * (Width / 8) : NUM_LANES*8;

  // Pad out unused vec_class bits if each classify result is on 8 bits
  if (!(TrueSIMDClass && SIMD_WIDTH >= 10)) begin
    if (CLASS_VEC_BITS < Width) begin : pad_vectorial_class
      assign slice_vec_class_result[Width-1:CLASS_VEC_BITS] = '0;
    end
  end

  // localparam logic [Width-1:0] CLASS_VEC_MASK = 2**CLASS_VEC_BITS - 1;

  assign slice_class_result = result_is_vector ? slice_vec_class_result : lane_class_mask[0];

  // Select the proper result
  assign result_o = result_is_class ? slice_class_result : slice_regular_result;

  assign extension_bit_o                              = lane_ext_bit[0]; // upper lanes unused
  assign tag_o                                        = lane_tags[0];    // upper lanes unused
  assign busy_o                                       = (| lane_busy);
  assign out_valid_o                                  = lane_out_valid[0]; // upper lanes unused
  assign early_out_valid_o                            = |lane_early_out_valid;


  // Collapse the lane status
  always_comb begin : output_processing
    // Collapse the status
    automatic fpnew_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i] & {5{lane_masks[i]}};
    status_o = temp_status;
  end
endmodule
// ----- 8< ----- FILE "./fpnew_opgroup_multifmt_slice.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>



module fpnew_opgroup_multifmt_slice #(
  parameter fpnew_pkg::opgroup_e      OpGroup       = fpnew_pkg::CONV,
  parameter int unsigned              Width         = 64,
  // FPU configuration
  parameter fpnew_pkg::fmt_logic_t    FpFmtConfig   = '1,
  parameter fpnew_pkg::ifmt_logic_t   IntFmtConfig  = '1,
  parameter logic                     EnableVectors = 1'b1,
  parameter fpnew_pkg::divsqrt_unit_t DivSqrtSel    = fpnew_pkg::THMULTI,
  parameter int unsigned              NumPipeRegs   = 0,
  parameter fpnew_pkg::pipe_config_t  PipeConfig    = fpnew_pkg::BEFORE,
  parameter logic                     ExtRegEna     = 1'b0,
  parameter type                      TagType       = logic,
  // Do not change
  localparam int unsigned NUM_OPERANDS = fpnew_pkg::num_operands(OpGroup),
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS,
  localparam int unsigned NUM_SIMD_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, EnableVectors),
  localparam type         MaskType     = logic [NUM_SIMD_LANES-1:0],
  localparam int unsigned ExtRegEnaWidth = NumPipeRegs == 0 ? 1 : NumPipeRegs
) (
  input logic                                     clk_i,
  input logic                                     rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][Width-1:0]       operands_i,
  input logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed_i,
  input fpnew_pkg::roundmode_e                    rnd_mode_i,
  input fpnew_pkg::operation_e                    op_i,
  input logic                                     op_mod_i,
  input fpnew_pkg::fp_format_e                    src_fmt_i,
  input fpnew_pkg::fp_format_e                    dst_fmt_i,
  input fpnew_pkg::int_format_e                   int_fmt_i,
  input logic                                     vectorial_op_i,
  input TagType                                   tag_i,
  input MaskType                                  simd_mask_i,
  // Input Handshake
  input  logic                                    in_valid_i,
  output logic                                    in_ready_o,
  input  logic                                    flush_i,
  // Output signals
  output logic [Width-1:0]                        result_o,
  output fpnew_pkg::status_t                      status_o,
  output logic                                    extension_bit_o,
  output TagType                                  tag_o,
  // Output handshake
  output logic                                    out_valid_o,
  input  logic                                    out_ready_i,
  // Indication of valid data in flight
  output logic                                    busy_o,
  // External register enable override
  input  logic [ExtRegEnaWidth-1:0]               reg_ena_i,
  // Early valid for external structural hazard generation
  output logic                                    early_out_valid_o
);

  if ((OpGroup == fpnew_pkg::DIVSQRT)) begin
    if ((DivSqrtSel == fpnew_pkg::TH32) && !((FpFmtConfig[0] == 1) && (FpFmtConfig[1:NUM_FORMATS-1] == '0))) begin
      $fatal(1, "T-Head-based DivSqrt unit supported only in FP32-only configurations. \
Set DivSqrtSel = THMULTI or DivSqrtSel = PULP to use a multi-format divider");
    end else if ((DivSqrtSel == fpnew_pkg::THMULTI) && (FpFmtConfig[3] == 1'b1)) begin
      $warning("The DivSqrt unit of C910 (instantiated by DivSqrtSel = THMULTI) does not support \
FP8. Please use the PULP DivSqrt unit when in need of div/sqrt operations on FP8.");
    end
  end

  localparam int unsigned MAX_FP_WIDTH   = fpnew_pkg::max_fp_width(FpFmtConfig);
  localparam int unsigned MAX_INT_WIDTH  = fpnew_pkg::max_int_width(IntFmtConfig);
  localparam int unsigned NUM_LANES = fpnew_pkg::max_num_lanes(Width, FpFmtConfig, 1'b1);
  localparam int unsigned NUM_DIVSQRT_LANES = fpnew_pkg::num_divsqrt_lanes(Width, FpFmtConfig, 1'b1, DivSqrtSel);
  localparam int unsigned NUM_INT_FORMATS = fpnew_pkg::NUM_INT_FORMATS;
  // We will send the format information along with the data
  localparam int unsigned FMT_BITS =
      fpnew_pkg::maximum($clog2(NUM_FORMATS), $clog2(NUM_INT_FORMATS));
  localparam int unsigned AUX_BITS = FMT_BITS + 2; // also add vectorial and integer flags

  logic [NUM_LANES-1:0] lane_in_ready, lane_out_valid, divsqrt_done, divsqrt_ready; // Handshake signals for the lanes
  logic                 vectorial_op;
  logic [FMT_BITS-1:0]  dst_fmt; // destination format to pass along with operation
  logic [AUX_BITS-1:0]  aux_data;

  // additional flags for CONV
  logic       dst_fmt_is_int, dst_is_cpk;
  logic [1:0] dst_vec_op; // info for vectorial results (for packing)
  logic [2:0] target_aux_d;
  logic       is_up_cast, is_down_cast;

  logic [NUM_FORMATS-1:0][Width-1:0]     fmt_slice_result;
  logic [NUM_INT_FORMATS-1:0][Width-1:0] ifmt_slice_result;

  logic [Width-1:0] conv_target_d, conv_target_q; // vectorial conversions update a register

  fpnew_pkg::status_t [NUM_LANES-1:0]   lane_status;
  logic   [NUM_LANES-1:0]               lane_ext_bit; // only the first one is actually used
  TagType [NUM_LANES-1:0]               lane_tags; // only the first one is actually used
  logic   [NUM_LANES-1:0]               lane_masks;
  logic   [NUM_LANES-1:0][AUX_BITS-1:0] lane_aux; // only the first one is actually used
  logic   [NUM_LANES-1:0]               lane_busy; // dito
  logic   [NUM_LANES-1:0]               lane_early_out_valid;


  logic                result_is_vector;
  logic [FMT_BITS-1:0] result_fmt;
  logic                result_fmt_is_int, result_is_cpk;
  logic [1:0]          result_vec_op; // info for vectorial results (for packing)

  logic simd_synch_rdy, simd_synch_done;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o   = lane_in_ready[0]; // Upstream ready is given by first lane
  assign vectorial_op = vectorial_op_i & EnableVectors; // only do vectorial stuff if enabled

  // Cast-and-Pack ops are encoded in operation and modifier
  assign dst_fmt_is_int = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::F2I);
  assign dst_is_cpk     = (OpGroup == fpnew_pkg::CONV) & (op_i == fpnew_pkg::CPKAB ||
                                                          op_i == fpnew_pkg::CPKCD);
  assign dst_vec_op     = (OpGroup == fpnew_pkg::CONV) & {(op_i == fpnew_pkg::CPKCD), op_mod_i};

  assign is_up_cast   = (fpnew_pkg::fp_width(dst_fmt_i) > fpnew_pkg::fp_width(src_fmt_i));
  assign is_down_cast = (fpnew_pkg::fp_width(dst_fmt_i) < fpnew_pkg::fp_width(src_fmt_i));

  // The destination format is the int format for F2I casts
  assign dst_fmt    = dst_fmt_is_int ? int_fmt_i : dst_fmt_i;

  // The data sent along consists of the vectorial flag and format bits
  assign aux_data      = {dst_fmt_is_int, vectorial_op, dst_fmt};
  assign target_aux_d  = {dst_vec_op, dst_is_cpk};

  // CONV passes one operand for assembly after the unit: opC for cpk, opB for others
  if (OpGroup == fpnew_pkg::CONV) begin : conv_target
    assign conv_target_d = dst_is_cpk ? operands_i[2] : operands_i[1];
  end else begin : not_conv_target
    assign conv_target_d = '0;
  end

  // For 2-operand units, prepare boxing info
  logic [NUM_FORMATS-1:0]      is_boxed_1op;
  logic [NUM_FORMATS-1:0][1:0] is_boxed_2op;

  always_comb begin : boxed_2op
    for (int fmt = 0; fmt < NUM_FORMATS; fmt++) begin
      is_boxed_1op[fmt] = is_boxed_i[fmt][0];
      is_boxed_2op[fmt] = is_boxed_i[fmt][1:0];
    end
  end

  // ---------------
  // Generate Lanes
  // ---------------
  for (genvar lane = 0; lane < int'(NUM_LANES); lane++) begin : gen_num_lanes
    localparam int unsigned LANE = unsigned'(lane); // unsigned to please the linter
    // Get a mask of active formats for this lane
    localparam fpnew_pkg::fmt_logic_t ACTIVE_FORMATS =
        fpnew_pkg::get_lane_formats(Width, FpFmtConfig, LANE);
    localparam fpnew_pkg::ifmt_logic_t ACTIVE_INT_FORMATS =
        fpnew_pkg::get_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned MAX_WIDTH = fpnew_pkg::max_fp_width(ACTIVE_FORMATS);

    // Cast-specific parameters
    localparam fpnew_pkg::fmt_logic_t CONV_FORMATS =
        fpnew_pkg::get_conv_lane_formats(Width, FpFmtConfig, LANE);
    localparam fpnew_pkg::ifmt_logic_t CONV_INT_FORMATS =
        fpnew_pkg::get_conv_lane_int_formats(Width, FpFmtConfig, IntFmtConfig, LANE);
    localparam int unsigned CONV_WIDTH = fpnew_pkg::max_fp_width(CONV_FORMATS);

    // Lane parameters from Opgroup
    localparam fpnew_pkg::fmt_logic_t LANE_FORMATS = (OpGroup == fpnew_pkg::CONV)
                                                     ? CONV_FORMATS : ACTIVE_FORMATS;
    localparam int unsigned LANE_WIDTH = (OpGroup == fpnew_pkg::CONV) ? CONV_WIDTH : MAX_WIDTH;

    logic [LANE_WIDTH-1:0] local_result; // lane-local results

    // Generate instances only if needed, lane 0 always generated
    if ((lane == 0) || (EnableVectors & (!(OpGroup == fpnew_pkg::DIVSQRT && (lane >= NUM_DIVSQRT_LANES))))) begin : active_lane
      logic in_valid, out_valid, out_ready; // lane-local handshake

      logic [NUM_OPERANDS-1:0][LANE_WIDTH-1:0] local_operands;  // lane-local oprands
      logic [LANE_WIDTH-1:0]                   op_result;       // lane-local results
      fpnew_pkg::status_t                      op_status;

      assign in_valid = in_valid_i & ((lane == 0) | vectorial_op); // upper lanes only for vectors

      // Slice out the operands for this lane, upper bits are ignored in the unit
      always_comb begin : prepare_input
        for (int unsigned i = 0; i < NUM_OPERANDS; i++) begin
          if (i == 2) begin
            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(op_i == fpnew_pkg::ADDS ? src_fmt_i : dst_fmt_i);
          end else begin
            local_operands[i] = operands_i[i] >> LANE*fpnew_pkg::fp_width(src_fmt_i);
          end
        end

        // override operand 0 for some conversions
        if (OpGroup == fpnew_pkg::CONV) begin
          // Source is an integer
          if (op_i == fpnew_pkg::I2F) begin
            local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::int_width(int_fmt_i);
          // vectorial F2F up casts
          end else if (op_i == fpnew_pkg::F2F) begin
            if (vectorial_op && op_mod_i && is_up_cast) begin // up cast with upper half
              local_operands[0] = operands_i[0] >> LANE*fpnew_pkg::fp_width(src_fmt_i) +
                                                   MAX_FP_WIDTH/2;
            end
          // CPK
          end else if (dst_is_cpk) begin
            if (lane == 1) begin
              local_operands[0] = operands_i[1][LANE_WIDTH-1:0]; // using opB as second argument
            end
          end
        end
      end

      // Instantiate the operation from the selected opgroup
      if (OpGroup == fpnew_pkg::ADDMUL) begin : lane_instance
        fpnew_fma_multi #(
          .FpFmtConfig ( LANE_FORMATS         ),
          .NumPipeRegs ( NumPipeRegs          ),
          .PipeConfig  ( PipeConfig           ),
          .TagType     ( TagType              ),
          .AuxType     ( logic [AUX_BITS-1:0] )
        ) i_fpnew_fma_multi (
          .clk_i,
          .rst_ni,
          .operands_i       ( local_operands                                  ),
          .is_boxed_i,
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .src2_fmt_i       ( op_i == fpnew_pkg::ADDS ? src_fmt_i : dst_fmt_i ),
          .dst_fmt_i,
          .tag_i,
          .mask_i           ( simd_mask_i[lane]                               ),
          .aux_i            ( aux_data                                        ),
          .in_valid_i       ( in_valid                                        ),
          .in_ready_o       ( lane_in_ready[lane]                             ),
          .flush_i,
          .result_o         ( op_result                                       ),
          .status_o         ( op_status                                       ),
          .extension_bit_o  ( lane_ext_bit[lane]                              ),
          .tag_o            ( lane_tags[lane]                                 ),
          .mask_o           ( lane_masks[lane]                                ),
          .aux_o            ( lane_aux[lane]                                  ),
          .out_valid_o      ( out_valid                                       ),
          .out_ready_i      ( out_ready                                       ),
          .busy_o           ( lane_busy[lane]                                 ),
          .reg_ena_i,
          .early_out_valid_o( lane_early_out_valid[lane]                      )
        );

      end else if (OpGroup == fpnew_pkg::DIVSQRT) begin : lane_instance
         if (DivSqrtSel == fpnew_pkg::TH32 && LANE_FORMATS[0] && (LANE_FORMATS[1:fpnew_pkg::NUM_FP_FORMATS-1] == '0)) begin : gen_th32_e906_divsqrt
          // The T-head-based DivSqrt unit is supported only in FP32-only configurations
          fpnew_divsqrt_th_32 #(
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_multi_th (
            .clk_i,
            .rst_ni,
            .operands_i       ( local_operands[1:0] ), // 2 operands
            .is_boxed_i       ( is_boxed_2op        ), // 2 operands
            .rnd_mode_i,
            .op_i,
            .tag_i,
            .mask_i           ( simd_mask_i[lane]   ),
            .aux_i            ( aux_data            ),
            .in_valid_i       ( in_valid            ),
            .in_ready_o       ( lane_in_ready[lane] ),
            .flush_i,
            .result_o         ( op_result           ),
            .status_o         ( op_status           ),
            .extension_bit_o  ( lane_ext_bit[lane]  ),
            .tag_o            ( lane_tags[lane]     ),
            .mask_o           ( lane_masks[lane]    ),
            .aux_o            ( lane_aux[lane]      ),
            .out_valid_o      ( out_valid           ),
            .out_ready_i      ( out_ready           ),
            .busy_o           ( lane_busy[lane]     ),
            .reg_ena_i,
            .early_out_valid_o( lane_early_out_valid[lane] )
          );
        end else if(DivSqrtSel == fpnew_pkg::THMULTI) begin : gen_thmulti_c910_divsqrt
          fpnew_divsqrt_th_64_multi #(
            .FpFmtConfig ( LANE_FORMATS         ),
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_th_64_c910 (
           .clk_i,
            .rst_ni,
            .operands_i       ( local_operands[1:0] ), // 2 operands
            .is_boxed_i       ( is_boxed_2op        ), // 2 operands
            .rnd_mode_i,
            .op_i,
            .dst_fmt_i,
            .tag_i,
            .mask_i           ( simd_mask_i[lane]   ),
            .aux_i            ( aux_data            ),
            .vectorial_op_i   ( vectorial_op        ), // synchronize only vectorial operations
            .in_valid_i       ( in_valid            ),
            .in_ready_o       ( lane_in_ready[lane] ),
            .divsqrt_done_o   ( divsqrt_done[lane]  ),
            .simd_synch_done_i( simd_synch_done     ),
            .divsqrt_ready_o  ( divsqrt_ready[lane] ),
            .simd_synch_rdy_i ( simd_synch_rdy      ),
            .flush_i,
            .result_o         ( op_result           ),
            .status_o         ( op_status           ),
            .extension_bit_o  ( lane_ext_bit[lane]  ),
            .tag_o            ( lane_tags[lane]     ),
            .mask_o           ( lane_masks[lane]    ),
            .aux_o            ( lane_aux[lane]      ),
            .out_valid_o      ( out_valid           ),
            .out_ready_i      ( out_ready           ),
            .busy_o           ( lane_busy[lane]     ),
            .reg_ena_i,
            .early_out_valid_o( lane_early_out_valid[lane] )
          );
        end else begin : gen_pulp_divsqrt
          fpnew_divsqrt_multi #(
            .FpFmtConfig ( LANE_FORMATS         ),
            .NumPipeRegs ( NumPipeRegs          ),
            .PipeConfig  ( PipeConfig           ),
            .TagType     ( TagType              ),
            .AuxType     ( logic [AUX_BITS-1:0] )
          ) i_fpnew_divsqrt_multi (
            .clk_i,
            .rst_ni,
            .operands_i       ( local_operands[1:0] ), // 2 operands
            .is_boxed_i       ( is_boxed_2op        ), // 2 operands
            .rnd_mode_i,
            .op_i,
            .dst_fmt_i,
            .tag_i,
            .mask_i           ( simd_mask_i[lane]   ),
            .aux_i            ( aux_data            ),
            .vectorial_op_i   ( vectorial_op        ),
            .in_valid_i       ( in_valid            ),
            .in_ready_o       ( lane_in_ready[lane] ),
            .divsqrt_done_o   ( divsqrt_done[lane]  ),
            .simd_synch_done_i( simd_synch_done     ),
            .divsqrt_ready_o  ( divsqrt_ready[lane] ),
            .simd_synch_rdy_i ( simd_synch_rdy      ),
            .flush_i,
            .result_o         ( op_result           ),
            .status_o         ( op_status           ),
            .extension_bit_o  ( lane_ext_bit[lane]  ),
            .tag_o            ( lane_tags[lane]     ),
            .mask_o           ( lane_masks[lane]    ),
            .aux_o            ( lane_aux[lane]      ),
            .out_valid_o      ( out_valid           ),
            .out_ready_i      ( out_ready           ),
            .busy_o           ( lane_busy[lane]     ),
            .reg_ena_i,
            .early_out_valid_o( lane_early_out_valid[lane] )
          );
        end

      end else if (OpGroup == fpnew_pkg::NONCOMP) begin : lane_instance

      end else if (OpGroup == fpnew_pkg::CONV) begin : lane_instance
        fpnew_cast_multi #(
          .FpFmtConfig  ( LANE_FORMATS         ),
          .IntFmtConfig ( CONV_INT_FORMATS     ),
          .NumPipeRegs  ( NumPipeRegs          ),
          .PipeConfig   ( PipeConfig           ),
          .TagType      ( TagType              ),
          .AuxType      ( logic [AUX_BITS-1:0] )
        ) i_fpnew_cast_multi (
          .clk_i,
          .rst_ni,
          .operands_i      ( local_operands[0]   ),
          .is_boxed_i      ( is_boxed_1op        ),
          .rnd_mode_i,
          .op_i,
          .op_mod_i,
          .src_fmt_i,
          .dst_fmt_i,
          .int_fmt_i,
          .tag_i,
          .mask_i           ( simd_mask_i[lane]   ),
          .aux_i            ( aux_data            ),
          .in_valid_i       ( in_valid            ),
          .in_ready_o       ( lane_in_ready[lane] ),
          .flush_i,
          .result_o         ( op_result           ),
          .status_o         ( op_status           ),
          .extension_bit_o  ( lane_ext_bit[lane]  ),
          .tag_o            ( lane_tags[lane]     ),
          .mask_o           ( lane_masks[lane]    ),
          .aux_o            ( lane_aux[lane]      ),
          .out_valid_o      ( out_valid           ),
          .out_ready_i      ( out_ready           ),
          .busy_o           ( lane_busy[lane]     ),
          .reg_ena_i,
          .early_out_valid_o( lane_early_out_valid[lane] )
        );
      end // ADD OTHER OPTIONS HERE

      // Handshakes are only done if the lane is actually used
      assign out_ready            = out_ready_i & ((lane == 0) | result_is_vector);
      assign lane_out_valid[lane] = out_valid & ((lane == 0) | result_is_vector);

      // Properly NaN-box or sign-extend the slice result if not in use
      assign local_result      = (lane_out_valid[lane] | ExtRegEna) ? op_result : '{default: lane_ext_bit[0]};
      assign lane_status[lane] = (lane_out_valid[lane] | ExtRegEna) ? op_status : '0;

    // Otherwise generate constant sign-extension
    end else begin : inactive_lane
      assign lane_out_valid[lane] = 1'b0; // unused lane
      assign lane_in_ready[lane]  = 1'b0; // unused lane
      assign lane_aux[lane]       = 1'b0; // unused lane
      assign lane_masks[lane]     = 1'b1; // unused lane
      assign lane_tags[lane]      = 1'b0; // unused lane
      assign divsqrt_done[lane]   = 1'b0; // unused lane
      assign divsqrt_ready[lane]  = 1'b0; // unused lane
      assign lane_ext_bit[lane]   = 1'b1; // NaN-box unused lane
      assign local_result         = {(LANE_WIDTH){lane_ext_bit[0]}}; // sign-extend/nan box
      assign lane_status[lane]    = '0;
      assign lane_busy[lane]      = 1'b0;
    end

    // Generate result packing depending on float format
    for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : pack_fp_result
      // Set up some constants
      localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
      // only for active formats within the lane
      if (ACTIVE_FORMATS[fmt]) begin
        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
            local_result[FP_WIDTH-1:0];
      end else if ((LANE+1)*FP_WIDTH <= Width) begin
        assign fmt_slice_result[fmt][(LANE+1)*FP_WIDTH-1:LANE*FP_WIDTH] =
            '{default: lane_ext_bit[LANE]};
      end else if (LANE*FP_WIDTH < Width) begin
        assign fmt_slice_result[fmt][Width-1:LANE*FP_WIDTH] =
            '{default: lane_ext_bit[LANE]};
      end
    end

    // Generate result packing depending on integer format
    if (OpGroup == fpnew_pkg::CONV) begin : int_results_enabled
      for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : pack_int_result
        // Set up some constants
        localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));
        if (ACTIVE_INT_FORMATS[ifmt]) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] =
            local_result[INT_WIDTH-1:0];
        end else if ((LANE+1)*INT_WIDTH <= Width) begin
          assign ifmt_slice_result[ifmt][(LANE+1)*INT_WIDTH-1:LANE*INT_WIDTH] = '0;
        end else if (LANE*INT_WIDTH < Width) begin
          assign ifmt_slice_result[ifmt][Width-1:LANE*INT_WIDTH] = '0;
        end
      end
    end
  end

  // Extend slice result if needed
  for (genvar fmt = 0; fmt < NUM_FORMATS; fmt++) begin : extend_fp_result
    // Set up some constants
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    if (NUM_LANES*FP_WIDTH < Width)
      assign fmt_slice_result[fmt][Width-1:NUM_LANES*FP_WIDTH] = '{default: lane_ext_bit[0]};
  end

  for (genvar ifmt = 0; ifmt < NUM_INT_FORMATS; ifmt++) begin : extend_or_mute_int_result
    // Mute int results if unused
    if (OpGroup != fpnew_pkg::CONV) begin : mute_int_result
      assign ifmt_slice_result[ifmt] = '0;

    // Extend slice result if needed
    end else begin : extend_int_result
      // Set up some constants
      localparam int unsigned INT_WIDTH = fpnew_pkg::int_width(fpnew_pkg::int_format_e'(ifmt));
      if (NUM_LANES*INT_WIDTH < Width)
        assign ifmt_slice_result[ifmt][Width-1:NUM_LANES*INT_WIDTH] = '0;
    end
  end

  // Bypass lanes with target operand for vectorial casts
  if (OpGroup == fpnew_pkg::CONV) begin : target_regs
    // Bypass pipeline signals, index i holds signal after i register stages
    logic [0:NumPipeRegs][Width-1:0] byp_pipe_target_q;
    logic [0:NumPipeRegs][2:0]       byp_pipe_aux_q;
    logic [0:NumPipeRegs]            byp_pipe_valid_q;
    // Ready signal is combinatorial for all stages
    logic [0:NumPipeRegs] byp_pipe_ready;

    // Input stage: First element of pipeline is taken from inputs
    assign byp_pipe_target_q[0]  = conv_target_d;
    assign byp_pipe_aux_q[0]     = target_aux_d;
    assign byp_pipe_valid_q[0]   = in_valid_i & vectorial_op;
    // Generate the register stages
    for (genvar i = 0; i < NumPipeRegs; i++) begin : gen_bypass_pipeline
      // Internal register enable for this stage
      logic reg_ena;
      // Determine the ready signal of the current stage - advance the pipeline:
      // 1. if the next stage is ready for our data
      // 2. if the next stage only holds a bubble (not valid) -> we can pop it
      assign byp_pipe_ready[i] = byp_pipe_ready[i+1] | ~byp_pipe_valid_q[i+1];
      // Valid: enabled by ready signal, synchronous clear with the flush signal
      `FFLARNC(byp_pipe_valid_q[i+1], byp_pipe_valid_q[i], byp_pipe_ready[i], flush_i, 1'b0, clk_i, rst_ni)
      // Enable register if pipleine ready and a valid data item is present
      assign reg_ena = (byp_pipe_ready[i] & byp_pipe_valid_q[i]) | reg_ena_i[i];
      // Generate the pipeline registers within the stages, use enable-registers
      `FFL(byp_pipe_target_q[i+1],  byp_pipe_target_q[i],  reg_ena, '0)
      `FFL(byp_pipe_aux_q[i+1],     byp_pipe_aux_q[i],     reg_ena, '0)
    end
    // Output stage: Ready travels backwards from output side, driven by downstream circuitry
    assign byp_pipe_ready[NumPipeRegs] = out_ready_i & result_is_vector;
    // Output stage: assign module outputs
    assign conv_target_q = byp_pipe_target_q[NumPipeRegs];

    // decode the aux data
    assign {result_vec_op, result_is_cpk} = byp_pipe_aux_q[NumPipeRegs];
  end else begin : no_conv
    assign {result_vec_op, result_is_cpk} = '0;
    assign conv_target_q = '0;
  end

  if ((DivSqrtSel != fpnew_pkg::TH32) && !ExtRegEna) begin
    // Synch lanes if there is more than one
    assign simd_synch_rdy  = EnableVectors ? &divsqrt_ready[NUM_DIVSQRT_LANES-1:0] : divsqrt_ready[0];
    assign simd_synch_done = EnableVectors ? &divsqrt_done[NUM_DIVSQRT_LANES-1:0]  : divsqrt_done[0];
  end else begin
    // Unused (TH32 divider only supported for scalar FP32 divsqrt)
    assign simd_synch_rdy  = '0;
    assign simd_synch_done = '0;
  end

  // ------------
  // Output Side
  // ------------
  assign {result_fmt_is_int, result_is_vector, result_fmt} = lane_aux[0];

  assign result_o = result_fmt_is_int
                    ? ifmt_slice_result[result_fmt]
                    : fmt_slice_result[result_fmt];

  assign extension_bit_o = lane_ext_bit[0]; // don't care about upper ones
  assign tag_o           = lane_tags[0];    // don't care about upper ones
  assign busy_o          = (| lane_busy);
  assign early_out_valid_o = |lane_early_out_valid;

  assign out_valid_o     = lane_out_valid[0]; // don't care about upper ones

  // Collapse the status
  always_comb begin : output_processing
    // Collapse the status
    automatic fpnew_pkg::status_t temp_status;
    temp_status = '0;
    for (int i = 0; i < int'(NUM_LANES); i++)
      temp_status |= lane_status[i] & {5{lane_masks[i]}};
    status_o = temp_status;
  end

endmodule
// ----- 8< ----- FILE "./fpnew_rounding.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_rounding #(
  parameter int unsigned AbsWidth=2 // Width of the abolute value, without sign bit
) (
  // Input value
  input logic [AbsWidth-1:0]   abs_value_i,             // absolute value without sign
  input logic                  sign_i,
  // Rounding information
  input logic [1:0]            round_sticky_bits_i,     // round and sticky bits {RS}
  input fpnew_pkg::roundmode_e rnd_mode_i,
  input logic                  effective_subtraction_i, // sign of inputs affects rounding of zeroes
  // Output value
  output logic [AbsWidth-1:0]  abs_rounded_o,           // absolute value without sign
  output logic                 sign_o,
  // Output classification
  output logic                 exact_zero_o             // output is an exact zero
);

  logic round_up; // Rounding decision

  // Take the rounding decision according to RISC-V spec
  // RoundMode | Mnemonic | Meaning
  // :--------:|:--------:|:-------
  //    000    |   RNE    | Round to Nearest, ties to Even
  //    001    |   RTZ    | Round towards Zero
  //    010    |   RDN    | Round Down (towards -\infty)
  //    011    |   RUP    | Round Up (towards \infty)
  //    100    |   RMM    | Round to Nearest, ties to Max Magnitude
  //    101    |   ROD    | Round towards odd (this mode is not define in RISC-V FP-SPEC)
  //  others   |          | *invalid*
  always_comb begin : rounding_decision
    unique case (rnd_mode_i)
      fpnew_pkg::RNE: // Decide accoring to round/sticky bits
        unique case (round_sticky_bits_i)
          2'b00,
          2'b01: round_up = 1'b0;           // < ulp/2 away, round down
          2'b10: round_up = abs_value_i[0]; // = ulp/2 away, round towards even result
          2'b11: round_up = 1'b1;           // > ulp/2 away, round up
          default: round_up = fpnew_pkg::DONT_CARE;
        endcase
      fpnew_pkg::RTZ: round_up = 1'b0; // always round down
      fpnew_pkg::RDN: round_up = (| round_sticky_bits_i) ? sign_i  : 1'b0; // to 0 if +, away if -
      fpnew_pkg::RUP: round_up = (| round_sticky_bits_i) ? ~sign_i : 1'b0; // to 0 if -, away if +
      fpnew_pkg::RMM: round_up = round_sticky_bits_i[1]; // round down if < ulp/2 away, else up
      fpnew_pkg::ROD: round_up = ~abs_value_i[0] & (| round_sticky_bits_i);
      default: round_up = fpnew_pkg::DONT_CARE; // propagate x
    endcase
  end

  // Perform the rounding, exponent change and overflow to inf happens automagically
  assign abs_rounded_o = abs_value_i + round_up;

  // True zero result is a zero result without dirty round/sticky bits
  assign exact_zero_o = (abs_value_i == '0) && (round_sticky_bits_i == '0);

  // In case of effective subtraction (thus signs of addition operands must have differed) and a
  // true zero result, the result sign is '-' in case of RDN and '+' for other modes.
  assign sign_o = (exact_zero_o && effective_subtraction_i)
                  ? (rnd_mode_i == fpnew_pkg::RDN)
                  : sign_i;

endmodule
// ----- 8< ----- FILE "./fpnew_top.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2019 ETH Zurich and University of Bologna.
//
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//
// SPDX-License-Identifier: SHL-0.51

// Author: Stefan Mach <smach@iis.ee.ethz.ch>

module fpnew_top #(
  // FPU configuration
  parameter fpnew_pkg::fpu_features_t       Features       = fpnew_pkg::RV64D_Xsflt,
  parameter fpnew_pkg::fpu_implementation_t Implementation = fpnew_pkg::DEFAULT_NOREGS,
  // DivSqrtSel chooses among PULP, TH32, or THMULTI (see documentation and fpnew_pkg.sv for further details)
  parameter fpnew_pkg::divsqrt_unit_t       DivSqrtSel     = fpnew_pkg::THMULTI,
  parameter type                            TagType        = logic,
  parameter int unsigned                    TrueSIMDClass  = 0,
  parameter int unsigned                    EnableSIMDMask = 0,
  // Do not change
  localparam int unsigned NumLanes     = fpnew_pkg::max_num_lanes(Features.Width, Features.FpFmtMask, Features.EnableVectors),
  localparam type         MaskType     = logic [NumLanes-1:0],
  localparam int unsigned WIDTH        = Features.Width,
  localparam int unsigned NUM_OPERANDS = 3
) (
  input logic                               clk_i,
  input logic                               rst_ni,
  // Input signals
  input logic [NUM_OPERANDS-1:0][WIDTH-1:0] operands_i,
  input fpnew_pkg::roundmode_e              rnd_mode_i,
  input fpnew_pkg::operation_e              op_i,
  input logic                               op_mod_i,
  input fpnew_pkg::fp_format_e              src_fmt_i,
  input fpnew_pkg::fp_format_e              dst_fmt_i,
  input fpnew_pkg::int_format_e             int_fmt_i,
  input logic                               vectorial_op_i,
  input TagType                             tag_i,
  input MaskType                            simd_mask_i,
  // Input Handshake
  input  logic                              in_valid_i,
  output logic                              in_ready_o,
  input  logic                              flush_i,
  // Output signals
  output logic [WIDTH-1:0]                  result_o,
  output fpnew_pkg::status_t                status_o,
  output TagType                            tag_o,
  // Output handshake
  output logic                              out_valid_o,
  input  logic                              out_ready_i,
  // Indication of valid data in flight
  output logic                              busy_o,
  output logic                              early_valid_o
);

  localparam int unsigned NUM_OPGROUPS = fpnew_pkg::NUM_OPGROUPS;
  localparam int unsigned NUM_FORMATS  = fpnew_pkg::NUM_FP_FORMATS;

  // ----------------
  // Type Definition
  // ----------------
  typedef struct packed {
    logic [WIDTH-1:0]   result;
    fpnew_pkg::status_t status;
    TagType             tag;
  } output_t;

  // Handshake signals for the blocks
  logic [NUM_OPGROUPS-1:0] opgrp_in_ready, opgrp_out_valid, opgrp_out_ready, opgrp_ext, opgrp_busy;
  logic [NUM_OPGROUPS-1:0] opgrp_early_valid;
  output_t [NUM_OPGROUPS-1:0] opgrp_outputs;

  logic [NUM_FORMATS-1:0][NUM_OPERANDS-1:0] is_boxed;

  // -----------
  // Input Side
  // -----------
  assign in_ready_o = in_valid_i & opgrp_in_ready[fpnew_pkg::get_opgroup(op_i)];

  // NaN-boxing check
  for (genvar fmt = 0; fmt < int'(NUM_FORMATS); fmt++) begin : gen_nanbox_check
    localparam int unsigned FP_WIDTH = fpnew_pkg::fp_width(fpnew_pkg::fp_format_e'(fmt));
    // NaN boxing is only generated if it's enabled and needed
    if (Features.EnableNanBox && (FP_WIDTH < WIDTH)) begin : check
      for (genvar op = 0; op < int'(NUM_OPERANDS); op++) begin : operands
        assign is_boxed[fmt][op] = (!vectorial_op_i)
                                   ? operands_i[op][WIDTH-1:FP_WIDTH] == '1
                                   : 1'b1;
      end
    end else begin : no_check
      assign is_boxed[fmt] = '1;
    end
  end

  // Filter out the mask if not used
  MaskType simd_mask;
  assign simd_mask = simd_mask_i | ~{NumLanes{logic'(EnableSIMDMask)}};

  // -------------------------
  // Generate Operation Blocks
  // -------------------------
  for (genvar opgrp = 0; opgrp < int'(NUM_OPGROUPS); opgrp++) begin : gen_operation_groups
    localparam int unsigned NUM_OPS = fpnew_pkg::num_operands(fpnew_pkg::opgroup_e'(opgrp));
    localparam fpnew_pkg::opgroup_e OpGroup = fpnew_pkg::opgroup_e'(opgrp);
    localparam logic EnableVectors = Features.EnableVectors;
    localparam fpnew_pkg::fmt_logic_t FpFmtMask = Features.FpFmtMask;
    localparam fpnew_pkg::ifmt_logic_t IntFmtMask = Features.IntFmtMask;
    localparam fpnew_pkg::fmt_unsigned_t FmtPipeRegs = Implementation.PipeRegs[opgrp];
    localparam fpnew_pkg::fmt_unit_types_t FmtUnitTypes = Implementation.UnitTypes[opgrp];
    localparam fpnew_pkg::pipe_config_t PipeConfig = Implementation.PipeConfig;

    logic in_valid;
    logic [NUM_FORMATS-1:0][NUM_OPS-1:0] input_boxed;

    assign in_valid = in_valid_i & (fpnew_pkg::get_opgroup(op_i) == fpnew_pkg::opgroup_e'(opgrp));

    // slice out input boxing
    always_comb begin : slice_inputs
      for (int unsigned fmt = 0; fmt < NUM_FORMATS; fmt++)
        input_boxed[fmt] = is_boxed[fmt][NUM_OPS-1:0];
    end

    fpnew_opgroup_block #(
      .OpGroup       ( OpGroup       ),
      .Width         ( WIDTH         ),
      .EnableVectors ( EnableVectors ),
      .DivSqrtSel    ( DivSqrtSel    ),
      .FpFmtMask     ( FpFmtMask     ),
      .IntFmtMask    ( IntFmtMask    ),
      .FmtPipeRegs   ( FmtPipeRegs   ),
      .FmtUnitTypes  ( FmtUnitTypes  ),
      .PipeConfig    ( PipeConfig    ),
      .TagType       ( TagType       ),
      .TrueSIMDClass ( TrueSIMDClass )
    ) i_opgroup_block (
      .clk_i,
      .rst_ni,
      .operands_i      ( operands_i[NUM_OPS-1:0] ),
      .is_boxed_i      ( input_boxed             ),
      .rnd_mode_i,
      .op_i,
      .op_mod_i,
      .src_fmt_i,
      .dst_fmt_i,
      .int_fmt_i,
      .vectorial_op_i,
      .tag_i,
      .simd_mask_i     ( simd_mask             ),
      .in_valid_i      ( in_valid              ),
      .in_ready_o      ( opgrp_in_ready[opgrp] ),
      .flush_i,
      .result_o        ( opgrp_outputs[opgrp].result ),
      .status_o        ( opgrp_outputs[opgrp].status ),
      .extension_bit_o ( opgrp_ext[opgrp]            ),
      .tag_o           ( opgrp_outputs[opgrp].tag    ),
      .out_valid_o     ( opgrp_out_valid[opgrp]      ),
      .out_ready_i     ( opgrp_out_ready[opgrp]      ),
      .busy_o          ( opgrp_busy[opgrp]           ),
      .early_valid_o   ( opgrp_early_valid[opgrp]    )
    );
  end

  // ------------------
  // Arbitrate Outputs
  // ------------------
  output_t arbiter_output;

  // Round-Robin arbiter to decide which result to use
  rr_arb_tree #(
    .NumIn     ( NUM_OPGROUPS ),
    .DataType  ( output_t     ),
    .AxiVldRdy ( 1'b1         )
  ) i_arbiter (
    .clk_i,
    .rst_ni,
    .flush_i,
    .rr_i   ( '0             ),
    .req_i  ( opgrp_out_valid ),
    .gnt_o  ( opgrp_out_ready ),
    .data_i ( opgrp_outputs   ),
    .gnt_i  ( out_ready_i     ),
    .req_o  ( out_valid_o     ),
    .data_o ( arbiter_output  ),
    .idx_o  ( /* unused */    )
  );

  // Unpack output
  assign result_o        = arbiter_output.result;
  assign status_o        = arbiter_output.status;
  assign tag_o           = arbiter_output.tag;

  assign early_valid_o   = |opgrp_early_valid;
  assign busy_o = (| opgrp_busy);

endmodule
// ----- 8< ----- FILE "./FloatCoreWrapper.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module FloatCoreWrapper(
  input logic clk_i,
  input logic rst_ni,
  input logic in_valid_i,
  output logic in_ready_o,
  input logic [32-1:0] operands_i_0,
  input logic [32-1:0] operands_i_1,
  input logic [32-1:0] operands_i_2,
  input logic[4-1:0] op_i,
  input logic op_mod_i,
  input logic[2:0] rnd_mode_i,
  input logic flush_i,
  output logic out_valid_o,
  input logic out_ready_i,
  output logic[32-1:0] result_o,
  output logic status_o_0,
  output logic status_o_1,
  output logic status_o_2,
  output logic status_o_3,
  output logic status_o_4,
  output logic busy_o,
  output logic early_valid_o
);

  logic [3-1:0][32-1:0] operands_i;
  assign operands_i[0] = operands_i_0;
  assign operands_i[1] = operands_i_1;
  assign operands_i[2] = operands_i_2;
  fpnew_pkg::status_t status_o_pkg;
  assign status_o_0 = status_o_pkg[0];
  assign status_o_1 = status_o_pkg[1];
  assign status_o_2 = status_o_pkg[2];
  assign status_o_3 = status_o_pkg[3];
  assign status_o_4 = status_o_pkg[4];
  localparam fpnew_pkg::fpu_implementation_t impl = '{
  PipeRegs:   '{default: 'd3},
  UnitTypes:  '{'{default: fpnew_pkg::PARALLEL}, // ADDMUL
                '{default: fpnew_pkg::MERGED},   // DIVSQRT
                '{default: fpnew_pkg::PARALLEL}, // NONCOMP
                '{default: fpnew_pkg::MERGED}},  // CONV
  PipeConfig: fpnew_pkg::DISTRIBUTED
};
  fpnew_top#(
      .Features(fpnew_pkg::RV32F),
      .Implementation(impl),
      .DivSqrtSel(fpnew_pkg::TH32)
    ) core(
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .operands_i(operands_i),
    .rnd_mode_i(fpnew_pkg::roundmode_e'(rnd_mode_i)),
    .op_i(fpnew_pkg::operation_e'(op_i)),
    .op_mod_i(op_mod_i),
    .src_fmt_i(fpnew_pkg::FP32),
    .dst_fmt_i(fpnew_pkg::FP32),
    .int_fmt_i(fpnew_pkg::INT32),
    .vectorial_op_i(1'b0),
    .tag_i(1'b0),
    .simd_mask_i(1'b0),
    .in_valid_i(in_valid_i),
    .flush_i(flush_i),
    .out_ready_i(out_ready_i),
    .in_ready_o(in_ready_o),
    .result_o(result_o),
    .status_o(status_o_pkg),
    .tag_o(),
    .out_valid_o(out_valid_o),
    .busy_o(busy_o),
    .early_valid_o(early_valid_o)
  );
endmodule
// ----- 8< ----- FILE "./rvv_backend_config.svh" ----- 8< -----

`ifndef RVV_CONFIG_SVH
`define RVV_CONFIG_SVH

// config for multi-issue
`define ISSUE_3_READ_PORT_6
//`define ISSUE_2_READ_PORT_6
//`define ISSUE_2_READ_PORT_4

`endif // RVV_CONFIG_SVH
// ----- 8< ----- FILE "./rvv_backend_define.svh" ----- 8< -----

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH
`define HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH

`ifndef RVV_CONFIG_SVH
`include "rvv_backend_config.svh"
`endif

// number of scalar core issue lane
`define ISSUE_LANE              4

// the max number of instructions are decoded per cycle in DE stage
`define NUM_DE_INST             2

// multi-issue and multi-read-ports of VRF
`ifdef ISSUE_3_READ_PORT_6
  // the max number of uops are written to Uops Queue per cycle in DE stage
  `define NUM_DE_UOP            6
  `define NUM_DE_UOP_WIDTH      3
  // the max number of uops are dispated per cycle in DP stage.
  `define NUM_DP_UOP            3
  // the number of read ports for VRF
  `define NUM_DP_VRF            6

  // the depth of queue/station/buffer
  `define CQ_DEPTH              16
  `define UQ_DEPTH              16
  `define ALU_RS_DEPTH          8
  `define PMTRDT_RS_DEPTH       8
  `define MUL_RS_DEPTH          8
  `define DIV_RS_DEPTH          8
  `define LSU_RS_DEPTH          8
  `define ROB_DEPTH             8

`elsif ISSUE_2_READ_PORT_6
  // the max number of uops are written to Uops Queue per cycle in DE stage
  `define NUM_DE_UOP            4
  `define NUM_DE_UOP_WIDTH      3
  // the max number of uops are dispated per cycle in DP stage
  `define NUM_DP_UOP            2
  // the number of read ports for VRF
  `define NUM_DP_VRF            6

  // the depth of queue/station/buffer
  `define CQ_DEPTH              16
  `define UQ_DEPTH              16
  `define ALU_RS_DEPTH          4
  `define PMTRDT_RS_DEPTH       8
  `define MUL_RS_DEPTH          4
  `define DIV_RS_DEPTH          4
  `define LSU_RS_DEPTH          4
  `define ROB_DEPTH             8

`else  //ISSUE_2_READ_PORT_4
  // the max number of uops are written to Uops Queue per cycle in DE stage
  `define NUM_DE_UOP            4
  `define NUM_DE_UOP_WIDTH      3
  // the max number of uops are dispated per cycle in DP stage
  `define NUM_DP_UOP            2
  // the number of read ports for VRF
  `define NUM_DP_VRF            4

  // the depth of queue/station/buffer
  `define CQ_DEPTH              16
  `define UQ_DEPTH              16
  `define ALU_RS_DEPTH          4
  `define PMTRDT_RS_DEPTH       8
  `define MUL_RS_DEPTH          4
  `define DIV_RS_DEPTH          4
  `define LSU_RS_DEPTH          4
  `define ROB_DEPTH             8
`endif

// VRF REG depth
`define NUM_VRF                 32

// Uops Queue data width
`define UQ_WIDTH                $bits(UOP_QUEUE_t)

// the max number of processor unit in EX stage
`define NUM_LSU                 2
`define NUM_ALU                 2
`define NUM_MUL                 2
`define NUM_PMTRDT              1
`define NUM_DIV                 1
`define NUM_PU                  `NUM_ALU+`NUM_PMTRDT+`NUM_MUL+`NUM_DIV+`NUM_LSU
 
// Reservation Station data width
`define ALU_RS_WIDTH            $bits(ALU_RS_t)

// the max number of uops are retired per cycle in RT stage
`define NUM_RT_UOP              4

`define ROB_DEPTH_WIDTH         $clog2(`ROB_DEPTH)

`define PC_WIDTH                32
`define XLEN                    32
`define BYTE_WIDTH              8
`define HWORD_WIDTH             16
`define WORD_WIDTH              32

`define EMUL_MAX                8

// ALU instruction will be split 8 uops at most
`define UOP_NUM_ALU             8
`define UOP_INDEX_WIDTH_ALU     $clog2(`UOP_NUM_ALU)

// LSU instruction will be split to EMUL_max=32 uops at most
`define UOP_NUM_LSU             32
`define UOP_INDEX_WIDTH_LSU     $clog2(`UOP_NUM_LSU)

// max(`UOP_INDEX_WIDTH_ALU,`UOP_INDEX_WIDTH_LSU)
`define UOP_INDEX_WIDTH         5

// ALU instruction will be split 8 uops at most
`define UOP_NUM_ALU             8
`define UOP_INDEX_WIDTH_ALU     $clog2(`UOP_NUM_ALU)

// Vector CSR
`define VLEN                    128
`define VLENB                   (`VLEN/8)
// VLMAX = VLEN*LMUL/SEW
// vstart < VLMAX_max and vl <= VLMAX_max, VLMAX_max=VLEN*LMUL_max(8)/SEW_min(8)=VLEN
`define VLMAX_MAX               `VLEN
`define VSTART_WIDTH            $clog2(`VLEN)
`define VL_WIDTH                $clog2(`VLEN)+1
`define VTYPE_VILL_WIDTH        1
`define VTYPE_VMA_WIDTH         1
`define VTYPE_VTA_WIDTH         1
`define VTYPE_VSEW_WIDTH        3
`define VTYPE_VLMUL_WIDTH       3
`define VCSR_VXRM_WIDTH         2
`define VCSR_VXSAT_WIDTH        1

// Instruction encoding
`define FUNCT6_WIDTH            6
`define NFIELD_WIDTH            3
`define VM_WIDTH                1
`define REGFILE_INDEX_WIDTH     5
`define UMOP_WIDTH              5
`define NREG_WIDTH              3
`define IMM_WIDTH               5
`define FUNCT3_WIDTH            3
`define OPCODE_WIDTH            7

// V0 mask regsiter index
`define V0_INDEX                5'b00000

`endif  // HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH
// ----- 8< ----- FILE "./rvv_backend.svh" ----- 8< -----

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`define HDL_VERILOG_RVV_DESIGN_RVV_SVH

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH
`include "rvv_backend_define.svh"
`endif  // not defined HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH

//
// IF stage, RVS send instruction package to Command Queue
//

// Enum type for SEW. See Table 2 in:
// https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#341-vector-selected-element-width-vsew20
typedef enum logic [2:0] {
  SEW8=0,
  SEW16=1,
  SEW32=2,
  SEW64=3
} RVVSEW;

// Enum type for LMUL. See:
// https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#vector-instruction-formats
typedef enum logic [2:0] {
  LMUL1=0,
  LMUL2=1,
  LMUL4=2,
  LMUL8=3,
  LMULRESERVED=4,
  LMUL1_8=5, // 1/8
  LMUL1_4=6, // 1/4
  LMUL1_2=7  // 1/2
} RVVLMUL;

// Enum type for vtype.vxrm: rounding mode
typedef enum logic [1:0] {
  RNU = 0,
  RNE = 1,
  RDN = 2,
  ROD = 3
} RVVXRM;

// The architectural configuration state of the RVV core.
typedef struct packed {
  logic                         vill; // This configuration is illegal
  logic [`VL_WIDTH-1:0]         vl;       // Max 128, need one extra bit
  logic [`VSTART_WIDTH-1:0]     vstart;
  logic [`VTYPE_VMA_WIDTH-1:0]  ma;        // 0:inactive element undisturbed, 1:inactive element agnostic
  logic [`VTYPE_VTA_WIDTH-1:0]  ta;        // 0:tail undisturbed, 1:tail agnostic
  RVVXRM                        xrm;       
  logic [`VCSR_VXSAT_WIDTH-1:0] xsat;   // rvv dont need this bit, but output this to rvs
`ifdef ZVE32F_ON
  logic [2:0]                   frm;       // rounding mode for floating-point
`endif  // ZVE32F_ON
  RVVSEW                        sew;
  RVVLMUL                       lmul;
  RVVLMUL                       lmul_orig;
} RVVConfigState;

// Enum to encode the major opcode of the instruction. See "Section 5. Vector
// Instruction Formats" of the RVV 1.0 spec.
typedef enum logic [1:0] {
  LOAD=0,
  STORE=1,
  RVV=2
} RVVOpCode;

// A decoded instruction forwarded to the RVVCore from the scalar core.
typedef struct packed {
  logic [`PC_WIDTH-1:0] pc;
  RVVOpCode             opcode;   // effectively bits [6:0] from instruction
  logic [24:0]          bits;     // bits [31:7] from instruction
} RVVInstruction;

// An command internal to the RVVCore. The immediate value of this command has
// been read from the scalar register file if necessary. It also contains
// additional data to track configuration register state (ie: SEW, LMUL, etc).
typedef struct packed {
`ifdef TB_SUPPORT
  logic [`PC_WIDTH-1:0] inst_pc;
`endif
  RVVOpCode             opcode;
  logic [24:0]          bits;
  logic [31:0]          rs1;
  RVVConfigState        arch_state;
} RVVCmd;

//
// DE stage, Command Queue to Uops Queue
//
// execution unit
typedef enum logic [2:0] {
  ALU,
  MUL,
  MAC,
  PMT,
  RDT,
  CMP,
  DIV,
  LSU
} EXE_UNIT_e;

// when EXE_UNIT_e is not LSU, it is used to distinguish arithmetic instructions, based on inst_encoding[14:12]
  parameter  OPIVV=3'b000;      // vs2,      vs1, vd.
  parameter  OPFVV=3'b001;      // vs2,      vs1, vd/rd. float, not support
  parameter  OPMVV=3'b010;      // vs2,      vs1, vd/rd.
  parameter  OPIVI=3'b011;      // vs2, imm[4:0], vd.
  parameter  OPIVX=3'b100;      // vs2,      rs1, vd.
  parameter  OPFVF=3'b101;      // vs2,      rs1, vd. float, not support
  parameter  OPMVX=3'b110;      // vs2,      rs1, vd/rd.
  parameter  OPCFG=3'b111;      // vset* instructions        

// when EXE_UNIT_e is not LSU, it identifys what instruction, vadd or vmacc or ..? based on inst_encoding[31:26]
  // OPI* instructions
  parameter VADD            =   6'b000_000;
  parameter VSUB            =   6'b000_010;
  parameter VRSUB           =   6'b000_011;
  parameter VMINU           =   6'b000_100;
  parameter VMIN            =   6'b000_101;
  parameter VMAXU           =   6'b000_110;
  parameter VMAX            =   6'b000_111;
  parameter VAND            =   6'b001_001;
  parameter VOR             =   6'b001_010;
  parameter VXOR            =   6'b001_011;
  parameter VRGATHER        =   6'b001_100;
  parameter VSLIDEUP_RGATHEREI16    =   6'b001_110;
  parameter VSLIDEDOWN      =   6'b001_111;
  parameter VADC            =   6'b010_000;
  parameter VMADC           =   6'b010_001;
  parameter VSBC            =   6'b010_010;
  parameter VMSBC           =   6'b010_011;
  parameter VMERGE_VMV      =   6'b010_111;     // it could be vmerge or vmv, based on vm field
  parameter VMSEQ           =   6'b011_000;
  parameter VMSNE           =   6'b011_001;
  parameter VMSLTU          =   6'b011_010;
  parameter VMSLT           =   6'b011_011;
  parameter VMSLEU          =   6'b011_100;
  parameter VMSLE           =   6'b011_101;
  parameter VMSGTU          =   6'b011_110;
  parameter VMSGT           =   6'b011_111;
  parameter VSADDU          =   6'b100_000;
  parameter VSADD           =   6'b100_001;
  parameter VSSUBU          =   6'b100_010;
  parameter VSSUB           =   6'b100_011;
  parameter VSLL            =   6'b100_101;
  parameter VSMUL_VMVNRR    =   6'b100_111;     // it could be vsmul or vmv<nr>r, based on vm field
  parameter VSRL            =   6'b101_000;
  parameter VSRA            =   6'b101_001;
  parameter VSSRL           =   6'b101_010;
  parameter VSSRA           =   6'b101_011;
  parameter VNSRL           =   6'b101_100;
  parameter VNSRA           =   6'b101_101;
  parameter VNCLIPU         =   6'b101_110;
  parameter VNCLIP          =   6'b101_111;
  parameter VWREDSUMU       =   6'b110_000;
  parameter VWREDSUM        =   6'b110_001;   

  // OPM* instructions
  parameter VREDSUM         =   6'b000_000;
  parameter VREDAND         =   6'b000_001;
  parameter VREDOR          =   6'b000_010;
  parameter VREDXOR         =   6'b000_011;
  parameter VREDMINU        =   6'b000_100;
  parameter VREDMIN         =   6'b000_101;
  parameter VREDMAXU        =   6'b000_110;
  parameter VREDMAX         =   6'b000_111;
  parameter VAADDU          =   6'b001_000;
  parameter VAADD           =   6'b001_001;
  parameter VASUBU          =   6'b001_010;
  parameter VASUB           =   6'b001_011;
  parameter VSLIDE1UP       =   6'b001_110;
  parameter VSLIDE1DOWN     =   6'b001_111;
  parameter VWRXUNARY0      =   6'b010_000;
  parameter VXUNARY0        =   6'b010_010;
  parameter VMUNARY0        =   6'b010_100;
  parameter VCOMPRESS       =   6'b010_111;
  parameter VMANDN          =   6'b011_000;
  parameter VMAND           =   6'b011_001;
  parameter VMOR            =   6'b011_010;
  parameter VMXOR           =   6'b011_011;
  parameter VMORN           =   6'b011_100;
  parameter VMNAND          =   6'b011_101;
  parameter VMNOR           =   6'b011_110;
  parameter VMXNOR          =   6'b011_111;
  parameter VDIVU           =   6'b100_000;
  parameter VDIV            =   6'b100_001;
  parameter VREMU           =   6'b100_010;
  parameter VREM            =   6'b100_011;
  parameter VMULHU          =   6'b100_100;
  parameter VMUL            =   6'b100_101;
  parameter VMULHSU         =   6'b100_110;
  parameter VMULH           =   6'b100_111;
  parameter VMADD           =   6'b101_001;
  parameter VNMSUB          =   6'b101_011;
  parameter VMACC           =   6'b101_101;
  parameter VNMSAC          =   6'b101_111;
  parameter VWADDU          =   6'b110_000;
  parameter VWADD           =   6'b110_001;
  parameter VWSUBU          =   6'b110_010;
  parameter VWSUB           =   6'b110_011;
  parameter VWADDU_W        =   6'b110_100;
  parameter VWADD_W         =   6'b110_101;
  parameter VWSUBU_W        =   6'b110_110;
  parameter VWSUB_W         =   6'b110_111;
  parameter VWMULU          =   6'b111_000;
  parameter VWMULSU         =   6'b111_010;
  parameter VWMUL           =   6'b111_011;
  parameter VWMACCU         =   6'b111_100;
  parameter VWMACC          =   6'b111_101;
  parameter VWMACCUS        =   6'b111_110;
  parameter VWMACCSU        =   6'b111_111;  

// vwxunary0, the uop could be vcpop.m, vfirst.m and vmv. They can be distinguished by vs1 field(inst_encoding[19:15]).
  parameter VMV_X_S         =   5'b00000;
  parameter VCPOP           =   5'b10000;
  parameter VFIRST          =   5'b10001;
  parameter VMV_S_X         =   5'b00000;  // vs2 field

// vxunary0, the uop could be vzext.vf2, vzext.vf4, vsext.vf2, vsext.vf4. They can be distinguished by vs1 field(inst_encoding[19:15]).
  parameter VZEXT_VF4       =   5'b00100;
  parameter VSEXT_VF4       =   5'b00101;
  parameter VZEXT_VF2       =   5'b00110;
  parameter VSEXT_VF2       =   5'b00111;

// vmxunary0, the uop could be vmsbf, vmsof, vmsif, viota, vid. They can be distinguished by vs1 field(inst_encoding[19:15]).
  parameter VMSBF           =   5'b00001;
  parameter VMSOF           =   5'b00010;
  parameter VMSIF           =   5'b00011;
  parameter VIOTA           =   5'b10000;
  parameter VID             =   5'b10001;

// when EXE_UNIT_e is LSU, it identifys what LSU instruction, unit-stride load or indexed store or ..? based on inst_encoding[31:26]
typedef enum logic [1:0] {
  US,         // Unit-Stride
  IU,         // Indexed Unordered
  CS,         // Constant Stride
  IO          // Indexed Ordered
} LSU_MOP_e;

// It identifys what unit-stride instruction when LSU_MOP_e=US, based on inst_encoding[24:20]
typedef enum logic [1:0] {
  US_US,         // Unit-Stride load/store
  US_WR,         // Whole Register load/store
  US_MK,         // MasK load/store, EEW=8(inst_encoding[14:12]=3'b000)
  US_FF          // Faul-only-First load
} LSU_UMOP_e;

// parameter for lsu decoding
  parameter  UNIT_STRIDE       = 3'b000;
  parameter  UNORDERED_INDEX   = 3'b001;
  parameter  CONSTANT_STRIDE   = 3'b010;
  parameter  ORDERED_INDEX     = 3'b011;

  parameter  US_REGULAR        = 5'b00000;
  parameter  US_WHOLE_REGISTER = 5'b01000;
  parameter  US_MASK           = 5'b01011;
  parameter  US_FAULT_FIRST    = 5'b10000;

// It identifys what inst_encoding[11:7] is used for when LSU instruction, based on inst_encoding[5]
typedef enum logic [0:0] {
  IS_LOAD,       // when load, inst_encoding[11:7] is seen as vd
  IS_STORE       // when store, inst_encoding[11:7] is seen as vs3
} LSU_IS_STORE_e;

// segment load/store 
typedef enum logic [0:0] {
  IS_SEGMENT,
  NONE      
} LSU_IS_SEG_e;

// combine those signals to LSU_TYPE
typedef struct packed {
  LSU_MOP_e         lsu_mop;
  LSU_UMOP_e        lsu_umop;
  LSU_IS_STORE_e    lsu_is_store;
  LSU_IS_SEG_e      lsu_is_seg;
} LSU_TYPE_t;

// function opcode
typedef union packed {
  logic   [`FUNCT6_WIDTH-1:0]         ari_funct6;
  LSU_TYPE_t                          lsu_funct6;
} FUNCT6_u;

// uop classification used for dispatch rule
typedef enum logic [2:0] {
  VVV,
  XVV,
  VVX,
  VXX,
  XVX,
  XXV,
  XXX
} UOP_CLASS_e;

// Effective MUL enum
typedef enum logic [3:0] {
  EMUL1=0,
  EMUL2=1,
  EMUL4=2,
  EMUL8=3,
  EMUL3,
  EMUL5,
  EMUL6,
  EMUL7,
  EMUL_NONE     // it means this is not supported 
} EMUL_e;

// Effective Element Width
typedef enum logic [2:0] {
  EEW_NONE,    // it means this is not supported 
  EEW1,
  EEW8, 
  EEW16,
  EEW32
} EEW_e;

// Number of REG
  parameter NREG1 = 3'b000;  
  parameter NREG2 = 3'b001;
  parameter NREG4 = 3'b011;
  parameter NREG8 = 3'b111;

// Number of FIELD
  parameter NF1 = 3'b000;  
  parameter NF2 = 3'b001;
  parameter NF3 = 3'b010;
  parameter NF4 = 3'b011;
  parameter NF5 = 3'b100;
  parameter NF6 = 3'b101;
  parameter NF7 = 3'b110;
  parameter NF8 = 3'b111;

// the uop struct stored in Uops Queue
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  FUNCT6_u                            uop_funct6;
  EXE_UNIT_e                          uop_exe_unit; 
  UOP_CLASS_e                         uop_class;   
  RVVConfigState                      vector_csr;  
  logic   [`VL_WIDTH-1:0]             vs_evl;             // effective vl
  logic                               ignore_vma;
  logic                               ignore_vta;
  logic                               force_vma_agnostic; // some situation will force to mask-agnostic regardless of vtype.vma
  logic                               force_vta_agnostic; // some situation will force to tail-agnostic regardless of vtype.vta

  logic                               vm;                 // Original 32bit instruction encoding: inst[25]
  logic                               v0_valid;           // when v0_valid=1, v0 will be regarded as a vector operand in this uop, not mask register. Like: vadc.vvm
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vd_index;           // Original 32bit instruction encoding: inst[11:7].this index is also used as vs3 in some uops 
  EEW_e                               vd_eew;  
  logic                               vd_valid;
  logic                               vs3_valid;          // when vs3_valid=1, vd will be regarded as a vector operand in this uop.
  // when vs1_index_valid=1, vs1 field is used as vs1_index to address VRF
  // when vs1_opcode_valid=0, vs1 field is used to decode some OPMVV uops 
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vs1;              
  EEW_e                               vs1_eew;            
  logic                               vs1_index_valid;
  logic                               vs1_opcode_valid;
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vs2_index; 	        // Original 32bit instruction encoding: inst[24:20]
  EEW_e                               vs2_eew;
  logic                               vs2_valid;
  logic   [`REGFILE_INDEX_WIDTH-1:0]  rd_index; 	        // Original 32bit instruction encoding: inst[11:7].
  logic                               rd_index_valid; 
  logic   [`XLEN-1:0] 	              rs1_data;           // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit. 
  logic        	                      rs1_data_valid;                                
          
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;          // used for calculate v0_start in DP stage
  logic                               first_uop_valid;    // one instruction may be split to many uops, this signal is used to specify the first uop in those uops of one instruction.
  logic                               last_uop_valid;     // one instruction may be split to many uops, this signal is used to specify the last uop in those uops of one instruction.
  logic   [$clog2(`EMUL_MAX)-1:0]     seg_field_index;    // used for calculate v0_start in DP stage for segment ld/st
  logic                               pshrob_valid;       // wheather this uop is pushed into ROB.
} UOP_QUEUE_t;    

// specify whether the current byte belongs to 'prestart' or 'body-inactive' or 'body-active' or 'tail'
typedef enum logic [1:0] {
  NOT_CHANGE    = 2'b00,      // the byte is not changed, which may belong to 'prestart' or superfluous element in widening/narrowing uop
  TAIL          = 2'b01,      // tail byte
  BODY_INACTIVE = 2'b10,      // body-inactive byte
  BODY_ACTIVE   = 2'b11       // body-active byte
} BYTE_TYPE_e;

// ReOrder Buffer data struct
typedef enum logic [0:0] {
  VRF,
  XRF
} W_DATA_TYPE_e;

// trap handle
typedef enum logic [1:0] {
  TRAP_LSU,         // RVS find some illegal instructions when complete LSU transaction, like bus error,
                    // which means a trap occurs to the instruction that is executing in RVV.
                    // So RVV will top CQ to receive new instructions and flush Command Queue and Uops Queue,
                    // and complete the instructions in EX, ME and WB stage. And RVS need to send rob_entry of that exception instruction.
                    // After RVV retire all uops before that exception instruction, RVV response a ready signal for trap application.
  TRAP_LSU_FF       // fault only first load, need to confirm whether has TLB or not.
} TRAP_INFO_e;

// the max number of byte in a vector register is VLENB
typedef BYTE_TYPE_e [`VLENB-1:0]      BYTE_TYPE_t;

typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  FUNCT6_u                            uop_funct6;  
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  logic   [`VSTART_WIDTH-1:0]         vstart;
  logic   [`VL_WIDTH-1:0]             vl;       
  // vm field can be used to identify vmadc.v?m/vmadc.v? uop in the same uop_funct6(6'b010000).
  // vm field can be used to identify vmsbc.v?m/vmsbc.v? uop in the same uop_funct6(6'b010011).   
  logic                               vm;               
  // rounding mode 
  RVVXRM                              vxrm;       
  // when the uop is vmadc.v?m/vmsbc.v?m, the uop will use v0_data as the third vector operand. EEW_v0=1.
  logic   [`VLEN-1:0]                 v0_data;
  logic                               v0_data_valid;
  // when the uop is mask uop(vmandn,vmand,...), the uop will use vd_data as the third vector operand. EEW_vd=1.
  logic   [`VLEN-1:0]                 vd_data;
  logic                               vd_data_valid;
  EEW_e                               vd_eew;  
  // when vs1_data_valid=0, vs1_data is used to decode some OPMVV uops
  // when vs1_data_valid=1, vs1_data is valid as a vector operand
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vs1;              
  logic   [`VLEN-1:0]                 vs1_data;           
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  logic                               vs2_data_valid;  
  EEW_e                               vs2_eew;
  // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit.
  logic   [`XLEN-1:0] 	              rs1_data;        
  logic        	                      rs1_data_valid;                                   
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;      
} ALU_RS_t;    

// DIV reservation station struct
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  FUNCT6_u                            uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  // when vs1_data_valid=1, vs1_data is valid as a vector operand
  logic   [`VLEN-1:0]                 vs1_data;           
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  logic                               vs2_data_valid;  
  EEW_e                               vs2_eew;
  // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit.
  logic   [`XLEN-1:0] 	              rs1_data;     
  logic        	                      rs1_data_valid;                                   
} DIV_RS_t; 

// MUL and MAC reservation station struct
typedef struct packed {   
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  FUNCT6_u                            uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  RVVXRM                              vxrm;       
  
  logic   [`VLEN-1:0]                 vs1_data;           
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  logic                               vs2_data_valid; 
  EEW_e                               vs2_eew; //eew for vs1, vs2, rs1
  logic   [`VLEN-1:0]                 vs3_data;	//vd, source for MAC add 
  logic                               vs3_data_valid; 
  // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit.
  logic   [`XLEN-1:0] 	              rs1_data;          
  logic          	                    rs1_data_valid;   
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;//indicate using low/high when widen mul. 0:low, 1:high
} MUL_RS_t;    

// PMT and RDT reservation station struct
typedef struct packed {   
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  EXE_UNIT_e                          uop_exe_unit; 
  FUNCT6_u                            uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  logic   [`VSTART_WIDTH-1:0]         vstart;
  logic   [`VL_WIDTH-1:0]             vl;       
  logic   [`VL_WIDTH-1:0]             vlmax;       
  logic                               vm;               
  // when the uop is producing-mask operation, the uop will use v0_data as the third vector operand when the uop is the last uop. EEW_v0=1.
  logic   [`VLEN-1:0]                 v0_data;
  logic                               v0_data_valid;
  logic   [`VLEN-1:0]                 vs1_data;          
  EEW_e                               vs1_eew;
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  EEW_e                               vs2_eew;
  BYTE_TYPE_t                         vs2_type;
  logic                               vs2_data_valid; 
  logic   [`VLEN-1:0]                 vs3_data;	//vd, source for producing-mask instruction
  logic                               vs3_data_valid; 
  // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit.
  // rs1_data could be from X[rs1] and imm(inst[19:15]). If it is imm, the 5-bit imm(inst[19:15]) will be sign-extend or zero-extend(shift instructions...) to XLEN-bit.
  logic   [`XLEN-1:0] 	              rs1_data;         
  logic        	                      rs1_data_valid;
  logic                               first_uop_valid;     
  logic                               last_uop_valid;     
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;      
} PMT_RDT_RS_t;    

// LSU reservation station struct
typedef struct packed {   
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif

  logic                               vidx_valid; 
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vidx_addr;
  logic   [`VLEN-1:0]                 vidx_data;            // vs2        
  logic                               vregfile_read_valid; 
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vregfile_read_addr;
  logic   [`VLEN-1:0]                 vregfile_read_data;   // vs3       
  logic                               v0_valid;
  logic   [`VLENB-1:0]                v0_data;              // byte strobe signal for mask load/store. 
                                                            // v0[i]=1 means vd/vs3[8*i +: 8] data is valid. 
} UOP_RVV2LSU_t;    

//
// EX stage, 
//
// send PU's result to ROB
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  logic   [`VLEN-1:0]                 w_data;             // when w_type=XRF, w_data[`XLEN-1:0] will store the scalar result
  logic                               w_valid;
  logic   [`VLENB-1:0]                vsaturate;
} PU2ROB_t;  

// lsu uop info to remap rob_entry for UOP_LSU2RVV_t
typedef struct packed {   
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic                               valid;
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  LSU_IS_STORE_e                      lsu_class; 
  logic	[`REGFILE_INDEX_WIDTH-1:0] 	  vregfile_write_addr;  
} LSU_MAP_INFO_t; 

// LSU feedback to RVV
typedef struct packed {   
`ifdef TB_SUPPORT
  // To trace wave
  logic   [`PC_WIDTH-1:0]             uop_pc;
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;         
`endif
  // For load data
  logic                               vregfile_write_valid;
  logic	[`REGFILE_INDEX_WIDTH-1:0] 	  vregfile_write_addr;  
  logic	[`VLEN-1:0] 			          	vregfile_write_data;  	// vd   
  // Store done signal to help ROB retire the store uop
  logic                               lsu_vstore_last;
} UOP_LSU2RVV_t;  

typedef struct packed {
  UOP_LSU2RVV_t                       uop_lsu2rvv;
  logic                               trap_valid;
} UOP_LSU_t;

typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic                               w_valid;            // write valid
  logic [`VLEN-1:0]                   w_data;             // write data; w_data[`XLEN-1:0] is scalar result if write type is XRF
  logic [`VLENB-1:0]                  vsaturate;
} RES_ROB_t;

// send uop to ROB
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`REGFILE_INDEX_WIDTH-1:0]  w_index;            //wr addr
  W_DATA_TYPE_e                       w_type;             //write type: 0 for VRF, 1 for XRF
  BYTE_TYPE_t                         byte_type;          //wr Byte mask
  RVVConfigState                      vector_csr;         //Receive Vstart, vlen,... And need to update vcsr when trap
  logic                               last_uop_valid;
} DP2ROB_t;

// send ROB info to DP
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic                               valid;              //entry valid
  logic                               w_valid;            //vd valid
  logic   [`REGFILE_INDEX_WIDTH-1:0]  w_index;            //vd addr
  W_DATA_TYPE_e                       w_type;             //write type: 0 for VRF, 1 for XRF
  logic   [`VLEN-1:0]                 w_data;             //when w_type=XRF, w_data[`XLEN-1:0] will store the scalar result
  BYTE_TYPE_t                         byte_type;          //wr Byte mask
  RVVConfigState                      vector_csr;         //Receive Vstart, vlen,... And need to update vcsr when trap
} ROB2DP_t;

typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
  logic                               last_uop_valid;
`endif
  logic                               w_valid;            //entry valid
  logic   [`REGFILE_INDEX_WIDTH-1:0]  w_index;            //wr addr
  logic   [`VLEN-1:0]                 w_data;             //when w_type=XRF, w_data[`XLEN-1:0] will store the scalar result
  W_DATA_TYPE_e                       w_type;             //to VRF or XRF
  BYTE_TYPE_t                         vd_type;            //wr Byte mask
  logic                               trap_flag;          //whether this entry in a trap
  RVVConfigState                      vector_csr;         //Receive Vstart, vlen,... And need to update vcsr when trap
  logic   [`VLENB-1:0]                vxsaturate;         //Update saturation bit
} ROB2RT_t;  

// the rob struct stored in ROB
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic                               valid;              // entry valid
  DP2ROB_t                            uop_info;           // Uop information
  RES_ROB_t                           uop_res;            // Uop result
  logic                               uop_done;           // Uop is finished.
  logic                               trap;
} ROB_t;

//
// Retire stage, bypass and write back to VRF/XRF, trap handler
//
// write back to XRF
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`REGFILE_INDEX_WIDTH-1:0]  rt_index; 
  logic   [`XLEN-1:0]                 rt_data; 
}RT2XRF_t;

// write back to VRF
typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]             uop_pc;
`endif
  logic   [`REGFILE_INDEX_WIDTH-1:0]  rt_index; 
  logic   [`VLEN-1:0]                 rt_data;
  logic   [`VLENB-1:0]                rt_strobe; 
}RT2VRF_t;

`endif  // HDL_VERILOG_RVV_DESIGN_RVV_SVH
// ----- 8< ----- FILE "./rvv_backend_sva.svh" ----- 8< -----

`ifndef RVV_ASSERT__SVH
`define RVV_ASSERT__SVH

`define RVV_ASSERT_CLK  rvv_backend.clk
`define RVV_ASSERT_RSTN rvv_backend.rst_n
// SV2009 feature - default values for arguments
`define rvv_expect(prop) assert property (@(posedge `RVV_ASSERT_CLK) disable iff (~`RVV_ASSERT_RSTN) prop)
`define rvv_forbid(seq)  assert property (@(posedge `RVV_ASSERT_CLK) disable iff (~`RVV_ASSERT_RSTN) not (strong(seq)))
`define rvv_cover(seq)   cover  property (@(posedge `RVV_ASSERT_CLK) disable iff (~`RVV_ASSERT_RSTN) seq)
`define rvv_assume(prop) assume property (@(posedge `RVV_ASSERT_CLK) disable iff (~`RVV_ASSERT_RSTN) prop)

`endif // RVV_ASSERT_SVH
// ----- 8< ----- FILE "./rvv_backend_alu.svh" ----- 8< -----

`ifndef ALU_DEFINE_SVH
`define ALU_DEFINE_SVH

typedef enum logic [0:0]{
  ADDSUB_VADD, 
  ADDSUB_VSUB
} ADDSUB_e;   

typedef enum logic [1:0]{
  SHIFT_SLL, 
  SHIFT_SRL,
  SHIFT_SRA
} SHIFT_e;   

typedef enum logic [1:0]{
  OP_NONE,
  OP_VCPOP, 
  OP_VIOTA,
  OP_OTHER
} ALU_SUB_OPCODE_e; 

typedef struct packed {
`ifdef TB_SUPPORT
  logic   [`PC_WIDTH-1:0]                   uop_pc;
`endif
  logic [`ROB_DEPTH_WIDTH-1:0]              rob_entry;
  EEW_e                                     vd_eew;
  logic [`UOP_INDEX_WIDTH-1:0]              uop_index;          
  ALU_SUB_OPCODE_e                          alu_sub_opcode; 
  logic [`VLEN-1:0]                         result_data;
  logic [`VLEN/64-1:0][63:0][$clog2(64):0]  data_viota_per64;
  logic [`VLENB-1:0]                        vsaturate;
} PIPE_DATA_t;

`endif // ALU_DEFINE_SVH
// ----- 8< ----- FILE "./rvv_backend_dispatch.svh" ----- 8< -----

`ifndef RVV_DISPATCH__SVH
`define RVV_DISPATCH__SVH

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH
`include "rvv_backend_define.svh"
`endif  // not defined HDL_VERILOG_RVV_DESIGN_RVV_DEFINE_SVH

// input signals for RAW check
typedef struct packed {
  logic [`REGFILE_INDEX_WIDTH-1:0] vs1_index;
  logic                            vs1_valid; // set if vs1 is a source operand
  logic [`REGFILE_INDEX_WIDTH-1:0] vs2_index;
  logic                            vs2_valid; // set if vs2 is a source operand
  logic [`REGFILE_INDEX_WIDTH-1:0] vd_index;
  logic                            vs3_valid; // set if vd is a source operand
  logic                            vm;
} SUC_UOP_RAW_t;

typedef struct packed {
  logic [`REGFILE_INDEX_WIDTH-1:0] w_index; 
  W_DATA_TYPE_e                    w_type; 
  logic                            w_valid;
  logic                            valid;
} PRE_UOP_RAW_t;

// RAW hazard information
typedef struct packed {
  logic [`ROB_DEPTH-1:0] vs1_hit;
  logic                  vs1_wait;
  logic [`ROB_DEPTH-1:0] vs2_hit;
  logic                  vs2_wait;
  logic [`ROB_DEPTH-1:0] vd_hit;
  logic                  vd_wait;
  logic [`ROB_DEPTH-1:0] v0_hit;
  logic                  v0_wait;
} RAW_UOP_ROB_t;

typedef struct packed {
  logic                  vs1_wait;
  logic                  vs2_wait;
  logic                  vd_wait;
  logic                  v0_wait;
} RAW_UOP_UOP_t;

// Input signals for structure hazard
typedef struct packed {
  logic [`REGFILE_INDEX_WIDTH-1:0] vs1_index;
  logic                            vs1_valid;
  logic [`REGFILE_INDEX_WIDTH-1:0] vs2_index;
  logic                            vs2_valid;
  logic [`REGFILE_INDEX_WIDTH-1:0] vd_index;
  logic                            vs3_valid;
  EXE_UNIT_e                       uop_exe_unit;
  UOP_CLASS_e                      uop_class;
} STRCT_UOP_t;

// Structure hazard information
typedef struct packed {
  logic                  vr_limit; // VRF read port limitation
} ARCH_HAZARD_t;

// input signals of ROB for bypass unit
typedef struct packed {
  logic [`VLEN-1:0]      w_data;
  BYTE_TYPE_t            byte_type;
  logic                  tail_one;
  logic                  inactive_one;
} ROB_BYP_t;

// the vector operand of uop
typedef struct packed {
  logic [`VLEN-1:0]      vs1;
  logic [`VLEN-1:0]      vs2;
  logic [`VLEN-1:0]      vd;
  logic [`VLEN-1:0]      v0;
} UOP_OPN_t;

// input signals for ctrl unit
typedef struct packed {
  EXE_UNIT_e             uop_exe_unit;
  logic                  pshrob_valid;
} UOP_CTRL_t;

// input signals for opr_byte_type unit
typedef struct packed {
  logic [`UOP_INDEX_WIDTH-1:0] uop_index;
  EXE_UNIT_e                   uop_exe_unit;
  EEW_e                        vd_eew;
  EEW_e                        vs1_eew;
  EEW_e                        vs2_eew;
  logic [`VSTART_WIDTH-1:0]    vstart;
  logic [`VL_WIDTH-1:0]        vl;
  logic                        vm;
  logic                        ignore_vma;
  logic                        ignore_vta;
} UOP_INFO_t;

// the vector operand byte type in uop
typedef struct packed {
  BYTE_TYPE_t           vs2;
  BYTE_TYPE_t           vd;
  logic [`VLENB-1:0]    v0_strobe;
} UOP_OPN_BYTE_TYPE_t;

`endif // RVV_DISPATCH__SVH
// ----- 8< ----- FILE "./rvv_backend_div.svh" ----- 8< -----

`ifndef DIV_DEFINE_SVH
`define DIV_DEFINE_SVH

typedef enum logic [0:0]{
  DIV_SIGN, 
  DIV_ZERO
} DIV_SIGN_SRC_e;   

`endif // DIV_DEFINE_SVH
// ----- 8< ----- FILE "./rvv_backend_pmtrdt.svh" ----- 8< -----

`ifndef PMTRDT_DEFINE_SVH
`define PMTRDT_DEFINE_SVH

typedef enum logic [1:0] {
  PERMUTATION,
  REDUCTION,
  COMPARE
} PMTRDT_UOP_TYPE_e;

typedef struct packed {
  PMTRDT_UOP_TYPE_e   uop_type; 
} PMTRDT_UOP_TYPE_t;

typedef enum logic [2:0] {
  NOT_EQUAL,
  EQUAL,
  LESS_THAN,
  LESS_THAN_OR_EQUAL,
  GREAT_THAN,
  GREAT_THAN_OR_EQUAL,
  COUT, // carry-out
  BOUT  // borrow-out
} CMP_TYPE_e;

typedef enum logic [2:0] {
  SUM,
  MAX,
  MIN,
  AND,
  OR,
  XOR
} RDT_OPERATION_e;

typedef enum logic [1:0] {
  SLIDE_DOWN,
  SLIDE_UP,
  GATHER
} PMT_OPERATION_e;

typedef struct packed {
  logic                     sign_opr;   // set if signed value, clear if unsigned value
  CMP_TYPE_e                cmp_opr;
  logic                     widen;      // set if vd EEW is 2*SEW
  RDT_OPERATION_e           rdt_opr;
  logic                     compress;   // set if the uop is compress instruction

  // signals from uop
`ifdef TB_SUPPORT
  logic [`PC_WIDTH-1:0]     uop_pc;
`endif
  logic [`ROB_DEPTH_WIDTH-1:0]    rob_entry;
  logic [`VL_WIDTH-1:0]     vl;
  logic [`VL_WIDTH-1:0]     cmp_evl; // evl for compare instruction
  logic                     vm;
  EEW_e                     vs1_eew;
  logic [`VLEN-1:0]         v0_data;
  logic [`VLEN-1:0]         vs3_data;
  logic                     last_uop_valid;
} RDT_CTRL_t;

typedef struct packed {
  PMT_OPERATION_e           pmt_opr;

  // signals from uop
`ifdef TB_SUPPORT
  logic [`PC_WIDTH-1:0]     uop_pc;
`endif
  logic [`ROB_DEPTH_WIDTH-1:0]    rob_entry;
  logic [`VLEN-1:0]         vs3_data;
} PMT_CTRL_t;

typedef struct packed {
  // signals from uop
`ifdef TB_SUPPORT
  logic [`PC_WIDTH-1:0]     uop_pc;
`endif
  logic [`ROB_DEPTH_WIDTH-1:0]    rob_entry;
  logic [`VLEN-1:0]         vs3_data;
  logic                     last_uop_valid;
} COMPRESS_CTRL_t;
`endif
// ----- 8< ----- FILE "./cdffr.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// FF with sync enable, clear and async rst_n; 

module cdffr ( q, clk, rst_n, c, e, d ) ; 
  parameter type T = logic;
  parameter T INIT  = '0;
  input         clk;
  input         rst_n;
  input         e, c;
  input  T      d;
  output T      q;
  always @(posedge clk or negedge rst_n) 
    if (!rst_n)     q <= INIT ;
    // Updated code to better version for coverage. 
    else if (c) q <= INIT; //solidify {'X(fail d == 0)};
    else if (e) q <= d;
endmodule
// ----- 8< ----- FILE "./compressor_3_2.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module compressor_3_2
(
  src1,
  src2,
  src3,
  result_sum,
  result_carry
);
  parameter WIDTH = 8;
  
  input   logic [WIDTH-1:0]   src1;
  input   logic [WIDTH-1:0]   src2;
  input   logic [WIDTH-1:0]   src3;
  output  logic [WIDTH-1:0]   result_sum;
  output  logic [WIDTH-1:0]   result_carry;

  logic [WIDTH-1:0]           xor_src1to2;
  genvar                      i;
  
  assign xor_src1to2 = src1^src2;
  assign result_sum = xor_src1to2^src3;
  
  generate
    for(i=0;i<WIDTH;i++) begin: GET_RESULT
      assign result_carry[i] = xor_src1to2[i] ? src3[i] : src1[i];
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./compressor_4_2.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module compressor_4_2
(
  src1,
  src2,
  src3,
  src4,
  cin,
  result_sum,
  result_carry,
  result_cout
);
  parameter WIDTH = 8;
  
  input   logic [WIDTH-1:0]   src1;
  input   logic [WIDTH-1:0]   src2;
  input   logic [WIDTH-1:0]   src3;
  input   logic [WIDTH-1:0]   src4;
  input   logic [WIDTH-1:0]   cin;
  output  logic [WIDTH-1:0]   result_sum;
  output  logic [WIDTH-1:0]   result_carry;
  output  logic [WIDTH-1:0]   result_cout;

  logic [WIDTH-1:0]           xor_src1to2;
  logic [WIDTH-1:0]           xor_src3to4;
  logic [WIDTH-1:0]           xor_src1to4;
  genvar                      i;
  
  assign xor_src1to2 = src1^src2;
  assign xor_src3to4 = src3^src4;
  
  generate
    for(i=0;i<WIDTH;i++) begin: GET_RESULT
      assign xor_src1to4[i] = xor_src3to4[i] ? ~xor_src1to2[i] : xor_src1to2[i];
      assign result_sum[i] = xor_src1to4[i] ? ~cin[i] : cin[i];
      assign result_cout[i] = xor_src1to2[i] ? src3[i] : src1[i];
      assign result_carry[i] = xor_src1to4[i] ? cin[i] : src4[i];
    end
  endgenerate
  
endmodule
// ----- 8< ----- FILE "./dff.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
//   DFFR   - posedge ff w/ rst_n,
//   Order of ports is:  q, clk, [rst_n], [e], d
//   E.g.  DFF #(4) qsig (qsig, clk, rst_n, dsig);

module dff ( q, clk, rst_n, d ) ; // FF with async rst_n;  
  parameter WIDTH = 1 ;
  input 	clk ;
  input 	rst_n ;
  input  [WIDTH-1:0] d ;
  output [WIDTH-1:0] q ;
  reg [WIDTH-1:0] 	 q ;
  
  always @(posedge clk or negedge rst_n) 
    if (!rst_n) q <= {WIDTH{1'b0}} ;
    else q <= d ;
endmodule
// ----- 8< ----- FILE "./edff.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// edff - posedge ff, async rst_n, sync enable.

module edff (q, e, d, clk, rst_n
);
  parameter type T = logic;
  parameter T INIT  = '0;

  output T        q;

  input  logic    e;
  input  T        d;
  input  logic    clk;
  input  logic    rst_n;

  always @(posedge clk or negedge rst_n)
    if (!rst_n)   q <= INIT;
    else if (e)   q <= d;

endmodule
// ----- 8< ----- FILE "./edff_2d.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module edff_2d (/*AUTOARG*/
   // Outputs
   q,
   // Inputs
   clk, rst_n, en, d
   );
   
    parameter REGISTER_WIDTH = 32;
    parameter NUM_OF_REGISTERS = 8;
    parameter RESET_STATE = 0;     
    
    input    clk;
    // synopsys sync_set_reset "rst_n"
    input    rst_n;
    input [NUM_OF_REGISTERS-1:0]   en;
    input [NUM_OF_REGISTERS*REGISTER_WIDTH-1 : 0 ] d ;

    output [NUM_OF_REGISTERS*REGISTER_WIDTH-1 : 0 ] q;
                                                             
    integer i;            
    reg [NUM_OF_REGISTERS*REGISTER_WIDTH-1 : 0 ] q;

    always @(posedge clk or negedge rst_n) begin  
        if ( !rst_n ) begin
          for (i = 0; i <= NUM_OF_REGISTERS-1; i = i + 1)
            q[REGISTER_WIDTH*(i+1)-1 -: REGISTER_WIDTH] <= RESET_STATE;
        end else begin
          for (i = 0; i <= NUM_OF_REGISTERS-1; i = i + 1)
            if (en[i]) begin
                q[REGISTER_WIDTH*(i+1)-1 -: REGISTER_WIDTH] <= d[REGISTER_WIDTH*(i+1)-1 -: REGISTER_WIDTH];
            end //else hold old value
        end 
    end
 
endmodule
// ----- 8< ----- FILE "./multi_fifo.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description
// the multi_fifo is a sync fifo mmodule with some specified features
// features:
//    1. multi push at a time
//    2. multi pop at a time
//    3. parameterize push/pop number with arbitrary value
//    4. output all fifo data and sort them based on read pointer
//    5. output write pointer and read pointer
// constraints:
//    1. do not support push&pop when fifo is full

module multi_fifo
(
  // global
  clk,
  rst_n,
  // push side
  push,
  datain,
  full,
  almost_full,
  // pop side
  pop,
  dataout,
  empty,
  almost_empty,
  // fifo info
  clear,
  fifo_data,
  wptr,
  rptr,
  entry_count
);
// ---parameter definition--------------------------------------------
  parameter type T      = logic [7:0];  // data structure
  parameter M           = 4;            // push signal width
  parameter N           = 4;            // pop signal width
  parameter DEPTH       = 16;           // fifo depth
  parameter POP_CLEAR   = 1'b0;         // clear data once pop
  parameter ASYNC_RSTN  = 1'b0;         // reset data
  parameter CHAOS_PUSH  = 1'b0;         // support push data disorderly
  parameter DATAOUT_REG = 1'b0;         // dataout signal register output. 
  parameter FULL_PUSH   = 1'b0;         // support push&pop when fifo is full.

  localparam DEPTH_BITS = $clog2(DEPTH);

// ---port definition-------------------------------------------------
  input   logic                   clk;
  input   logic                   rst_n;
  input   logic [M-1:0]           push;         // M bits indicates M push operation(s). 
  input   T     [M-1:0]           datain;
  output  logic                   full;
  output  logic [M-1:0]           almost_full;  // almost_full[0]==1 - full
                                                // almost_full[1]==1 -  free spaces <=1
                                                // almost_full[M-1]==1 -  free spaces <=M-1
  input   logic [N-1:0]           pop;          // N bits indicates N pop operation(s).
  output  T     [N-1:0]           dataout;
  output  logic                   empty;
  output  logic [N-1:0]           almost_empty; // almost_empty[0]==1 - empty
                                                // almost_empty[1]==1 - The quantity of valid data <= 1
                                                // almost_empty[N-1]==1 - The  quantity of valid data <= N-1
  input   logic                   clear;
  output  T     [DEPTH-1:0]       fifo_data;    // sort based on rptr
  output  logic [DEPTH_BITS-1:0]  wptr;         // write pointer
  output  logic [DEPTH_BITS-1:0]  rptr;         // read pointer
  output  logic [DEPTH_BITS  :0]  entry_count;  // the number of occupied entry.

// ---internal signal definition--------------------------------------
  T mem[DEPTH-1:0];

  logic                           entry_count_en; 
  logic         [DEPTH_BITS  :0]  entry_count_now;
  logic         [DEPTH_BITS  :0]  next_entry_count;
  logic         [DEPTH_BITS  :0]  push_count;
  logic         [DEPTH_BITS  :0]  pop_count;
  logic         [DEPTH_BITS-1:0]  next_wptr;
  logic         [DEPTH_BITS-1:0]  next_rptr;
  logic         [DEPTH_BITS-1:0]  wind_rptr [DEPTH-1:0];
  logic         [DEPTH_BITS-1:0]  wind_wptr [DEPTH-1:0];

  logic         [M-1:0]           push_seq;
  T             [M-1:0]           datain_seq;
  logic         [DEPTH_BITS:0]    ptr_diff1;
  logic         [DEPTH_BITS:0]    ptr_diff2;
  logic         [DEPTH_BITS-1:0]  offset;
  logic         [DEPTH-1:0]       push_extend;
  logic         [2*DEPTH-1:0]     pop_shift;
  logic         [DEPTH-1:0]       pop_extend;
// ---code start------------------------------------------------------
  genvar  i;  
  integer l,k;
  
  // fifo status
  // valid data count
  assign next_entry_count = entry_count + push_count - pop_count;
  assign entry_count_en = (|push) | (|pop);
  cdffr #(.T(logic[DEPTH_BITS:0])) u_entry_count_reg (.q(entry_count), .c(clear), .e(entry_count_en), .d(next_entry_count), .clk(clk), .rst_n(rst_n));

  generate
  // full
    if(FULL_PUSH) 
      assign entry_count_now = entry_count - pop_count;
    else
      assign entry_count_now = entry_count;

    assign full = (entry_count_now == DEPTH);
    assign almost_full[0] = full;

    for (i=1; i<M; i++) begin : gen_almost_full
      assign almost_full[i] = (entry_count_now + i >= DEPTH);
    end

  // empty
    assign empty           = (entry_count == '0);
    assign almost_empty[0] = empty;

    for (i=1; i<N; i++) begin : gen_almost_empty
      assign almost_empty[i] = (entry_count <= i);
    end

  // data
    for (i=0; i<DEPTH; i++) begin : gen_fifo_data
      assign fifo_data[i] = mem[wind_rptr[i]];
    end

  // wind back rptr/wptr
    for (i=0; i<DEPTH; i++) begin : gen_wind_ptr
      assign wind_rptr[i] = rptr+i;
      assign wind_wptr[i] = wptr+i;
    end
  endgenerate
  // dataout
  always_comb begin
    pop_count = {(DEPTH_BITS)'(0), pop[0]};
    for (int j=1; j<N; j++) pop_count = pop_count + pop[j];
  end
  
  assign next_rptr = rptr + pop_count;
  cdffr #(.T(logic[DEPTH_BITS-1:0])) u_rptr_reg (.q(rptr), .c(clear), .e(|pop), .d(next_rptr), .clk(clk), .rst_n(rst_n));
  
  generate
    if(DATAOUT_REG) begin
      logic [DEPTH_BITS:0]          remain_count;
      logic [N-1:0][DEPTH_BITS-1:0] current_rptr_mem;   // pick data from fifo to output
      logic [N-1:0][DEPTH_BITS-1:0] current_rptr_psh;   // when fifo is empty, pick the pushing data 

      assign remain_count = entry_count-pop_count;

      for (i=0; i<N; i++) begin : gen_rptr
        assign current_rptr_mem[i] = next_rptr+i;
        assign current_rptr_psh[i] = i-remain_count;
      end

      if (ASYNC_RSTN) begin
        if (CHAOS_PUSH) begin
          for (i=0; i<N; i++) begin : gen_dataout
            always_ff @(posedge clk, negedge rst_n) begin
              if (!rst_n)
                dataout[i] <= 'b0;
              else if ((i<remain_count)&(|pop)) 
                dataout[i] <= mem[current_rptr_mem[i]]; 
              else if ((push_seq[current_rptr_psh[i]]&(current_rptr_psh[i]<(DEPTH_BITS)'(M)))&
                       ((|pop)|(|push_seq))
                      )
                dataout[i] <= datain_seq[current_rptr_psh[i]];
            end
          end
        end else begin
          for (i=0; i<N; i++) begin : gen_dataout
            always_ff @(posedge clk, negedge rst_n) begin
              if (!rst_n)
                dataout[i] <= 'b0;
              else if ((i<remain_count)&(|pop))
                dataout[i] <= mem[current_rptr_mem[i]]; 
              else if ((push[current_rptr_psh[i]]&(current_rptr_psh[i]<(DEPTH_BITS)'(M)))&
                       ((|pop)|(|push))
                      )
                dataout[i] <= datain[current_rptr_psh[i]];
            end
          end
        end
      end 
      else begin
        if (CHAOS_PUSH) begin
          for (i=0; i<N; i++) begin : gen_dataout
            always_ff @(posedge clk) begin
              if ((i<remain_count)&(|pop)) 
                dataout[i] <= mem[current_rptr_mem[i]]; 
              else if ((push_seq[current_rptr_psh[i]]&(current_rptr_psh[i]<(DEPTH_BITS)'(M)))&
                       ((|pop)|(|push_seq))
                      )
                dataout[i] <= datain_seq[current_rptr_psh[i]];
            end
          end
        end else begin
          for (i=0; i<N; i++) begin : gen_dataout
            always_ff @(posedge clk) begin
              if ((i<remain_count)&(|pop))
                dataout[i] <= mem[current_rptr_mem[i]]; 
              else if ((push[current_rptr_psh[i]]&(current_rptr_psh[i]<(DEPTH_BITS)'(M)))&
                       ((|pop)|(|push))
                      )
                dataout[i] <= datain[current_rptr_psh[i]];
            end
          end
        end
      end
    end
    else begin
      for (i=0; i<N; i++) begin : gen_dataout
        assign dataout[i] = mem[wind_rptr[i]];
      end
    end
  endgenerate

  // datain
  always_comb begin
    push_count = {(DEPTH_BITS)'(0), push[0]};
    for (int j=1; j<M; j++) push_count = push_count + push[j];
  end

  assign next_wptr = wptr + push_count;
  cdffr #(.T(logic[DEPTH_BITS-1:0])) u_wptr_reg (.q(wptr), .c(clear), .e(|push), .d(next_wptr), .clk(clk), .rst_n(rst_n));

  generate
    if (CHAOS_PUSH) begin
      always_comb begin
        push_seq = '0;
        datain_seq = '0;
        l = 0;
        for (k=0; k<M; k++) begin
          if (push[k]) begin
            push_seq[l] = 1'b1;
            datain_seq[l] = datain[k];
            l++;
          end
        end
      end
    end else begin
      assign push_seq = push;
      assign datain_seq = datain;
    end

    if (POP_CLEAR&FULL_PUSH) begin
      assign ptr_diff1 = {1'b0,rptr} - {1'b0,wptr};
      assign ptr_diff2 = {1'b1,rptr} - {1'b0,wptr};
      assign offset    = ptr_diff1[DEPTH_BITS] ? ptr_diff2[DEPTH_BITS-1:0] : ptr_diff1[DEPTH_BITS-1:0];
      
      assign push_extend = (DEPTH)'(push_seq);
      assign pop_shift   = {(DEPTH)'(pop),(DEPTH)'(pop)}<<offset;
      assign pop_extend  = pop_shift[2*DEPTH-1:DEPTH];
    end

    if (ASYNC_RSTN)
      if (POP_CLEAR&FULL_PUSH) begin
        always_ff @(posedge clk or negedge rst_n) begin
          if (!rst_n)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else if (clear)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else begin
            for (int j=0; j<DEPTH; j++) begin
              if (push_extend[j] & (j<M)) 
                mem[wind_wptr[j]] <= datain_seq[j];
              else if (pop_extend[j])
                mem[wind_wptr[j]] <= 'b0;
            end
          end
        end
      end 
      else if(POP_CLEAR) begin
        always_ff @(posedge clk or negedge rst_n) begin
          if (!rst_n)
            for (int j=0; j<DEPTH; j++) begin 
              mem[j] <= '0;
            end
          else if (clear)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else begin
            for (int j=0; j<M; j++) begin
              if (push_seq[j]) mem[wind_wptr[j]] <= datain_seq[j];
            end
  
            for (int j=0; j<N; j++) begin
              if (pop[j]) mem[wind_rptr[j]] <= '0;
            end
          end
        end
      end
      else begin
        always_ff @(posedge clk or negedge rst_n) begin
          if (!rst_n)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else begin
            for (int j=0; j<M; j++) begin
              if (push_seq[j]) mem[wind_wptr[j]] <= datain_seq[j];
            end
          end
        end
      end
    else begin
      if (POP_CLEAR&FULL_PUSH) begin
        always_ff @(posedge clk) begin
          if (clear)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else begin
            for (int j=0; j<DEPTH; j++) begin
              if (push_extend[j] & (j<M)) 
                mem[wind_wptr[j]] <= datain_seq[j];
              else if (pop_extend[j])
                mem[wind_wptr[j]] <= 'b0;
            end
          end
        end
      end 
      else if(POP_CLEAR) begin
        always_ff @(posedge clk or negedge rst_n) begin
          if (clear)
            for (int j=0; j<DEPTH; j++) begin
              mem[j] <= '0;
            end
          else begin
            for (int j=0; j<M; j++) begin
              if (push_seq[j]) mem[wind_wptr[j]] <= datain_seq[j];
            end
  
            for (int j=0; j<N; j++) begin
              if (pop[j]) mem[wind_rptr[j]] <= '0;
            end
          end
        end
      end
      else begin
        always_ff @(posedge clk) begin
          for (int j=0; j<M; j++) begin
            if (push_seq[j]) mem[wind_wptr[j]] <= datain_seq[j];
          end
        end
      end
    end
  endgenerate

  `ifdef ASSERT_ON
    // test for overflow
      generate
        if(!FULL_PUSH) begin
          for (i=0; i<M; i++) begin
            assert property (@(posedge clk) disable iff (!rst_n) not ( push_seq[i] && almost_full[i]))
              else $error("MULTI_FIFO: overflow of fifo when push_seq[%d] and almost_full[%d]", i, i);
          end
        end
      endgenerate
    // test for underflow
      generate
        for (i=0; i<N; i++) begin
          assert property (@(posedge clk) disable iff (!rst_n) not ( pop[i] && almost_empty[i]))
            else $error("MULTI_FIFO: underflow of fifo when pop[%d] and almost_empty[%d]", i, i);
        end
      endgenerate
  `endif

endmodule
// ----- 8< ----- FILE "./RvvFrontEnd.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A module that assembles RVVInstructions into RVVCmd before storing into the
// RVVInstructionQueue. It's also responsible for handling architectural
// configuration state (ie. LMUL, SEW). Inputs to this module maybe unaligned
// (ie [invalid, valid, valid, invalid]) while outputs will always be aligned
// (ie [valid, valid, invalid, invalid]).
// Arguments from the scalar register file (for vx or configuration
// instructions) arrive one cycle after the Instruction is dispatched, so this
// module introduces one cycle of latency before putting the command into the
// queue.
module RvvFrontEnd#(parameter N = 4,
                    parameter CAPACITYBITS=$clog2(2*N + 1),
                    parameter REDUCE_LMUL = 1)
(
  input clk,
  input rstn,

  input logic [`VSTART_WIDTH-1:0]     vstart_i,
  input logic [`VCSR_VXRM_WIDTH-1:0]  vxrm_i,
  input logic [`VCSR_VXSAT_WIDTH-1:0] vxsat_i,
  input logic [2:0]                   frm_i,

  // Instruction input.
  input logic [N-1:0] inst_valid_i,
  input RVVInstruction [N-1:0] inst_data_i,
  output logic [N-1:0] inst_ready_o,

  // Register file input
  input logic [(2*N)-1:0] reg_read_valid_i,
  input logic [(2*N)-1:0][31:0] reg_read_data_i,

  // Scalar Regfile writeback for configuration functions.
  output logic [N-1:0] reg_write_valid_o,
  output logic [N-1:0][4:0] reg_write_addr_o,
  output logic [N-1:0][31:0] reg_write_data_o,

  // Command output.
  output logic [N-1:0] cmd_valid_o,
  output RVVCmd [N-1:0] cmd_data_o,
  input logic [CAPACITYBITS-1:0] queue_capacity_i,  // Number of elements that can be enqueued
  output logic [CAPACITYBITS-1:0] queue_capacity_o,

  // Trap output.
  output logic trap_valid_o,
  output RVVInstruction trap_data_o,

  // Config state
  output config_state_valid,
  output RVVConfigState config_state
);
  localparam COUNTBITS = $clog2(N + 1);
  typedef logic [COUNTBITS-1:0] count_t;

  // vtype architectural state
  logic vill;
  RVVConfigState config_state_q;

  // Instructions to assemble into commands
  logic [N-1:0] valid_inst_q;     // If the instruction in this slot is valid
  count_t valid_inst_count_q;     // The sum of valid_inst_q
  RVVInstruction inst_q [N-1:0];  // The instruction in the slot

  // Backpressure
  count_t valid_in_psum [N:0];
  always_comb begin
    valid_in_psum[0] = 0;
    for (int i = 0; i < N; i++) begin
      valid_in_psum[i+1] = valid_in_psum[i] + inst_valid_i[i];
    end
  end

  // State, for time being lets do not state forwarding for timing
  logic config_state_reduction;
  always_comb begin
    config_state_reduction = 1;
    for (int i = 0; i < N; i++) begin
      config_state_reduction = config_state_reduction & (!valid_inst_q[i]);
    end
  end
  assign config_state_valid = config_state_reduction;
  assign config_state = config_state_q;

  logic [CAPACITYBITS-1:0] queue_capacity;
  assign queue_capacity_o = queue_capacity;
  always_comb begin
    queue_capacity = queue_capacity_i - valid_inst_count_q;
  end

  logic inst_accepted [N-1:0];
  count_t valid_inst_count_d;
  always_comb begin
    for (int i = 0; i < N; i++) begin
      inst_accepted[i] = (valid_in_psum[i] < queue_capacity) && inst_valid_i[i];
      inst_ready_o[i] = inst_accepted[i];
    end
    valid_inst_count_d = (valid_in_psum[N] < queue_capacity) ?
        valid_in_psum[N] : queue_capacity;
  end

  always_ff @(posedge clk or negedge rstn) begin
    if (!rstn) begin
      for (int i = 0; i < N; i++) begin
        valid_inst_q[i] <= 0;
        valid_inst_count_q <= 0;
      end;
    end else begin
      for (int i = 0; i < N; i++) begin
        valid_inst_q[i] <= inst_accepted[i];
        valid_inst_count_q <= valid_inst_count_d;
      end
    end
  end

  always_ff @(posedge clk) begin
    for (int i = 0; i < N; i++) begin
      inst_q[i] <= inst_data_i[i];
    end
  end

  // Update configuration architectural state
  RVVConfigState inst_config_state [N:0];
  logic [31:0] avl [N-1:0];
  logic [31:0] vlmax [N-1:0];
  logic is_setvl [N-1:0];
  logic [`VL_WIDTH-1:0] vl_minus_one [N-1:0];
  always_comb begin
    inst_config_state[0] = config_state_q;
    inst_config_state[0].vstart = vstart_i;
    inst_config_state[0].xrm = RVVXRM'(vxrm_i);
    inst_config_state[0].xsat = vxsat_i;
`ifdef ZVE32F_ON
    inst_config_state[0].frm = frm_i;
`endif  // ZVE32F_ON
    for (int i = 0; i < N; i++) begin
      inst_config_state[i+1] = inst_config_state[i];
      avl[i] = 0;
      vlmax[i] = 0;
      is_setvl[i] = 0;

      if (valid_inst_q[i] &&
          (inst_q[i].opcode == RVV) &&
          (inst_q[i].bits[7:5] == 3'b111)) begin
        if (inst_q[i].bits[24] == 0) begin  // vsetvli
          // Set AVL based on encoding (see Section 6.2 of RVV spec)
          unique case (inst_q[i].bits[12:8])
            0: unique case (inst_q[i].bits[4:0])
              0:  avl[i] = inst_config_state[i].vl;  // rd = x0, rs1 = x0
              default: avl[i] = 32'hFFFFFFFF;        // rd != x0, rs1 = x0
            endcase
            default: avl[i] = reg_read_data_i[2*i];  // rs1 != x0
          endcase

          inst_config_state[i+1].lmul_orig = RVVLMUL'(inst_q[i].bits[15:13]);
          inst_config_state[i+1].sew = RVVSEW'(inst_q[i].bits[18:16]);
          inst_config_state[i+1].ta = inst_q[i].bits[19];
          inst_config_state[i+1].ma = inst_q[i].bits[20];
          is_setvl[i] = 1;
        end else if (inst_q[i].bits[24:23] == 2'b11) begin  // vsetivli
          avl[i] =
              {{(`VL_WIDTH - 5){1'b0}}, inst_q[i].bits[12:8]};
          inst_config_state[i+1].lmul_orig = RVVLMUL'(inst_q[i].bits[15:13]);
          inst_config_state[i+1].sew = RVVSEW'(inst_q[i].bits[18:16]);
          inst_config_state[i+1].ta = inst_q[i].bits[19];
          inst_config_state[i+1].ma = inst_q[i].bits[20];
          is_setvl[i] = 1;
        end else if (inst_q[i].bits[24:23] == 2'b10) begin  // vsetvl
          // Set AVL based on encoding (see Section 6.2 of RVV spec)
          unique case (inst_q[i].bits[12:8])
            0: unique case (inst_q[i].bits[4:0])
              0:  avl[i] = inst_config_state[i].vl;  // rd = x0, rs1 = x0
              default: avl[i] = 32'hFFFFFFFF;        // rd != x0, rs1 = x0
            endcase
            default: avl[i] = reg_read_data_i[2*i];  // rs1 != x0
          endcase
          inst_config_state[i+1].lmul_orig =
              RVVLMUL'(reg_read_data_i[(2*i) + 1][2:0]);
          inst_config_state[i+1].sew =
              RVVSEW'(reg_read_data_i[(2*i) + 1][5:3]);
          inst_config_state[i+1].ta = reg_read_data_i[(2*i) + 1][6];
          inst_config_state[i+1].ma = reg_read_data_i[(2*i) + 1][7];
          is_setvl[i] = 1;
        end
      end

      if (is_setvl[i]) begin
        // Compute legality of vtype.
        unique case (inst_config_state[i+1].sew)
          SEW8:
            unique case(inst_config_state[i+1].lmul_orig)
              LMULRESERVED: inst_config_state[i+1].vill = 1;
              LMUL1_8: inst_config_state[i+1].vill = 1;
              default: inst_config_state[i+1].vill = 0;
            endcase
          SEW16:
            unique case(inst_config_state[i+1].lmul_orig)
              LMULRESERVED: inst_config_state[i+1].vill = 1;
              LMUL1_8: inst_config_state[i+1].vill = 1;
              LMUL1_4: inst_config_state[i+1].vill = 1;
              default: inst_config_state[i+1].vill = 0;
            endcase
          SEW32:
            unique case(inst_config_state[i+1].lmul_orig)
              LMULRESERVED: inst_config_state[i+1].vill = 1;
              LMUL1_8: inst_config_state[i+1].vill = 1;
              LMUL1_4: inst_config_state[i+1].vill = 1;
              LMUL1_2: inst_config_state[i+1].vill = 1;
              default: inst_config_state[i+1].vill = 0;
            endcase
          default: inst_config_state[i+1].vill = 1;
        endcase

        // Compute vl to set (saturating with necessary)
        unique case (inst_config_state[i+1].lmul_orig)
          LMUL1_8: vlmax[i] = ((`VLENB)/8) >> inst_config_state[i+1].sew;
          LMUL1_4: vlmax[i] = ((`VLENB)/4) >> inst_config_state[i+1].sew;
          LMUL1_2: vlmax[i] = ((`VLENB)/2) >> inst_config_state[i+1].sew;
          LMUL1: vlmax[i] = (`VLENB) >> inst_config_state[i+1].sew;
          LMUL2: vlmax[i] = (2*(`VLENB)) >> inst_config_state[i+1].sew;
          LMUL4: vlmax[i] = (4*(`VLENB)) >> inst_config_state[i+1].sew;
          LMUL8: vlmax[i] = (8*(`VLENB)) >> inst_config_state[i+1].sew;
          default: vlmax[i] = 0;
        endcase

        if (inst_config_state[i+1].vill) begin
          // If illegal, set to 0. See end of section 6.1 of RVV spec.
          inst_config_state[i+1].vl = 0;
        end else if (avl[i] > vlmax[i]) begin
          // One possible valid impl according to 6.3 of RVV spec.
          inst_config_state[i+1].vl = vlmax[i];
        end else begin
          inst_config_state[i+1].vl = avl[i];
        end

        inst_config_state[i+1].lmul = inst_config_state[i+1].lmul_orig;

        // TODO: filter out illegal lmul for widening ALU ops and non-indexed
        // LSU ops where eew>sew.
        if (REDUCE_LMUL) begin
          // We use vl here, it's guaranteed to be <= vlmax. This operation
          // should either reduce lmul or keep it untouched.
          // We don't need to worry about eew&emul here:
          // - the current sew&lmul is valid (does not lead to emul>8) and
          //   we don't increase it, so we cannot generate emul>8.
          // - we must keep lmul valid for the current sew, like lmul>=m1 for
          //   sew=e32. The resulting enul must also be valid.
          vl_minus_one[i] = (inst_config_state[i+1].vl == (`VL_WIDTH)'('b0)) ?
              (`VL_WIDTH)'('b0) :
              inst_config_state[i+1].vl - (`VL_WIDTH)'('b1);
          unique case (inst_config_state[i+1].sew)
            SEW8: begin
              if (vl_minus_one[i][`VL_WIDTH-2+:2] != 'b00) begin
                // vl from VLEN/2+1 to VLEN
                inst_config_state[i+1].lmul = LMUL8;
              end else if (vl_minus_one[i][`VL_WIDTH-3] == 'b1) begin
                // vl from VLEN/4+1 to VLEN/2
                inst_config_state[i+1].lmul = LMUL4;
              end else if (vl_minus_one[i][`VL_WIDTH-4] == 'b1) begin
                // vl from VLEN/8+1 to VLEN/4
                inst_config_state[i+1].lmul = LMUL2;
              end else if (vl_minus_one[i][`VL_WIDTH-5] == 'b1) begin
                // vl from VLEN/16+1 to VLEN/8
                inst_config_state[i+1].lmul = LMUL1;
              end else if (vl_minus_one[i][`VL_WIDTH-6] == 'b1) begin
                // vl from VLEN/32+1 to VLEN/16
                inst_config_state[i+1].lmul = LMUL1_2;
              end else begin
                // vl from 0 to VLEN/32
                inst_config_state[i+1].lmul = LMUL1_4;
              end
            end
            SEW16: begin
              if (vl_minus_one[i][`VL_WIDTH-3+:2] != 'b00) begin
                // vl from VLEN/4+1 to VLEN/2
                inst_config_state[i+1].lmul = LMUL8;
              end else if (vl_minus_one[i][`VL_WIDTH-4] == 'b1) begin
                // vl from VLEN/8+1 to VLEN/4
                inst_config_state[i+1].lmul = LMUL4;
              end else if (vl_minus_one[i][`VL_WIDTH-5] == 'b1) begin
                // vl from VLEN/16+1 to VLEN/8
                inst_config_state[i+1].lmul = LMUL2;
              end else if (vl_minus_one[i][`VL_WIDTH-6] == 'b1) begin
                // vl from VLEN/32+1 to VLEN/16
                inst_config_state[i+1].lmul = LMUL1;
              end else begin
                // vl from 0 to VLEN/32
                inst_config_state[i+1].lmul = LMUL1_2;
              end
            end
            SEW32: begin
              if (vl_minus_one[i][`VL_WIDTH-4+:2] != 'b00) begin
                // vl from VLEN/8+1 to VLEN/4
                inst_config_state[i+1].lmul = LMUL8;
              end else if (vl_minus_one[i][`VL_WIDTH-5] == 'b1) begin
                // vl from VLEN/16+1 to VLEN/8
                inst_config_state[i+1].lmul = LMUL4;
              end else if (vl_minus_one[i][`VL_WIDTH-6] == 'b1) begin
                // vl from VLEN/32+1 to VLEN/16
                inst_config_state[i+1].lmul = LMUL2;
              end else begin
                // vl from 0 to VLEN/32
                inst_config_state[i+1].lmul = LMUL1;
              end
            end
          endcase
        end
      end
    end
  end

  always_ff @(posedge clk or negedge rstn) begin
    if (!rstn) begin
      // Per Section 3.11 of RVV spec, the recommended state on reset is
      // vill is set, with the remain vtype bits and vl being set to 0.
      config_state_q.vill <= 1;
      config_state_q.vl <= 0;
      config_state_q.vstart <= 0;
      config_state_q.ma <= 0;
      config_state_q.ta <= 0;
      config_state_q.xrm <= RNU;
      config_state_q.xsat <= 0;
`ifdef ZVE32F_ON
      config_state_q.frm <= 0;
`endif  // ZVE32F_ON
      config_state_q.sew <= SEW8;
      config_state_q.lmul <= LMUL1;
    end else begin
      // Update config state next cycle
      config_state_q <= inst_config_state[N];
    end
  end

  // Propagate outputs
  logic [N-1:0] unaligned_cmd_valid;
  RVVCmd [N-1:0] unaligned_cmd_data;
  logic [N-1:0] unaligned_trap_valid;  // Should this instruction trap
  RVVInstruction [N-1:0] unaligned_trap_data;
  always_comb begin
    for (int i = 0; i < N; i++) begin
      unaligned_trap_valid[i] = valid_inst_q[i] && !is_setvl[i] &&
          inst_config_state[i+1].vill;
      unaligned_trap_data[i] = inst_q[i];
      unaligned_cmd_valid[i] = valid_inst_q[i] && !is_setvl[i] &&
          !inst_config_state[i+1].vill;

      // Combine instruction + arch state into command
`ifdef TB_SUPPORT
      unaligned_cmd_data[i].inst_pc = inst_q[i].pc;
`endif
      unaligned_cmd_data[i].opcode = inst_q[i].opcode;
      unaligned_cmd_data[i].bits = inst_q[i].bits;
      unaligned_cmd_data[i].arch_state = inst_config_state[i+1];
      // TODO: Handle rs propagation for loads/stores
      unaligned_cmd_data[i].rs1 =
          inst_q[i].bits[7] ? reg_read_data_i[2*i] : 0;

      // Write new value of vl into rd for configuration function.
      reg_write_valid_o[i] = is_setvl[i];
      reg_write_addr_o[i] = inst_q[i].bits[4:0];
      reg_write_data_o[i] =
          {{(`XLEN-`VL_WIDTH){1'b0}}, inst_config_state[i+1].vl};
    end
  end

  // Align outputs
  Aligner#(.T(RVVCmd), .N(N)) cmd_aligner(
      .valid_in(unaligned_cmd_valid),
      .data_in(unaligned_cmd_data),
      .valid_out(cmd_valid_o),
      .data_out(cmd_data_o)
  );

  // Trap
  logic trap_occurred;
  RVVInstruction trap_data;
  assign trap_valid_o = trap_occurred;
  assign trap_data_o = trap_data;
  always_comb begin
    trap_occurred = (unaligned_trap_valid != 0);
    // Initialize all trap_data fields to some zero value
    trap_data.pc = '0;
    trap_data.bits = '0;
    trap_data.opcode = RVV;

    for (int i = 0; i < N; i++) begin
      if (unaligned_trap_valid[i]) begin
        trap_occurred = 1'b1;
        trap_data = unaligned_trap_data[i];
        break;
      end
    end
  end

  // Assertions
`ifndef SYNTHESIS
  logic [N-1:0] lsu_requires_rs1_read;
  logic [N-1:0] non_lsu_requires_rs1_read;
  logic [N-1:0] requires_rs1_read;
  logic [N-1:0] lsu_requires_rs2_read;
  logic [N-1:0] non_lsu_requires_rs2_read;
  logic [N-1:0] requires_rs2_read;
  always_comb begin
    for (int i = 0; i < N; i++) begin
      // All LSU instructions read from rs1
      lsu_requires_rs1_read[i] = (inst_q[i].opcode != RVV);
      // Non LSU rs1 check
      non_lsu_requires_rs1_read[i] = (inst_q[i].opcode == RVV) && (
        (inst_q[i].bits[7:5] == 'b100) ||  // OPIVX
        (inst_q[i].bits[7:5] == 'b110) ||  // OPMVX
        ((inst_q[i].bits[7:5] == 'b111) && (inst_q[i].bits[24:23] != 2'b11))  // vsetvl and vsetvli
      );
      requires_rs1_read[i] =
          lsu_requires_rs1_read[i] || non_lsu_requires_rs1_read[i];

      // Only strided loads/stores (mop=0b10) read rs2
      lsu_requires_rs2_read[i] = (inst_q[i].opcode != RVV) &&
          (inst_q[i].bits[20:19] == 2'b10);
      // vsetvl is only non LSU instruction that reads rs2
      non_lsu_requires_rs2_read[i] = (inst_q[i].opcode == RVV) &&
          (inst_q[i].bits[7:5] == 3'b111) &&
          (inst_q[i].bits[24:18] == 7'b1000000);
      requires_rs2_read[i] =
          lsu_requires_rs2_read[i] || non_lsu_requires_rs2_read[i];
    end
  end

  always @(posedge clk) begin
    for (int i = 0; i < N; i++) begin
      assert(!valid_inst_q[i] || !requires_rs1_read[i] ||
              reg_read_valid_i[2*i]);
      assert(!valid_inst_q[i] || !requires_rs2_read[i] ||
              reg_read_valid_i[(2*i) + 1]);
    end
  end
`endif  // not def SYNTHESIS
endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_addsub.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef ALU_DEFINE_SVH
`include "rvv_backend_alu.svh"
`endif

module rvv_backend_alu_unit_addsub
(
  alu_uop_valid,
  alu_uop,
  result_valid,
  result
);
//
// interface signals
//
  // ALU RS handshake signals
  input   logic                   alu_uop_valid;
  input   ALU_RS_t                alu_uop;

  // ALU send result signals to ROB
  output  logic                   result_valid;
  output  PU2ROB_t                result;

//
// internal signals
//
  // ALU_RS_t struct signals
  logic   [`ROB_DEPTH_WIDTH-1:0]  rob_entry;
  FUNCT6_u                        uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]     uop_funct3;
  logic   [`VSTART_WIDTH-1:0]     vstart;
  logic   [`VL_WIDTH-1:0]         vl;       
  logic                           vm;       
  RVVXRM                          vxrm;       
  logic   [`VLEN-1:0]             v0_data;
  logic                           v0_data_valid;
  logic   [`VLEN-1:0]             vd_data;           
  logic                           vd_data_valid;
  logic   [`VLEN-1:0]             vs1_data;           
  logic                           vs1_data_valid; 
  logic   [`VLEN-1:0]             vs2_data;	        
  logic                           vs2_data_valid;  
  EEW_e                           vs2_eew;
  logic   [`XLEN-1:0] 	          rs1_data;        
  logic        	                  rs1_data_valid;
  logic   [`UOP_INDEX_WIDTH-1:0]  uop_index;          

  // execute 
  // add and sub instructions
  logic   [`VLENB-1:0]                                v0_data_in_use;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               src2_data;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               src1_data;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               product8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]  product16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]    product32;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               round8_src;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]  round16_src;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]    round32_src;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               round8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]  round16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]    round32;
  logic   [`VLENB-1:0]                                cin;
  logic   [`VLENB-1:0]                                cout8;
  logic   [`VLEN/`HWORD_WIDTH-1:0]                    cout16;
  logic   [`VLEN/`WORD_WIDTH-1:0]                     cout32;
  logic   [`VLENB-1:0]                                addu_upoverflow;
  logic   [`VLENB-1:0]                                add_upoverflow;
  logic   [`VLENB-1:0]                                add_underoverflow;
  logic   [`VLENB-1:0]                                subu_underoverflow;
  logic   [`VLENB-1:0]                                sub_upoverflow;
  logic   [`VLENB-1:0]                                sub_underoverflow;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]               result_minmax8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]  result_minmax16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]    result_minmax32;
  logic   [`VLEN-1:0]                                 result_data;   // regular data for EEW_vd = 8b,16b,32b
  ADDSUB_e                                            opcode;
  
  // for-loop
  genvar                                              j;

//
// prepare source data to calculate    
//
  // split ALU_RS_t struct
  assign  rob_entry      = alu_uop.rob_entry;
  assign  uop_funct6     = alu_uop.uop_funct6;
  assign  uop_funct3     = alu_uop.uop_funct3;
  assign  vstart         = alu_uop.vstart;
  assign  vl             = alu_uop.vl;
  assign  vm             = alu_uop.vm;
  assign  vxrm           = alu_uop.vxrm;
  assign  v0_data        = alu_uop.v0_data;
  assign  v0_data_valid  = alu_uop.v0_data_valid;
  assign  vd_data        = alu_uop.vd_data;
  assign  vd_data_valid  = alu_uop.vd_data_valid;
  assign  vs1_data       = alu_uop.vs1_data;
  assign  vs1_data_valid = alu_uop.vs1_data_valid;
  assign  vs2_data       = alu_uop.vs2_data;
  assign  vs2_data_valid = alu_uop.vs2_data_valid;
  assign  vs2_eew        = alu_uop.vs2_eew;
  assign  rs1_data       = alu_uop.rs1_data;
  assign  rs1_data_valid = alu_uop.rs1_data_valid;
  assign  uop_index      = alu_uop.uop_index;

//  
// prepare source data 
//
  // prepare valid signal 
  always_comb begin
    // initial the data
    result_valid = 'b0;

    case(uop_funct3) 
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VSUB,
          VSADD,
          VSSUB,
          VSADDU,
          VSSUBU: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid;
          end

          VADC,
          VSBC: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid&(vm==1'b0)&v0_data_valid;
          end

          VMINU,
          VMIN,
          VMAXU,
          VMAX: begin
            result_valid = alu_uop_valid&vs1_data_valid&vs2_data_valid;
          end
        endcase
      end

      OPIVX: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VSUB,
          VRSUB,
          VSADD,
          VSSUB,
          VSADDU,
          VSSUBU: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid;
          end

          VADC,
          VSBC: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid&(vm==1'b0)&v0_data_valid;
          end

          VMINU,
          VMIN,
          VMAXU,
          VMAX: begin
            result_valid = alu_uop_valid&rs1_data_valid&vs2_data_valid;
          end
        endcase
      end
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VRSUB,
          VSADD,
          VSADDU: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid;
          end

          VADC: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid&(vm==1'b0)&v0_data_valid;
          end
        endcase
      end

      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VWADDU,
          VWADD,
          VWSUBU,
          VWSUB: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid&((vs2_eew==EEW8)|(vs2_eew==EEW16));
          end

          VWADDU_W,
          VWADD_W,
          VWSUBU_W,
          VWSUB_W: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid&((vs2_eew==EEW16)|(vs2_eew==EEW32));
          end

          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid;
          end
        endcase
      end
      
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VWADDU,
          VWADD,
          VWSUBU,
          VWSUB: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid&((vs2_eew==EEW8)|(vs2_eew==EEW16));
          end

          VWADDU_W,
          VWADD_W,
          VWSUBU_W,
          VWSUB_W: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid&((vs2_eew==EEW16)|(vs2_eew==EEW32));
          end

          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid;
          end
        endcase
      end
    endcase
  end
 
  // prepare source data
  always_comb begin
    // initial the data
    src2_data    = 'b0;
    src1_data    = 'b0;

    case(uop_funct3) 
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VSUB,
          VADC,
          VSBC,
          VSADDU,
          VSADD,
          VSSUBU,
          VSSUB,
          VMINU,
          VMIN,
          VMAXU,
          VMAX: begin
            src2_data = vs2_data;
            src1_data = vs1_data;
          end
        endcase
      end

      OPIVX: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VSUB,
          VADC,
          VSBC,
          VSADDU,
          VSADD,
          VSSUBU,
          VSSUB,
          VMINU,
          VMIN,
          VMAXU,
          VMAX: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin  
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                EEW32: begin 
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
              endcase
            end
          end
          
          VRSUB: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src2_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin  
                  src2_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                EEW32: begin 
                  src2_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
              endcase
            end
            
            src1_data = vs2_data;
          end
        endcase
      end

      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VADD,
          VADC,
          VSADDU,
          VSADD: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin  
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                EEW32: begin 
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
              endcase
            end
          end
          
          VRSUB: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src2_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin  
                  src2_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                EEW32: begin 
                  src2_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src2_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+2] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src2_data[4*i+3] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
              endcase
            end

            src1_data = vs2_data;
          end
        endcase
      end

      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VWADDU,
          VWSUBU: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   = vs2_data[(2*i)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = 'b0;
                    src2_data[4*i+2] = vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = 'b0;

                    src1_data[4*i]   = vs1_data[(2*i)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = 'b0;
                    src1_data[4*i+2] = vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = 'b0;
                  end
                  else begin
                    src2_data[4*i]   = vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = 'b0;
                    src2_data[4*i+2] = vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = 'b0;

                    src1_data[4*i]   = vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = 'b0;
                    src1_data[4*i+2] = vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = 'b0;
                  end
                end
                EEW16: begin
                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   = vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = 'b0;
                    src2_data[4*i+3] = 'b0;

                    src1_data[4*i]   = vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = 'b0;
                    src1_data[4*i+3] = 'b0;
                  end
                  else begin
                    src2_data[4*i]   = vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = 'b0;
                    src2_data[4*i+3] = 'b0;

                    src1_data[4*i]   = vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = 'b0;
                    src1_data[4*i+3] = 'b0;
                  end
                end
              endcase
            end
          end

          VWADD,
          VWSUB: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   =              vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = {`BYTE_WIDTH{vs2_data[(2*i+1)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+2] =              vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};

                    src1_data[4*i]   =              vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = {`BYTE_WIDTH{vs1_data[(2*i+1)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+2] =              vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src2_data[4*i]   =              vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+2] =              vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};

                    src1_data[4*i]   =              vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+2] =              vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                end
                EEW16: begin
                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   =              vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] =              vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};

                    src1_data[4*i]   =              vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] =              vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src2_data[4*i]   =              vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] =              vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};

                    src1_data[4*i]   =              vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] =              vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                end
              endcase
            end
          end

          VWADDU_W,
          VWSUBU_W: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW16: begin
                  if(uop_index[0]==1'b0) begin
                    src1_data[4*i]   = vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = 'b0;
                    src1_data[4*i+2] = vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = 'b0;
                  end
                  else begin
                    src1_data[4*i]   = vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = 'b0; 
                    src1_data[4*i+2] = vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = 'b0;
                  end
                end
                EEW32: begin
                  if(uop_index[0]==1'b0) begin
                    src1_data[4*i]   = vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = 'b0;
                    src1_data[4*i+3] = 'b0;
                  end
                  else begin
                    src1_data[4*i]   = vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = 'b0;
                    src1_data[4*i+3] = 'b0;
                  end
                end
              endcase
            end
          end

          VWADD_W,
          VWSUB_W: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW16: begin
                  if(uop_index[0]==1'b0) begin
                    src1_data[4*i]   =              vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = {`BYTE_WIDTH{vs1_data[(2*i+1)*`BYTE_WIDTH-1]}}; 
                    src1_data[4*i+2] =              vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src1_data[4*i]   =              vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH-1]}}; 
                    src1_data[4*i+2] =              vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}}; 
                  end
                end
                EEW32: begin
                  if(uop_index[0]==1'b0) begin
                    src1_data[4*i]   =              vs1_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] =              vs1_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src1_data[4*i]   =              vs1_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+1] =              vs1_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[4*i+2] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                    src1_data[4*i+3] = {`BYTE_WIDTH{vs1_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                end
              endcase
            end
          end

          VAADDU,
          VASUBU,
          VAADD,
          VASUB: begin
            src2_data = vs2_data;
            src1_data = vs1_data;
          end
        endcase
      end
      
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VWADDU,
          VWSUBU: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src1_data[4*i]   =  rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = 'b0;
                  src1_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = 'b0;

                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   = vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = 'b0;
                    src2_data[4*i+2] = vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = 'b0;
                  end
                  else begin
                    src2_data[4*i]   = vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = 'b0;
                    src2_data[4*i+2] = vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = 'b0;
                  end
                end
                EEW16: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = 'b0;
                  src1_data[4*i+3] = 'b0;

                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   = vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = 'b0;
                    src2_data[4*i+3] = 'b0;
                  end
                  else begin
                    src2_data[4*i]   = vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = 'b0;
                    src2_data[4*i+3] = 'b0;
                  end
                end
              endcase
            end
          end

          VWADD,
          VWSUB: begin
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src1_data[4*i]   =              rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = {`BYTE_WIDTH{rs1_data[`BYTE_WIDTH-1]}};
                  src1_data[4*i+2] =              rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = {`BYTE_WIDTH{rs1_data[`BYTE_WIDTH-1]}};

                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   =              vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = {`BYTE_WIDTH{vs2_data[(2*i+1)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+2] =              vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src2_data[4*i]   =              vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+2] =              vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                end
                EEW16: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = {`BYTE_WIDTH{rs1_data[2*`BYTE_WIDTH-1]}};
                  src1_data[4*i+3] = {`BYTE_WIDTH{rs1_data[2*`BYTE_WIDTH-1]}};

                  if(uop_index[0]==1'b0) begin
                    src2_data[4*i]   =              vs2_data[(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] =              vs2_data[(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                  else begin
                    src2_data[4*i]   =              vs2_data[`VLEN/2+(2*i  )*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+1] =              vs2_data[`VLEN/2+(2*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src2_data[4*i+2] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                    src2_data[4*i+3] = {`BYTE_WIDTH{vs2_data[`VLEN/2+(2*i+2)*`BYTE_WIDTH-1]}};
                  end
                end
              endcase
            end
          end

          VWADDU_W,
          VWSUBU_W: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW16: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = 'b0;
                  src1_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = 'b0;
                end
                EEW32: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = 'b0;
                  src1_data[4*i+3] = 'b0;
                end
              endcase
            end
          end

          VWADD_W,
          VWSUB_W: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW16: begin
                  src1_data[4*i]   =              rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = {`BYTE_WIDTH{rs1_data[`BYTE_WIDTH-1]}};
                  src1_data[4*i+2] =              rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = {`BYTE_WIDTH{rs1_data[`BYTE_WIDTH-1]}};
                end
                EEW32: begin
                  src1_data[4*i]   =              rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] =              rs1_data[`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = {`BYTE_WIDTH{rs1_data[2*`BYTE_WIDTH-1]}};
                  src1_data[4*i+3] = {`BYTE_WIDTH{rs1_data[2*`BYTE_WIDTH-1]}};
                end
              endcase
            end
          end

          VAADDU,
          VASUBU,
          VAADD,
          VASUB: begin
            src2_data = vs2_data;

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              case(vs2_eew)
                EEW8: begin
                  src1_data[4*i]   = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0 +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin  
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                EEW32: begin 
                  src1_data[4*i]   = rs1_data[0             +: `BYTE_WIDTH];
                  src1_data[4*i+1] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+2] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data[4*i+3] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
              endcase
            end
          end
        endcase
      end
    endcase
  end
 
  // prepare cin
  always_comb begin
    v0_data_in_use = 'b0;

    case(vs2_eew)
      EEW8: begin
        v0_data_in_use = v0_data[{uop_index,{($clog2(`VLENB)){1'b0}}} +: `VLENB];
      end
      EEW16: begin
        v0_data_in_use = {{(`VLENB/2){1'b0}}, v0_data[{uop_index,{($clog2(`VLENB/2)){1'b0}}} +: `VLENB/2]};
      end
      EEW32: begin
        v0_data_in_use = {{(`VLENB*3/4){1'b0}}, v0_data[{uop_index,{($clog2(`VLENB/4)){1'b0}}} +: `VLENB/4]};
      end
    endcase
  end

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j=j+1) begin: GET_CIN
      always_comb begin
        // initial the data
        cin[4*j]   = 'b0;
        cin[4*j+1] = 'b0;
        cin[4*j+2] = 'b0;
        cin[4*j+3] = 'b0;

        case(uop_funct3) 
          OPIVV,
          OPIVX,
          OPIVI: begin
            case(uop_funct6.ari_funct6)
              VADC,
              VSBC: begin
                case(vs2_eew)
                  EEW8: begin                    
                    cin[4*j]   = v0_data_in_use[4*j];
                    cin[4*j+1] = v0_data_in_use[4*j+1];
                    cin[4*j+2] = v0_data_in_use[4*j+2];
                    cin[4*j+3] = v0_data_in_use[4*j+3];
                  end
                  EEW16: begin
                    cin[4*j]   = v0_data_in_use[2*j];
                    cin[4*j+1] = 'b0;
                    cin[4*j+2] = v0_data_in_use[2*j+1];
                    cin[4*j+3] = 'b0;
                  end
                  EEW32: begin
                    cin[4*j]   = v0_data_in_use[j];
                    cin[4*j+1] = 'b0;
                    cin[4*j+2] = 'b0;
                    cin[4*j+3] = 'b0;
                  end
                endcase
              end
            endcase
          end
        endcase
      end
    end
  endgenerate

  // get opcode for f_addsub
  always_comb begin
    // initial the data
    opcode = ADDSUB_VADD;

    // prepare source data
    case(uop_funct3) 
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)    
          VADD,
          VADC,
          VSADDU,
          VSADD: begin
            opcode = ADDSUB_VADD;
          end
          VSUB,
          VRSUB,
          VSBC,
          VSSUBU,
          VSSUB,
          VMINU,
          VMIN,
          VMAXU,
          VMAX: begin
            opcode = ADDSUB_VSUB;
          end
        endcase
      end
      OPMVV,
      OPMVX: begin
        case(uop_funct6.ari_funct6)    
          VWADDU,
          VWADD,
          VWADDU_W,
          VWADD_W,
          VAADDU,
          VAADD: begin
            opcode = ADDSUB_VADD;
          end
          VWSUBU,
          VWSUB,
          VWSUBU_W,
          VWSUB_W,
          VASUBU,
          VASUB: begin
            opcode = ADDSUB_VSUB;
          end
        endcase
      end
    endcase
  end

//    
// calculate the result
//
  // for add and sub instructions
  generate
    for (j=0;j<`VLENB;j=j+1) begin: EXE_VADDSUB_PROD8
      assign {cout8[j],product8[j]} = f_full_addsub8(opcode, src2_data[j], src1_data[j], cin[j]);
    end
  endgenerate
  
  generate
    for (j=0;j<`VLEN/`HWORD_WIDTH;j=j+1) begin: EXE_VADDSUB_PROD16
      assign {cout16[j],product16[j]} = {f_half_addsub8(opcode, {cout8[2*j+1],product8[2*j+1]}, cout8[2*j]), product8[2*j]};
    end
  endgenerate 

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j=j+1) begin: EXE_VADDSUB_PROD32
      assign {cout32[j],product32[j]} = {f_half_addsub16(opcode, {cout16[2*j+1],product16[2*j+1]}, cout16[2*j]), product16[2*j]};
    end
  endgenerate 
  
  // rounding result
  always_comb begin
    round8_src  = 'b0;
    round16_src = 'b0;
    round32_src = 'b0;
    round8  = 'b0;
    round16 = 'b0;
    round32 = 'b0;
    
    case(uop_funct6.ari_funct6)
      VAADDU,
      VASUBU: begin
        case(vxrm)
          RNU: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = product8[i][0] ? round8_src[i]+1'b1 : round8_src[i];
            end

            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = product16[i][0] ? round16_src[i]+1'b1 : round16_src[i];
            end

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {cout32[i],product32[i][`WORD_WIDTH-1:1]};
              round32[i] = product32[i][0] ? f_src_plus1(round32_src[i]) : round32_src[i];
            end
          end
          RNE: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = product8[i][0]&product8[i][1] ? round8_src[i]+1'b1 : round8_src[i];
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = product16[i][0]&product16[i][1] ? round16_src[i]+1'b1 : round16_src[i];
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {cout32[i],product32[i][`WORD_WIDTH-1:1]};
              round32[i] = product32[i][0]&product32[i][1] ? f_src_plus1(round32_src[i]) : round32_src[i];
            end
          end
          RDN: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {cout8[i],product8[i][`BYTE_WIDTH-1:1]}; 
              round8[i] = round8_src[i];
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {cout16[i],product16[i][`HWORD_WIDTH-1:1]}; 
              round16[i] = round16_src[i];
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {cout32[i],product32[i][`WORD_WIDTH-1:1]}; 
              round32[i] = round32_src[i];
            end
          end
          ROD: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = (!product8[i][1])&product8[i][0] ? round8_src[i]+1'b1 : round8_src[i];
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = (!product16[i][1])&product16[i][0] ? round16_src[i]+1'b1 : round16_src[i]; 
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {cout32[i],product32[i][`WORD_WIDTH-1:1]}; 
              round32[i] = (!product32[i][1])&product32[i][0] ? f_src_plus1(round32_src[i]) : round32_src[i]; 
            end
          end
        endcase
      end
      VAADD,
      VASUB: begin
        case(vxrm)
          RNU: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {src2_data[i][`BYTE_WIDTH-1]^src1_data[i][`BYTE_WIDTH-1]?(!cout8[i]):cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = product8[i][0] ? round8_src[i]+1'b1 : round8_src[i]; 
                                            
            end
            
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {src2_data[2*i+1][`BYTE_WIDTH-1]^src1_data[2*i+1][`BYTE_WIDTH-1]?(!cout16[i]):cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = product16[i][0] ? round16_src[i]+1'b1 : round16_src[i]; 
            end

            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {src2_data[4*i+3][`BYTE_WIDTH-1]^src1_data[4*i+3][`BYTE_WIDTH-1]?(!cout32[i]):cout32[i],product32[i][`WORD_WIDTH-1:1]};
              round32[i] = product32[i][0] ? f_src_plus1(round32_src[i]) : round32_src[i]; 
            end
          end
          RNE: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {src2_data[i][`BYTE_WIDTH-1]^src1_data[i][`BYTE_WIDTH-1]?(!cout8[i]):cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = product8[i][0]&product8[i][1] ? round8_src[i]+1'b1 : round8_src[i]; 
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {src2_data[2*i+1][`BYTE_WIDTH-1]^src1_data[2*i+1][`BYTE_WIDTH-1]?(!cout16[i]):cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = product16[i][0]&product16[i][1] ? round16_src[i]+1'b1 : round16_src[i]; 
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {src2_data[4*i+3][`BYTE_WIDTH-1]^src1_data[4*i+3][`BYTE_WIDTH-1]?(!cout32[i]):cout32[i],product32[i][`WORD_WIDTH-1:1]};
              round32[i] = product32[i][0]&product32[i][1] ? f_src_plus1(round32_src[i]) : round32_src[i]; 
            end
          end
          RDN: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {src2_data[i][`BYTE_WIDTH-1]^src1_data[i][`BYTE_WIDTH-1]?(!cout8[i]):cout8[i],product8[i][`BYTE_WIDTH-1:1]}; 
              round8[i] = round8_src[i];
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {src2_data[2*i+1][`BYTE_WIDTH-1]^src1_data[2*i+1][`BYTE_WIDTH-1]?(!cout16[i]):cout16[i],product16[i][`HWORD_WIDTH-1:1]}; 
              round16[i] = round16_src[i];
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {src2_data[4*i+3][`BYTE_WIDTH-1]^src1_data[4*i+3][`BYTE_WIDTH-1]?(!cout32[i]):cout32[i],product32[i][`WORD_WIDTH-1:1]}; 
              round32[i] = round32_src[i];
            end
          end
          ROD: begin
            for(int i=0;i<`VLENB;i=i+1) begin
              round8_src[i] = {src2_data[i][`BYTE_WIDTH-1]^src1_data[i][`BYTE_WIDTH-1]?(!cout8[i]):cout8[i],product8[i][`BYTE_WIDTH-1:1]};
              round8[i] = (!product8[i][1])&product8[i][0] ? round8_src[i]+1'b1 : round8_src[i]; 
            end
    
            for(int i=0;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
              round16_src[i] = {src2_data[2*i+1][`BYTE_WIDTH-1]^src1_data[2*i+1][`BYTE_WIDTH-1]?(!cout16[i]):cout16[i],product16[i][`HWORD_WIDTH-1:1]};
              round16[i] = (!product16[i][1])&product16[i][0] ? round16_src[i]+1'b1 : round16_src[i]; 
            end
    
            for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
              round32_src[i] = {src2_data[4*i+3][`BYTE_WIDTH-1]^src1_data[4*i+3][`BYTE_WIDTH-1]?(!cout32[i]):cout32[i],product32[i][`WORD_WIDTH-1:1]};
              round32[i] = (!product32[i][1])&product32[i][0] ? f_src_plus1(round32_src[i]) : round32_src[i]; 
            end
          end
        endcase
      end
    endcase
  end

  // overflow check
  generate 
    for (j=0;j<`VLEN/`WORD_WIDTH;j++) begin: OVERFLOW
      always_comb begin
        // initial
        addu_upoverflow[   4*j +: 4] = 'b0;
        add_upoverflow[    4*j +: 4] = 'b0;
        add_underoverflow[ 4*j +: 4] = 'b0;
        subu_underoverflow[4*j +: 4] = 'b0;
        sub_upoverflow[    4*j +: 4] = 'b0;
        sub_underoverflow[ 4*j +: 4] = 'b0;
          
        case(vs2_eew)
          EEW8: begin
            addu_upoverflow[4*j +: 4] = {cout8[4*j+3],cout8[4*j+2],cout8[4*j+1],cout8[4*j]};

            add_upoverflow[4*j +: 4] = {
              ((product8[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j+2][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+2][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+2][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j  ][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j  ][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j  ][`BYTE_WIDTH-1]==1'b0))};

            add_underoverflow[4*j +: 4] = {
              ((product8[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j+2][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+2][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+2][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j  ][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j  ][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j  ][`BYTE_WIDTH-1]==1'b1))};
            
            subu_underoverflow[4*j +: 4] = {cout8[4*j+3],cout8[4*j+2],cout8[4*j+1],cout8[4*j]};

            sub_upoverflow[4*j +: 4] = {
              ((product8[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j+2][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+2][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+2][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b1)),
              ((product8[4*j  ][`BYTE_WIDTH-1]==1'b1)&(src2_data[4*j  ][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j  ][`BYTE_WIDTH-1]==1'b1))};

            sub_underoverflow[4*j +: 4] = {
              ((product8[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j+2][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+2][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+2][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b0)),
              ((product8[4*j  ][`BYTE_WIDTH-1]==1'b0)&(src2_data[4*j  ][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j  ][`BYTE_WIDTH-1]==1'b0))};
          end
          EEW16: begin
            addu_upoverflow[4*j +: 4] = {cout16[2*j+1],1'b0,cout16[2*j],1'b0};

            add_upoverflow[4*j +: 4] = {
              ((product16[2*j+1][`HWORD_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              1'b0,
              ((product16[2*j  ][`HWORD_WIDTH-1]==1'b1)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b0)),
              1'b0};

            add_underoverflow[4*j +: 4] = {
              ((product16[2*j+1][`HWORD_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              1'b0,
              ((product16[2*j  ][`HWORD_WIDTH-1]==1'b0)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b1)),
              1'b0};

            subu_underoverflow[4*j +: 4] = {cout16[2*j+1],1'b0,cout16[2*j],1'b0};

            sub_upoverflow[4*j +: 4] = {
              ((product16[2*j+1][`HWORD_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              1'b0,
              ((product16[2*j  ][`HWORD_WIDTH-1]==1'b1)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b1)),
              1'b0};

            sub_underoverflow[4*j +: 4] = {
              ((product16[2*j+1][`HWORD_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              1'b0,
              ((product16[2*j  ][`HWORD_WIDTH-1]==1'b0)&(src2_data[4*j+1][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+1][`BYTE_WIDTH-1]==1'b0)),
              1'b0};
          end
          EEW32: begin
            addu_upoverflow[4*j +: 4] = {cout32[j],3'b0};

            add_upoverflow[4*j +: 4] = {
              ((product32[j][`WORD_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              3'b0};

            add_underoverflow[4*j +: 4] = {
              ((product32[j][`WORD_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              3'b0};

            subu_underoverflow[4*j +: 4] = {cout32[j],3'b0};

            sub_upoverflow[4*j +: 4] = {
              ((product32[j][`WORD_WIDTH-1]==1'b1)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b0)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b1)),
              3'b0};

            sub_underoverflow[4*j +: 4] = {
              ((product32[j][`WORD_WIDTH-1]==1'b0)&(src2_data[4*j+3][`BYTE_WIDTH-1]==1'b1)&(src1_data[4*j+3][`BYTE_WIDTH-1]==1'b0)),
              3'b0};
          end
        endcase
      end
    end
  endgenerate

  // assign to result_data
  generate 
    for (j=0;j<`VLEN/`WORD_WIDTH;j++) begin: GET_RESULT_DATA
      always_comb begin
        // initial the data
        result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'b0;
        result_minmax8[4*j+3]  = 'b0;
        result_minmax8[4*j+2]  = 'b0;
        result_minmax8[4*j+1]  = 'b0;
        result_minmax8[4*j]    = 'b0;
        result_minmax16[2*j+1] = 'b0;
        result_minmax16[2*j]   = 'b0;
        result_minmax32[j]     = 'b0;
 
        // calculate result data
        case(uop_funct3) 
          OPIVV,
          OPIVX,
          OPIVI: begin
            case(uop_funct6.ari_funct6)
              VADD,
              VSUB,
              VRSUB,
              VADC,
              VSBC: begin
                case(vs2_eew)
                  EEW8: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {product8[4*j+3],product8[4*j+2],product8[4*j+1],product8[4*j]};
                  end
                  EEW16: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {product16[2*j+1],product16[2*j]};
                  end
                  EEW32: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j];
                  end
                endcase
              end
              
              VSADDU: begin
                case(vs2_eew)
                  EEW8: begin
                    if(addu_upoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = product8[4*j];
                      
                    if(addu_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+1];
                    
                    if(addu_upoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+2];

                    if(addu_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+3];
                  end
                  EEW16: begin
                    if(addu_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = product16[2*j];
                      
                    if(addu_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = product16[2*j+1];
                  end
                  EEW32: begin
                    if(addu_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'hffff_ffff;
                    else
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j];
                  end
                endcase
              end

              VSADD: begin
                case(vs2_eew)
                  EEW8: begin
                    if (add_upoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (add_underoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = product8[4*j];
                      
                    if (add_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (add_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+1];
                    
                    if (add_upoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (add_underoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+2];

                    if (add_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (add_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+3];
                  end
                  EEW16: begin
                    if (add_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (add_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = product16[2*j];                   

                    if (add_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (add_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = product16[2*j+1];                   
                  end
                  EEW32: begin
                    if (add_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'h7fff_ffff;
                    else if (add_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'h8000_0000;
                    else
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j]; 
                  end
                endcase
              end

              VSSUBU: begin
                case(vs2_eew)
                  EEW8: begin
                    if(subu_underoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = product8[4*j];
                      
                    if(subu_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+1];
                    
                    if(subu_underoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+2];

                    if(subu_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+3];
                  end
                  EEW16: begin
                    if(subu_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = product16[2*j];
                      
                    if(subu_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = product16[2*j+1];
                  end
                  EEW32: begin
                    if(subu_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'd0;
                    else
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j];
                  end
                endcase
              end

              VSSUB: begin
                case(vs2_eew)
                  EEW8: begin
                    if (sub_upoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (sub_underoverflow[4*j])
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH +: `BYTE_WIDTH] = product8[4*j];
                      
                    if (sub_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (sub_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+1*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+1];
                    
                    if (sub_upoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (sub_underoverflow[4*j+2])
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+2*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+2];

                    if (sub_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (sub_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[j*`WORD_WIDTH+3*`BYTE_WIDTH +: `BYTE_WIDTH] = product8[4*j+3];
                  end
                  EEW16: begin
                    if (sub_upoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (sub_underoverflow[4*j+1])
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[j*`WORD_WIDTH +: `HWORD_WIDTH] = product16[2*j];                   

                    if (sub_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (sub_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[j*`WORD_WIDTH+1*`HWORD_WIDTH +: `HWORD_WIDTH] = product16[2*j+1];                   
                  end
                  EEW32: begin
                    if (sub_upoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'h7fff_ffff;
                    else if (sub_underoverflow[4*j+3])
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = 'h8000_0000;
                    else
                      result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j]; 
                  end
                endcase
              end

              VMINU: begin
                case(vs2_eew)
                  EEW8: begin
                    result_minmax8[4*j+3] = cout8[4*j+3] ? src2_data[4*j+3] : src1_data[4*j+3];
                    result_minmax8[4*j+2] = cout8[4*j+2] ? src2_data[4*j+2] : src1_data[4*j+2];
                    result_minmax8[4*j+1] = cout8[4*j+1] ? src2_data[4*j+1] : src1_data[4*j+1];
                    result_minmax8[4*j  ] = cout8[4*j  ] ? src2_data[4*j  ] : src1_data[4*j  ];

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax8[4*j+3],
                                                                 result_minmax8[4*j+2],
                                                                 result_minmax8[4*j+1],
                                                                 result_minmax8[4*j]};
                  end
                  EEW16: begin
                    result_minmax16[2*j+1] = cout16[2*j+1] ? {src2_data[4*j+3],src2_data[4*j+2]} : {src1_data[4*j+3],src1_data[4*j+2]}; 
                    result_minmax16[2*j  ] = cout16[2*j  ] ? {src2_data[4*j+1],src2_data[4*j  ]} : {src1_data[4*j+1],src1_data[4*j  ]};

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax16[2*j+1],
                                                                 result_minmax16[2*j]};
                  end
                  EEW32: begin
                    result_minmax32[j] = cout32[j] ? {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]}: 
                                                     {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]}; 

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = result_minmax32[j];
                  end
                endcase
              end

              VMIN: begin
                case(vs2_eew)
                  EEW8: begin
                    case({src2_data[4*j][`BYTE_WIDTH-1],src1_data[4*j][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax8[4*j] = src2_data[4*j];
                      2'b01  : result_minmax8[4*j] = src1_data[4*j];
                      default: result_minmax8[4*j] = product8[4*j][`BYTE_WIDTH-1] ? src2_data[4*j] : src1_data[4*j];
                    endcase

                    case({src2_data[4*j+1][`BYTE_WIDTH-1],src1_data[4*j+1][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax8[4*j+1] = src2_data[4*j+1];
                      2'b01  : result_minmax8[4*j+1] = src1_data[4*j+1];
                      default: result_minmax8[4*j+1] = product8[4*j+1][`BYTE_WIDTH-1] ? src2_data[4*j+1] : src1_data[4*j+1];
                    endcase

                    case({src2_data[4*j+2][`BYTE_WIDTH-1],src1_data[4*j+2][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax8[4*j+2] = src2_data[4*j+2];
                      2'b01  : result_minmax8[4*j+2] = src1_data[4*j+2];
                      default: result_minmax8[4*j+2] = product8[4*j+2][`BYTE_WIDTH-1] ? src2_data[4*j+2] : src1_data[4*j+2];
                    endcase

                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax8[4*j+3] = src2_data[4*j+3];
                      2'b01  : result_minmax8[4*j+3] = src1_data[4*j+3];
                      default: result_minmax8[4*j+3] = product8[4*j+3][`BYTE_WIDTH-1] ? src2_data[4*j+3] : src1_data[4*j+3];
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax8[4*j+3],
                                                                 result_minmax8[4*j+2],
                                                                 result_minmax8[4*j+1],
                                                                 result_minmax8[4*j]};
                  end
                  EEW16: begin
                    case({src2_data[4*j+1][`BYTE_WIDTH-1],src1_data[4*j+1][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax16[2*j] = {src2_data[4*j+1],src2_data[4*j]};
                      2'b01  : result_minmax16[2*j] = {src1_data[4*j+1],src1_data[4*j]};
                      default: result_minmax16[2*j] = product16[2*j][`HWORD_WIDTH-1] ? {src2_data[4*j+1],src2_data[4*j]} : {src1_data[4*j+1],src1_data[4*j]};
                    endcase

                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax16[2*j+1] = {src2_data[4*j+3],src2_data[4*j+2]};
                      2'b01  : result_minmax16[2*j+1] = {src1_data[4*j+3],src1_data[4*j+2]};
                      default: result_minmax16[2*j+1] = product16[2*j+1][`HWORD_WIDTH-1] ? {src2_data[4*j+3],src2_data[4*j+2]} : {src1_data[4*j+3],src1_data[4*j+2]};
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax16[2*j+1],
                                                                 result_minmax16[2*j]};
                  end
                  EEW32: begin
                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b10  : result_minmax32[j] = {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]};
                      2'b01  : result_minmax32[j] = {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]};
                      default: result_minmax32[j] = product32[j][`WORD_WIDTH-1] ? 
                                                      {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]}:
                                                      {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]}; 
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = result_minmax32[j];
                  end
                endcase
              end

              VMAXU: begin
                case(vs2_eew)
                  EEW8: begin
                    result_minmax8[4*j+3] = cout8[4*j+3] ? src1_data[4*j+3] : src2_data[4*j+3];
                    result_minmax8[4*j+2] = cout8[4*j+2] ? src1_data[4*j+2] : src2_data[4*j+2];
                    result_minmax8[4*j+1] = cout8[4*j+1] ? src1_data[4*j+1] : src2_data[4*j+1];
                    result_minmax8[4*j  ] = cout8[4*j  ] ? src1_data[4*j  ] : src2_data[4*j  ];

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax8[4*j+3],
                                                                 result_minmax8[4*j+2],
                                                                 result_minmax8[4*j+1],
                                                                 result_minmax8[4*j]};
                  end
                  EEW16: begin
                    result_minmax16[2*j+1] = cout16[2*j+1] ? {src1_data[4*j+3],src1_data[4*j+2]} : {src2_data[4*j+3],src2_data[4*j+2]}; 
                    result_minmax16[2*j  ] = cout16[2*j  ] ? {src1_data[4*j+1],src1_data[4*j  ]} : {src2_data[4*j+1],src2_data[4*j  ]};

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax16[2*j+1],
                                                                 result_minmax16[2*j]};
                  end
                  EEW32: begin
                    result_minmax32[j] = cout32[j] ? {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]}: 
                                                     {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]}; 

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = result_minmax32[j];
                  end
                endcase
              end

              VMAX: begin
                case(vs2_eew)
                  EEW8: begin
                    case({src2_data[4*j][`BYTE_WIDTH-1],src1_data[4*j][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax8[4*j] = src2_data[4*j];
                      2'b10  : result_minmax8[4*j] = src1_data[4*j];
                      default: result_minmax8[4*j] = product8[4*j][`BYTE_WIDTH-1] ? src1_data[4*j] : src2_data[4*j];
                    endcase

                    case({src2_data[4*j+1][`BYTE_WIDTH-1],src1_data[4*j+1][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax8[4*j+1] = src2_data[4*j+1];
                      2'b10  : result_minmax8[4*j+1] = src1_data[4*j+1];
                      default: result_minmax8[4*j+1] = product8[4*j+1][`BYTE_WIDTH-1] ? src1_data[4*j+1] : src2_data[4*j+1];
                    endcase

                    case({src2_data[4*j+2][`BYTE_WIDTH-1],src1_data[4*j+2][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax8[4*j+2] = src2_data[4*j+2];
                      2'b10  : result_minmax8[4*j+2] = src1_data[4*j+2];
                      default: result_minmax8[4*j+2] = product8[4*j+2][`BYTE_WIDTH-1] ? src1_data[4*j+2] : src2_data[4*j+2];
                    endcase

                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax8[4*j+3] = src2_data[4*j+3];
                      2'b10  : result_minmax8[4*j+3] = src1_data[4*j+3];
                      default: result_minmax8[4*j+3] = product8[4*j+3][`BYTE_WIDTH-1] ? src1_data[4*j+3] : src2_data[4*j+3];
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax8[4*j+3],
                                                                 result_minmax8[4*j+2],
                                                                 result_minmax8[4*j+1],
                                                                 result_minmax8[4*j]};
                  end
                  EEW16: begin
                    case({src2_data[4*j+1][`BYTE_WIDTH-1],src1_data[4*j+1][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax16[2*j] = {src2_data[4*j+1],src2_data[4*j]};
                      2'b10  : result_minmax16[2*j] = {src1_data[4*j+1],src1_data[4*j]};
                      default: result_minmax16[2*j] = product16[2*j][`HWORD_WIDTH-1] ? {src1_data[4*j+1],src1_data[4*j]} : {src2_data[4*j+1],src2_data[4*j]};
                    endcase

                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax16[2*j+1] = {src2_data[4*j+3],src2_data[4*j+2]};
                      2'b10  : result_minmax16[2*j+1] = {src1_data[4*j+3],src1_data[4*j+2]};
                      default: result_minmax16[2*j+1] = product16[2*j+1][`HWORD_WIDTH-1] ? {src1_data[4*j+3],src1_data[4*j+2]} : {src2_data[4*j+3],src2_data[4*j+2]};
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {result_minmax16[2*j+1],
                                                                 result_minmax16[2*j]};
                  end
                  EEW32: begin
                    case({src2_data[4*j+3][`BYTE_WIDTH-1],src1_data[4*j+3][`BYTE_WIDTH-1]})
                      2'b01  : result_minmax32[j] = {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]};
                      2'b10  : result_minmax32[j] = {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]};
                      default: result_minmax32[j] = product32[j][`WORD_WIDTH-1] ? 
                                                      {src1_data[4*j+3],src1_data[4*j+2],src1_data[4*j+1],src1_data[4*j]}:
                                                      {src2_data[4*j+3],src2_data[4*j+2],src2_data[4*j+1],src2_data[4*j]}; 
                    endcase

                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = result_minmax32[j];
                  end
                endcase
              end        


            endcase
          end
          
          OPMVV,
          OPMVX: begin
            case(uop_funct6.ari_funct6)
              VWADDU,
              VWSUBU,
              VWADD,
              VWSUB: begin
                case(vs2_eew)
                  EEW8: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {product16[2*j+1], product16[2*j]};
                  end
                  EEW16: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j];
                  end
                endcase
              end

              VWADDU_W,
              VWSUBU_W,
              VWADD_W,
              VWSUB_W: begin
                case(vs2_eew)
                  EEW16: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {product16[2*j+1], product16[2*j]};
                  end
                  EEW32: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = product32[j];
                  end
                endcase
              end

              VAADDU,
              VAADD,
              VASUBU,
              VASUB: begin
                case(vs2_eew)
                  EEW8: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {round8[4*j+3], round8[4*j+2], round8[4*j+1], round8[4*j]};
                  end
                  EEW16: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = {round16[2*j+1], round16[2*j]};
                  end
                  EEW32: begin
                    result_data[j*`WORD_WIDTH +: `WORD_WIDTH] = round32[j];
                  end
                endcase
              end
            endcase
          end
        endcase
      end
    end
  endgenerate

//
// submit result to ROB
//
  always_comb begin
    // initial
  `ifdef TB_SUPPORT
    result.uop_pc    = alu_uop.uop_pc;
  `endif
    result.rob_entry = rob_entry;
    result.w_data    = result_data;
    result.w_valid   = result_valid;
    result.vsaturate = 'b0;

    case(uop_funct3) 
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VSADDU: begin
            result.vsaturate = addu_upoverflow;
          end
          VSADD: begin
            result.vsaturate = add_upoverflow|add_underoverflow;
          end
          VSSUBU: begin
            result.vsaturate = subu_underoverflow;
          end
          VSSUB: begin
            result.vsaturate = sub_upoverflow|sub_underoverflow;
          end
        endcase
      end
    endcase
  end

//
// function unit
//
  // add and sub function
  function [`BYTE_WIDTH:0] f_full_addsub8;
    // x +/- (y+cin)
    input ADDSUB_e                opcode;  
    input logic [`BYTE_WIDTH-1:0] src_x;
    input logic [`BYTE_WIDTH-1:0] src_y;
    input logic                   src_cin;

    logic [`BYTE_WIDTH-1:0]       result;
    logic                         cout;

    if (opcode==ADDSUB_VADD) 
      {cout,result} = (`BYTE_WIDTH+1)'(src_x) + (`BYTE_WIDTH+1)'(src_y) + (`BYTE_WIDTH+1)'(src_cin);
    else //(opcode==ADDSUB_VSUB)
      {cout,result} = (`BYTE_WIDTH+1)'(src_x) - (`BYTE_WIDTH+1)'(src_y) - (`BYTE_WIDTH+1)'(src_cin);
    
    return {cout,result};

  endfunction

  function [`BYTE_WIDTH:0] f_half_addsub8;
    // x +/- cin
    input ADDSUB_e              opcode;  
    input logic [`BYTE_WIDTH:0] src_x;
    input logic                 src_cin;

    logic [`BYTE_WIDTH-1:0]     result;
    logic                       cout;
    
    if (opcode==ADDSUB_VADD)
      {cout,result} = src_x + src_cin;
    else //(opcode==ADDSUB_VSUB)
      {cout,result} = src_x - src_cin;

    return {cout,result};  

  endfunction

  function [`HWORD_WIDTH:0] f_half_addsub16;
    // x +/- cin
    input ADDSUB_e               opcode;  
    input logic [`HWORD_WIDTH:0] src_x;
    input logic                  src_cin;

    logic [`HWORD_WIDTH-1:0]     result;
    logic                        cout;
    
    if (opcode==ADDSUB_VADD)
      {cout,result} = src_x + src_cin;
    else //(opcode==ADDSUB_VSUB)
      {cout,result} = src_x - src_cin;

    return {cout,result}; 

  endfunction

  function [`WORD_WIDTH-1:0] f_src_plus1;
    // x + cin
    input logic [`WORD_WIDTH-1:0] src_x;

    logic [`HWORD_WIDTH-1:0] res_hi;
    logic [`HWORD_WIDTH:0]   res_lo;

    res_hi = src_x[`WORD_WIDTH-1:`HWORD_WIDTH] + 1'b1;
    res_lo = (`HWORD_WIDTH+1)'(src_x[`HWORD_WIDTH-1:0]) + 1'b1;
    
    if (res_lo[`HWORD_WIDTH])
      return {res_hi,res_lo[`HWORD_WIDTH-1:0]};
    else
      return {src_x[`WORD_WIDTH-1:`HWORD_WIDTH],res_lo[`HWORD_WIDTH-1:0]};

  endfunction

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_execution_p1.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_alu_unit_execution_p1
(
  alu_uop_valid,
  alu_uop,
  result
);
//
// interface signals
//
  input   logic           alu_uop_valid;
  input   PIPE_DATA_t     alu_uop;
  output  PU2ROB_t        result;

  // internal signals
  logic   [`XLEN-1:0]                               result_data_vcpop;
  logic   [`VLEN-1:0][$clog2(`VLEN):0]              result_data_viota;
  logic   [`VLENB-1:0][$clog2(`VLEN):0]             result_data_viota8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][$clog2(`VLEN):0] result_data_viota16;
  logic   [`VLEN/`WORD_WIDTH-1:0][$clog2(`VLEN):0]  result_data_viota32;

  genvar                  j;

  // calculate viota and vcpop 
  generate
    if(`VLEN==128) begin
      for(j=0;j<64;j++) begin: GET_VIOTA128
        assign result_data_viota[j] = ($clog2(`VLEN)+1)'(alu_uop.data_viota_per64[0][j]);
        assign result_data_viota[j+64] = ($clog2(`VLEN)+1)'({1'b0,alu_uop.data_viota_per64[1][j]} + {1'b0,alu_uop.data_viota_per64[0][63]});
      end
    end
  endgenerate
  
  generate
    for(j=0; j<`VLENB;j++) begin: GET_VIOTA8
      assign result_data_viota8[j] = result_data_viota[{alu_uop.uop_index,j[$clog2(`VLENB)-1:0]}];
    end

    for(j=0; j<`VLEN/`HWORD_WIDTH;j++) begin: GET_VIOTA16
      assign result_data_viota16[j] = result_data_viota[{alu_uop.uop_index,j[$clog2(`VLEN/`HWORD_WIDTH)-1:0]}];
    end

    for(j=0; j<`VLEN/`WORD_WIDTH;j++) begin: GET_VIOTA32
      assign result_data_viota32[j] = result_data_viota[{alu_uop.uop_index,j[$clog2(`VLEN/`WORD_WIDTH)-1:0]}];
    end
  endgenerate
  
  // vcpop
  assign result_data_vcpop = (`XLEN)'(result_data_viota[`VLEN-1]);

//
// submit result to ROB
//
  // get result_uop
  always_comb begin
    // initial the data
    `ifdef TB_SUPPORT
    result.uop_pc    = alu_uop.uop_pc;
    `endif
    result.rob_entry = alu_uop.rob_entry;
    result.w_valid   = alu_uop_valid;
    result.w_data    = alu_uop.result_data;
    result.vsaturate = alu_uop.vsaturate;

    // calculate result data
    case(alu_uop.alu_sub_opcode)
      OP_VCPOP: begin
        result.w_data = (`VLEN)'(result_data_vcpop);
        result.vsaturate = 'b0;
      end
      OP_VIOTA: begin
        result.vsaturate = 'b0;
        
        case(alu_uop.vd_eew)
          EEW8: begin
            for(int i=0; i<`VLENB;i++) begin
              result.w_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = (`BYTE_WIDTH)'(result_data_viota8[i]);
            end
          end
          EEW16: begin
            for(int i=0; i<`VLEN/`HWORD_WIDTH;i++) begin
              result.w_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = (`HWORD_WIDTH)'(result_data_viota16[i]);
            end
          end
          EEW32: begin
            for(int i=0; i<`VLEN/`WORD_WIDTH;i++) begin
              result.w_data[i*`WORD_WIDTH +: `WORD_WIDTH] = (`WORD_WIDTH)'(result_data_viota32[i]);
            end
          end
        endcase
      end
    endcase
  end

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_mask_viota.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
//module rvv_backend_alu_unit_mask_viota64
//(
//  source,
//  result_viota64
//);
//  input  logic  [63:0]                source;
//  output logic  [63:0][$clog2(64):0]  result_viota64;
//
//  logic [1:0][31:0][$clog2(32):0]     result_viota32;
//
//  genvar                              j;
//  
//  // calculate
//  generate
//    for(j=0;j<2;j++) begin: GET_VIOTA32
//      rvv_backend_alu_unit_mask_viota32
//      u_viota32
//      (
//        .source         (source[32*j +: 32]),
//        .result_viota32 (result_viota32[j])
//      );
//    end
//    
//    for(j=0;j<32;j++) begin: GET_VIOTA64
//      assign result_viota64[j] = result_viota32[0][j];
//      assign result_viota64[j+32] = result_viota32[1][j]+result_viota32[0][31];
//    end
//  endgenerate
//
//endmodule
 
//
//  another viota64 by using viota16
//

// module rvv_backend_alu_unit_mask_viota64
// (
//   source,
//   result_viota64
// );
//   input  logic  [63:0]                source;
//   output logic  [63:0][$clog2(64):0]  result_viota64;
// 
//   logic [3:0][15:0][$clog2(16):0]     result_viota16;
//   logic      [15:0][$clog2(16):0]     sum_47to32;
//   logic      [15:0][$clog2(16):0]     carry_47to32;
//   logic      [15:0][$clog2(16):0]     sum_63to48;
//   logic      [15:0][$clog2(16):0]     carry_63to48;
//   logic      [15:0][$clog2(16):0]     cout_63to48;
// 
//   genvar                              j;
//   
//   // calculate
//   generate
//     for(j=0;j<4;j++) begin: GET_VIOTA16
//       rvv_backend_alu_unit_mask_viota16
//       u_viota16
//       (
//         .source         (source[16*j +: 16]),
//         .result_viota16 (result_viota16[j])
//       );
//     end
//     
//     for(j=0;j<16;j++) begin: GET_VIOTA64
//       assign result_viota64[j] = result_viota16[0][j];
//       assign result_viota64[j+16] = result_viota16[1][j]+result_viota16[0][15];
//       assign result_viota64[j+32] = sum_47to32[j]+{carry_47to32[j],1'b0};
//       assign result_viota64[j+48] = sum_63to48[j]+{({1'b0,carry_63to48[j]}+{1'b0,cout_63to48[j]}),1'b0};
// 
//       compressor_3_2
//       #(
//         .WIDTH  ($clog2(16)+1)
//       )
//       viota64_47to32
//       (
//         .src1         (result_viota16[0][15]),
//         .src2         (result_viota16[1][15]),
//         .src3         (result_viota16[2][j]),
//         .result_sum   (sum_47to32[j]),
//         .result_carry (carry_47to32[j])
//       );
// 
//       compressor_4_2
//       #(
//         .WIDTH  ($clog2(16)+1)
//       )
//       viota64_63to48
//       (
//         .src1         (result_viota16[0][15]),
//         .src2         (result_viota16[1][15]),
//         .src3         (result_viota16[2][15]),
//         .src4         (result_viota16[3][j]),
//         .cin          ('0),
//         .result_sum   (sum_63to48[j]),
//         .result_carry (carry_63to48[j]),
//         .result_cout  (cout_63to48[j])
//       );
//     end
//   endgenerate
// 
// endmodule

module rvv_backend_alu_unit_mask_viota32
(
  source,
  result_viota32
);

  input  logic [31:0]               source;
  output logic [31:0][$clog2(32):0] result_viota32;
  
  logic [3:0][6:0][2:0]             result_viota7;
  logic      [6:0][2:0]             sum_20to14;
  logic      [6:0][2:0]             carry_20to14;
  logic      [6:0][2:0]             sum_27to21;
  logic      [6:0][2:0]             carry_27to21;
  logic      [6:0][2:0]             cout_27to21;
  logic      [3:0][2:0]             result_viota4;
  logic      [3:0][2:0]             sum_31to28;
  logic      [3:0][2:0]             carry_31to28;
  logic      [3:0][2:0]             cout_31to28;
  
  genvar                            j;

  // calculate
  generate
    for(j=0;j<4;j++) begin: GET_VIOTA7_FOR_27_0_BIT
      rvv_backend_alu_unit_mask_viota7
      u_viota7
      (
        .source(source[j*7 +: 7]),
        .result_viota7(result_viota7[j])
      );
    end
  endgenerate

  rvv_backend_alu_unit_mask_viota4
  u_viota4
  (
    .source(source[31:28]),
    .result_viota4(result_viota4)
  );

  generate
    for(j=0;j<7;j++) begin: GET_VIOTA32_27_0
      assign result_viota32[j] = ($clog2(32)+1)'(result_viota7[0][j]);
      assign result_viota32[j+7] = ($clog2(32)+1)'(result_viota7[1][j])+($clog2(32)+1)'(result_viota7[0][6]);
      assign result_viota32[j+14] = ($clog2(32)+1)'(sum_20to14[j])+($clog2(32)+1)'({carry_20to14[j],1'b0});
      assign result_viota32[j+21] = ($clog2(32)+1)'(sum_27to21[j])+($clog2(32)+1)'({({1'b0,carry_27to21[j]})+($clog2(32)+1)'({1'b0,cout_27to21[j]}),1'b0});


      compressor_3_2
      #(
        .WIDTH        (3)
      )
      viota32_20to14
      (
        .src1         (result_viota7[0][6]),
        .src2         (result_viota7[1][6]),
        .src3         (result_viota7[2][j]),
        .result_sum   (sum_20to14[j]),
        .result_carry (carry_20to14[j])
      );
      
      compressor_4_2
      #(
        .WIDTH        (3)
      )
      viota32_27to21
      (
        .src1         (result_viota7[0][6]),
        .src2         (result_viota7[1][6]),
        .src3         (result_viota7[2][6]),
        .src4         (result_viota7[3][j]),
        .cin          ('0),
        .result_sum   (sum_27to21[j]),
        .result_carry (carry_27to21[j]),
        .result_cout  (cout_27to21[j])
      );
    end

    for(j=0;j<4;j++) begin: GET_VIOTA32_31_28
      assign result_viota32[j+28] = ($clog2(32)+1)'(sum_31to28[j])+
                                    ($clog2(32)+1)'({({1'b0,carry_31to28[j]})+
                                    ($clog2(32)+1)'({1'b0,cout_31to28[j]}),1'b0});

      compressor_4_2
      #(
        .WIDTH        (3)
      )
      viota32_31to28
      (
        .src1         (result_viota7[0][6]),
        .src2         (result_viota7[1][6]),
        .src3         (result_viota7[2][6]),
        .src4         (result_viota7[3][6]),
        .cin          (result_viota4[j]),
        .result_sum   (sum_31to28[j]),
        .result_carry (carry_31to28[j]),
        .result_cout  (cout_31to28[j])
      );
    end
  endgenerate
  
endmodule

// module rvv_backend_alu_unit_mask_viota16
// (
//   source,
//   result_viota16
// );
//   input  logic  [15:0]               source;
//   output logic  [15:0][$clog2(16):0] result_viota16;
// 
//   logic [3:0][3:0][$clog2(4):0]      result_viota4;
//   logic      [3:0][$clog2(4):0]      sum_11to8;
//   logic      [3:0][$clog2(4):0]      carry_11to8;
//   logic      [3:0][$clog2(4):0]      sum_15to12;
//   logic      [3:0][$clog2(4):0]      carry_15to12;
//   logic      [3:0][$clog2(4):0]      cout_15to12;
// 
//   genvar                             j;
//   
//   // calculate
//   generate
//     for(j=0;j<4;j++) begin: GET_VIOTA4
//       rvv_backend_alu_unit_mask_viota4
//       u_viota4
//       (
//         .source         (source[j*4 +: 4]),
//         .result_viota7  (result_viota4[j])
//       );
//     end
// 
//     for(j=0;j<4;j++) begin: GET_VIOTA16
//       assign result_viota16[j] = result_viota4[0][j];
//       assign result_viota16[j+4] = result_viota4[1][j]+result_viota4[0][3];
//       assign result_viota16[j+8] = sum_11to8[j]+{carry_11to8[j],1'b0};
//       assign result_viota16[j+12] = sum_15to12[j]+{({1'b0,carry_15to12[j]}+{1'b0,cout_15to12[j]}),1'b0};
// 
//       compressor_3_2
//       #(
//         .WIDTH  ($clog2(4)+1)
//       )
//       viota16_11to8
//       (
//         .src1         (result_viota4[0][3]),
//         .src2         (result_viota4[1][3]),
//         .src3         (result_viota4[2][j]),
//         .result_sum   (sum_11to8[j]),
//         .result_carry (carry_11to8[j])
//       );
// 
//       compressor_4_2
//       #(
//         .WIDTH  ($clog2(4)+1)
//       )
//       viota16_15to12
//       (
//         .src1         (result_viota4[0][3]),
//         .src2         (result_viota4[1][3]),
//         .src3         (result_viota4[2][3]),
//         .src4         (result_viota4[3][j]),
//         .cin          ('0),
//         .result_sum   (sum_15to12[j]),
//         .result_carry (carry_15to12[j]),
//         .result_cout  (cout_15to12[j])
//       );
//     end
//   endgenerate
// 
// endmodule

module rvv_backend_alu_unit_mask_viota7
(
  source,
  result_viota7
);

  input  logic [6:0]      source;
  output logic [6:0][2:0] result_viota7;
  
  logic [3:0][2:0]        result_viota4;

  rvv_backend_alu_unit_mask_viota4
  u_viota4
  (
    .source(source[3:0]),
    .result_viota4(result_viota4)
  );
  
  assign result_viota7[3:0] = result_viota4;

  always_comb begin
    case(source[4])
      1'b0: begin
        result_viota7[4] = result_viota4[3];
      end
      1'b1: begin
        result_viota7[4] = result_viota4[3]+1'b1;
      end
      default: begin
        result_viota7[4] = result_viota4[3];
      end
    endcase

    case(source[5:4])
      2'b00: begin
        result_viota7[5] = result_viota4[3];
      end
      2'b01,
      2'b10: begin
        result_viota7[5] = result_viota4[3]+1'b1;
      end
      2'b11: begin
        result_viota7[5] = result_viota4[3]+2'd2;
      end
      default: begin
        result_viota7[5] = result_viota4[3];
      end
    endcase

    case(source[6:4])
      3'b000: begin
        result_viota7[6] = result_viota4[3];
      end
      3'b001,
      3'b010,
      3'b100: begin
        result_viota7[6] = result_viota4[3]+1'b1;
      end
      3'b011,
      3'b101,
      3'b110: begin
        result_viota7[6] = result_viota4[3]+2'd2;
      end
      3'b111: begin
        result_viota7[6] = result_viota4[3]+2'd3;
      end
      default: begin
        result_viota7[6] = result_viota4[3];
      end
    endcase
  end

endmodule

module rvv_backend_alu_unit_mask_viota4
(
  source,
  result_viota4 
);

  input  logic [3:0]              source;
  output logic [3:0][$clog2(4):0] result_viota4;
  
  always_comb begin
    case(source[0])
      1'b0: begin
        result_viota4[0] = 3'd0;
      end
      1'b1: begin
        result_viota4[0] = 3'd1;
      end
      default: begin
        result_viota4[0] = 3'd0;
      end
    endcase

    case(source[1:0])
      2'b00: begin
        result_viota4[1] = 3'd0;
      end
      2'b01,
      2'b10: begin
        result_viota4[1] = 3'd1;
      end
      2'b11: begin
        result_viota4[1] = 3'd2;
      end
      default: begin
        result_viota4[1] = 3'd0;
      end
    endcase

    case(source[2:0])
      3'b000: begin
        result_viota4[2] = 3'd0;
      end
      3'b001,
      3'b010,
      3'b100: begin
        result_viota4[2] = 3'd1;
      end
      3'b011,
      3'b101,
      3'b110: begin
        result_viota4[2] = 3'd2;
      end
      3'b111: begin
        result_viota4[2] = 3'd3;
      end
      default: begin
        result_viota4[2] = 3'd0;
      end
    endcase

    case(source)
      4'b0000: begin
        result_viota4[3] = 3'd0;
      end
      4'b0001,
      4'b0010,
      4'b0100,
      4'b1000: begin
        result_viota4[3] = 3'd1;
      end
      4'b0011,
      4'b0101,
      4'b1001,
      4'b0110,
      4'b1010,
      4'b1100: begin
        result_viota4[3] = 3'd2;
      end
      4'b0111,
      4'b1011,
      4'b1101,
      4'b1110: begin
        result_viota4[3] = 3'd3;
      end
      4'b1111: begin
        result_viota4[3] = 3'd4;
      end
      default: begin
        result_viota4[3] = 3'd0;
      end
    endcase
  end

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_mask.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_alu_unit_mask
(
  alu_uop_valid,
  alu_uop,
  result_valid,
  result,
  result_2cycle
);
//
// interface signals
//
  // ALU RS handshake signals
  input   logic           alu_uop_valid;
  input   ALU_RS_t        alu_uop;

  // ALU send result signals to ROB
  output  logic           result_valid;
  output  PIPE_DATA_t     result;
  output  logic           result_2cycle;

//
// internal signals
//
  // ALU_RS_t struct signals
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  FUNCT6_u                            uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  logic   [`VSTART_WIDTH-1:0]         vstart;
  logic   [`VLEN-1:0]                 vstart_onehot;
  logic   [`VLEN-1:0]                 vstart_onehot_sub1;
  logic   [`VL_WIDTH-1:0]             vl;       
  logic                               vm;
  logic   [`VLEN-1:0]                 v0_data;           
  logic                               v0_data_valid;
  logic   [`VLEN-1:0]                 vd_data;           
  logic                               vd_data_valid;
  EEW_e                               vd_eew;
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vs1_opcode;              
  logic   [`VLEN-1:0]                 vs1_data;           
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  logic                               vs2_data_valid;  
  EEW_e                               vs2_eew;
  logic   [`XLEN-1:0] 	              rs1_data;        
  logic        	                      rs1_data_valid;
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;          

  // execute 
  logic   [`VLEN-1:0]                 src2_data;
  logic   [`VLEN-1:0]                 src2_data_sub1;
  logic   [`VLEN-1:0]                 src2_data_viota;
  logic   [`VLEN-1:0]                 src1_data;
  logic   [`VLEN-1:0]                 tail_mask;
  ALU_SUB_OPCODE_e                    alu_sub_opcode; 
  logic   [`VLEN-1:0]                 result_data;
  logic   [`VLEN-1:0]                 result_data_andn;
  logic   [`VLEN-1:0]                 result_data_and; 
  logic   [`VLEN-1:0]                 result_data_or;  
  logic   [`VLEN-1:0]                 result_data_xor; 
  logic   [`VLEN-1:0]                 result_data_orn; 
  logic   [`VLEN-1:0]                 result_data_nand;
  logic   [`VLEN-1:0]                 result_data_nor; 
  logic   [`VLEN-1:0]                 result_data_xnor;
  logic   [`VLEN-1:0]                 result_data_vmsof;
  logic   [`VLEN-1:0]                 result_vmsif;
  logic   [`VLEN-1:0]                 result_data_vmsif;
  logic   [`VLEN-1:0]                 result_data_vmsbf;
  logic   [`VLEN-1:0]                 result_data_vfirst;
  logic   [`VLEN/32-1:0][31:0][$clog2(32):0]        data_viota_per32;
  logic   [`VLEN/64-1:0][63:0][$clog2(64):0]        data_viota_per64;
  logic   [`VLEN-1:0][$clog2(`VLEN):0]              result_data_viota;
  logic   [`VLENB-1:0][$clog2(`VLEN):0]             result_data_viota8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][$clog2(`VLEN):0] result_data_viota16;
  logic   [`VLEN/`WORD_WIDTH-1:0][$clog2(`VLEN):0]  result_data_viota32;
  logic   [`VLEN-1:0]                 result_data_vid8;
  logic   [`VLEN-1:0]                 result_data_vid16;
  logic   [`VLEN-1:0]                 result_data_vid32;

  // for-loop
  genvar                              j;
  genvar                              h;

//
// prepare source data to calculate    
//
  // split ALU_RS_t struct
  assign  rob_entry      = alu_uop.rob_entry;
  assign  uop_funct6     = alu_uop.uop_funct6;
  assign  uop_funct3     = alu_uop.uop_funct3;
  assign  vstart         = alu_uop.vstart;
  assign  vl             = alu_uop.vl;
  assign  vm             = alu_uop.vm;
  assign  v0_data        = alu_uop.v0_data;
  assign  v0_data_valid  = alu_uop.v0_data_valid;
  assign  vd_data        = alu_uop.vd_data;
  assign  vd_data_valid  = alu_uop.vd_data_valid;
  assign  vd_eew         = alu_uop.vd_eew;
  assign  vs1_opcode     = alu_uop.vs1;
  assign  vs1_data       = alu_uop.vs1_data;
  assign  vs1_data_valid = alu_uop.vs1_data_valid;
  assign  vs2_data       = alu_uop.vs2_data;
  assign  vs2_data_valid = alu_uop.vs2_data_valid;
  assign  vs2_eew        = alu_uop.vs2_eew;
  assign  rs1_data       = alu_uop.rs1_data;
  assign  rs1_data_valid = alu_uop.rs1_data_valid;
  assign  uop_index      = alu_uop.uop_index;
  
//  
// prepare source data 
//
  // get tail mask
  generate
    for(j=0;j<`VLEN;j++) begin: GET_TAIL
      assign tail_mask[j] = j<vl;
    end
  endgenerate

  // prepare valid signal
  always_comb begin
    // initial the data
    result_valid = 'b0;
    alu_sub_opcode = OP_NONE;
    result_2cycle = 'b0;

    // prepare source data
    case(uop_funct3)
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VAND,
          VOR,
          VXOR: begin
            result_valid = alu_uop_valid&vs1_data_valid&vs2_data_valid;
            alu_sub_opcode = OP_OTHER;
          end
        endcase
      end
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VAND,
          VOR,
          VXOR: begin
            result_valid = alu_uop_valid&rs1_data_valid&vs2_data_valid;
            alu_sub_opcode = OP_OTHER;
          end
        endcase
      end
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VMANDN,
          VMAND,
          VMOR,
          VMXOR,
          VMORN,
          VMNAND,
          VMNOR,
          VMXNOR: begin
            result_valid = alu_uop_valid&vs1_data_valid&vs2_data_valid&vm&vd_data_valid;
            alu_sub_opcode = OP_OTHER;
          end
          VWRXUNARY0: begin
            case(vs1_opcode)
              VCPOP: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&((vm==1'b1)||((vm==1'b0)&v0_data_valid));
                alu_sub_opcode = OP_VCPOP;
                result_2cycle = 1'b1;
              end
              VFIRST: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&((vm==1'b1)||((vm==1'b0)&v0_data_valid));
                alu_sub_opcode = OP_OTHER;
              end
            endcase
          end
          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF,
              VMSOF,
              VMSIF: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&((vm==1'b1)||((vm==1'b0)&vd_data_valid&v0_data_valid));
                alu_sub_opcode = OP_OTHER;
              end
              VIOTA: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&((vm==1'b1)||((vm==1'b0)&v0_data_valid));
                alu_sub_opcode = OP_VIOTA;
                // it can get the viota result in one cycle whose element index in vd belongs to 0-31.
                // Otherwise, it will get the result in the next cycle.
                case(vd_eew)
                  EEW8   : result_2cycle = uop_index >= (`UOP_INDEX_WIDTH)'(32/(`VLEN/8));
                  EEW16  : result_2cycle = uop_index >= (`UOP_INDEX_WIDTH)'(32/(`VLEN/16));
                  default: result_2cycle = uop_index >= (`UOP_INDEX_WIDTH)'(32/(`VLEN/32));  //EEW32
                endcase
              end
              VID: begin
                result_valid = alu_uop_valid;
                alu_sub_opcode = OP_OTHER;
              end
            endcase
          end
        endcase
      end
    endcase
  end

  // prepare source data
  always_comb begin
    // initial the data
    src2_data       = 'b0;
    src1_data       = 'b0;
    src2_data_viota = 'b0; 

    // prepare source data
    case(uop_funct3)
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VAND,
          VOR,
          VXOR: begin
            src2_data = vs2_data;
            src1_data = vs1_data;
          end
        endcase
      end
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VAND,
          VOR,
          VXOR: begin
            src2_data = vs2_data;
            for(int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
              case(vs2_eew) 
                EEW8: begin
                  src1_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {(`WORD_WIDTH/`BYTE_WIDTH){rs1_data[0 +: `BYTE_WIDTH]}};
                end
                EEW16: begin
                  src1_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {(`WORD_WIDTH/`HWORD_WIDTH){rs1_data[0 +: `HWORD_WIDTH]}};
                end
                EEW32: begin
                  src1_data[i*`WORD_WIDTH +: `WORD_WIDTH] = rs1_data;
                end
              endcase
            end
          end 
        endcase
      end
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VMANDN,
          VMAND,
          VMOR,
          VMXOR,
          VMORN,
          VMNAND,
          VMNOR,
          VMXNOR: begin
            src2_data  = vs2_data;
            src1_data  = vs1_data;
          end
          VWRXUNARY0: begin
            case(vs1_opcode)
              VCPOP: begin
                if (vm==1'b1)
                  src2_data_viota = vs2_data&tail_mask;
                else
                  src2_data_viota = vs2_data&tail_mask&v0_data; 
              end
              VFIRST: begin
                if (vm==1'b1)
                  src2_data = vs2_data&tail_mask;
                else
                  src2_data = vs2_data&tail_mask&v0_data; 
              end
            endcase
          end
          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF,
              VMSOF,
              VMSIF: begin
                if (vm==1'b1)
                  src2_data = vs2_data;
                else
                  src2_data = vs2_data&v0_data; 
              end
              VIOTA: begin
                if (vm==1'b1)
                  src2_data_viota = {vs2_data[`VLEN-2:0],1'b0};
                else
                  src2_data_viota = {vs2_data[`VLEN-2:0]&v0_data[`VLEN-2:0],1'b0}; 
              end
              // no source operand for VID
            endcase
          end
        endcase
      end
    endcase
  end

//    
// calculate the result
//
  assign result_data_and   = src2_data & src1_data;  
  assign result_data_andn  = src2_data & (~src1_data);  
  assign result_data_or    = src2_data | src1_data;  
  assign result_data_xor   = src2_data ^ src1_data;  
  assign result_data_orn   = src2_data | (~src1_data);  
  assign result_data_nand  = ~(src2_data & src1_data);  
  assign result_data_nor   = ~(src2_data | src1_data);  
  assign result_data_xnor  = ~(src2_data ^ src1_data); 
  assign src2_data_sub1    = src2_data - 1'b1;
  assign result_data_vmsof = src2_data & (~src2_data_sub1);
  assign result_vmsif      = src2_data ^ src2_data_sub1;
  assign result_data_vmsif = (src2_data==0) ? {`VLEN{1'b1}} : result_vmsif;  
  assign result_data_vmsbf = (src2_data==0) ? {`VLEN{1'b1}} : {1'b0,result_vmsif[`VLEN-1:1]}; 
 
  // vfirst
  always_comb begin
    result_data_vfirst = 'b0;
    
    if (src2_data=='b0) 
      result_data_vfirst = {`VLEN{1'b1}};
    else begin
      for(int i=0;i<`VLEN;i++) begin
        if (result_data_vmsof[i]==1'b1)
          result_data_vfirst = (`VLEN)'(i);         // one-hot to 8421BCD. get the index of first 1
      end
    end
  end

  // viota and vcpop, still need process in next pipeline
  generate
    for(j=0; j<`VLEN/32;j++) begin: GET_VIOTA_PER32
      rvv_backend_alu_unit_mask_viota32
      u_viota32
      (
        .source         (src2_data_viota[32*j +: 32]),
        .result_viota32 (data_viota_per32[j])
      );
    end

    for(j=0; j<`VLENB;j++) begin: GET_VIOTA8
      if ((3)'($clog2(32/`VLENB)) <= 3'd3) // There may be up to 8 uops, so RHS in if-condition is $clog2(8)=3
        assign result_data_viota8[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[$clog2(32/`VLENB)-1:0],j[$clog2(`VLENB)-1:0]}]);
      else
        assign result_data_viota8[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[2:0],j[$clog2(`VLENB)-1:0]}]);
    end

    for(j=0; j<`VLEN/`HWORD_WIDTH;j++) begin: GET_VIOTA16
      if ((3)'($clog2(32/(`VLEN/`HWORD_WIDTH))) <= 3'd3)
        assign result_data_viota16[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[$clog2(32/(`VLEN/`HWORD_WIDTH))-1:0],j[$clog2(`VLEN/`HWORD_WIDTH)-1:0]}]);
      else
        assign result_data_viota16[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[2:0],j[$clog2(`VLEN/`HWORD_WIDTH)-1:0]}]);
    end

    for(j=0; j<`VLEN/`WORD_WIDTH;j++) begin: GET_VIOTA32
      if ((3)'($clog2(32/(`VLEN/`WORD_WIDTH))) <= 3'd3)
        assign result_data_viota32[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[$clog2(32/(`VLEN/`WORD_WIDTH))-1:0],j[$clog2(`VLEN/`WORD_WIDTH)-1:0]}]);
      else
        assign result_data_viota32[j] = ($clog2(`VLEN)+1)'(data_viota_per32[0][{alu_uop.uop_index[2:0],j[$clog2(`VLEN/`WORD_WIDTH)-1:0]}]);
    end

    for(j=0;j<`VLEN/64;j++) begin: GET_VIOTA_PER64_J
      for(h=0;h<32;h++) begin: GET_VIOTA_PER64_H
        assign data_viota_per64[j][h] = {1'b0,data_viota_per32[2*j][h]};
        assign data_viota_per64[j][h+32] = {1'b0,data_viota_per32[2*j+1][h]} + {1'b0,data_viota_per32[2*j][31]};
      end
    end
  endgenerate

  // vid
  generate
    for(j=0;j<`VLENB;j++) begin: GET_VID8
      assign result_data_vid8[j*`BYTE_WIDTH +: `BYTE_WIDTH] = (`BYTE_WIDTH)'({uop_index, j[$clog2(`VLENB)-1:0]});
    end
  endgenerate

  generate
    for(j=0;j<`VLEN/`HWORD_WIDTH;j++) begin: GET_VID16
      assign result_data_vid16[j*`HWORD_WIDTH +: `HWORD_WIDTH] = (`HWORD_WIDTH)'({uop_index, j[$clog2(`VLEN/`HWORD_WIDTH)-1:0]});
    end
  endgenerate

  generate
    for(j=0;j<`VLEN/`WORD_WIDTH;j++) begin: GET_VID32
      assign result_data_vid32[j*`WORD_WIDTH +: `WORD_WIDTH] = (`WORD_WIDTH)'({uop_index, j[$clog2(`VLEN/`WORD_WIDTH)-1:0]});
    end
  endgenerate

  // get result_data
  always_comb begin
    // initial the data
    result_data = 'b0; 
 
    // calculate result data
    case(uop_funct3)
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VAND: begin
            result_data = result_data_and;
          end
          VOR: begin
            result_data = result_data_or;
          end
          VXOR: begin
            result_data = result_data_xor;
          end
        endcase
      end
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VMANDN: begin
            result_data = result_data_andn;
          end
          VMAND: begin
            result_data = result_data_and; 
          end
          VMOR: begin
            result_data = result_data_or; 
          end
          VMXOR: begin
            result_data = result_data_xor; 
          end
          VMORN: begin
            result_data = result_data_orn; 
          end
          VMNAND: begin
            result_data = result_data_nand; 
          end
          VMNOR: begin
            result_data = result_data_nor; 
          end
          VMXNOR: begin
            result_data = result_data_xnor; 
          end
          VWRXUNARY0: begin
            case(vs1_opcode)
              VFIRST: begin
                result_data = result_data_vfirst;
              end
            endcase
          end
          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF: begin
                result_data = result_data_vmsbf;
              end
              VMSOF: begin
                result_data = result_data_vmsof;
              end
              VMSIF: begin
                result_data = result_data_vmsif;
              end
              VIOTA: begin
                case(vd_eew)
                  EEW8: begin
                    for(int i=0; i<`VLENB;i++) begin
                      result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = (`BYTE_WIDTH)'(result_data_viota8[i]);
                    end
                  end
                  EEW16: begin
                    for(int i=0; i<`VLEN/`HWORD_WIDTH;i++) begin
                      result_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = (`HWORD_WIDTH)'(result_data_viota16[i]);
                    end
                  end
                  EEW32: begin
                    for(int i=0; i<`VLEN/`WORD_WIDTH;i++) begin
                      result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = (`WORD_WIDTH)'(result_data_viota32[i]);
                    end
                  end
                endcase
              end
              VID: begin
                case(vd_eew)
                  EEW8: begin
                    result_data = result_data_vid8;
                  end
                  EEW16: begin
                    result_data = result_data_vid16;
                  end
                  EEW32: begin
                    result_data = result_data_vid32;
                  end
                endcase
              end
            endcase
          end
        endcase
      end
    endcase
  end

//
// submit result to ROB
//
  assign vstart_onehot = (`VLEN)'('b1)<<vstart;
  assign vstart_onehot_sub1 = vstart_onehot - 1'b1;

  always_comb begin
    // initial
    `ifdef TB_SUPPORT
    result.uop_pc           = alu_uop.uop_pc;
    `endif
    result.rob_entry        = rob_entry;
    result.vd_eew           = vd_eew;
    result.uop_index        = uop_index;
    result.alu_sub_opcode   = alu_sub_opcode;
    result.data_viota_per64 = data_viota_per64;
    result.vsaturate        = 'b0;
    result.result_data      = 'b0;

    case(uop_funct3)
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VAND,
          VOR,
          VXOR: begin
            result.result_data = result_data;
          end
        endcase
      end
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VMANDN,
          VMAND,
          VMOR,
          VMXOR,
          VMORN,
          VMNAND,
          VMNOR,
          VMXNOR: begin
            result.result_data = result_data&(~vstart_onehot_sub1) | vd_data&vstart_onehot_sub1;
          end
          VWRXUNARY0: begin
            case(vs1_opcode)
              VFIRST: begin
                result.result_data = result_data;
              end
            endcase
          end
          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF,
              VMSOF,
              VMSIF: begin
                if (vm==1'b1)
                  result.result_data = result_data;
                else 
                  result.result_data = result_data&v0_data | vd_data&(~v0_data);
              end
              VIOTA: begin
                result.result_data = result_data;
              end
              VID: begin
                result.result_data = result_data;
              end
            endcase
          end
        endcase
      end
    endcase
  end   

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_other.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_alu_unit_other
(
  alu_uop_valid,
  alu_uop,
  result_valid,
  result
);
//
// interface signals
//
  // ALU RS handshake signals
  input   logic                   alu_uop_valid;
  input   ALU_RS_t                alu_uop;

  // ALU send result signals to ROB
  output  logic                   result_valid;
  output  PU2ROB_t                result;

//
// internal signals
//
  // ALU_RS_t struct signals
  logic   [`ROB_DEPTH_WIDTH-1:0]      rob_entry;
  FUNCT6_u                            uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]         uop_funct3;
  logic                               vm;
  EEW_e                               vd_eew;
  logic   [`VLEN-1:0]                 v0_data;
  logic                               v0_data_valid;
  logic   [`REGFILE_INDEX_WIDTH-1:0]  vs1_opcode;              
  logic   [`VLEN-1:0]                 vs1_data;           
  logic                               vs1_data_valid; 
  logic   [`VLEN-1:0]                 vs2_data;	        
  logic                               vs2_data_valid;  
  EEW_e                               vs2_eew;
  logic   [`XLEN-1:0] 	              rs1_data;        
  logic        	                      rs1_data_valid;
  logic   [`UOP_INDEX_WIDTH-1:0]      uop_index;          

  // execute 
  // mask logic instructions
  logic   [`VLENB-1:0]                                v0_data_in_use;
  logic   [`VLEN-1:0]                                 src2_data;
  logic   [`VLEN-1:0]                                 src1_data;
  logic   [`VLEN-1:0]                                 result_data;
  logic   [`VLEN-1:0]                                 result_data_extend;  
  logic   [`VLEN-1:0]                                 result_data_vmerge; 
  
  // for-loop
  genvar                                              j;

//
// prepare source data to calculate    
//
  // split ALU_RS_t struct
  assign  rob_entry      = alu_uop.rob_entry;
  assign  uop_funct6     = alu_uop.uop_funct6;
  assign  uop_funct3     = alu_uop.uop_funct3;
  assign  vm             = alu_uop.vm;
  assign  v0_data        = alu_uop.v0_data;
  assign  v0_data_valid  = alu_uop.v0_data_valid;
  assign  vd_eew         = alu_uop.vd_eew;
  assign  vs1_opcode     = alu_uop.vs1;
  assign  vs1_data       = alu_uop.vs1_data;
  assign  vs1_data_valid = alu_uop.vs1_data_valid;
  assign  vs2_data       = alu_uop.vs2_data;
  assign  vs2_data_valid = alu_uop.vs2_data_valid;
  assign  vs2_eew        = alu_uop.vs2_eew;
  assign  rs1_data       = alu_uop.rs1_data;
  assign  rs1_data_valid = alu_uop.rs1_data_valid;
  assign  uop_index      = alu_uop.uop_index;

//  
// prepare source data 
//
  // get valid signal
  always_comb begin
    result_valid = 'b0;

    // prepare source data
    case(uop_funct3)
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            //                                          vmv.v           vmerge.v
            result_valid = alu_uop_valid&vs1_data_valid&(vm||vs2_data_valid&v0_data_valid);
          end
        endcase
      end

      OPIVX: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            //                                          vmv.v           vmerge.v
            result_valid = alu_uop_valid&rs1_data_valid&(vm||vs2_data_valid&v0_data_valid);
          end
        endcase
      end

      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            //                                          vmv.v           vmerge.v
            result_valid = alu_uop_valid&rs1_data_valid&(vm||vs2_data_valid&v0_data_valid);
          end
          VSMUL_VMVNRR: begin
            result_valid = alu_uop_valid&vm&vs2_data_valid;
          end
        endcase
      end

      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VXUNARY0: begin
            case(vs1_opcode) 
              VZEXT_VF2,
              VSEXT_VF2: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&((vs2_eew==EEW8)|(vs2_eew==EEW16));
              end
              VZEXT_VF4,
              VSEXT_VF4: begin
                result_valid = alu_uop_valid&(vs1_data_valid==1'b0)&vs2_data_valid&(vs2_eew==EEW8);
              end
            endcase
          end
          VWRXUNARY0: begin
            // vmv.x.s
            result_valid = alu_uop_valid&vm&vs2_data_valid&(vs1_opcode==VMV_X_S);
          end
        endcase
      end

      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VWRXUNARY0: begin
            // vmv.s.x
            result_valid = alu_uop_valid&vm&rs1_data_valid;
          end
        endcase
      end
    endcase
  end

  // prepare source data
  always_comb begin
    // initial the data
    src2_data    = 'b0;
    src1_data    = 'b0;

    // prepare source data
    case(uop_funct3)
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            // vmv.v
            if(vm) begin
              src1_data = vs1_data;
            end
            // vmerge.v
            else begin
              src2_data = vs2_data;
              src1_data = vs1_data;
            end
          end
        endcase
      end

      OPIVX: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            // vmv.v
            if(vm==1'b1) begin
              for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                case(vd_eew)
                  EEW8: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                  end
                  EEW16: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                  EEW32: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                endcase
              end
            end
            // vmerge.v
            else begin
              src2_data = vs2_data;
              for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                case(vs2_eew)
                  EEW8: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                  end
                  EEW16: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                  EEW32: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                endcase
              end
            end
          end
        endcase
      end

      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            // vmv.v
            if(vm==1'b1) begin
              for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                case(vd_eew)
                  EEW8: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                  end
                  EEW16: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                  EEW32: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                endcase
              end
            end
            // vmerge.v
            else begin
              src2_data = vs2_data;
              for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                case(vs2_eew)
                  EEW8: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
                  end
                  EEW16: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                  EEW32: begin
                    src1_data[(4*i  )*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[0             +: `BYTE_WIDTH];
                    src1_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[1*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[2*`BYTE_WIDTH +: `BYTE_WIDTH];
                    src1_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = rs1_data[3*`BYTE_WIDTH +: `BYTE_WIDTH];
                  end
                endcase
              end
            end
          end
          VSMUL_VMVNRR: begin
            if(vm) begin
              src2_data = vs2_data;
            end
          end
        endcase
      end

      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VXUNARY0: begin
            case(vs1_opcode) 
              VZEXT_VF2,
              VSEXT_VF2: begin
                if (uop_index[0]==1'b0)
                  src2_data = {2{vs2_data[0 +: `VLEN/2]}};
                else
                  src2_data = {2{vs2_data[`VLEN/2 +: `VLEN/2]}};
              end
              VZEXT_VF4,
              VSEXT_VF4: begin
                if (uop_index[1:0]==2'b0)
                  src2_data = {4{vs2_data[0 +: `VLEN/4]}};
                else if (uop_index[1:0]==2'b01)
                  src2_data = {4{vs2_data[1*`VLEN/4 +: `VLEN/4]}};
                else if (uop_index[1:0]==2'b10)
                  src2_data = {4{vs2_data[2*`VLEN/4 +: `VLEN/4]}};
                else
                  src2_data = {4{vs2_data[3*`VLEN/4 +: `VLEN/4]}};
              end
            endcase
          end
          VWRXUNARY0: begin
            // vmv.x.s
            if(vs1_opcode==VMV_X_S) begin
              case(vs2_eew)
                EEW8: begin
                  src2_data[0 +: `BYTE_WIDTH] = vs2_data[0 +: `BYTE_WIDTH];
                end
                EEW16: begin
                  src2_data[0 +: `HWORD_WIDTH] = vs2_data[0 +: `HWORD_WIDTH];
                end
                EEW32: begin
                  src2_data[0 +: `WORD_WIDTH] = vs2_data[0 +: `WORD_WIDTH];
                end
              endcase
            end
          end
        endcase
      end

      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VWRXUNARY0: begin
            // vmv.s.x
            case(vd_eew)
              EEW8: begin
                src1_data[0 +: `BYTE_WIDTH] = rs1_data[0 +: `BYTE_WIDTH];
              end
              EEW16: begin
                src1_data[0 +: `HWORD_WIDTH] = rs1_data[0 +: `HWORD_WIDTH];
              end
              EEW32: begin
                src1_data[0 +: `WORD_WIDTH] = rs1_data[0 +: `WORD_WIDTH];
              end
            endcase
          end
        endcase
      end
    endcase
  end

//    
// calculate the result
//
  // VXUNARY0
  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j=j+1) begin: EXE_EXTEND
      always_comb begin
        result_data_extend[j*`WORD_WIDTH +: `WORD_WIDTH] = 'b0;
        
        case(vs1_opcode) 
          VZEXT_VF2: begin
            case(vs2_eew)
              EEW8: begin
                result_data_extend[(2*j  )*`HWORD_WIDTH +: `HWORD_WIDTH] = {8'b0, src2_data[(2*j  )*`BYTE_WIDTH +: `BYTE_WIDTH]};
                result_data_extend[(2*j+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = {8'b0, src2_data[(2*j+1)*`BYTE_WIDTH +: `BYTE_WIDTH]};
              end
              EEW16: begin
                result_data_extend[j*`WORD_WIDTH +: `WORD_WIDTH] = {16'b0, src2_data[j*`HWORD_WIDTH +: `HWORD_WIDTH]};
              end
            endcase
          end
          VSEXT_VF2: begin
            case(vs2_eew)
              EEW8: begin
                result_data_extend[(2*j  )*`HWORD_WIDTH +: `HWORD_WIDTH] = {{8{src2_data[(2*j+1)*`BYTE_WIDTH-1]}}, src2_data[(2*j  )*`BYTE_WIDTH +: `BYTE_WIDTH]};
                result_data_extend[(2*j+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = {{8{src2_data[(2*j+2)*`BYTE_WIDTH-1]}}, src2_data[(2*j+1)*`BYTE_WIDTH +: `BYTE_WIDTH]};
              end
              EEW16: begin
                result_data_extend[j*`WORD_WIDTH +: `WORD_WIDTH] = {{16{src2_data[(j+1)*`HWORD_WIDTH-1]}},src2_data[j*`HWORD_WIDTH +: `HWORD_WIDTH]};
              end
            endcase
          end
          VZEXT_VF4: begin
            case(vs2_eew)
              EEW8: begin
                result_data_extend[j*`WORD_WIDTH +: `WORD_WIDTH] = {24'b0, src2_data[j*`BYTE_WIDTH +: `BYTE_WIDTH]};
              end
            endcase
          end
          VSEXT_VF4: begin       
            case(vs2_eew)
              EEW8: begin
                result_data_extend[j*`WORD_WIDTH +: `WORD_WIDTH] = {{24{src2_data[(j+1)*`BYTE_WIDTH-1]}}, src2_data[j*`BYTE_WIDTH +: `BYTE_WIDTH]};
              end
            endcase
          end
        endcase
      end
    end
  endgenerate
 
  // vmerge
  always_comb begin
    v0_data_in_use = 'b0;

    case(vs2_eew)
      EEW8: begin
        v0_data_in_use = v0_data[{uop_index,{($clog2(`VLENB)){1'b0}}} +: `VLENB];
      end
      EEW16: begin
        v0_data_in_use = {{(`VLENB/2){1'b0}}, v0_data[{uop_index,{($clog2(`VLENB/2)){1'b0}}} +: `VLENB/2]};
      end
      EEW32: begin
        v0_data_in_use = {{(`VLENB*3/4){1'b0}}, v0_data[{uop_index,{($clog2(`VLENB/4)){1'b0}}} +: `VLENB/4]};
      end
    endcase
  end 

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j=j+1) begin: EXE_VMERGE
      always_comb begin
        result_data_vmerge[j*`WORD_WIDTH +: `WORD_WIDTH] = 'b0;
        
        case(vs2_eew)
          EEW8: begin
            result_data_vmerge[(4*j  )*`BYTE_WIDTH +: `BYTE_WIDTH] = v0_data_in_use[4*j] ?
                                                                     src1_data[(4*j  )*`BYTE_WIDTH +: `BYTE_WIDTH] :
                                                                     src2_data[(4*j  )*`BYTE_WIDTH +: `BYTE_WIDTH] ;
            result_data_vmerge[(4*j+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = v0_data_in_use[4*j+1] ?
                                                                     src1_data[(4*j+1)*`BYTE_WIDTH +: `BYTE_WIDTH] :
                                                                     src2_data[(4*j+1)*`BYTE_WIDTH +: `BYTE_WIDTH] ;
            result_data_vmerge[(4*j+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = v0_data_in_use[4*j+2] ?
                                                                     src1_data[(4*j+2)*`BYTE_WIDTH +: `BYTE_WIDTH] :
                                                                     src2_data[(4*j+2)*`BYTE_WIDTH +: `BYTE_WIDTH] ;
            result_data_vmerge[(4*j+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = v0_data_in_use[4*j+3] ?
                                                                     src1_data[(4*j+3)*`BYTE_WIDTH +: `BYTE_WIDTH] :
                                                                     src2_data[(4*j+3)*`BYTE_WIDTH +: `BYTE_WIDTH] ;
          end
          EEW16: begin
            result_data_vmerge[(2*j  )*`HWORD_WIDTH +: `HWORD_WIDTH] = v0_data_in_use[2*j] ?
                                                                     src1_data[(2*j  )*`HWORD_WIDTH +: `HWORD_WIDTH] :
                                                                     src2_data[(2*j  )*`HWORD_WIDTH +: `HWORD_WIDTH] ;
            result_data_vmerge[(2*j+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = v0_data_in_use[2*j+1] ?
                                                                     src1_data[(2*j+1)*`HWORD_WIDTH +: `HWORD_WIDTH] :
                                                                     src2_data[(2*j+1)*`HWORD_WIDTH +: `HWORD_WIDTH] ;
          end
          EEW32: begin
            result_data_vmerge[j*`WORD_WIDTH +: `WORD_WIDTH] = v0_data_in_use[j] ?
                                                               src1_data[j*`WORD_WIDTH +: `WORD_WIDTH] :
                                                               src2_data[j*`WORD_WIDTH +: `WORD_WIDTH] ;
          end
        endcase
      end
    end
  endgenerate

  // get results
  always_comb begin
    // initial the data
    result_data = 'b0; 

    case(uop_funct3) 
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VMERGE_VMV: begin
            if(vm==1'b0)
              result_data = result_data_vmerge;
            else
              result_data = src1_data;
          end
          VSMUL_VMVNRR: begin
            result_data = src2_data;
          end
        endcase
      end
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VXUNARY0: begin
            result_data = result_data_extend;
          end
          VWRXUNARY0: begin
            result_data = src2_data;
          end
        endcase
      end
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VWRXUNARY0: begin
            result_data = src1_data;
          end
        endcase
      end
    endcase
  end

//
// submit result to ROB
//
`ifdef TB_SUPPORT
  assign result.uop_pc = alu_uop.uop_pc;
`endif

  assign result.rob_entry = rob_entry;

  assign result.w_data = result_data;

  assign result.w_valid = result_valid;

  assign result.vsaturate = 'b0;

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit_shift.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_alu_unit_shift
(
  alu_uop_valid,
  alu_uop,
  result_valid,
  result
);
//
// interface signals
//
  // ALU RS handshake signals
  input   logic                   alu_uop_valid;
  input   ALU_RS_t                alu_uop;

  // ALU send result signals to ROB
  output  logic                   result_valid;
  output  PU2ROB_t                result;

//
// internal signals
//
  // ALU_RS_t struct signals
  logic   [`ROB_DEPTH_WIDTH-1:0]  rob_entry;
  FUNCT6_u                        uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]     uop_funct3;
  RVVXRM                          vxrm;       
  logic   [`VLEN-1:0]             vs1_data;           
  logic                           vs1_data_valid; 
  logic   [`VLEN-1:0]             vs2_data;	        
  logic                           vs2_data_valid;  
  EEW_e                           vs2_eew;
  logic   [`XLEN-1:0] 	          rs1_data;        
  logic        	                  rs1_data_valid;
  logic   [`UOP_INDEX_WIDTH-1:0]  uop_index;          

  // execute 
  // add and sub instructions
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]                      src2_data8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]         src2_data16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             src2_data32;
  logic   [`VLENB/2-1:0][$clog2(`BYTE_WIDTH)-1:0]              shift_amount8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][$clog2(`HWORD_WIDTH)-1:0] shift_amount16;
  logic   [`VLEN/`WORD_WIDTH-1:0][$clog2(`WORD_WIDTH)-1:0]     shift_amount32;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]                      product8_tmp;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]         product16_tmp;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             product32_tmp;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]                        product8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]           product16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             product32;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]                      round_bits8_tmp;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]         round_bits16_tmp;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             round_bits32_tmp;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]                        round_bits8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]           round_bits16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             round_bits32;
  logic   [`VLENB-1:0]                                         round_increment8;
  logic   [`VLEN/`HWORD_WIDTH-1:0]                             round_increment16;
  logic   [`VLEN/`WORD_WIDTH-1:0]                              round_increment32;
  logic   [`VLENB-1:0][`BYTE_WIDTH-1:0]                        round8;
  logic   [`VLEN/`HWORD_WIDTH-1:0][`HWORD_WIDTH-1:0]           round16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]             round32;
  logic   [`VLEN/`HWORD_WIDTH-1:0]                             cout16;
  logic   [`VLEN/`WORD_WIDTH-1:0]                              cout32;
  logic   [`VLENB-1:0]                                         upoverflow;
  logic   [`VLENB-1:0]                                         underoverflow;
  logic   [`VLEN-1:0]                                          result_data; 
  SHIFT_e                                                      opcode;
  
  // for-loop
  genvar                          j;

//
// prepare source data to calculate    
//
  // split ALU_RS_t struct
  assign  rob_entry      = alu_uop.rob_entry;
  assign  uop_funct6     = alu_uop.uop_funct6;
  assign  uop_funct3     = alu_uop.uop_funct3;
  assign  vxrm           = alu_uop.vxrm;
  assign  vs1_data       = alu_uop.vs1_data;
  assign  vs1_data_valid = alu_uop.vs1_data_valid;
  assign  vs2_data       = alu_uop.vs2_data;
  assign  vs2_data_valid = alu_uop.vs2_data_valid;
  assign  vs2_eew        = alu_uop.vs2_eew;
  assign  rs1_data       = alu_uop.rs1_data;
  assign  rs1_data_valid = alu_uop.rs1_data_valid;
  assign  uop_index      = alu_uop.uop_index;
  
//  
// prepare source data 
//
  // prepare valid signal 
  always_comb begin
    // initial the data
    result_valid   = 'b0;

    case(uop_funct3) 
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VSLL,
          VSRL,
          VSRA,
          VSSRL,
          VSSRA: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid;
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            result_valid = alu_uop_valid&vs2_data_valid&vs1_data_valid&((vs2_eew==EEW16)|(vs2_eew==EEW32));
          end
        endcase
      end

      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VSLL,
          VSRL,
          VSRA,
          VSSRL,
          VSSRA: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid;
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            result_valid = alu_uop_valid&vs2_data_valid&rs1_data_valid&((vs2_eew==EEW16)|(vs2_eew==EEW32));
          end
        endcase
      end
    endcase
  end

  // prepare source data
  always_comb begin
    // initial the data
    src2_data8     = 'b0;
    src2_data16    = 'b0;
    src2_data32    = 'b0;
    shift_amount8  = 'b0;
    shift_amount16 = 'b0;
    shift_amount32 = 'b0;

    case(uop_funct3) 
      OPIVV: begin
        case(uop_funct6.ari_funct6)
          VSLL,
          VSRL,
          VSSRL: begin
            case(vs2_eew)
              EEW8: begin
                for(int i=0;i<`VLENB/2;i=i+1) begin
                  src2_data8[i]    = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  shift_amount8[i] = vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)];
                end
                for(int i=`VLENB/2;i<`VLENB*3/4;i=i+1) begin
                  src2_data16[   i-`VLENB/2] = {8'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount16[i-`VLENB/2] = {1'b0,vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)]};
                end         
                for(int i=`VLENB*3/4;i<`VLENB;i=i+1) begin
                  src2_data32[   i-`VLENB*3/4] = {24'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount32[i-`VLENB*3/4] = {2'b0, vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)]};
                end
              end
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = vs1_data[i*`HWORD_WIDTH +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, vs1_data[i*`HWORD_WIDTH +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = vs1_data[i*`WORD_WIDTH +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase
          end

          VSRA,
          VSSRA: begin
             case(vs2_eew)
              EEW8: begin
                for(int i=0;i<`VLENB/2;i=i+1) begin
                  src2_data8[i]    = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  shift_amount8[i] = vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)];
                end
                for(int i=`VLENB/2;i<`VLENB*3/4;i=i+1) begin
                  src2_data16[   i-`VLENB/2] = {{8{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount16[i-`VLENB/2] = {1'b0,vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)]};
                end         
                for(int i=`VLENB*3/4;i<`VLENB;i=i+1) begin
                  src2_data32[   i-`VLENB*3/4] = {{24{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount32[i-`VLENB*3/4] = {2'b0,vs1_data[i*`BYTE_WIDTH +: $clog2(`BYTE_WIDTH)]};
                end
              end
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = vs1_data[i*`HWORD_WIDTH +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0,vs1_data[i*`HWORD_WIDTH +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = vs1_data[i*`WORD_WIDTH +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase         
          end

          VNSRL,
          VNCLIPU: begin
            case(vs2_eew)
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  if (uop_index[0]==1'b0)
                    shift_amount16[i] = vs1_data[i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)];
                  else
                    shift_amount16[i] = vs1_data[`VLEN/2+i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  if (uop_index[0]==1'b0)
                    shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, vs1_data[i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)]};
                  else
                    shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, vs1_data[`VLEN/2+i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH  +: `WORD_WIDTH];
                  if (uop_index[0]==1'b0)
                    shift_amount32[i] = vs1_data[i*`HWORD_WIDTH +: $clog2(`WORD_WIDTH)];
                  else
                    shift_amount32[i] = vs1_data[`VLEN/2+i*`HWORD_WIDTH +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase
          end

          VNSRA,
          VNCLIP: begin
             case(vs2_eew)
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  if (uop_index[0]==1'b0)
                    shift_amount16[i] = vs1_data[i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)];
                  else
                    shift_amount16[i] = vs1_data[`VLEN/2+i*`BYTE_WIDTH  +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  if (uop_index[0]==1'b0)
                    shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, vs1_data[i*`BYTE_WIDTH +: $clog2(`HWORD_WIDTH)]};
                  else
                    shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, vs1_data[`VLEN/2+i*`BYTE_WIDTH +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH  +: `WORD_WIDTH];
                  if (uop_index[0]==1'b0)
                    shift_amount32[i] = vs1_data[i*`HWORD_WIDTH +: $clog2(`WORD_WIDTH)];
                  else
                    shift_amount32[i] = vs1_data[`VLEN/2+i*`HWORD_WIDTH +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase  
          end
        endcase
      end

      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VSLL,
          VSRL,
          VSSRL: begin
             case(vs2_eew)
              EEW8: begin
                for(int i=0;i<`VLENB/2;i=i+1) begin
                  src2_data8[i]    = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  shift_amount8[i] = rs1_data[0             +: $clog2(`BYTE_WIDTH)];
                end
                for(int i=`VLENB/2;i<`VLENB*3/4;i=i+1) begin
                  src2_data16[   i-`VLENB/2] = {8'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount16[i-`VLENB/2] = {1'b0,rs1_data[0             +: $clog2(`BYTE_WIDTH)]};
                end         
                for(int i=`VLENB*3/4;i<`VLENB;i=i+1) begin
                  src2_data32[   i-`VLENB*3/4] = {24'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount32[i-`VLENB*3/4] = {2'b0, rs1_data[0             +: $clog2(`BYTE_WIDTH)]};
                end
              end
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = rs1_data[0              +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, rs1_data[0              +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = rs1_data[0             +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase       
          end

          VSRA,
          VSSRA: begin
            case(vs2_eew)
              EEW8: begin
                for(int i=0;i<`VLENB/2;i=i+1) begin
                  src2_data8[i]    = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  shift_amount8[i] = rs1_data[0             +: $clog2(`BYTE_WIDTH)];
                end
                for(int i=`VLENB/2;i<`VLENB*3/4;i=i+1) begin
                  src2_data16[   i-`VLENB/2] = {{8{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount16[i-`VLENB/2] = {1'b0,rs1_data[0 +: $clog2(`BYTE_WIDTH)]};
                end         
                for(int i=`VLENB*3/4;i<`VLENB;i=i+1) begin
                  src2_data32[   i-`VLENB*3/4] = {{24{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  shift_amount32[i-`VLENB*3/4] = {2'b0,rs1_data[0 +: $clog2(`BYTE_WIDTH)]};
                end
              end
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = rs1_data[0              +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0,rs1_data[0 +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = rs1_data[0 +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase          
          end

          VNSRL,
          VNCLIPU: begin
            case(vs2_eew)
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = rs1_data[0              +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0, rs1_data[0              +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = rs1_data[0             +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase  
          end

          VNSRA,
          VNCLIP: begin
            case(vs2_eew)
              EEW16: begin
                for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
                  src2_data16[i]    = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  shift_amount16[i] = rs1_data[0              +: $clog2(`HWORD_WIDTH)];
                end
                for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
                  src2_data32[   i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  shift_amount32[i-`VLEN/`HWORD_WIDTH/2] = {1'b0,rs1_data[0 +: $clog2(`HWORD_WIDTH)]};
                end   
              end
              EEW32: begin
                for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
                  src2_data32[i]    = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  shift_amount32[i] = rs1_data[0 +: $clog2(`WORD_WIDTH)];
                end
              end
            endcase 
          end
        endcase
      end
    endcase
  end

  // get opcode for f_addsub
  always_comb begin
    // initial the data
    opcode = SHIFT_SLL;

    // prepare source data
    case(uop_funct3) 
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)    
          VSLL: begin
            opcode = SHIFT_SLL;
          end
          VSRL,
          VNSRL,
          VSSRL,
          VNCLIPU: begin
            opcode = SHIFT_SRL;
          end
          VSRA,
          VNSRA,
          VSSRA,
          VNCLIP: begin
            opcode = SHIFT_SRA;
          end
        endcase
      end
    endcase
  end

//    
// calculate the result
//
  // shift instructions
  generate
    for (j=0;j<`VLENB/2;j=j+1) begin: EXE_PROD8
      assign {product8_tmp[j], round_bits8_tmp[j]} = f_shift8(opcode, src2_data8[j], shift_amount8[j]);
    end
  endgenerate
  
  generate
    for (j=0;j<`VLEN/`HWORD_WIDTH/2;j=j+1) begin: EXE_PROD16
      assign {product16_tmp[j], round_bits16_tmp[j]} = f_shift16(opcode, src2_data16[j], shift_amount16[j]);
    end
  endgenerate 

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j=j+1) begin: EXE_PROD32
      assign {product32_tmp[j], round_bits32_tmp[j]} = f_shift32(opcode, src2_data32[j], shift_amount32[j]);
    end
  endgenerate 
  
  always_comb begin
    product8    = 'b0;
    round_bits8 = 'b0;

    for(int i=0;i<`VLENB/2;i=i+1) begin
      product8[i]    = product8_tmp[i];
      round_bits8[i] = round_bits8_tmp[i];
    end
    for(int i=`VLENB/2;i<`VLENB*3/4;i=i+1) begin
      product8[i]    = product16_tmp[   i-`VLENB/2][0           +: `BYTE_WIDTH];
      round_bits8[i] = round_bits16_tmp[i-`VLENB/2][`BYTE_WIDTH +: `BYTE_WIDTH];
    end         
    for(int i=`VLENB*3/4;i<`VLENB;i=i+1) begin
      product8[i]    = product32_tmp[   i-`VLENB*3/4][0             +: `BYTE_WIDTH];
      round_bits8[i] = round_bits32_tmp[i-`VLENB*3/4][3*`BYTE_WIDTH +: `BYTE_WIDTH];
    end
  end
 
  always_comb begin
    product16    = 'b0;
    round_bits16 = 'b0;

    for(int i=0;i<`VLEN/`HWORD_WIDTH/2;i=i+1) begin
      product16[i]    = product16_tmp[i];
      round_bits16[i] = round_bits16_tmp[i];
    end
    for(int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i=i+1) begin
      product16[i]    = product32_tmp[   i-`VLEN/`HWORD_WIDTH/2][0            +: `HWORD_WIDTH];
      round_bits16[i] = round_bits32_tmp[i-`VLEN/`HWORD_WIDTH/2][`HWORD_WIDTH +: `HWORD_WIDTH];
    end   
  end

  always_comb begin
    product32    = 'b0;
    round_bits32 = 'b0;

    for(int i=0;i<`VLEN/`WORD_WIDTH;i=i+1) begin
      product32[i]    = product32_tmp[i];
      round_bits32[i] = round_bits32_tmp[i];
    end
  end

  // round increment
  generate
    for (j=0;j<`VLENB;j++) begin: INCREMENT8
      always_comb begin
        round_increment8[j] = 'b0;
        
        case(vxrm)
          RNU: begin
            round_increment8[j] = round_bits8[j][`BYTE_WIDTH-1];
          end
          RNE: begin
            round_increment8[j] = round_bits8[j][`BYTE_WIDTH-1] & (
                                  (round_bits8[j][`BYTE_WIDTH-2:0]!='b0) |
                                  product8[j][0]);
          end
          RDN: begin
            round_increment8[j] = 'b0;
          end
          ROD: begin
            round_increment8[j] = (!product8[j][0]) & (round_bits8[j]!='b0);
          end
        endcase
      end
    end
  endgenerate

  generate
    for (j=0;j<`VLEN/`HWORD_WIDTH;j++) begin: INCREMENT16
      always_comb begin
        round_increment16[j] = 'b0;
        
        case(vxrm)
          RNU: begin
            round_increment16[j] = round_bits16[j][`HWORD_WIDTH-1];
          end
          RNE: begin
            round_increment16[j] = round_bits16[j][`HWORD_WIDTH-1] & (
                                  (round_bits16[j][`HWORD_WIDTH-2:0]!='b0) |
                                  product16[j][0]);
          end
          RDN: begin
            round_increment16[j] = 'b0;
          end
          ROD: begin
            round_increment16[j] = (!product16[j][0]) & (round_bits16[j]!='b0);
          end
        endcase
      end
    end
  endgenerate

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j++) begin: INCREMENT32
      always_comb begin
        round_increment32[j] = 'b0;
        
        case(vxrm)
          RNU: begin
            round_increment32[j] = round_bits32[j][`WORD_WIDTH-1];
          end
          RNE: begin
            round_increment32[j] = round_bits32[j][`WORD_WIDTH-1] & (
                                  (round_bits32[j][`WORD_WIDTH-2:0]!='b0) |
                                  product32[j][0]);
          end
          RDN: begin
            round_increment32[j] = 'b0;
          end
          ROD: begin
            round_increment32[j] = (!product32[j][0]) & (round_bits32[j]!='b0);
          end
        endcase
      end
    end
  endgenerate

  // rounding result
  generate
    for (j=0;j<`VLENB;j++) begin: ROUND8
      always_comb begin
        round8[j] = 'b0;

        if (opcode == SHIFT_SRL)
          round8[j] = f_half_add8({1'b0, product8[j]}, round_increment8[j]); 
        else if (opcode == SHIFT_SRA)
          round8[j] = f_half_add8({product8[j][`BYTE_WIDTH-1], product8[j]}, round_increment8[j]); 
      end
    end
  endgenerate

  generate
    for (j=0;j<`VLEN/`HWORD_WIDTH;j++) begin: ROUND16
      always_comb begin
        cout16[j]  = 'b0; 
        round16[j] = 'b0;

        if (opcode == SHIFT_SRL)
          {cout16[j], round16[j]} = f_half_add16({1'b0, product16[j]}, round_increment16[j]); 
        else if (opcode == SHIFT_SRA)
          {cout16[j], round16[j]} = f_half_add16({product16[j][`HWORD_WIDTH-1], product16[j]}, round_increment16[j]); 
      end
    end
  endgenerate

  generate
    for (j=0;j<`VLEN/`WORD_WIDTH;j++) begin: ROUND32
      always_comb begin
        cout32[j]  = 'b0; 
        round32[j] = 'b0;

        if (opcode == SHIFT_SRL)
          {cout32[j], round32[j]} = f_half_add32({1'b0, product32[j]}, round_increment32[j]); 
        else if (opcode == SHIFT_SRA)
          {cout32[j], round32[j]} = f_half_add32({product32[j][`WORD_WIDTH-1], product32[j]}, round_increment32[j]); 
      end
    end
  endgenerate

  // overflow check for vnclipu and vnclip 
  generate 
    for (j=0;j<`VLEN/`WORD_WIDTH/2;j++) begin: GET_OVERFLOW
      always_comb begin
        // initial
        upoverflow[   4*j +: 4] = 'b0;
        underoverflow[4*j +: 4] = 'b0;
        upoverflow[   4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
        underoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
          
        case(vs2_eew)
          EEW16: begin
            case(opcode)
              SHIFT_SRL: begin
              // unsigned overflow check for vnclipu
                if(uop_index[0]==1'b0) begin
                  upoverflow[4*j +: 4] = {
                    ({cout16[4*j+3], round16[4*j+3][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j+2], round16[4*j+2][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j+1], round16[4*j+1][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j  ], round16[4*j  ][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0)};

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                end
                else begin
                  upoverflow[4*j +: 4] = 'b0;

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    ({cout16[4*j+3], round16[4*j+3][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j+2], round16[4*j+2][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j+1], round16[4*j+1][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0),
                    ({cout16[4*j  ], round16[4*j  ][`BYTE_WIDTH +: `BYTE_WIDTH]}!='b0)};
                end
              end
              SHIFT_SRA: begin
              // signed overflow check for vnclip
                if(uop_index[0]==1'b0) begin
                  upoverflow[4*j +: 4] = {
                    (cout16[4*j+3]=='b0)&(round16[4*j+3][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j+2]=='b0)&(round16[4*j+2][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j+1]=='b0)&(round16[4*j+1][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j  ]=='b0)&(round16[4*j  ][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0)};

                  underoverflow[4*j +: 4] = {
                    (cout16[4*j+3]=='b1)&(round16[4*j+3][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j+2]=='b1)&(round16[4*j+2][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j+1]=='b1)&(round16[4*j+1][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j  ]=='b1)&(round16[4*j  ][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff)};

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                  underoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                end
                else begin
                  upoverflow[4*j +: 4] = 'b0;
                  underoverflow[4*j +: 4] = 'b0;

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    (cout16[4*j+3]=='b0)&(round16[4*j+3][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j+2]=='b0)&(round16[4*j+2][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j+1]=='b0)&(round16[4*j+1][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0),
                    (cout16[4*j  ]=='b0)&(round16[4*j  ][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='b0)};

                  underoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    (cout16[4*j+3]=='b1)&(round16[4*j+3][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j+2]=='b1)&(round16[4*j+2][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j+1]=='b1)&(round16[4*j+1][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff),
                    (cout16[4*j  ]=='b1)&(round16[4*j  ][`BYTE_WIDTH-1 +: `BYTE_WIDTH+1]!='h1ff)};
                end
              end
            endcase
          end
          EEW32: begin
            case(opcode)
              SHIFT_SRL: begin
              // unsigned overflow check for vnclipu
                if(uop_index[0]==1'b0) begin
                  upoverflow[4*j +: 4] = {
                    ({cout32[2*j+1], round32[2*j+1][`HWORD_WIDTH +: `HWORD_WIDTH]}!='b0),1'b0,
                    ({cout32[2*j  ], round32[2*j  ][`HWORD_WIDTH +: `HWORD_WIDTH]}!='b0),1'b0};

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                end
                else begin
                  upoverflow[4*j +: 4] = 'b0;

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    ({cout32[2*j+1], round32[2*j+1][`HWORD_WIDTH +: `HWORD_WIDTH]}!='b0),1'b0,
                    ({cout32[2*j  ], round32[2*j  ][`HWORD_WIDTH +: `HWORD_WIDTH]}!='b0),1'b0};
                end
              end
              SHIFT_SRA: begin
              // signed overflow check for vnclip
                if(uop_index[0]==1'b0) begin
                  upoverflow[4*j +: 4] = {
                    (cout32[2*j+1]=='b0)&(round32[2*j+1][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='b0),1'b0,
                    (cout32[2*j  ]=='b0)&(round32[2*j  ][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='b0),1'b0};

                  underoverflow[4*j +: 4] = {
                    (cout32[2*j+1]=='b1)&(round32[2*j+1][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='h1ffff),1'b0,
                    (cout32[2*j  ]=='b1)&(round32[2*j  ][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='h1ffff),1'b0};

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                  underoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = 'b0;
                end
                else begin
                  upoverflow[4*j +: 4] = 'b0;
                  underoverflow[4*j +: 4] = 'b0;

                  upoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    (cout32[2*j+1]=='b0)&(round32[2*j+1][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='b0),1'b0,
                    (cout32[2*j  ]=='b0)&(round32[2*j  ][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='b0),1'b0};

                  underoverflow[4*(j+`VLEN/`WORD_WIDTH/2) +: 4] = {
                    (cout32[2*j+1]=='b1)&(round32[2*j+1][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='h1ffff),1'b0,
                    (cout32[2*j  ]=='b1)&(round32[2*j  ][`HWORD_WIDTH-1 +: `HWORD_WIDTH+1]!='h1ffff),1'b0};
                end
              end
            endcase
          end
        endcase
      end
    end
  endgenerate

  // assign to result_data
  always_comb begin
    // initial the data
    result_data = 'b0;
 
    for(int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
      // calculate result data
      case(uop_funct3) 
        OPIVV,
        OPIVX,
        OPIVI: begin
          case(uop_funct6.ari_funct6)
            VSLL,
            VSRL,
            VSRA: begin
              case(vs2_eew)
                EEW8: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {product8[4*i+3],product8[4*i+2],product8[4*i+1],product8[4*i]};
                end
                EEW16: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {product16[2*i+1],product16[2*i]};
                end
                EEW32: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = product32[i];
                end
              endcase
            end
  
            VNSRL,
            VNSRA: begin
              case(vs2_eew)
                EEW16: begin
                  if (uop_index[0]==1'b0)
                    result_data[i*`HWORD_WIDTH         +: `HWORD_WIDTH] = {product16[2*i+1][`BYTE_WIDTH-1:0],product16[2*i][`BYTE_WIDTH-1:0]};
                  else
                    result_data[`VLEN/2+i*`HWORD_WIDTH +: `HWORD_WIDTH] = {product16[2*i+1][`BYTE_WIDTH-1:0],product16[2*i][`BYTE_WIDTH-1:0]};
                end
                EEW32: begin
                  if (uop_index[0]==1'b0)
                    result_data[i*`HWORD_WIDTH         +: `HWORD_WIDTH] = product32[i][`HWORD_WIDTH-1:0];
                  else
                    result_data[`VLEN/2+i*`HWORD_WIDTH +: `HWORD_WIDTH] = product32[i][`HWORD_WIDTH-1:0];
                end
              endcase
            end

            VSSRL,
            VSSRA: begin
              case(vs2_eew)
                EEW8: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {round8[4*i+3],round8[4*i+2],round8[4*i+1],round8[4*i]};
                end
                EEW16: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = {round16[2*i+1],round16[2*i]};
                end
                EEW32: begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = round32[i];
                end
              endcase
            end

            VNCLIPU: begin
              case(vs2_eew)
                EEW16: begin
                  if (i<`VLEN/`WORD_WIDTH/2) begin
                    if (upoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+1][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+2][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+3][`BYTE_WIDTH-1 : 0];
                  end
                  else begin
                    if (upoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+1][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+2][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'hff;
                    else
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+3][`BYTE_WIDTH-1 : 0];
                  end
                end
                EEW32: begin
                  if (i<`VLEN/`WORD_WIDTH/2) begin
                    if (upoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*i][`HWORD_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*i+1][`HWORD_WIDTH-1 : 0];
                  end
                  else begin
                    if (upoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*(i-`VLEN/`WORD_WIDTH/2)][`HWORD_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'hffff;
                    else
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*(i-`VLEN/`WORD_WIDTH/2)+1][`HWORD_WIDTH-1 : 0];
                  end
                end
              endcase
            end

            VNCLIP: begin
              case(vs2_eew)
                EEW16: begin
                  if (i<`VLEN/`WORD_WIDTH/2) begin
                    if (upoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+1][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+2][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*i+3][`BYTE_WIDTH-1 : 0];
                  end
                  else begin
                    if (upoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i])
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+1])
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+1)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+1][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+2])
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+2)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+2][`BYTE_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h7f;
                    else if (underoverflow[4*i+3])
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = 'h80;
                    else
                      result_data[(4*i+3)*`BYTE_WIDTH +: `BYTE_WIDTH] = round16[4*(i-`VLEN/`WORD_WIDTH/2)+3][`BYTE_WIDTH-1 : 0];
                  end
                end
                EEW32: begin
                  if (i<`VLEN/`WORD_WIDTH/2) begin
                    if (upoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (underoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*i][`HWORD_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (underoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*i+1][`HWORD_WIDTH-1 : 0];
                  end
                  else begin
                    if (upoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (underoverflow[4*i+1])
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[(2*i)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*(i-`VLEN/`WORD_WIDTH/2)][`HWORD_WIDTH-1 : 0];

                    if (upoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h7fff;
                    else if (underoverflow[4*i+3])
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = 'h8000;
                    else
                      result_data[(2*i+1)*`HWORD_WIDTH +: `HWORD_WIDTH] = round32[2*(i-`VLEN/`WORD_WIDTH/2)+1][`HWORD_WIDTH-1 : 0];
                  end
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

//
// submit result to ROB
//
  // saturate signal
  always_comb begin
    // initial
    `ifdef TB_SUPPORT
    result.uop_pc    = alu_uop.uop_pc;
    `endif
    result.rob_entry = rob_entry;
    result.w_data    = result_data;
    result.w_valid   = result_valid;
    result.vsaturate = 'b0;

    case(uop_funct3) 
      OPIVV,
      OPIVX,
      OPIVI: begin
        case(uop_funct6.ari_funct6)
          VNCLIPU: begin
            result.vsaturate = upoverflow;
          end
          VNCLIP: begin
            result.vsaturate = underoverflow|upoverflow;
          end
        endcase
      end
    endcase
  end

//
// function unit
//
  // shifter function
  function [2*`BYTE_WIDTH-1:0] f_shift8;
    input SHIFT_e                         opcode;
    input logic [`BYTE_WIDTH-1:0]         operand;
    input logic [$clog2(`BYTE_WIDTH)-1:0] amount;

    logic signed [`BYTE_WIDTH:0]   src;
    logic signed [`BYTE_WIDTH:0]   res;
    logic signed [`BYTE_WIDTH-1:0] round;

    if ((opcode==SHIFT_SLL)||(opcode==SHIFT_SRL))
      src = {1'b0,operand};
    else 
      src = {operand[`BYTE_WIDTH-1],operand};   // (opcode==SHIFT_SRA)

    if (opcode==SHIFT_SLL) begin
      res = src<<amount;
      round  = 'b0;
    end
    else begin
      // ((opcode==SHIFT_SRL)||(opcode==SHIFT_SRA))
      res = src>>>amount;    
      round  = operand<<(`BYTE_WIDTH-amount); 
    end

    return {res[`BYTE_WIDTH-1:0],round};
  endfunction

  function [2*`HWORD_WIDTH-1:0] f_shift16;
    input SHIFT_e                          opcode;
    input logic [`HWORD_WIDTH-1:0]         operand;
    input logic [$clog2(`HWORD_WIDTH)-1:0] amount;

    logic signed [`HWORD_WIDTH:0]   src;
    logic signed [`HWORD_WIDTH:0]   res;
    logic signed [`HWORD_WIDTH-1:0] round;

    if ((opcode==SHIFT_SLL)||(opcode==SHIFT_SRL))
      src = {1'b0,operand};
    else 
      src = {operand[`HWORD_WIDTH-1],operand};   // (opcode==SHIFT_SRA)

    if (opcode==SHIFT_SLL) begin
      res = src<<amount;
      round  = 'b0;
    end
    else begin
      // ((opcode==SHIFT_SRL)||(opcode==SHIFT_SRA))
      res = src>>>amount;    
      round  = operand<<(`HWORD_WIDTH-amount); 
    end

    return {res[`HWORD_WIDTH-1:0],round};

  endfunction

  function [2*`WORD_WIDTH-1:0] f_shift32;
    input SHIFT_e                         opcode;
    input logic [`WORD_WIDTH-1:0]         operand;
    input logic [$clog2(`WORD_WIDTH)-1:0] amount;

    logic signed [`WORD_WIDTH:0]   src;
    logic signed [`WORD_WIDTH:0]   res;
    logic signed [`WORD_WIDTH-1:0] round;

    if ((opcode==SHIFT_SLL)||(opcode==SHIFT_SRL))
      src = {1'b0,operand};
    else 
      src = {operand[`WORD_WIDTH-1],operand};   // (opcode==SHIFT_SRA)

    if (opcode==SHIFT_SLL) begin
      res = src<<amount;
      round  = 'b0;
    end
    else begin
      // ((opcode==SHIFT_SRL)||(opcode==SHIFT_SRA))
      res = src>>>amount;    
      round  = operand<<(`WORD_WIDTH-amount); 
    end

    return {res[`WORD_WIDTH-1:0],round};

  endfunction

  function [`BYTE_WIDTH-1:0] f_half_add8;
    // x + cin
    input logic [`BYTE_WIDTH:0] src_x;
    input logic                 cin;
    
    logic [`BYTE_WIDTH:0] result;

    result = cin ? src_x + 1'b1 : src_x;

    f_half_add8 = result[`BYTE_WIDTH-1:0];
  endfunction

  function [`HWORD_WIDTH:0] f_half_add16;
    // x + cin
    input logic [`HWORD_WIDTH:0] src_x;
    input logic                  cin;

    f_half_add16 = cin ? src_x + 1'b1 : src_x;
  endfunction

  function [`WORD_WIDTH:0] f_half_add32;
    // x + cin
    input logic [`WORD_WIDTH:0] src_x;
    input logic                 cin;

    f_half_add32 = cin ? src_x + 1'b1 : src_x;
  endfunction

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_alu_unit
(
  clk,
  rst_n,
  alu_uop_valid,
  alu_uop,
  pop_rs,
  result_valid,
  result,
  result_ready,
  trap_flush_rvv
);
//
// interface signals
//
  // global signal
  input   logic           clk;
  input   logic           rst_n;

  // ALU RS handshake signals
  input   logic           alu_uop_valid;
  input   ALU_RS_t        alu_uop;
  output  logic           pop_rs;

  // ALU send result signals to ROB
  output  logic           result_valid;
  output  PU2ROB_t        result;
  input   logic           result_ready;

  // trap-flush
  input   logic           trap_flush_rvv;

//
// internal signals
//   
  logic                   result_valid_addsub_p0;
  PU2ROB_t                result_addsub_p0;
  logic                   result_valid_shift_p0;
  PU2ROB_t                result_shift_p0;
  logic                   result_valid_mask_p0;
  PIPE_DATA_t             result_mask_p0;
  logic                   result_mask_2cycle;
  logic                   result_valid_other_p0;
  PU2ROB_t                result_other_p0;
  PU2ROB_t                result_p1;
  // pipeline
  logic                   result_valid_p1_en;
  logic                   result_valid_p1_in;
  logic                   result_valid_p1;
  logic                   alu_uop_p1_en;
  PIPE_DATA_t             alu_uop_p1_in;
  PIPE_DATA_t             alu_uop_p1;

//
// instance
//
  rvv_backend_alu_unit_addsub u_alu_addsub
  (
    .alu_uop_valid        (alu_uop_valid),
    .alu_uop              (alu_uop),
    .result_valid         (result_valid_addsub_p0),
    .result               (result_addsub_p0)
  );

  rvv_backend_alu_unit_shift u_alu_shift
  (
    .alu_uop_valid        (alu_uop_valid),
    .alu_uop              (alu_uop),
    .result_valid         (result_valid_shift_p0),
    .result               (result_shift_p0)
  );
  
  rvv_backend_alu_unit_mask u_alu_mask_p0
  ( 
    .alu_uop_valid        (alu_uop_valid),
    .alu_uop              (alu_uop),
    .result_valid         (result_valid_mask_p0),
    .result               (result_mask_p0),
    .result_2cycle        (result_mask_2cycle)
  );

  rvv_backend_alu_unit_other u_alu_other
  (
    .alu_uop_valid        (alu_uop_valid),
    .alu_uop              (alu_uop),
    .result_valid         (result_valid_other_p0),
    .result               (result_other_p0)
  );

// pipeline
  // result_valid_p1
  always_comb begin
    case({result_valid_p1,(result_valid_addsub_p0|result_valid_shift_p0|result_valid_mask_p0|result_valid_other_p0)})
      2'b01: begin
        result_valid_p1_en = result_mask_2cycle;
        result_valid_p1_in = 1'b1;
      end
      2'b10: begin
        result_valid_p1_en = result_ready;
        result_valid_p1_in = 1'b0;
      end
      2'b11: begin
        result_valid_p1_en = 1'b0;
        result_valid_p1_in = 1'b0;
      end
      default: begin
        result_valid_p1_en = 1'b1;
        result_valid_p1_in = 1'b0;
      end
    endcase
  end
  
  cdffr
  result_valid_p1_cdffr
  ( 
    .clk        (clk),
    .rst_n      (rst_n),
    .c          (trap_flush_rvv),
    .e          (result_valid_p1_en),
    .d          (result_valid_p1_in),
    .q          (result_valid_p1)
  ); 
  
  // alu_uop_p1
  always_comb begin
    case({result_valid_p1,(result_valid_addsub_p0|result_valid_shift_p0|result_valid_mask_p0|result_valid_other_p0)})
      2'b01: begin
        alu_uop_p1_en = result_mask_2cycle;
      end
      2'b11: begin
        alu_uop_p1_en = result_ready;        
      end
      default: begin
        alu_uop_p1_en = 1'b0;
      end
    endcase
  end

  always_comb begin
  `ifdef TB_SUPPORT 
    alu_uop_p1_in.uop_pc         = 'b0;
  `endif
    alu_uop_p1_in.rob_entry      = 'b0;
    alu_uop_p1_in.vd_eew         = EEW_NONE;
    alu_uop_p1_in.uop_index      = 'b0;
    alu_uop_p1_in.alu_sub_opcode = OP_OTHER;
    alu_uop_p1_in.result_data    = 'b0;
    alu_uop_p1_in.data_viota_per64 = 'b0;
    alu_uop_p1_in.vsaturate      = 'b0;

    case(1'b1)
      result_valid_addsub_p0: begin 
      `ifdef TB_SUPPORT 
        alu_uop_p1_in.uop_pc      = result_addsub_p0.uop_pc;
      `endif
        alu_uop_p1_in.rob_entry   = result_addsub_p0.rob_entry;
        alu_uop_p1_in.result_data = result_addsub_p0.w_data;
        alu_uop_p1_in.vsaturate   = result_addsub_p0.vsaturate;
      end
      result_valid_shift_p0: begin
      `ifdef TB_SUPPORT 
        alu_uop_p1_in.uop_pc      = result_shift_p0.uop_pc;
      `endif
        alu_uop_p1_in.rob_entry   = result_shift_p0.rob_entry;
        alu_uop_p1_in.result_data = result_shift_p0.w_data;
        alu_uop_p1_in.vsaturate   = result_shift_p0.vsaturate;
      end
      result_valid_other_p0: begin
      `ifdef TB_SUPPORT 
        alu_uop_p1_in.uop_pc      = result_other_p0.uop_pc;
      `endif
        alu_uop_p1_in.rob_entry   = result_other_p0.rob_entry;
        alu_uop_p1_in.result_data = result_other_p0.w_data;
        alu_uop_p1_in.vsaturate   = result_other_p0.vsaturate;
      end
      result_valid_mask_p0: begin
        alu_uop_p1_in             = result_mask_p0;
      end
    endcase
  end

  edff
  #(
    .T      (PIPE_DATA_t)
  )
  alu_uop_d1
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (alu_uop_p1_en), 
    .d      (alu_uop_p1_in),
    .q      (alu_uop_p1)
  );

  rvv_backend_alu_unit_execution_p1 u_alu_p1
  ( 
    .alu_uop_valid        (result_valid_p1),
    .alu_uop              (alu_uop_p1),
    .result               (result_p1)
  );

// 
// submit to ROB
// 
  always_comb begin
    result_valid = 'b0;
    result       = 'b0;
    pop_rs       = 'b0;

    case({result_valid_p1,(result_valid_addsub_p0|result_valid_shift_p0|result_valid_mask_p0|result_valid_other_p0)})
      2'b01: begin
        case(1'b1)
          result_valid_addsub_p0: begin
            result_valid = 1'b1;
            result       = result_addsub_p0;
            pop_rs       = 1'b1;
          end
          result_valid_shift_p0: begin
            result_valid = 1'b1;
            result       = result_shift_p0;
            pop_rs       = 1'b1;
          end
          result_valid_other_p0: begin
            result_valid = 1'b1;
            result       = result_other_p0;
            pop_rs       = 1'b1;
          end
          result_valid_mask_p0: begin
            result_valid      = !result_mask_2cycle;
`ifdef TB_SUPPORT
            result.uop_pc     = result_mask_p0.uop_pc;
`endif
            result.rob_entry  = result_mask_p0.rob_entry;
            result.w_data     = result_mask_p0.result_data;
            result.w_valid    = 1'b1;
            result.vsaturate  = 'b0;
            pop_rs            = 1'b1;
          end
        endcase
      end
      2'b10: begin
        result_valid = 1'b1;
        result       = result_p1;
        pop_rs       = 1'b0;
      end
      2'b11: begin
        result_valid = 1'b1;
        result       = result_p1;
        pop_rs       = result_ready;
      end
    endcase
  end

endmodule
// ----- 8< ----- FILE "./rvv_backend_alu.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description: 
// 1. Instantiate rvv_backend_alu_unit and connect to ALU Reservation Station and ROB.
//
// feature list:
// 1. The number of ALU units (`NUM_ALU) is configurable.
// 2. The size of vector length (`VLEN) is configurable.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_alu
(
  clk,
  rst_n,
  pop_ex2rs,
  alu_uop_rs2ex,
  fifo_empty_rs2ex,
  fifo_almost_empty_rs2ex,
  result_valid_ex2rob,
  result_ex2rob,
  result_ready_rob2alu,
  trap_flush_rvv
);

//
// interface signals
//
  // global signal
  input   logic                         clk;
  input   logic                         rst_n;

  // ALU RS to ALU unit
  output  logic       [`NUM_ALU-1:0]    pop_ex2rs;
  input   ALU_RS_t    [`NUM_ALU-1:0]    alu_uop_rs2ex;
  input   logic                         fifo_empty_rs2ex;
  input   logic       [`NUM_ALU-1:0]    fifo_almost_empty_rs2ex;

  // submit ALU result to ROB
  output  logic       [`NUM_ALU-1:0]    result_valid_ex2rob;
  output  PU2ROB_t    [`NUM_ALU-1:0]    result_ex2rob;
  input   logic       [`NUM_ALU-1:0]    result_ready_rob2alu;

  // trap-flush
  input   logic                         trap_flush_rvv;

//
// internal signals
//
  // ALU RS to ALU unit
  logic               [`NUM_ALU-1:0]    alu_uop_valid_rs2ex;    
  logic               [`NUM_ALU-1:0]    pop_valid;
  logic               [`NUM_ALU-1:0]    result_valid_ex;
  
  // for-loop
  genvar                                i;

//
// Instantiate 2 rvv_backend_alu_unit
//
  // generate valid signals
  assign alu_uop_valid_rs2ex[0] = !fifo_empty_rs2ex;

  generate 
    for (i=1;i<`NUM_ALU;i=i+1) begin: GET_UOP_VALID
      assign  alu_uop_valid_rs2ex[i] = !fifo_almost_empty_rs2ex[i];
    end
  endgenerate

  // instantiate
  generate
    for (i=0;i<`NUM_ALU;i=i+1) begin: ALU_UNIT
      rvv_backend_alu_unit u_alu_unit
        (
          // inputs
          .clk            (clk),
          .rst_n          (rst_n),
          .alu_uop_valid  (alu_uop_valid_rs2ex[i]),
          .alu_uop        (alu_uop_rs2ex[i]),
          .result_ready   (result_ready_rob2alu[i]),
          // outputs
          .pop_rs         (pop_valid[i]),
          .result_valid   (result_valid_ex[i]),
          .result         (result_ex2rob[i]),
          // trap-flush
          .trap_flush_rvv (trap_flush_rvv)
        );
    end
  endgenerate

  // generate pop signals
  assign pop_ex2rs[0] = pop_valid[0]&result_ready_rob2alu[0];
  
  generate
    for (i=1;i<`NUM_ALU;i=i+1) begin: POP_ALU_RS
      assign pop_ex2rs[i] = pop_valid[i]&result_ready_rob2alu[i]&(&pop_valid[i-1:0]);
    end
  endgenerate

  assign result_valid_ex2rob = result_valid_ex;

endmodule
// ----- 8< ----- FILE "./rvv_backend_decode_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
//
// description:
// 1. It sends instruction package to arithmetic decode unit or lsu decode unit based on instruction opcode.
//
// feature list:
// 1. One instruction can be decoded to 8 uops at most.
// 2. Decoder will push 4 uops at most into Uops Queue, so decoder only decode to 4 uops at most per cycle.
// 3. uops_de2dp.rs1_data could be from X[rs1] and imm(inst[19:15]).
// 4. If the instruction is in wrong encoding, it will be discarded directly without applying a trap, but take assertion in simulation.
// 5. The vstart of the instruction will be calculated to a new value for every decoded uops.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_decode_unit
(
  inst_valid_cq2de,
  inst_cq2de,
  uop_index_remain,
  uop_valid_de2uq,
  uop_de2uq
);
//
// interface signals
//
  // CQ to Decoder unit signals
  input   logic                         inst_valid_cq2de;
  input   RVVCmd                        inst_cq2de;
  input   logic [`UOP_INDEX_WIDTH-1:0]  uop_index_remain;
  
  // Decoder unit to Uops Queue signals
  output  logic       [`NUM_DE_UOP-1:0] uop_valid_de2uq;
  output  UOP_QUEUE_t [`NUM_DE_UOP-1:0] uop_de2uq;

//
// internal signals
//
  RVVOpCode                             inst_opcode;     // inst original encoding[6:0]
  logic                                 valid_ari;
  logic                                 valid_lsu;

  // decoded arithmetic uops
  logic       [`NUM_DE_UOP-1:0]         uop_valid_ari;
  UOP_QUEUE_t [`NUM_DE_UOP-1:0]         uop_ari;

  // decoded LSU uops
  logic       [`NUM_DE_UOP-1:0]         uop_valid_lsu;
  UOP_QUEUE_t [`NUM_DE_UOP-1:0]         uop_lsu;

//
// decode
//
  assign inst_opcode  = inst_cq2de.opcode;
 
  // decode opcode
  assign valid_lsu    = (inst_valid_cq2de==1'b1) & ((inst_opcode==LOAD) | (inst_opcode==STORE));
  
  assign valid_ari    = (inst_valid_cq2de==1'b1) & (inst_opcode==RVV);
  
  // decode LSU instruction 
  rvv_backend_decode_unit_lsu u_lsu_decode
  (
    .inst_valid        (valid_lsu),
    .inst              (inst_cq2de),
    .uop_index_remain  (uop_index_remain),
    .uop_valid         (uop_valid_lsu),
    .uop               (uop_lsu)
  );

  // decode arithmetic instruction
  rvv_backend_decode_unit_ari u_ari_decode
  (
    .inst_valid        (valid_ari),
    .inst              (inst_cq2de),
    .uop_index_remain  (uop_index_remain),
    .uop_valid         (uop_valid_ari),
    .uop               (uop_ari)
  );

  // output
  always_comb begin 
    uop_valid_de2uq     = 'b0;
    uop_de2uq           = 'b0;
    
    case(1'b1)
      valid_lsu: begin
        uop_valid_de2uq = uop_valid_lsu;
        uop_de2uq       = uop_lsu;
      end
  
      valid_ari: begin
        uop_valid_de2uq = uop_valid_ari;
        uop_de2uq       = uop_ari;
      end
    endcase
  end

endmodule
// ----- 8< ----- FILE "./rvv_backend_decode_unit_ari.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_decode_unit_ari
(
  inst_valid,
  inst,
  uop_index_remain,
  uop_valid,
  uop
);
//
// interface signals
//
  input   logic                                     inst_valid;
  input   RVVCmd                                    inst;
  input   logic       [`UOP_INDEX_WIDTH-1:0]        uop_index_remain;
  
  output  logic       [`NUM_DE_UOP-1:0]             uop_valid;
  output  UOP_QUEUE_t [`NUM_DE_UOP-1:0]             uop;

//
// internal signals
//
  // split INST_t struct signals
  logic   [`FUNCT6_WIDTH-1:0]                       inst_funct6;      // inst original encoding[31:26]           
  logic   [`VM_WIDTH-1:0]                           inst_vm;          // inst original encoding[25]      
  logic   [`REGFILE_INDEX_WIDTH-1:0]                inst_vs2;         // inst original encoding[24:20]
  logic   [`REGFILE_INDEX_WIDTH-1:0]                inst_vs1;         // inst original encoding[19:15]
  logic   [`IMM_WIDTH-1:0]                          inst_imm;         // inst original encoding[19:15]
  logic   [`FUNCT3_WIDTH-1:0]                       inst_funct3;      // inst original encoding[14:12]
  logic   [`REGFILE_INDEX_WIDTH-1:0]                inst_vd;          // inst original encoding[11:7]
  logic   [`REGFILE_INDEX_WIDTH-1:0]                inst_rd;          // inst original encoding[11:7]
  logic   [`NREG_WIDTH-1:0]                         inst_nr;          // inst original encoding[17:15]
  
  // use vs1 as opcode
  logic   [`REGFILE_INDEX_WIDTH-1:0]                vs1_opcode;
  logic   [`REGFILE_INDEX_WIDTH-1:0]                vs2_opcode;
   
  RVVConfigState                                    vector_csr_ari;
  logic   [`VSTART_WIDTH-1:0]                       csr_vstart;
  logic   [`VL_WIDTH-1:0]                           csr_vl;
  logic   [`VL_WIDTH-1:0]                           evl;
  RVVSEW                                            csr_sew;
  RVVLMUL                                           csr_lmul;
  logic   [`XLEN-1:0] 	                            rs1;
  EMUL_e                                            emul_vd;          
  EMUL_e                                            emul_vs2;          
  EMUL_e                                            emul_vs1;          
  logic   [`UOP_INDEX_WIDTH_ALU:0]                  emul_max;
  EEW_e                                             eew_vd;          
  EEW_e                                             eew_vs2;          
  EEW_e                                             eew_vs1;
  EEW_e                                             eew_max;          
  logic                                             valid_opi;
  logic                                             valid_opm;
  logic                                             inst_encoding_correct;
  logic                                             check_special;
  logic                                             check_vd_overlap_v0;
  logic                                             check_vd_part_overlap_vs2;
  logic                                             check_vd_part_overlap_vs1;
  logic                                             check_vd_overlap_vs2;
  logic                                             check_vd_overlap_vs1;
  logic                                             check_vs2_part_overlap_vd_2_1;
  logic                                             check_vs1_part_overlap_vd_2_1;
  logic                                             check_vs2_part_overlap_vd_4_1;
  logic                                             check_common;
  logic                                             check_vd_align;
  logic                                             check_vs2_align;
  logic                                             check_vs1_align;
  logic                                             check_sew;
  logic                                             check_lmul;
  logic                                             check_evl_not_0;
  logic                                             check_vstart_sle_evl;
  logic   [`UOP_INDEX_WIDTH-1:0]                    uop_vstart;         
  logic   [`UOP_INDEX_WIDTH-1:0]                    uop_index_base;         
  logic   [`NUM_DE_UOP-1:0][`UOP_INDEX_WIDTH:0]     uop_index_current;   
  logic   [`UOP_INDEX_WIDTH-1:0]                    uop_index_max;         
  
  // enum/union
  FUNCT6_u                                          funct6_ari;

  // result
`ifdef TB_SUPPORT
  logic   [`NUM_DE_UOP-1:0][`PC_WIDTH-1:0]            uop_pc;
`endif
  logic   [`NUM_DE_UOP-1:0][`FUNCT3_WIDTH-1:0]        uop_funct3;
  FUNCT6_u        [`NUM_DE_UOP-1:0]                   uop_funct6;
  EXE_UNIT_e      [`NUM_DE_UOP-1:0]                   uop_exe_unit; 
  UOP_CLASS_e     [`NUM_DE_UOP-1:0]                   uop_class;   
  RVVConfigState  [`NUM_DE_UOP-1:0]                   vector_csr;  
  logic   [`NUM_DE_UOP-1:0][`VL_WIDTH-1:0]            vs_evl;             
  logic   [`NUM_DE_UOP-1:0]                           ignore_vma;
  logic   [`NUM_DE_UOP-1:0]                           ignore_vta;
  logic   [`NUM_DE_UOP-1:0]                           force_vma_agnostic; 
  logic   [`NUM_DE_UOP-1:0]                           force_vta_agnostic; 
  logic   [`NUM_DE_UOP-1:0]                           vm;                 
  logic   [`NUM_DE_UOP-1:0]                           v0_valid;           
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vd_index;           
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    vd_offset;
  EEW_e   [`NUM_DE_UOP-1:0]                           vd_eew;  
  logic   [`NUM_DE_UOP-1:0]                           vd_valid;
  logic   [`NUM_DE_UOP-1:0]                           vs3_valid;          
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vs1;              
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    vs1_offset;
  EEW_e   [`NUM_DE_UOP-1:0]                           vs1_eew;            
  logic   [`NUM_DE_UOP-1:0]                           vs1_index_valid;
  logic   [`NUM_DE_UOP-1:0]                           vs1_opcode_valid;
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vs2_index; 	        
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    vs2_offset;
  EEW_e   [`NUM_DE_UOP-1:0]                           vs2_eew;
  logic   [`NUM_DE_UOP-1:0]                           vs2_valid;
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_index; 	        
  logic   [`NUM_DE_UOP-1:0]                           rd_index_valid; 
  logic   [`NUM_DE_UOP-1:0][`XLEN-1:0] 	              rs1_data;           
  logic   [`NUM_DE_UOP-1:0]     	                    rs1_data_valid;     
  logic   [`NUM_DE_UOP-1:0][`UOP_INDEX_WIDTH-1:0]     uop_index;          
  logic   [`NUM_DE_UOP-1:0]                           first_uop_valid;    
  logic   [`NUM_DE_UOP-1:0]                           last_uop_valid;     
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    seg_field_index;
  logic   [`NUM_DE_UOP-1:0]                           pshrob_valid;     

  // use for for-loop 
  genvar                                              j;

//
// decode
//
  assign inst_funct6    = inst.bits[24:19];
  assign inst_vm        = inst.bits[18];
  assign inst_vs2       = inst.bits[17:13];
  assign vs2_opcode     = inst.bits[17:13];
  assign inst_vs1       = inst.bits[12:8];
  assign vs1_opcode     = inst.bits[12:8];
  assign inst_imm       = inst.bits[12:8];
  assign inst_funct3    = inst.bits[7:5];
  assign inst_vd        = inst.bits[4:0];
  assign inst_rd        = inst.bits[4:0];
  assign inst_nr        = inst_vs1[`NREG_WIDTH-1:0];
  assign vector_csr_ari = inst.arch_state;
  assign csr_vstart     = inst.arch_state.vstart;
  assign csr_vl         = inst.arch_state.vl;
  assign csr_sew        = inst.arch_state.sew;
  assign csr_lmul       = inst.arch_state.lmul;
  assign rs1            = inst.rs1;

  // decode arithmetic instruction funct6
  assign funct6_ari.ari_funct6 = inst_valid ? inst_funct6 : 'b0;

  always_comb begin
    // initial the data
    valid_opi = 'b0;
    valid_opm = 'b0;
    
    case(inst_funct3)
      OPIVV,
      OPIVX,
      OPIVI: begin
        valid_opi = inst_valid;
      end
      OPMVV,
      OPMVX: begin
        valid_opm = inst_valid;
      end
    endcase
  end 

  // get EMUL
  always_comb begin
    // initial
    emul_vd  = EMUL_NONE;
    emul_vs2 = EMUL_NONE;
    emul_vs1 = EMUL_NONE;
    
    case(inst_funct3)
      OPIVV: begin
        // OPI* instruction
        case(inst_funct6)
          VADD,
          VADC,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VRGATHER,
          VSUB,
          VSBC,
          VMINU,
          VMIN,
          VMAXU,
          VMAX,
          VSSUBU,
          VSSUB,
          VSMUL_VMVNRR: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL8;
              end
            endcase
          end

          // destination vector register is mask register
          VMADC,
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL8;
              end
            endcase
          end

          VMSBC,
          VMSLTU,
          VMSLT: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL2;
              end              
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL4;
              end              
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL8;
              end              
            endcase
          end

          // narrowing instructions
          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP:begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL4;
              end
            endcase 
          end
          
          VMERGE_VMV: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL2;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL4;
                emul_vs1    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL8;
                emul_vs1    = EMUL8;
              end
            endcase
          end
          
          // widening instructions
          VWREDSUMU,
          VWREDSUM: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL1;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL1;
              end
            endcase
          end

          VSLIDEUP_RGATHEREI16: begin        
            // VRGATHEREI16
            case(csr_lmul)
              LMUL1_4: begin
                case(csr_sew)
                  SEW8,
                  SEW16: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                    emul_vs1    = EMUL1;
                  end
                endcase
              end
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL1: begin
                case(csr_sew)
                  SEW8: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                    emul_vs1    = EMUL2;
                  end
                  SEW16,
                  SEW32: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                    emul_vs1    = EMUL1;
                  end
                endcase
              end
              LMUL2: begin                  
                case(csr_sew)
                  SEW8: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL2;
                    emul_vs1    = EMUL4;
                  end
                  SEW16: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL2;
                    emul_vs1    = EMUL2;
                  end
                  SEW32: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL2;
                    emul_vs1    = EMUL1;
                  end
                endcase
              end
              LMUL4: begin
                case(csr_sew)
                  SEW8: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL4;
                    emul_vs1    = EMUL8;
                  end
                  SEW16: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL4;
                    emul_vs1    = EMUL4;
                  end
                  SEW32: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL4;
                    emul_vs1    = EMUL2;
                  end
                endcase
              end
              LMUL8: begin
                case(csr_sew)
                  SEW16: begin
                    emul_vd     = EMUL8;
                    emul_vs2    = EMUL8;
                    emul_vs1    = EMUL8;
                  end
                  SEW32: begin
                    emul_vd     = EMUL8;
                    emul_vs2    = EMUL8;
                    emul_vs1    = EMUL4;
                  end
                endcase
              end
            endcase
          end
        endcase
      end
      
      OPIVX: begin
        // OPI* instruction
        case(inst_funct6)
          VADD,
          VADC,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VRGATHER,
          VSUB,
          VSBC,
          VMINU,
          VMIN,
          VMAXU,
          VMAX,
          VSSUBU,
          VSSUB,
          VRSUB,
          VSLIDEDOWN,
          VSMUL_VMVNRR,
          VSLIDEUP_RGATHEREI16: begin        
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          // destination vector register is mask register
          VMADC,
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          VMSBC,
          VMSLTU,
          VMSLT: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          // narrowing instructions
          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP:begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL4;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL8;
              end
            endcase
          end
          
          VMSGTU,
          VMSGT: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          VMERGE_VMV: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL8;
              end
            endcase
          end
        endcase
      end
      
      OPIVI: begin
        // OPI* instruction
        case(inst_funct6)
          VADD,
          VADC,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VRGATHER,
          VRSUB,
          VSLIDEDOWN,
          VSLIDEUP_RGATHEREI16: begin        
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          // destination vector register is mask register
          VMADC,
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE,
          VMSGTU,
          VMSGT: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          // narrowing instructions
          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP:begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL4;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL8;
              end
            endcase
          end
          
          VMERGE_VMV: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                if (inst_vm=='b0)
                  emul_vs2  = EMUL8;
              end
            endcase
          end

          VSMUL_VMVNRR: begin
            // vmv<nr>r.v instruction
            case(inst_nr)
              NREG1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              NREG2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              NREG4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              NREG8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end
        endcase
      end

      OPMVV: begin
        // OPM* instruction
        case(inst_funct6)
          // widening instructions: 2SEW = SEW op SEW
          VWADDU,
          VWSUBU,
          VWADD,
          VWSUB,
          VWMUL,
          VWMULU,
          VWMULSU,
          VWMACCU,
          VWMACC,
          VWMACCSU: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL4;
              end
            endcase
          end
          
          // widening instructions: 2SEW = 2SEW op SEW
          VWADDU_W,
          VWSUBU_W,
          VWADD_W,
          VWSUB_W: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL4;
              end
            endcase
          end

          VXUNARY0: begin
            case(vs1_opcode) 
              VZEXT_VF2,
              VSEXT_VF2: begin
                case(csr_lmul)
                  LMUL1_2,
                  LMUL1: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                  end
                  LMUL2: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL1;
                  end
                  LMUL4: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL2;
                  end
                  LMUL8: begin
                    emul_vd     = EMUL8;
                    emul_vs2    = EMUL4;
                  end
                endcase
              end
              VZEXT_VF4,
              VSEXT_VF4: begin
                case(csr_lmul)
                  LMUL1: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                  end
                  LMUL2: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL1;
                  end
                  LMUL4: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL1;
                  end
                  LMUL8: begin
                    emul_vd     = EMUL8;
                    emul_vs2    = EMUL2;
                  end
                endcase
              end
            endcase
          end
 
          // SEW = SEW op SEW
          VMUL,
          VMULH,
          VMULHU,
          VMULHSU,
          VDIVU,
          VDIV,
          VREMU,
          VREM,
          VMACC,
          VNMSAC,
          VMADD,
          VNMSUB,
          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL8;
              end
            endcase
          end
         
          // reduction
          VREDSUM,
          VREDMAXU,
          VREDMAX,
          VREDMINU,
          VREDMIN,
          VREDAND,
          VREDOR,
          VREDXOR: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL1;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL1;
              end
            endcase
          end

          // mask 
          VMAND,
          VMNAND,
          VMANDN,
          VMXOR,
          VMOR,
          VMNOR,
          VMORN,
          VMXNOR: begin
            emul_vd     = EMUL1;
            emul_vs2    = EMUL1;
            emul_vs1    = EMUL1;
          end

          VWRXUNARY0: begin
            case(vs1_opcode)
              VCPOP,
              VFIRST,
              VMV_X_S: begin
                emul_vs2  = EMUL1;
              end
            endcase
          end

          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF,
              VMSIF,
              VMSOF: begin
                emul_vd         = EMUL1;
                emul_vs2        = EMUL1;
              end
              VIOTA: begin
                case(csr_lmul)
                  LMUL1_4,
                  LMUL1_2,
                  LMUL1: begin
                    emul_vd     = EMUL1;
                    emul_vs2    = EMUL1;
                  end
                  LMUL2: begin
                    emul_vd     = EMUL2;
                    emul_vs2    = EMUL1;
                  end
                  LMUL4: begin
                    emul_vd     = EMUL4;
                    emul_vs2    = EMUL1;
                  end
                  LMUL8: begin
                    emul_vd     = EMUL8;
                    emul_vs2    = EMUL1;
                  end
                endcase
              end
              VID: begin
                case(csr_lmul)
                  LMUL1_4,
                  LMUL1_2,
                  LMUL1: begin
                    emul_vd     = EMUL1;
                  end
                  LMUL2: begin
                    emul_vd     = EMUL2;
                  end
                  LMUL4: begin
                    emul_vd     = EMUL4;
                  end
                  LMUL8: begin
                    emul_vd     = EMUL8;
                  end
                endcase
              end
            endcase
          end

          VCOMPRESS: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL1;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL1;
              end
            endcase
          end
        endcase
      end

      OPMVX: begin
        // OPM* instruction
        case(inst_funct6)
          // widening instructions: 2SEW = SEW op SEW
          VWADDU,
          VWSUBU,
          VWADD,
          VWSUB,
          VWMUL,
          VWMULU,
          VWMULSU,
          VWMACCU,
          VWMACC,
          VWMACCSU: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL4;
              end
            endcase
          end
          
          // widening instructions: 2SEW = 2SEW op SEW
          VWADDU_W,
          VWSUBU_W,
          VWADD_W,
          VWSUB_W: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              LMUL2: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              LMUL4: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          // SEW = SEW op SEW
          VMUL,
          VMULH,
          VMULHU,
          VMULHSU,
          VDIVU,
          VDIV,
          VREMU,
          VREM,
          VMACC,
          VNMSAC,
          VMADD,
          VNMSUB,
          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end

          VWMACCUS: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL1: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL4;
              end
            endcase
          end
         
          // reduction
          VREDSUM,
          VREDMAXU,
          VREDMAX,
          VREDMINU,
          VREDMIN,
          VREDAND,
          VREDOR,
          VREDXOR: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
                emul_vs1    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL2;
                emul_vs1    = EMUL1;
              end
              LMUL4: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL4;
                emul_vs1    = EMUL1;
              end
              LMUL8: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL8;
                emul_vs1    = EMUL1;
              end
            endcase
          end

          VWRXUNARY0: begin
            if(vs2_opcode==VMV_S_X) begin
              emul_vd     = EMUL1;
            end
          end

          VSLIDE1UP,
          VSLIDE1DOWN: begin
            case(csr_lmul)
              LMUL1_4,
              LMUL1_2,
              LMUL1: begin
                emul_vd     = EMUL1;
                emul_vs2    = EMUL1;
              end
              LMUL2: begin
                emul_vd     = EMUL2;
                emul_vs2    = EMUL2;
              end
              LMUL4: begin
                emul_vd     = EMUL4;
                emul_vs2    = EMUL4;
              end
              LMUL8: begin
                emul_vd     = EMUL8;
                emul_vs2    = EMUL8;
              end
            endcase
          end
        endcase
      end
    endcase
  end
 
  always_comb begin
    if((emul_vd==EMUL8)||(emul_vs2==EMUL8)||(emul_vs1==EMUL8))
      emul_max = (`UOP_INDEX_WIDTH_ALU+1)'('d8);
    else if((emul_vd==EMUL4)||(emul_vs2==EMUL4)||(emul_vs1==EMUL4))
      emul_max = (`UOP_INDEX_WIDTH_ALU+1)'('d4);
    else if((emul_vd==EMUL2)||(emul_vs2==EMUL2)||(emul_vs1==EMUL2))
      emul_max = (`UOP_INDEX_WIDTH_ALU+1)'('d2);
    else if((emul_vd==EMUL1)||(emul_vs2==EMUL1)||(emul_vs1==EMUL1))
      emul_max = (`UOP_INDEX_WIDTH_ALU+1)'('d1);
    else
      emul_max = 'd0;
  end


// get EEW 
  always_comb begin
    // initial
    eew_vd          = EEW_NONE;
    eew_vs2         = EEW_NONE;
    eew_vs1         = EEW_NONE;
    eew_max         = EEW_NONE;

    case(inst_funct3)
      OPIVV,
      OPIVX,
      OPIVI: begin
        // OPI* instruction
        case(funct6_ari.ari_funct6)
          VADD,
          VADC,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VRGATHER: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
          
          VSUB,
          VSBC,
          VMINU,
          VMIN,
          VMAXU,
          VMAX,
          VSSUBU,
          VSSUB: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VRSUB,
          VSLIDEDOWN: begin       
            case(inst_funct3)
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VMADC,
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VMSBC,
          VMSLTU,
          VMSLT: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VMSGTU,
          VMSGT: begin
            case(inst_funct3)
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW8;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VMERGE_VMV: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    if (inst_vm=='b0)
                      eew_vs2   = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VSMUL_VMVNRR: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VWREDSUMU,
          VWREDSUM: begin
            case(inst_funct3)
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
          
          VSLIDEUP_RGATHEREI16: begin
            case(inst_funct3)
              // VRGATHEREI16
              OPIVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
              // VSLIDEUP
              OPIVX,
              OPIVI: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
        endcase
      end

      OPMVV,
      OPMVX: begin
        // OPM* instruction
        case(funct6_ari.ari_funct6)
          // widening instructions: 2SEW = SEW op SEW
          VWADDU,
          VWSUBU,
          VWADD,
          VWSUB,
          VWMUL,
          VWMULU,
          VWMULSU,
          VWMACCU,
          VWMACC,
          VWMACCSU: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPMVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW8;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
         
          // widening instructions: 2SEW = 2SEW op SEW
          VWADDU_W,
          VWSUBU_W,
          VWADD_W,
          VWSUB_W: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW8;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPMVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          // SEW = extend 1/2SEW or 1/4SEW
          VXUNARY0: begin
            case(inst_funct3)
              OPMVV: begin
                case(vs1_opcode) 
                  VZEXT_VF2,
                  VSEXT_VF2: begin
                    case(csr_sew)
                      SEW16: begin
                        eew_vd      = EEW16;
                        eew_vs2     = EEW8;
                        eew_max     = EEW16;
                      end
                      SEW32: begin
                        eew_vd      = EEW32;
                        eew_vs2     = EEW16;
                        eew_max     = EEW32;
                      end
                    endcase
                  end
                  VZEXT_VF4,
                  VSEXT_VF4: begin
                    case(csr_sew)
                      SEW32: begin
                        eew_vd      = EEW32;
                        eew_vs2     = EEW8;
                        eew_max     = EEW32;
                      end
                    endcase
                  end
                endcase
              end
            endcase
          end

          // SEW = SEW op SEW
          VMUL,
          VMULH,
          VMULHU,
          VMULHSU,
          VDIVU,
          VDIV,
          VREMU,
          VREM,
          VMACC,
          VNMSAC,
          VMADD,
          VNMSUB,
          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
              OPMVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
          
          VWMACCUS: begin
            case(inst_funct3)
              OPMVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW8;
                    eew_max     = EEW16;
                  end
                  SEW16: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW16;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          // reduction
          VREDSUM,
          VREDMAXU,
          VREDMAX,
          VREDMINU,
          VREDMIN,
          VREDAND,
          VREDOR,
          VREDXOR: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          // mask 
          VMAND,
          VMNAND,
          VMANDN,
          VMXOR,
          VMOR,
          VMNOR,
          VMORN,
          VMXNOR: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8,
                  SEW16,
                  SEW32: begin
                    eew_vd      = EEW1;
                    eew_vs2     = EEW1;
                    eew_vs1     = EEW1;
                    eew_max     = EEW1;
                  end
                endcase
              end
            endcase
          end

          VWRXUNARY0: begin
            case(inst_funct3)
              OPMVV: begin
                case(vs1_opcode)
                  VCPOP,
                  VFIRST,
                  VMV_X_S: begin
                    case(csr_sew)
                      SEW8: begin
                        eew_vs2     = EEW8;
                        eew_max     = EEW8;
                      end
                      SEW16: begin
                        eew_vs2     = EEW16;
                        eew_max     = EEW16;
                      end
                      SEW32: begin
                        eew_vs2     = EEW32;
                        eew_max     = EEW32;
                      end
                    endcase
                  end
                endcase
              end
              OPMVX: begin
                if(vs2_opcode==VMV_S_X) begin
                  case(csr_sew)
                    SEW8: begin
                      eew_vd      = EEW8;
                      eew_max     = EEW8;
                    end
                    SEW16: begin
                      eew_vd      = EEW16;
                      eew_max     = EEW16;
                    end
                    SEW32: begin
                      eew_vd      = EEW32;
                      eew_max     = EEW32;
                    end
                  endcase
                end
              end
            endcase
          end

          VMUNARY0: begin
            case(inst_funct3)
              OPMVV: begin
                case(vs1_opcode)
                  VMSBF,
                  VMSIF,
                  VMSOF: begin
                    case(csr_sew)
                      SEW8,
                      SEW16,
                      SEW32: begin
                        eew_vd      = EEW1;
                        eew_vs2     = EEW1;
                        eew_max     = EEW1;
                      end
                    endcase
                  end
                  VIOTA:begin
                    case(csr_sew)
                      SEW8: begin
                        eew_vd      = EEW8;
                        eew_vs2     = EEW1;
                        eew_max     = EEW8;
                      end
                      SEW16: begin
                        eew_vd      = EEW16;
                        eew_vs2     = EEW1;
                        eew_max     = EEW16;
                      end
                      SEW32: begin
                        eew_vd      = EEW32;
                        eew_vs2     = EEW1;
                        eew_max     = EEW32;
                      end
                    endcase
                  end
                  VID: begin
                    case(csr_sew)
                      SEW8: begin
                        eew_vd      = EEW8;
                        eew_max     = EEW8;
                      end
                      SEW16: begin
                        eew_vd      = EEW16;
                        eew_max     = EEW16;
                      end
                      SEW32: begin
                        eew_vd      = EEW32;
                        eew_max     = EEW32;
                      end
                    endcase
                  end
                endcase
              end
            endcase
          end

          VSLIDE1UP,
          VSLIDE1DOWN: begin
            case(inst_funct3)
              OPMVX: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end

          VCOMPRESS: begin
            case(inst_funct3)
              OPMVV: begin
                case(csr_sew)
                  SEW8: begin
                    eew_vd      = EEW8;
                    eew_vs2     = EEW8;
                    eew_vs1     = EEW1;
                    eew_max     = EEW8;
                  end
                  SEW16: begin
                    eew_vd      = EEW16;
                    eew_vs2     = EEW16;
                    eew_vs1     = EEW1;
                    eew_max     = EEW16;
                  end
                  SEW32: begin
                    eew_vd      = EEW32;
                    eew_vs2     = EEW32;
                    eew_vs1     = EEW1;
                    eew_max     = EEW32;
                  end
                endcase
              end
            endcase
          end
        endcase
      end
    endcase
  end

//  
// instruction encoding error check
//
  assign inst_encoding_correct = check_special&check_common;

  // check whether vd overlaps v0 when vm=0
  // check_vd_overlap_v0=1 means check pass (vd does NOT overlap v0)
  assign check_vd_overlap_v0 = (((inst_vm==1'b0)&(inst_vd!='b0)) | (inst_vm==1'b1));

  // check whether vd partially overlaps vs2 with EEW_vd<EEW_vs2
  // check_vd_part_overlap_vs2=1 means that check pass (vd group does NOT overlap vs2 group partially)
  always_comb begin
    check_vd_part_overlap_vs2 = 'b0;          
    
    case(emul_vs2)
      EMUL1: begin
        check_vd_part_overlap_vs2 = 1'b1;          
      end
      EMUL2: begin
        check_vd_part_overlap_vs2 = !((inst_vd[0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])));
      end
      EMUL4: begin
        check_vd_part_overlap_vs2 = !((inst_vd[1:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])));
      end
      EMUL8 : begin
        check_vd_part_overlap_vs2 = !((inst_vd[2:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])));
      end
    endcase
  end

  // check whether vd partially overlaps vs1 with EEW_vd<EEW_vs1
  // check_vd_part_overlap_vs1=1 means that check pass (vd group does NOT overlap vs1 group partially)
  always_comb begin
    check_vd_part_overlap_vs1     = 'b0;          
    
    case(emul_vs1)
      EMUL1: begin
        check_vd_part_overlap_vs1 = 1'b1;          
      end
      EMUL2: begin
        check_vd_part_overlap_vs1 = !((inst_vd[0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs1[`REGFILE_INDEX_WIDTH-1:1])));
      end
      EMUL4: begin
        check_vd_part_overlap_vs1 = !((inst_vd[1:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs1[`REGFILE_INDEX_WIDTH-1:2])));
      end
      EMUL8 : begin
        check_vd_part_overlap_vs1 = !((inst_vd[2:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs1[`REGFILE_INDEX_WIDTH-1:3])));
      end
    endcase
  end

  // vd cannot overlap vs2
  // check_vd_overlap_vs2=1 means that check pass (vd group does NOT overlap vs2 group fully)
  always_comb begin
    if((emul_vd==EMUL8)|(emul_vs2==EMUL8)) 
      check_vd_overlap_vs2 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3]);
    else if((emul_vd==EMUL4)|(emul_vs2==EMUL4)) 
      check_vd_overlap_vs2 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2]);
    else if((emul_vd==EMUL2)|(emul_vs2==EMUL2)) 
      check_vd_overlap_vs2 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1]);
    else if((emul_vd==EMUL1)|(emul_vs2==EMUL1)) 
      check_vd_overlap_vs2 = (inst_vd!=inst_vs2);
    else 
      check_vd_overlap_vs2 = 'b0;
  end
  
  // vd cannot overlap vs1
  // check_vd_overlap_vs1=1 means that check pass (vd group does NOT overlap vs1 group fully)
  always_comb begin
    if((emul_vd==EMUL8)|(emul_vs1==EMUL8)) 
      check_vd_overlap_vs1 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs1[`REGFILE_INDEX_WIDTH-1:3]);
    else if((emul_vd==EMUL4)|(emul_vs1==EMUL4)) 
      check_vd_overlap_vs1 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs1[`REGFILE_INDEX_WIDTH-1:2]);
    else if((emul_vd==EMUL2)|(emul_vs1==EMUL2)) 
      check_vd_overlap_vs1 = !(inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs1[`REGFILE_INDEX_WIDTH-1:1]);
    else if((emul_vd==EMUL1)|(emul_vs1==EMUL1)) 
      check_vd_overlap_vs1 = (inst_vd!=inst_vs1);
    else 
      check_vd_overlap_vs1 = 'b0;
  end

  // check whether vs2 group partially overlaps vd group for EEW_vd:EEW_vs2=2:1
  always_comb begin
    check_vs2_part_overlap_vd_2_1 = 'b0;

    case(emul_vd)
      EMUL1: begin
        check_vs2_part_overlap_vd_2_1 = 1'b1;
      end
      EMUL2: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])&(inst_vs2[0]!=1'b1));
      end
      EMUL4: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])&(inst_vs2[1:0]!=2'b10));
      end
      EMUL8: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])&(inst_vs2[2:0]!=3'b100));
      end
    endcase
  end
  
  // check whether vs1 group partially overlaps vd group for EEW_vd:EEW_vs1=2:1
  always_comb begin
    check_vs1_part_overlap_vd_2_1 = 'b0;

    case(emul_vd)
      EMUL1: begin
        check_vs1_part_overlap_vd_2_1 = 1'b1;
      end
      EMUL2: begin
        check_vs1_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs1[`REGFILE_INDEX_WIDTH-1:1])&(inst_vs1[0]!=1'b1));
      end
      EMUL4: begin
        check_vs1_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs1[`REGFILE_INDEX_WIDTH-1:2])&(inst_vs1[1:0]!=2'b10));
      end
      EMUL8: begin
        check_vs1_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs1[`REGFILE_INDEX_WIDTH-1:3])&(inst_vs1[2:0]!=3'b100));
      end
    endcase
  end

  // check whether vs2 group partially overlaps vd group for EEW_vd:EEW_vs2=4:1
  always_comb begin
    check_vs2_part_overlap_vd_4_1 = 'b0;

    case(emul_vd)
      EMUL1: begin
        check_vs2_part_overlap_vd_4_1 = 1'b1;
      end
      EMUL2: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])&(inst_vs2[0]!=1'b1));
      end
      EMUL4: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])&(inst_vs2[1:0]!=2'b11));
      end
      EMUL8: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])&(inst_vs2[2:0]!=3'b110));
      end
    endcase
  end
 
  // start to check special requirements for every instructions
  always_comb begin 
    check_special = 'b0;
    
    case(inst_funct3)
      OPIVV: begin
        case(funct6_ari.ari_funct6)
          VADD,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VSLIDEDOWN: begin
            check_special = check_vd_overlap_v0;
          end
        
          VSUB,
          VMINU,
          VMIN,
          VMAXU,
          VMAX,
          VSSUBU,
          VSSUB: begin
            check_special = check_vd_overlap_v0;
          end

          VADC: begin
            check_special = (inst_vm==1'b0)&(inst_vd!='b0);
          end

          VMADC: begin
            check_special = check_vd_part_overlap_vs2&check_vd_part_overlap_vs1;
          end

          VSBC: begin
            check_special = (inst_vm==1'b0)&(inst_vd!='b0);
          end
      
          VMSBC: begin
            check_special = check_vd_part_overlap_vs2&check_vd_part_overlap_vs1;
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            check_special = check_vd_overlap_v0&check_vd_part_overlap_vs2;
          end
          
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            check_special = check_vd_part_overlap_vs2&check_vd_part_overlap_vs1;
          end

          VMSLTU,
          VMSLT: begin
            check_special = check_vd_part_overlap_vs2&check_vd_part_overlap_vs1;
          end

          VMERGE_VMV: begin
            // when vm=1, it is vmv instruction and vs2_index must be 5'b0.
            check_special = ((inst_vm=='b0)&(inst_vd!='b0)) | ((inst_vm==1'b1)&(inst_vs2=='b0));
          end
               
          VSMUL_VMVNRR: begin
            check_special = check_vd_overlap_v0;
          end

          VWREDSUMU,
          VWREDSUM: begin
            check_special = (csr_vstart=='b0);
          end

          VSLIDEUP_RGATHEREI16: begin
            // VRGATHEREI16
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2&check_vd_overlap_vs1;                
          end
          
          VRGATHER: begin
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2&check_vd_overlap_vs1;
          end
        endcase
      end
      OPIVX: begin
        case(funct6_ari.ari_funct6)
          VADD,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VSLIDEDOWN: begin
            check_special = check_vd_overlap_v0;
          end
        
          VSUB,
          VMINU,
          VMIN,
          VMAXU,
          VMAX,
          VSSUBU,
          VSSUB: begin
            check_special = check_vd_overlap_v0;
          end

          VRSUB: begin
            check_special = check_vd_overlap_v0;
          end

          VADC: begin
            check_special = (inst_vm==1'b0)&(inst_vd!='b0);
          end

          VMADC: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VSBC: begin
            check_special = (inst_vm==1'b0)&(inst_vd!='b0);
          end
      
          VMSBC: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            check_special = check_vd_overlap_v0&check_vd_part_overlap_vs2;
          end
          
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VMSLTU,
          VMSLT: begin
            check_special = check_vd_part_overlap_vs2;
          end
          
          VMSGTU,
          VMSGT: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VMERGE_VMV: begin
            // when vm=1, it is vmv instruction and vs2_index must be 5'b0.
            check_special = ((inst_vm=='b0)&(inst_vd!='b0)) | ((inst_vm==1'b1)&(inst_vs2=='b0));
          end
               
          VSMUL_VMVNRR: begin
            check_special = check_vd_overlap_v0;
          end

          VSLIDEUP_RGATHEREI16: begin
            // VSLIDEUP 
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2;
          end
          
          VRGATHER: begin
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2;
          end
        endcase
      end
      OPIVI: begin
        case(funct6_ari.ari_funct6)
          VADD,
          VAND,
          VOR,
          VXOR,
          VSLL,
          VSRL,
          VSRA,
          VSADDU,
          VSADD,
          VSSRL,
          VSSRA,
          VSLIDEDOWN: begin
            check_special = check_vd_overlap_v0;
          end

          VRSUB: begin
            check_special = check_vd_overlap_v0;
          end

          VADC: begin
            check_special = (inst_vm==1'b0)&(inst_vd!='b0);
          end

          VMADC: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VNSRL,
          VNSRA,
          VNCLIPU,
          VNCLIP: begin
            check_special = check_vd_overlap_v0&check_vd_part_overlap_vs2;
          end
          
          VMSEQ,
          VMSNE,
          VMSLEU,
          VMSLE: begin
            check_special = check_vd_part_overlap_vs2;
          end
          
          VMSGTU,
          VMSGT: begin
            check_special = check_vd_part_overlap_vs2;
          end

          VMERGE_VMV: begin
            // when vm=1, it is vmv instruction and vs2_index must be 5'b0.
            check_special = ((inst_vm=='b0)&(inst_vd!='b0)) | ((inst_vm==1'b1)&(inst_vs2=='b0));
          end
               
          VSMUL_VMVNRR: begin
            check_special = (inst_vm == 1'b1)&(inst_vs1[4:3]==2'b0)&
                            ((inst_nr==NREG1)|(inst_nr==NREG2)|(inst_nr==NREG4)|(inst_nr==NREG8));
          end

          VSLIDEUP_RGATHEREI16: begin
            // VSLIDEUP 
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2;
          end
          
          VRGATHER: begin
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2;
          end
        endcase
      end

      OPMVV: begin
        case(funct6_ari.ari_funct6)
          VWADDU,
          VWSUBU,
          VWADD,
          VWSUB,
          VWMUL,
          VWMULU,
          VWMULSU,
          VWMACCU,
          VWMACC,
          VWMACCSU: begin
            // overlap constraint
            check_special = check_vd_overlap_v0&check_vs2_part_overlap_vd_2_1&check_vs1_part_overlap_vd_2_1;                
          end

          VWADDU_W,
          VWSUBU_W,
          VWADD_W,
          VWSUB_W: begin
            // overlap constraint
            check_special = check_vd_overlap_v0&check_vs1_part_overlap_vd_2_1;                
          end
          
          VXUNARY0: begin
            case(vs1_opcode) 
              VZEXT_VF2,
              VSEXT_VF2: begin
                // overlap constraint
                check_special = check_vd_overlap_v0&check_vs2_part_overlap_vd_2_1;                
              end
              VZEXT_VF4,
              VSEXT_VF4: begin
                // overlap constraint
                check_special = check_vd_overlap_v0&check_vs2_part_overlap_vd_4_1;                
              end
            endcase
          end

          VMUL,
          VMULH,
          VMULHU,
          VMULHSU,
          VDIVU,
          VDIV,
          VREMU,
          VREM,
          VMACC,
          VNMSAC,
          VMADD,
          VNMSUB,
          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            check_special = check_vd_overlap_v0;          
          end

          // reduction
          VREDSUM,
          VREDMAXU,
          VREDMAX,
          VREDMINU,
          VREDMIN,
          VREDAND,
          VREDOR,
          VREDXOR: begin
            check_special = (csr_vstart=='b0);
          end

          // mask 
          VMAND,
          VMNAND,
          VMANDN,
          VMXOR,
          VMOR,
          VMNOR,
          VMORN,
          VMXNOR: begin
            check_special = inst_vm;
          end
          
          VWRXUNARY0: begin
            case(vs1_opcode)
              VCPOP,
              VFIRST: begin
                check_special = (csr_vstart=='b0);
              end
              VMV_X_S: begin
                check_special = (inst_vm==1'b1);
              end
            endcase
          end

          VMUNARY0: begin
            case(vs1_opcode)
              VMSBF,
              VMSIF,
              VMSOF,
              VIOTA: begin
                check_special = (csr_vstart=='b0)&check_vd_overlap_v0&check_vd_overlap_vs2;
              end
              VID: begin
                check_special = (inst_vs2=='b0)&check_vd_overlap_v0;
              end
            endcase
          end

          VCOMPRESS: begin
            // destination register group cannot overlap the source register group
            check_special = (csr_vstart=='b0)&inst_vm&check_vd_overlap_vs2&check_vd_overlap_vs1;
          end
        endcase
      end
      OPMVX: begin
        case(funct6_ari.ari_funct6)
          VWADDU,
          VWSUBU,
          VWADD,
          VWSUB,
          VWMUL,
          VWMULU,
          VWMULSU,
          VWMACCU,
          VWMACC,
          VWMACCSU: begin
            // overlap constraint
            check_special = check_vd_overlap_v0&check_vs2_part_overlap_vd_2_1;                
          end

          VWADDU_W,
          VWSUBU_W,
          VWADD_W,
          VWSUB_W: begin
            check_special = check_vd_overlap_v0;                
          end

          VMUL,
          VMULH,
          VMULHU,
          VMULHSU,
          VDIVU,
          VDIV,
          VREMU,
          VREM,
          VMACC,
          VNMSAC,
          VMADD,
          VNMSUB,
          VAADDU,
          VAADD,
          VASUBU,
          VASUB: begin
            check_special = check_vd_overlap_v0;          
          end

          VWMACCUS: begin
            check_special = check_vd_overlap_v0&check_vs2_part_overlap_vd_2_1;                
          end

          VSLIDE1DOWN: begin
            check_special = check_vd_overlap_v0;          
          end
          
          VWRXUNARY0: begin
            check_special = (vs2_opcode==VMV_S_X)&(inst_vm==1'b1)&(inst_vs2=='b0);
          end

          VSLIDE1UP: begin
            // destination register group cannot overlap the source register group
            check_special = check_vd_overlap_v0&check_vd_overlap_vs2;
          end
        endcase
      end
    endcase
  end

  //check common requirements for all instructions
  assign check_common = check_vd_align&check_vs2_align&check_vs1_align&check_sew&check_lmul&check_evl_not_0&check_vstart_sle_evl;

  // check whether vd is aligned to emul_vd
  always_comb begin
    check_vd_align = 'b0; 

    case(emul_vd)
      EMUL_NONE,
      EMUL1: begin
        check_vd_align = 1'b1; 
      end
      EMUL2: begin
        check_vd_align = (inst_vd[0]==1'b0); 
      end
      EMUL4: begin
        check_vd_align = (inst_vd[1:0]==2'b0); 
      end
      EMUL8: begin
        check_vd_align = (inst_vd[2:0]==3'b0); 
      end
    endcase
  end

  // check whether vs2 is aligned to emul_vs2
  always_comb begin
    check_vs2_align = 'b0; 

    case(emul_vs2)
      EMUL_NONE,
      EMUL1: begin
        check_vs2_align = 1'b1; 
      end
      EMUL2: begin
        check_vs2_align = (inst_vs2[0]==1'b0); 
      end
      EMUL4: begin
        check_vs2_align = (inst_vs2[1:0]==2'b0); 
      end
      EMUL8: begin
        check_vs2_align = (inst_vs2[2:0]==3'b0); 
      end
    endcase
  end
    
  // check whether vs1 is aligned to emul_vs1
  always_comb begin
    check_vs1_align = 'b0; 
    
    case(emul_vs1)
      EMUL_NONE,
      EMUL1: begin
        check_vs1_align = 1'b1; 
      end
      EMUL2: begin
        check_vs1_align = (inst_vs1[0]==1'b0); 
      end
      EMUL4: begin
        check_vs1_align = (inst_vs1[1:0]==2'b0); 
      end
      EMUL8: begin
        check_vs1_align = (inst_vs1[2:0]==3'b0); 
      end
    endcase
  end
 
  // check the validation of EEW
  assign check_sew = (eew_max != EEW_NONE);
    
  // check the validation of EMUL
  assign check_lmul = (emul_max != 'd0); 
  
  // get evl
  always_comb begin
    evl = csr_vl;
  
    case(inst_funct3)
      OPIVI: begin
        case(funct6_ari.ari_funct6)
          VSMUL_VMVNRR: begin
            // vmv<nr>r.v
            case(emul_max)
              (`UOP_INDEX_WIDTH_ALU+1)'('d1): begin
                case(eew_max)
                  EEW8: begin
                    evl = 1*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 1*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 1*`VLEN/32;
                  end
                endcase
              end
              (`UOP_INDEX_WIDTH_ALU+1)'('d2): begin
                case(eew_max)
                  EEW8: begin
                    evl = 2*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 2*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 2*`VLEN/32;
                  end
                endcase
              end
              (`UOP_INDEX_WIDTH_ALU+1)'('d4): begin
                case(eew_max)
                  EEW8: begin
                    evl = 4*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 4*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 4*`VLEN/32;
                  end
                endcase
              end
              (`UOP_INDEX_WIDTH_ALU+1)'('d8): begin
                case(eew_max)
                  EEW8: begin
                    evl = 8*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 8*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 8*`VLEN/32;
                  end
                endcase
              end
            endcase
          end
        endcase
      end

      OPMVX: begin
        case(funct6_ari.ari_funct6)
          VWRXUNARY0: begin
            if(vs2_opcode==VMV_S_X) begin
              evl = 'b1;
            end
          end
        endcase
      end
    endcase
  end

  // check evl is not 0
  // check vstart < evl
  always_comb begin
    check_evl_not_0 = evl!='b0;
    check_vstart_sle_evl = {1'b0,csr_vstart} < evl;
    
    // Instructions that write an x register or f register do so even when vstart >= vl, including when vl=0.
    case({valid_opm,funct6_ari.ari_funct6})
      {1'b1,VWRXUNARY0}: begin
        case(inst_funct3)
          OPMVV: begin
            case(vs1_opcode)
              VCPOP,
              VFIRST,
              VMV_X_S: begin
                check_evl_not_0 = 'b1;
                check_vstart_sle_evl = 'b1;
              end
            endcase
          end
          OPMVX: begin
            if(vs2_opcode==VMV_S_X) begin
              check_evl_not_0 = csr_vl!='b0;
              check_evl_not_0 = {1'b0,csr_vstart} < csr_vl;
            end
          end
        endcase
      end
    endcase
  end

  `ifdef ASSERT_ON
    `ifdef TB_SUPPORT
      `rvv_forbid((inst_valid==1'b1)&(inst_encoding_correct==1'b0))
      else $warning("pc(0x%h) instruction will be discarded directly.\n",$sampled(inst.inst_pc));
    `else
      `rvv_forbid((inst_valid==1'b1)&(inst_encoding_correct==1'b0))
      else $warning("This instruction will be discarded directly.\n");
    `endif
  `endif

//
// split instruction to uops
//
`ifdef TB_SUPPORT
  // assign uop pc
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_PC
      uop_pc[i] = inst.inst_pc;
    end
  end
`endif

  // update uop funct3
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_FUNCT3
      uop_funct3[i] = inst_funct3;
    end
  end

  // update uop funct6
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_FUNCT6
      uop_funct6[i] = funct6_ari;
    end
  end

  // allocate uop to execution unit
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_EXE_UNIT
      // initial
      uop_exe_unit[i] = ALU;
      
      case(1'b1)
        valid_opi: begin
          // allocate OPI* uop to execution unit
          case(funct6_ari.ari_funct6)
            VADD,
            VSUB,
            VRSUB,
            VADC,
            VSBC,
            VAND,
            VOR,
            VXOR,
            VSLL,
            VSRL,
            VSRA,
            VNSRL,
            VNSRA,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VMERGE_VMV,
            VSADDU,
            VSADD,
            VSSUBU,
            VSSUB,
            VSSRL,
            VSSRA,
            VNCLIPU,
            VNCLIP: begin
              uop_exe_unit[i]     = ALU;
            end 
            
            // Although comparison instructions belong to ALU previously, 
            // they will be sent to RDT unit to execute for better performance. 
            // Because all uops of the comparison instructions have a single vector destination index, 
            // which is similar to reduction instructions.
            VMADC,
            VMSBC,
            VMSEQ,
            VMSNE,
            VMSLTU,
            VMSLT,
            VMSLEU,
            VMSLE,
            VMSGTU,
            VMSGT:begin
              uop_exe_unit[i] = CMP;
            end
            VWREDSUMU,
            VWREDSUM: begin
              uop_exe_unit[i] = RDT;
            end

            VSLIDEUP_RGATHEREI16,
            VSLIDEDOWN,
            VRGATHER: begin
              uop_exe_unit[i] = PMT;
            end

            VSMUL_VMVNRR: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin
                  uop_exe_unit[i] = MUL;
                end
                OPIVI: begin 
                  uop_exe_unit[i] = ALU;
                end
              endcase
            end
          endcase
        end

        valid_opm: begin
          // allocate OPM* uop to execution unit
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VXUNARY0,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB,
            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR,
            VWRXUNARY0,
            VMUNARY0: begin
              uop_exe_unit[i] = ALU;
            end

            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VWMUL,
            VWMULU,
            VWMULSU: begin
              uop_exe_unit[i] = MUL;
            end

            VDIVU,
            VDIV,
            VREMU,
            VREM: begin
              uop_exe_unit[i] = DIV;
            end
            
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VWMACCU,
            VWMACC,
            VWMACCSU,
            VWMACCUS: begin
              uop_exe_unit[i] = MAC;
            end

            // reduction
            VREDSUM,
            VREDMAXU,
            VREDMAX,
            VREDMINU,
            VREDMIN,
            VREDAND,
            VREDOR,
            VREDXOR: begin
              uop_exe_unit[i] = RDT;
            end

            VSLIDE1UP,
            VSLIDE1DOWN,
            VCOMPRESS: begin
              uop_exe_unit[i] = PMT;
            end
          endcase
        end
      endcase
    end
  end

// get the start number of uop_index
  always_comb begin
    if((funct6_ari.ari_funct6==VWRXUNARY0)&(inst_funct3==OPMVV)&(vs1_opcode==VMV_X_S)) begin
      uop_vstart = 'b0;
    end
    else begin
      case(eew_max)
        EEW8: begin
          uop_vstart = (`UOP_INDEX_WIDTH)'(csr_vstart[4 +: `UOP_INDEX_WIDTH_ALU]);
        end
        EEW16: begin
          uop_vstart = (`UOP_INDEX_WIDTH)'(csr_vstart[3 +: `UOP_INDEX_WIDTH_ALU]);
        end
        EEW32: begin
          uop_vstart = (`UOP_INDEX_WIDTH)'(csr_vstart[2 +: `UOP_INDEX_WIDTH_ALU]);
        end
        default: begin
          uop_vstart = 'b0;
        end
      endcase
    end
  end
  
  // select uop_vstart and uop_index_remain as the base uop_index
  always_comb begin
    // initial
    uop_index_base = (|uop_index_remain) ? uop_index_remain : uop_vstart;

    case(1'b1)
      valid_opi: begin
        case(funct6_ari.ari_funct6)
          VSLIDEUP_RGATHEREI16,
          VRGATHER: begin
            uop_index_base = uop_index_remain;
          end
        endcase
      end

      valid_opm: begin
        case(funct6_ari.ari_funct6)
          VSLIDE1UP: begin
            uop_index_base = uop_index_remain;
          end
        endcase
      end
    endcase
  end

  // calculate the uop_index used in decoding uops 
  generate
    for(j=0;j<`NUM_DE_UOP;j++) begin: GET_UOP_INDEX
      assign uop_index_current[j] = {1'b0, uop_index_base} + j[`UOP_INDEX_WIDTH:0];
    end
  endgenerate

  // get the max uop index 
  always_comb begin
    case(emul_max)
      (`UOP_INDEX_WIDTH_ALU+1)'('d1): uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
      (`UOP_INDEX_WIDTH_ALU+1)'('d2): uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
      (`UOP_INDEX_WIDTH_ALU+1)'('d4): uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
      (`UOP_INDEX_WIDTH_ALU+1)'('d8): uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
      default:                        uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
    endcase
  end

  // generate uop valid
  always_comb begin        
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VALID
      if ((uop_index_current[i]<={1'b0,uop_index_max})&inst_valid) 
        uop_valid[i]  = inst_encoding_correct;
      else
        uop_valid[i]  = 'b0;
    end
  end

  // update uop class
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_CLASS
      // initial 
      uop_class[i] = XXX;
      
      case(1'b1)
        valid_opi: begin
          // OPI*
          case(funct6_ari.ari_funct6)
            VADD,
            VADC,
            VAND,
            VOR,
            VXOR,
            VSLL,
            VSRL,
            VSRA,
            VNSRL,
            VNSRA,
            VSADDU,
            VSADD,
            VSMUL_VMVNRR,
            VSSRL,
            VSSRA,
            VNCLIPU,
            VNCLIP,
            VRGATHER: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = XVV;
                end
                OPIVX,
                OPIVI: begin
                  uop_class[i]  = XVX;
                end 
              endcase
            end

            VSUB,
            VSBC,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VSSUBU,
            VSSUB: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = XVV;
                end
                OPIVX: begin
                  uop_class[i]  = XVX;
                end 
              endcase
            end

            VRSUB,
            VSLIDEDOWN: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin
                  uop_class[i]  = XVX;
                end 
              endcase
            end

            VMADC,
            VMSEQ,
            VMSNE,
            VMSLEU,
            VMSLE: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = VVV;
                end
                OPIVX,
                OPIVI: begin
                  uop_class[i]  = VVX;
                end
              endcase
            end

            VMSBC,
            VMSLTU,
            VMSLT: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = VVV;
                end
                OPIVX: begin
                  uop_class[i]  = VVX;
                end
              endcase
            end

            VMSGTU,
            VMSGT: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin
                  uop_class[i]  = VVX;
                end 
              endcase
            end
            
            VMERGE_VMV: begin
              case(inst_funct3)
                OPIVV: begin
                  if (inst_vm==1'b0)
                    uop_class[i]  = XVV;
                  else
                    uop_class[i]  = XXV;
                end
                OPIVX,
                OPIVI: begin
                  if (inst_vm==1'b0)
                    uop_class[i]  = XVX;
                  else
                    uop_class[i]  = XXX;
                end
              endcase
            end

            VWREDSUMU,
            VWREDSUM: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = XVV;
                end
              endcase
            end

            VSLIDEUP_RGATHEREI16: begin
              case(inst_funct3)
                OPIVV: begin
                  uop_class[i]  = XVV;
                end
                OPIVX,
                OPIVI: begin
                  uop_class[i]  = VVX;
                end
              endcase
            end
          endcase
        end

        valid_opm: begin
          // OPM*
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VDIVU,
            VDIV,
            VREMU,
            VREM,
            VWMUL,
            VWMULU,
            VWMULSU,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = XVV;
                end
                OPMVX: begin
                  uop_class[i]  = XVX;
                end
              endcase
            end 
            
            VXUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = XVX;
                end
              endcase
            end

            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VWMACCU,
            VWMACC,
            VWMACCSU: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = VVV;
                end
                OPMVX: begin
                  uop_class[i]  = VVX;
                end
              endcase
            end

            VWMACCUS: begin
              case(inst_funct3)
                OPMVX: begin
                  uop_class[i]  = VVX;
                end
              endcase
            end 

            // reduction
            VREDSUM,
            VREDMAXU,
            VREDMAX,
            VREDMINU,
            VREDMIN,
            VREDAND,
            VREDOR,
            VREDXOR: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = XVV;
                end
              endcase
            end

            // permutation
            VCOMPRESS: begin
              case(inst_funct3)
                OPMVV: begin
                  if (first_uop_valid[i])
                    uop_class[i]  = VVV;
                  else
                    uop_class[i]  = VVX;
                end
              endcase
            end

            // mask
            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = VVV;
                end
              endcase
            end

            VWRXUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  uop_class[i]  = XVX;
                end
                OPMVX: begin
                  uop_class[i]  = XXX;
                end
              endcase
            end

            VMUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  case(vs1_opcode)
                    VMSBF,
                    VMSIF,
                    VMSOF: begin
                      if (inst_vm==1'b0)
                        // need vd as vs3
                        uop_class[i]  = VVX;
                      else
                        uop_class[i]  = XVX;
                    end
                    VIOTA: begin
                      uop_class[i]  = XVX;
                    end
                    VID: begin
                      uop_class[i]  = XXX;
                    end
                  endcase
                end
              endcase
            end

            VSLIDE1UP,
            VSLIDE1DOWN: begin
              case(inst_funct3)
                OPMVX: begin
                  uop_class[i]  = XVX;
                end
              endcase
            end 
          endcase
        end
      endcase
    end
  end

  // update vector_csr and vstart
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VCSR
      vector_csr[i] = vector_csr_ari;

      // update vstart of every uop
      if(uop_index_current[i]>{1'b0,uop_vstart}) begin
        case(1'b1)
          valid_opi: begin
            // OPI*
            case(funct6_ari.ari_funct6)
              VMADC,
              VMSBC,
              VMSEQ,
              VMSNE,
              VMSLTU,
              VMSLT,
              VMSLEU,
              VMSLE,
              VMSGTU,
              VMSGT,
              VWREDSUMU,
              VWREDSUM: begin
                vector_csr[i].vstart = vector_csr_ari.vstart;
              end
              default: begin 
                case(eew_max)
                  EEW8: begin
                    vector_csr[i].vstart  = {uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLENB)){1'b0}}};
                  end
                  EEW16: begin
                    vector_csr[i].vstart  = {1'b0,uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLEN/`HWORD_WIDTH)){1'b0}}};
                  end
                  EEW32: begin
                    vector_csr[i].vstart  = {2'b0,uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLEN/`WORD_WIDTH)){1'b0}}};
                  end
                endcase
              end
            endcase
          end
          valid_opm: begin
            // OPM*
            case(funct6_ari.ari_funct6)
              VREDSUM,
              VREDMAXU,
              VREDMAX,
              VREDMINU,
              VREDMIN,
              VREDAND,
              VREDOR,
              VREDXOR,
              VCOMPRESS: begin
                vector_csr[i].vstart = vector_csr_ari.vstart;
              end
              default: begin 
                case(eew_max)
                  EEW8: begin
                    vector_csr[i].vstart  = {uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLENB)){1'b0}}};
                  end
                  EEW16: begin
                    vector_csr[i].vstart  = {1'b0,uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLEN/`HWORD_WIDTH)){1'b0}}};
                  end
                  EEW32: begin
                    vector_csr[i].vstart  = {2'b0,uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0],{($clog2(`VLEN/`WORD_WIDTH)){1'b0}}};
                  end
                endcase
              end
            endcase
          end
        endcase
      end
    end
  end

  // update vs_evl
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_EVL
      vs_evl[i] = evl;
    end
  end
 
  // update ignore_vma and ignore_vta
  // some instructions use vm as an extra opcode, so it needs ignore vma policy.
  // the instructions whose EEW_vd=1b can write the result to TAIL elements, so it needs ignore vta policy.
  always_comb begin
    // initial 
    ignore_vma = 'b0;
    ignore_vta = 'b0;
      
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_IGNORE
      case(inst_funct3) 
        OPIVV,
        OPIVX,
        OPIVI: begin
          case(funct6_ari.ari_funct6)
            VADC,
            VSBC: begin
              ignore_vma[i] = 1'b1;
              ignore_vta[i] = 1'b0;
            end
            VMADC,
            VMSBC,
            VMSEQ,
            VMSNE,
            VMSLTU,
            VMSLT,
            VMSLEU,
            VMSLE,
            VMSGTU,
            VMSGT: begin
              ignore_vma[i] = 1'b1;
              ignore_vta[i] = 1'b1;
            end
            VMERGE_VMV: begin
              if (inst_vm=='b0) begin
                ignore_vma[i] = 1'b1;
              end
            end
          endcase
        end

        OPMVV: begin
          case(funct6_ari.ari_funct6)
            VMANDN,
            VMAND,
            VMOR,
            VMXOR,
            VMORN,
            VMNAND,
            VMNOR,
            VMXNOR: begin
              ignore_vma[i] = 1'b1;
              ignore_vta[i] = 1'b1;
            end
            VMUNARY0: begin
              case(vs1_opcode)
                VMSBF,
                VMSOF,
                VMSIF: begin
                  ignore_vma[i] = 1'b1;
                  ignore_vta[i] = 1'b1;
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end
  
  // update force_vma_agnostic
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_FORCE_VMA
      //When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic.
      force_vma_agnostic[i] = ((check_vd_overlap_vs2==1'b0)&(eew_vd!=eew_vs2)&(eew_vd!=EEW_NONE)&(eew_vs2!=EEW_NONE)) |
                              ((check_vd_overlap_vs1==1'b0)&(eew_vd!=eew_vs1)&(eew_vd!=EEW_NONE)&(eew_vs1!=EEW_NONE));
    end
  end

  // update force_vta_agnostic
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_FORCE_VTA
      force_vta_agnostic[i] = (eew_vd==EEW1) |   // Mask destination tail elements are always treated as tail-agnostic
      //When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic.
                              ((check_vd_overlap_vs2==1'b0)&(eew_vd!=eew_vs2)&(eew_vd!=EEW_NONE)&(eew_vs2!=EEW_NONE)) |
                              ((check_vd_overlap_vs1==1'b0)&(eew_vd!=eew_vs1)&(eew_vd!=EEW_NONE)&(eew_vs1!=EEW_NONE));
    end
  end

  // update vm field
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VM
      vm[i] = inst_vm;
    end
  end
  
  // some uop need v0 as the vector operand
  always_comb begin
    // initial 
    v0_valid = 'b0;
       
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_V0
      case(1'b1)
        valid_opi: begin
          // OPI*
          case(funct6_ari.ari_funct6)
            VADC,
            VMADC,
            VMERGE_VMV: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  v0_valid[i] = !inst_vm;
                end
              endcase
            end 
            VSBC,
            VMSBC: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin
                  v0_valid[i] = !inst_vm;
                end
              endcase
            end
          endcase
        end
        valid_opm: begin
          // OPM*
          case(funct6_ari.ari_funct6)
            VWRXUNARY0: begin
              case(vs1_opcode)
                VCPOP,
                VFIRST: begin
                  v0_valid[i] = !inst_vm;
                end
              endcase
            end
            VMUNARY0: begin
              case(vs1_opcode)
                VMSBF,
                VMSOF,
                VMSIF,
                VIOTA: begin
                  v0_valid[i] = !inst_vm;
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end    
  
  // update vd_offset and valid
  always_comb begin
    vd_offset = 'b0;
    vd_valid  = 'b0;

    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VD_OFFSET  
      case(1'b1)
        valid_opi: begin
          case(funct6_ari.ari_funct6)
            VADD,
            VADC,
            VAND,
            VOR,
            VXOR,
            VSLL,
            VSRL,
            VSRA,
            VMERGE_VMV,
            VSADDU,
            VSADD,
            VSMUL_VMVNRR,
            VSSRL,
            VSSRA,
            VRGATHER: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin  
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end 
              endcase
            end

            VSUB,
            VSBC,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VSSUBU,
            VSSUB: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin  
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end 
              endcase
            end

            VRSUB,
            VSLIDEDOWN: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin  
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end 
              endcase
            end

            VMADC,
            VMSEQ,
            VMSNE,
            VMSLEU,
            VMSLE: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin  
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = last_uop_valid[i];
                end
              endcase
            end
            
            VMSBC,
            VMSLTU,
            VMSLT: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin  
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = last_uop_valid[i];
                end
              endcase
            end
            
            VMSGTU,
            VMSGT: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin  
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = last_uop_valid[i];
                end
              endcase
            end

            VNSRL,
            VNSRA,
            VNCLIPU,
            VNCLIP: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  vd_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end

            VWREDSUMU,
            VWREDSUM: begin
              if(inst_funct3==OPIVV) begin
                vd_offset[i] = 'b0;
                vd_valid[i]  = last_uop_valid[i];
              end
            end

            VSLIDEUP_RGATHEREI16: begin
              case(inst_funct3)
                OPIVV: begin
                  case({emul_max,emul_vd})
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d1),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL2},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL4},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL8}: begin
                      vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                      vd_valid[i]  = 1'b1;
                    end
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL2},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL4}: begin
                      vd_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                      vd_valid[i]  = 1'b1;
                    end
                  endcase
                end
                OPIVX,
                OPIVI: begin  
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end 
              endcase
            end
          endcase
        end

        valid_opm: begin
          // OPM*
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VDIVU,
            VDIV,
            VREMU,
            VREM,
            VWMUL,
            VWMULU,
            VWMULSU,
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VWMACCU,
            VWMACC,
            VWMACCSU,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB: begin
              case(inst_funct3)
                OPMVV,
                OPMVX: begin
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end   

            VXUNARY0,
            VCOMPRESS: begin
              case(inst_funct3)
                OPMVV: begin
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end

            VWMACCUS,
            VSLIDE1UP,
            VSLIDE1DOWN: begin
              case(inst_funct3)
                OPMVX: begin
                  vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end 
            
            VREDSUM,
            VREDMAXU,
            VREDMAX,
            VREDMINU,
            VREDMIN,
            VREDAND,
            VREDOR,
            VREDXOR: begin
              case(inst_funct3)
                OPMVV: begin
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = last_uop_valid[i];
                end
              endcase
            end
             
            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR: begin
              case(inst_funct3)
                OPMVV: begin
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end

            VWRXUNARY0: begin
              case(inst_funct3)
                OPMVX: begin
                  vd_offset[i] = 'b0;
                  vd_valid[i]  = 1'b1;
                end
              endcase
            end
         
            VMUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  case(vs1_opcode)
                    VMSBF,
                    VMSIF,
                    VMSOF: begin
                      vd_offset[i] = 'b0;
                      vd_valid[i]  = 1'b1;
                    end
                    VIOTA,
                    VID: begin
                      vd_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                      vd_valid[i]  = 1'b1;
                    end
                  endcase
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update vd_index and eew 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VD_OFFSET
      vd_index[i] = inst_vd + {2'b0, vd_offset[i]};
      vd_eew[i]   = eew_vd;
    end
  end

  // some uop need vd as the vs3 vector operand
  always_comb begin
    // initial
    vs3_valid = 'b0;

    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS3_VALID
      case(1'b1)
        valid_opi: begin
          // OPI*
          case(funct6_ari.ari_funct6)
            VMADC: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
            VMSBC: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
            VMSEQ,
            VMSNE,
            VMSLEU,
            VMSLE: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  vs3_valid[i] = last_uop_valid[i];
                end
              endcase
            end
            VMSLTU,
            VMSLT: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin
                  vs3_valid[i] = last_uop_valid[i];
                end
              endcase
            end
            VMSGTU,
            VMSGT: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin
                  vs3_valid[i] = last_uop_valid[i];
                end
              endcase
            end
            VSLIDEUP_RGATHEREI16: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
          endcase
        end

        valid_opm: begin
          // OPM*
          case(funct6_ari.ari_funct6)
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VWMACCU,
            VWMACC,
            VWMACCSU: begin
              case(inst_funct3)
                OPMVV,
                OPMVX: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
            VWMACCUS: begin
              case(inst_funct3)
                OPMVX: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR,
            VCOMPRESS: begin
              case(inst_funct3)
                OPMVV: begin
                  vs3_valid[i] = 1'b1;
                end
              endcase
            end
            VMUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  case(vs1_opcode)
                    VMSBF,
                    VMSIF,
                    VMSOF: begin
                      if (inst_vm==1'b0)
                        vs3_valid[i] = 1'b1;
                    end
                  endcase
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end
  
  // update vs1_offset and valid
  always_comb begin
    vs1_offset      = 'b0; 
    vs1_index_valid = 'b0;
      
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS1_OFFSET
      case(inst_funct3)
        OPIVV: begin
          case(funct6_ari.ari_funct6)
            VADD,
            VSUB,
            VADC,
            VMADC,
            VSBC,
            VMSBC,
            VAND,
            VOR,
            VXOR,
            VSLL,
            VSRL,
            VSRA,
            VMSEQ,
            VMSNE,
            VMSLTU,
            VMSLT,
            VMSLEU,
            VMSLE,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VMERGE_VMV,
            VSADDU,
            VSADD,
            VSSUBU,
            VSSUB,
            VSMUL_VMVNRR,
            VSSRL,
            VSSRA,
            VRGATHER: begin
              vs1_offset[i]      = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
              vs1_index_valid[i] = 1'b1;   
            end
            
            VNSRL,
            VNSRA,
            VNCLIPU,
            VNCLIP: begin
              vs1_offset[i]      = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
              vs1_index_valid[i] = 1'b1;
            end
            
            VWREDSUMU,
            VWREDSUM: begin
              vs1_offset[i]      = 'b0;
              vs1_index_valid[i] = last_uop_valid[i];
            end        
            
            VSLIDEUP_RGATHEREI16: begin
              case({emul_max,emul_vs1})
                {(`UOP_INDEX_WIDTH_ALU+1)'('d1),EMUL1},
                {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL2},
                {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL4},
                {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL8}: begin
                  vs1_offset[i]      = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs1_index_valid[i] = 1'b1;
                end
                {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL1},
                {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL2},
                {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL4}: begin
                  vs1_offset[i]      = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                  vs1_index_valid[i] = 1'b1;
                end
              endcase
            end
          endcase
        end

        OPMVV: begin
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VWMUL,
            VWMULU,
            VWMULSU,
            VWMACCU,
            VWMACC,
            VWMACCSU: begin
              vs1_offset[i]      = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
              vs1_index_valid[i] = 1'b1;        
            end

            VXUNARY0,
            VWRXUNARY0,
            VMUNARY0: begin
              vs1_offset[i]      = 'b0; // vs1 is regarded as opcode
              vs1_index_valid[i] = 'b0;        
            end

            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VDIVU,
            VDIV,
            VREMU,
            VREM,
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB: begin
              vs1_offset[i]      = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
              vs1_index_valid[i] = 1'b1;        
            end

            // reduction
            VREDSUM,
            VREDMAXU,
            VREDMAX,
            VREDMINU,
            VREDMIN,
            VREDAND,
            VREDOR,
            VREDXOR: begin
              vs1_offset[i]      = 'b0;
              vs1_index_valid[i] = last_uop_valid[i];
            end

            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR: begin
              vs1_offset[i]      = 'b0;
              vs1_index_valid[i] = 1'b1;
            end

            VCOMPRESS: begin
              if (first_uop_valid[i]) begin
                vs1_offset[i]      = 'b0;
                vs1_index_valid[i] = 1'b1;        
              end
            end
          endcase
        end
      endcase
    end
  end

  // update vs1(index or opcode) and eew
  always_comb begin 
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS1
      vs1[i]     = inst_vs1 + {2'b0, vs1_offset[i]}; 
      vs1_eew[i] = eew_vs1; 
    end
  end

  // some uop will use vs1 field as an opcode to decode  
  always_comb begin
    // initial
    vs1_opcode_valid = 'b0;
    
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS1_OPCODE
      case(inst_funct3)
        OPIVI: begin
          case(funct6_ari.ari_funct6)
            VSMUL_VMVNRR: begin
              vs1_opcode_valid[i] = 1'b1;   // vmvnrr.v's vs1 opcode is 5'b0, which means vmv1r.v
            end
          endcase
        end
        
        OPMVV: begin
          case(funct6_ari.ari_funct6)
            VXUNARY0: begin
              vs1_opcode_valid[i] = 1'b1;
            end
            VWRXUNARY0: begin
              case(vs1_opcode)
                VCPOP,
                VFIRST,
                VMV_X_S: begin
                  vs1_opcode_valid[i] = 1'b1;
                end
              endcase
            end
            VMUNARY0: begin
              case(vs1_opcode)
                VMSBF,
                VMSIF,
                VMSOF,
                VIOTA: begin
                  vs1_opcode_valid[i] = 1'b1;
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update vs2 offset and valid  
  always_comb begin
    // initial
    vs2_offset = 'b0; 
    vs2_valid = 'b0; 
      
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS2_OFFSET
      case(1'b1)
        valid_opi: begin
          // OPI*
          case(funct6_ari.ari_funct6)
            VADD,
            VADC,
            VMADC,
            VAND,
            VOR,
            VXOR,
            VSLL,
            VSRL,
            VSRA,
            VNSRL,
            VNSRA,
            VMSEQ,
            VMSNE,
            VMSLEU,
            VMSLE,
            VSADDU,
            VSADD,
            VSMUL_VMVNRR,
            VSSRL,
            VSSRA,
            VNCLIPU,
            VNCLIP,
            VRGATHER: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;
                end
              endcase
            end
            
            VSUB,
            VSBC,
            VMSBC,
            VMSLTU,
            VMSLT,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VSSUBU,
            VSSUB: begin
              case(inst_funct3)
                OPIVV,
                OPIVX: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;
                end
              endcase
            end

            VRSUB,
            VMSGTU,
            VMSGT,
            VSLIDEDOWN: begin
              case(inst_funct3)
                OPIVX,
                OPIVI: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;
                end
              endcase
            end
            
            VMERGE_VMV: begin
              case(inst_funct3)
                OPIVV,
                OPIVX,
                OPIVI: begin
                  if(inst_vm==1'b0) begin
                    vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                    vs2_valid[i]  = 1'b1;
                  end
                end
              endcase
            end
           
            VWREDSUMU,
            VWREDSUM: begin
              case(inst_funct3)
                OPIVV: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;
                end
              endcase
            end

            VSLIDEUP_RGATHEREI16: begin
              case(inst_funct3)
                OPIVV: begin
                  case({emul_max,emul_vs2})
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d1),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL2},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL4},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL8}: begin
                      vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                      vs2_valid[i]  = 1'b1;
                    end
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL2},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL4}: begin
                      vs2_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                      vs2_valid[i]  = 1'b1;
                    end
                  endcase
                end
                OPIVX,
                OPIVI: begin  
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;
                end 
              endcase
            end
          endcase
        end

        valid_opm: begin
          // OPM* 
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWMUL,
            VWMULU,
            VWMULSU,
            VWMACCU,
            VWMACC,
            VWMACCSU: begin
              case(inst_funct3)
                OPMVV,
                OPMVX: begin
                  vs2_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                  vs2_valid[i]  = 1'b1;        
                end
              endcase
            end
            
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VDIVU,
            VDIV,
            VREMU,
            VREM,
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB: begin
              case(inst_funct3)
                OPMVV,
                OPMVX: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;        
                end
              endcase
            end

            VXUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  case({emul_max,emul_vs2})
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d1),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d2),EMUL1},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL1}: begin
                      vs2_offset[i] = 'b0;
                      vs2_valid[i]  = 1'b1;
                    end
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d4),EMUL2},
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL4}: begin
                      vs2_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                      vs2_valid[i]  = 1'b1;
                    end
                    {(`UOP_INDEX_WIDTH_ALU+1)'('d8),EMUL2}: begin
                      vs2_offset[i] = {2'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:2]};
                      vs2_valid[i]  = 1'b1;
                    end
                  endcase
                end
              endcase
            end

            VWMACCUS: begin
              case(inst_funct3)
                OPMVX: begin
                  vs2_offset[i] = {1'b0, uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:1]};
                  vs2_valid[i]  = 1'b1;        
                end
              endcase
            end

            VREDSUM,
            VREDMAXU,
            VREDMAX,
            VREDMINU,
            VREDMIN,
            VREDAND,
            VREDOR,
            VREDXOR,
            VWRXUNARY0,
            VCOMPRESS: begin
              case(inst_funct3)
                OPMVV: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;   
                end
              endcase
            end

            VMAND,
            VMNAND,
            VMANDN,
            VMXOR,
            VMOR,
            VMNOR,
            VMORN,
            VMXNOR: begin
              case(inst_funct3)
                OPMVV: begin
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1;   
                end
              endcase
            end

            VMUNARY0: begin
              case(inst_funct3)
                OPMVV: begin
                  case(vs1_opcode)
                    VMSBF,
                    VMSIF,
                    VMSOF,
                    VIOTA: begin
                      vs2_offset[i] = 'b0;
                      vs2_valid[i]  = 1'b1;   
                    end
                  endcase
                end
              endcase
            end

            VSLIDE1UP,
            VSLIDE1DOWN: begin
              case(inst_funct3)
                OPMVX: begin
                  vs2_offset[i] = uop_index_current[i][`UOP_INDEX_WIDTH_ALU-1:0];
                  vs2_valid[i]  = 1'b1;        
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update vs2 index and eew   
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS2
      vs2_index[i] = inst_vs2 + {2'b0, vs2_offset[i]}; 
      vs2_eew[i]   = eew_vs2; 
    end
  end

  // update rd_index and valid
  always_comb begin
    // initial
    rd_index       = 'b0;
    rd_index_valid = 'b0;
     
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_RD
      case(funct6_ari.ari_funct6)
        VWRXUNARY0: begin
          case(inst_funct3)
            OPMVV: begin
              case(vs1_opcode)
                VCPOP,
                VFIRST,
                VMV_X_S: begin
                  rd_index[i]         = inst_rd;
                  rd_index_valid[i]   = 1'b1;
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update rs1_data and rs1_data_valid 
  always_comb begin
    // initial
    rs1_data       = 'b0;
    rs1_data_valid = 'b0;
      
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_RS1
      case(1'b1)
        valid_opi: begin
          // OPI*
          case(funct6_ari.ari_funct6)
            VADD,
            VRSUB,
            VADC,
            VMADC,
            VAND,
            VOR,
            VXOR,
            VMSEQ,
            VMSNE,
            VMSLEU,
            VMSLE,
            VMSGTU,
            VMSGT,
            VMERGE_VMV,
            VSADDU,
            VSADD: begin
              case(inst_funct3)
                OPIVX: begin
                  rs1_data[i]       = rs1;
                  rs1_data_valid[i] = 1'b1;
                end
                OPIVI: begin
                  rs1_data[i]       = {{(`XLEN-`IMM_WIDTH){inst_imm[`IMM_WIDTH-1]}},inst_imm[`IMM_WIDTH-1:0]};
                  rs1_data_valid[i] = 1'b1;
                end
              endcase
            end
          
            VSUB,
            VSBC,
            VMSBC,
            VMSLTU,
            VMSLT,
            VMINU,
            VMIN,
            VMAXU,
            VMAX,
            VSSUBU,
            VSSUB,
            VSMUL_VMVNRR: begin
              case(inst_funct3)
                OPIVX: begin
                  rs1_data[i]       = rs1;
                  rs1_data_valid[i] = 1'b1;
                end
              endcase
            end  

            VSLL,
            VSRL,
            VSRA,
            VNSRL,
            VNSRA,
            VSSRL,
            VSSRA,
            VNCLIPU,
            VNCLIP,
            VSLIDEUP_RGATHEREI16,
            VSLIDEDOWN,
            VRGATHER: begin
              case(inst_funct3)
                OPIVX: begin
                  rs1_data[i]       = rs1;
                  rs1_data_valid[i] = 1'b1;
                end
                OPIVI: begin
                  rs1_data[i]       = {{(`XLEN-`IMM_WIDTH){1'b0}},inst_imm[`IMM_WIDTH-1:0]};
                  rs1_data_valid[i] = 1'b1;
                end
              endcase
            end
          endcase
        end
        
        valid_opm: begin
          // OPM*
          case(funct6_ari.ari_funct6)
            VWADDU,
            VWSUBU,
            VWADD,
            VWSUB,
            VWADDU_W,
            VWSUBU_W,
            VWADD_W,
            VWSUB_W,
            VMUL,
            VMULH,
            VMULHU,
            VMULHSU,
            VDIVU,
            VDIV,
            VREMU,
            VREM,
            VWMUL,
            VWMULU,
            VWMULSU,
            VMACC,
            VNMSAC,
            VMADD,
            VNMSUB,
            VWMACCU,
            VWMACC,
            VWMACCSU,
            VWMACCUS,
            VAADDU,
            VAADD,
            VASUBU,
            VASUB,
            VWRXUNARY0,
            VSLIDE1UP,
            VSLIDE1DOWN: begin
              case(inst_funct3)
                OPMVX: begin
                  rs1_data[i]       = rs1;
                  rs1_data_valid[i] = 1'b1;
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update first_uop valid
  always_comb begin
    // initial 
    first_uop_valid = 'b0;
    
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_FIRST
      first_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == uop_vstart;

      case(1'b1)
        valid_opi: begin
          case(funct6_ari.ari_funct6)
            VSLIDEUP_RGATHEREI16,
            VRGATHER: begin
              first_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == 'b0;
            end
          endcase
        end
        valid_opm: begin
          case(funct6_ari.ari_funct6)
            VSLIDE1UP: begin
              first_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == 'b0;
            end
          endcase
        end
      endcase
    end
  end

  // update last_uop valid
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_LAST
      last_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == uop_index_max;
    end
  end

  // update uop index
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: ASSIGN_UOP_INDEX
      uop_index[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0];
    end
  end
  
  // update segment_index
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: ASSIGN_SEG_INDEX
      seg_field_index[i] = 'b0;
    end
  end

  // pshrob_valid decide on whether this uop is pushed into ROB.
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: PSHROB_VLD
      pshrob_valid[i] = ((uop_exe_unit[i]==CMP)||(uop_exe_unit[i]==RDT)) ? last_uop_valid[i] : 'b1;
    end
  end

  // assign result to output
  generate
    for(j=0;j<`NUM_DE_UOP;j++) begin: ASSIGN_RES
    `ifdef TB_SUPPORT
      assign uop[j].uop_pc              = uop_pc[j];
    `endif  
      assign uop[j].uop_funct3          = uop_funct3[j];
      assign uop[j].uop_funct6          = uop_funct6[j];
      assign uop[j].uop_exe_unit        = uop_exe_unit[j]; 
      assign uop[j].uop_class           = uop_class[j];   
      assign uop[j].vector_csr          = vector_csr[j];  
      assign uop[j].vs_evl              = vs_evl[j];            
      assign uop[j].ignore_vma          = ignore_vma[j];
      assign uop[j].ignore_vta          = ignore_vta[j];
      assign uop[j].force_vma_agnostic  = force_vma_agnostic[j];
      assign uop[j].force_vta_agnostic  = force_vta_agnostic[j];
      assign uop[j].vm                  = vm[j];                
      assign uop[j].v0_valid            = v0_valid[j];          
      assign uop[j].vd_index            = vd_index[j];          
      assign uop[j].vd_eew              = vd_eew[j];  
      assign uop[j].vd_valid            = vd_valid[j];
      assign uop[j].vs3_valid           = vs3_valid[j];         
      assign uop[j].vs1                 = vs1[j];              
      assign uop[j].vs1_eew             = vs1_eew[j];           
      assign uop[j].vs1_index_valid     = vs1_index_valid[j];
      assign uop[j].vs1_opcode_valid    = vs1_opcode_valid[j];
      assign uop[j].vs2_index 	        = vs2_index[j]; 	       
      assign uop[j].vs2_eew             = vs2_eew[j];
      assign uop[j].vs2_valid           = vs2_valid[j];
      assign uop[j].rd_index 	          = rd_index[j]; 	       
      assign uop[j].rd_index_valid      = rd_index_valid[j]; 
      assign uop[j].rs1_data            = rs1_data[j];           
      assign uop[j].rs1_data_valid      = rs1_data_valid[j];    
      assign uop[j].uop_index           = uop_index[j];         
      assign uop[j].first_uop_valid     = first_uop_valid[j];   
      assign uop[j].last_uop_valid      = last_uop_valid[j];    
      assign uop[j].seg_field_index     = seg_field_index[j];   
      assign uop[j].pshrob_valid        = pshrob_valid[j];   
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_decode_unit_lsu.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_decode_unit_lsu
(
  inst_valid,
  inst,
  uop_index_remain,
  uop_valid,
  uop
);
//
// interface signals
//
  input   logic                               inst_valid;
  input   RVVCmd                              inst;
  input   logic       [`UOP_INDEX_WIDTH-1:0]  uop_index_remain;
  
  output  logic       [`NUM_DE_UOP-1:0]       uop_valid;
  output  UOP_QUEUE_t [`NUM_DE_UOP-1:0]       uop;

//
// internal signals
//
  // split INST_t struct signals
  logic   [`FUNCT6_WIDTH-1:0]                     inst_funct6;      // inst original encoding[31:26]           
  logic   [`NFIELD_WIDTH-1:0]                     inst_nf;          // inst original encoding[31:29]
  logic   [`VM_WIDTH-1:0]                         inst_vm;          // inst original encoding[25]      
  logic   [`REGFILE_INDEX_WIDTH-1:0]              inst_vs2;         // inst original encoding[24:20]
  logic   [`UMOP_WIDTH-1:0]                       inst_umop;        // inst original encoding[24:20]
  logic   [`FUNCT3_WIDTH-1:0]                     inst_funct3;      // inst original encoding[14:12]
  logic   [`REGFILE_INDEX_WIDTH-1:0]              inst_vd;          // inst original encoding[11:7]
  RVVOpCode                                       inst_opcode;      // inst original encoding[6:0]

  RVVConfigState                                  vector_csr_lsu;
  logic   [`VSTART_WIDTH-1:0]                     csr_vstart;
  logic   [`VL_WIDTH-1:0]                         csr_vl;
  logic   [`VL_WIDTH-1:0]                         evl;
  RVVSEW                                          csr_sew;
  RVVLMUL                                         csr_lmul;
  EMUL_e                                          emul_vd;          
  EMUL_e                                          emul_vs2;          
  EMUL_e                                          emul_vd_nf; 
  EMUL_e                                          emul_max; 
  EEW_e                                           eew_vd;          
  EEW_e                                           eew_vs2;          
  EEW_e                                           eew_max;         
  logic                                           valid_lsu;
  logic                                           valid_lsu_opcode;
  logic                                           valid_lsu_mop;
  logic                                           inst_encoding_correct;
  logic                                           check_special;
  logic                                           check_vd_overlap_v0;
  logic                                           check_vd_part_overlap_vs2;
  logic   [`REGFILE_INDEX_WIDTH:0]                vd_index_start;
  logic   [`REGFILE_INDEX_WIDTH:0]                vd_index_end;
  logic   [`REGFILE_INDEX_WIDTH-1:0]              vd_index_offset;
  logic                                           check_vd_overlap_vs2;
  logic                                           check_vs2_part_overlap_vd_2_1;
  logic                                           check_vs2_part_overlap_vd_4_1;
  logic                                           check_common;
  logic                                           check_vd_align;
  logic                                           check_vs2_align;
  logic                                           check_vd_in_range;
  logic   [`REGFILE_INDEX_WIDTH-1:0]              check_vd_cmp;
  logic                                           check_sew;
  logic                                           check_lmul;
  logic                                           check_evl_not_0;
  logic                                           check_vstart_sle_evl;
  logic   [`UOP_INDEX_WIDTH-1:0]                  uop_index_base;         
  logic   [`NUM_DE_UOP-1:0][`UOP_INDEX_WIDTH:0]   uop_index_current;   
  logic   [`UOP_INDEX_WIDTH-1:0]                  uop_index_max;         
   
  // convert logic to enum/union
  FUNCT6_u                                        funct6_lsu;

  // result
`ifdef TB_SUPPORT
  logic   [`NUM_DE_UOP-1:0][`PC_WIDTH-1:0]            uop_pc;
`endif
  logic   [`NUM_DE_UOP-1:0][`FUNCT3_WIDTH-1:0]        uop_funct3;
  FUNCT6_u        [`NUM_DE_UOP-1:0]                   uop_funct6;
  EXE_UNIT_e      [`NUM_DE_UOP-1:0]                   uop_exe_unit; 
  UOP_CLASS_e     [`NUM_DE_UOP-1:0]                   uop_class;   
  RVVConfigState  [`NUM_DE_UOP-1:0]                   vector_csr;  
  logic   [`NUM_DE_UOP-1:0][`VL_WIDTH-1:0]            vs_evl;             
  logic   [`NUM_DE_UOP-1:0]                           ignore_vma;
  logic   [`NUM_DE_UOP-1:0]                           ignore_vta;
  logic   [`NUM_DE_UOP-1:0]                           force_vma_agnostic; 
  logic   [`NUM_DE_UOP-1:0]                           force_vta_agnostic; 
  logic   [`NUM_DE_UOP-1:0]                           vm;                 
  logic   [`NUM_DE_UOP-1:0]                           v0_valid;           
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vd_index;           
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    vd_offset;
  EEW_e   [`NUM_DE_UOP-1:0]                           vd_eew;  
  logic   [`NUM_DE_UOP-1:0]                           vd_valid;
  logic   [`NUM_DE_UOP-1:0]                           vs3_valid;          
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vs1;              
  EEW_e   [`NUM_DE_UOP-1:0]                           vs1_eew;            
  logic   [`NUM_DE_UOP-1:0]                           vs1_index_valid;
  logic   [`NUM_DE_UOP-1:0]                           vs1_opcode_valid;
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] vs2_index; 	        
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    vs2_offset;
  EEW_e   [`NUM_DE_UOP-1:0]                           vs2_eew;
  logic   [`NUM_DE_UOP-1:0]                           vs2_valid;
  logic   [`NUM_DE_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_index; 	        
  logic   [`NUM_DE_UOP-1:0]                           rd_index_valid; 
  logic   [`NUM_DE_UOP-1:0][`XLEN-1:0] 	              rs1_data;           
  logic   [`NUM_DE_UOP-1:0]     	                    rs1_data_valid;     
  logic   [`NUM_DE_UOP-1:0][`UOP_INDEX_WIDTH-1:0]     uop_index;          
  logic   [`NUM_DE_UOP-1:0]                           first_uop_valid;    
  logic   [`NUM_DE_UOP-1:0]                           last_uop_valid;     
  logic   [`NUM_DE_UOP-1:0][$clog2(`EMUL_MAX)-1:0]    seg_field_index;
  logic   [`NUM_DE_UOP-1:0]                           pshrob_valid;     

  // use for for-loop 
  genvar                                          j;
  
  // local parameter for SEW in original endocing[14:12]
  localparam  SEW_8     = 3'b000;
  localparam  SEW_16    = 3'b101;
  localparam  SEW_32    = 3'b110;

//
// decode
//
  assign inst_funct6    = inst.bits[24:19];
  assign inst_nf        = inst.bits[24:22];
  assign inst_vm        = inst.bits[18];
  assign inst_vs2       = inst.bits[17:13];
  assign inst_umop      = inst.bits[17:13];
  assign inst_funct3    = inst.bits[7:5];
  assign inst_vd        = inst.bits[4:0];
  assign inst_opcode    = inst.opcode;
  assign vector_csr_lsu = inst.arch_state;
  assign csr_vstart     = inst.arch_state.vstart;
  assign csr_vl         = inst.arch_state.vl;
  assign csr_sew        = inst.arch_state.sew;
  assign csr_lmul       = inst.arch_state.lmul;
  
// decode funct6
  // valid signal
  assign valid_lsu = valid_lsu_opcode&valid_lsu_mop&inst_valid;

  // identify load or store
  always_comb begin
    funct6_lsu.lsu_funct6.lsu_is_store = IS_LOAD;
    valid_lsu_opcode                   = 'b0;

    case(inst_opcode)
      LOAD: begin
        funct6_lsu.lsu_funct6.lsu_is_store = IS_LOAD;
        valid_lsu_opcode                   = 1'b1;
      end
      STORE: begin
        funct6_lsu.lsu_funct6.lsu_is_store = IS_STORE;
        valid_lsu_opcode                   = 1'b1;
      end
    endcase

  // lsu_mop distinguishes unit-stride, constant-stride, unordered index, ordered index
  // lsu_umop identifies what unit-stride instruction belong to when lsu_mop=US
    // initial 
    funct6_lsu.lsu_funct6.lsu_mop    = US;
    funct6_lsu.lsu_funct6.lsu_umop   = US_US;
    funct6_lsu.lsu_funct6.lsu_is_seg = NONE;
    valid_lsu_mop                    = 'b0;
    
    case(inst_funct6[2:0])
      UNIT_STRIDE: begin
        case(inst_umop)
          US_REGULAR: begin          
            funct6_lsu.lsu_funct6.lsu_mop    = US;
            funct6_lsu.lsu_funct6.lsu_umop   = US_US;
            valid_lsu_mop                    = 1'b1;
            funct6_lsu.lsu_funct6.lsu_is_seg = (inst_nf!=NF1) ? IS_SEGMENT : NONE;
          end
          US_WHOLE_REGISTER: begin
            funct6_lsu.lsu_funct6.lsu_mop    = US;
            funct6_lsu.lsu_funct6.lsu_umop   = US_WR;
            valid_lsu_mop                    = 1'b1;
          end
          US_MASK: begin
            funct6_lsu.lsu_funct6.lsu_mop    = US;
            funct6_lsu.lsu_funct6.lsu_umop   = US_MK;
            valid_lsu_mop                    = 1'b1;
          end
          US_FAULT_FIRST: begin
            funct6_lsu.lsu_funct6.lsu_mop    = US;
            funct6_lsu.lsu_funct6.lsu_umop   = US_FF;
            valid_lsu_mop                    = 1'b1;
            funct6_lsu.lsu_funct6.lsu_is_seg = (inst_nf!=NF1) ? IS_SEGMENT : NONE;
          end
        endcase
      end
      UNORDERED_INDEX: begin
        funct6_lsu.lsu_funct6.lsu_mop    = IU;
        valid_lsu_mop                    = 1'b1;
        funct6_lsu.lsu_funct6.lsu_is_seg = (inst_nf!=NF1) ? IS_SEGMENT : NONE;
      end
      CONSTANT_STRIDE: begin
        funct6_lsu.lsu_funct6.lsu_mop    = CS;
        valid_lsu_mop                    = 1'b1;
        funct6_lsu.lsu_funct6.lsu_is_seg = (inst_nf!=NF1) ? IS_SEGMENT : NONE;
      end
      ORDERED_INDEX: begin
        funct6_lsu.lsu_funct6.lsu_mop    = IO;
        valid_lsu_mop                    = 1'b1;
        funct6_lsu.lsu_funct6.lsu_is_seg = (inst_nf!=NF1) ? IS_SEGMENT : NONE;
      end
    endcase
  end

// get EMUL
  always_comb begin
    // initial
    emul_vd         = EMUL_NONE;
    emul_vs2        = EMUL_NONE;
    emul_vd_nf      = EMUL_NONE;
    emul_max        = EMUL_NONE;
    uop_index_max   = 'd0;

    if (valid_lsu) begin  
      case(funct6_lsu.lsu_funct6.lsu_mop)
        US: begin
          case(funct6_lsu.lsu_funct6.lsu_umop)
            US_US,
            US_FF: begin
              case(inst_nf)
                // emul_vd = ceil(inst_funct3/csr_sew*csr_lmul)
                // emul_vd_nf = NF*emul_vd
                // emul_vs2: no emul_vs2 for unit
                // emul_max = max(emul_vd_nf,emul_vs2) = emul_vd_nf
                // uop_index_max = NF*max(emul_vd,emul_vs2) = emul_vd_nf
                NF1: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL1;
                          emul_max      = EMUL1;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                          emul_max      = EMUL_e'({1'b0, csr_lmul});
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                          emul_max      = EMUL_e'({1'b0, csr_lmul});
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                          emul_max      = EMUL_e'({1'b0, csr_lmul});
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL1;
                          emul_max      = EMUL1;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL8;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL1;
                          emul_max      = EMUL1;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                        end
                        LMUL1_2: begin    
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL8;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL1;
                          emul_max      = EMUL1;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL1;
                          emul_max      = EMUL1;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                      endcase
                    end
                  endcase
                end
                NF2: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL1_2: begin    
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL4;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL2;
                          emul_max      = EMUL2;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                      endcase
                    end
                  endcase
                end
                NF3: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL3;
                          emul_max      = EMUL3;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL3;
                          emul_max      = EMUL3;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL3;
                          emul_max      = EMUL3;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                        end
                        LMUL1_2: begin    
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL3;
                          emul_max      = EMUL3;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL3;
                          emul_max      = EMUL3;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                  endcase
                end
                NF4: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL2: begin
                          emul_vd       = EMUL_e'({1'b0, csr_lmul});
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL1: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL1_2: begin    
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL4: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL4;
                          emul_max      = EMUL4;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                        end
                        LMUL8: begin
                          emul_vd       = EMUL2;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                  endcase
                end
                NF5: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL5;
                          emul_max      = EMUL5;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL5;
                          emul_max      = EMUL5;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL5;
                          emul_max      = EMUL5;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL5;
                          emul_max      = EMUL5;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL5;
                          emul_max      = EMUL5;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                        end
                      endcase
                    end
                  endcase
                end
                NF6: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end                
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL6;
                          emul_max      = EMUL6;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                        end
                      endcase
                    end
                  endcase
                end
                NF7: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL7;
                          emul_max      = EMUL7;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL7;
                          emul_max      = EMUL7;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL7;
                          emul_max      = EMUL7;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL7;
                          emul_max      = EMUL7;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL7;
                          emul_max      = EMUL7;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                        end
                      endcase
                    end
                  endcase
                end
                NF8: begin
                  case({inst_funct3,csr_sew})
                    // 1:1
                    {SEW_8,SEW8},
                    {SEW_16,SEW16},
                    {SEW_32,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2,
                        LMUL1: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 2:1
                    {SEW_16,SEW8},
                    {SEW_32,SEW16}: begin            
                      case(csr_lmul)
                        LMUL1_4,
                        LMUL1_2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 4:1
                    {SEW_32,SEW8}: begin            
                      case(csr_lmul)
                        LMUL1_4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:2
                    {SEW_8,SEW16},
                    {SEW_16,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1_2,
                        LMUL1,
                        LMUL2: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                    // 1:4
                    {SEW_8,SEW32}: begin            
                      case(csr_lmul)
                        LMUL1,
                        LMUL2,
                        LMUL4: begin
                          emul_vd       = EMUL1;
                          emul_vd_nf    = EMUL8;
                          emul_max      = EMUL8;
                          uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                        end
                      endcase
                    end
                  endcase
                end
              endcase
            end
            US_WR: begin
              case(inst_nf)
                NF1: begin
                  emul_vd       = EMUL1;
                  emul_vd_nf    = EMUL1;
                  emul_max      = EMUL1;
                  uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                end
                NF2: begin
                  emul_vd       = EMUL2;
                  emul_vd_nf    = EMUL2;
                  emul_max      = EMUL2;
                  uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                end
                NF4: begin
                  emul_vd       = EMUL4;
                  emul_vd_nf    = EMUL4;
                  emul_max      = EMUL4;
                  uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                end
                NF8: begin
                  emul_vd       = EMUL8;
                  emul_vd_nf    = EMUL8;
                  emul_max      = EMUL8;
                  uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                end
              endcase
            end
            US_MK: begin
              case(csr_lmul)
                LMUL1_4,
                LMUL1_2,
                LMUL1,
                LMUL2,
                LMUL4,
                LMUL8: begin
                  emul_vd       = EMUL1;
                  emul_vd_nf    = EMUL1;
                  emul_max      = EMUL1;
                  uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                end
              endcase
            end
          endcase
        end

        CS: begin
          case(inst_nf)
            // emul_vd = ceil(inst_funct3/csr_sew*csr_lmul)
            // emul_vs2: no emul_vs2 for unit
            // emul_vd_nf = NF*emul_vd
            // emul_max = max(emul_vd_nf,emul_vs2) = emul_vd_nf
            // uop_index_max = NF*max(emul_vd,emul_vs2) = emul_vd_nf
            NF1: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL8;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL8;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                  endcase
                end
              endcase
            end
            NF2: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                  endcase
                end
              endcase
            end
            NF3: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
              endcase
            end
            NF4: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
            NF5: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
              endcase
            end
            NF6: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end                
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
              endcase
            end
            NF7: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
              endcase
            end
            NF8: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1,
                    LMUL2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1,
                    LMUL2,
                    LMUL4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
          endcase
        end
        
        IU,
        IO: begin
          case(inst_nf)
            // emul_vd = ceil(csr_lmul)
            // emul_vd_nf = NF*emul_vd
            // emul_vs2 = ceil(inst_funct3/csr_sew*csr_lmul)
            // emul_max = max(emul_vd_nf,emul_vs2) 
            // uop_index_max = NF*max(emul_vd,emul_vs2)
            NF1: begin
              case({inst_funct3,csr_sew})
                // 1:1
                // {vs2,vd}
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL1;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL1;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d0);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL8: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL_e'({1'b0, csr_lmul});
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL_e'({1'b0, csr_lmul});
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
            NF2: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL2;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL4;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL2;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL2;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d1);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL4: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
            NF3: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d11);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                    LMUL1: begin    
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d11);
                    end
                    LMUL2: begin    
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d23);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL3;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL3;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d2);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
              endcase
            end
            NF4: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL_e'({1'b0, csr_lmul});
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL1_2: begin    
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL1: begin    
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                    LMUL2: begin    
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL8;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d31);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL4;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL4;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d3);
                    end
                    LMUL2: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
            NF5: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d9);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d9);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d19);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL5;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL5;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d4);
                    end
                  endcase
                end
              endcase
            end
            NF6: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d11);
                    end
                  endcase
                end                
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d11);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d23);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL6;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL6;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d5);
                    end
                  endcase
                end
              endcase
            end
            NF7: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d13);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d13);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d27);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL7;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL7;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d6);
                    end
                  endcase
                end
              endcase
            end
            NF8: begin
              case({inst_funct3,csr_sew})
                // 1:1
                {SEW_8,SEW8},
                {SEW_16,SEW16},
                {SEW_32,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 2:1
                {SEW_16,SEW8},
                {SEW_32,SEW16}: begin            
                  case(csr_lmul)
                    LMUL1_4,
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                  endcase
                end
                // 4:1
                {SEW_32,SEW8}: begin            
                  case(csr_lmul)
                    LMUL1_4: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                    LMUL1_2: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL2;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d15);
                    end
                    LMUL1: begin
                      emul_vd       = EMUL_e'({1'b0, csr_lmul});
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL4;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d31);
                    end
                  endcase
                end
                // 1:2
                {SEW_8,SEW16},
                {SEW_16,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1_2,
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
                // 1:4
                {SEW_8,SEW32}: begin            
                  case(csr_lmul)
                    LMUL1: begin
                      emul_vd       = EMUL1;
                      emul_vd_nf    = EMUL8;
                      emul_vs2      = EMUL1;
                      emul_max      = EMUL8;
                      uop_index_max = (`UOP_INDEX_WIDTH)'('d7);
                    end
                  endcase
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

// get EEW 
  always_comb begin
    // initial
    eew_vd  = EEW_NONE;
    eew_vs2 = EEW_NONE;
    eew_max = EEW_NONE;  

    if (valid_lsu) begin  
      case(funct6_lsu.lsu_funct6.lsu_mop)
        US: begin
          case(funct6_lsu.lsu_funct6.lsu_umop)
            US_US,
            US_WR,
            US_FF: begin
              case(inst_funct3)
                SEW_8: begin
                  eew_vd          = EEW8;
                  eew_max         = EEW8;
                end
                SEW_16: begin
                  eew_vd          = EEW16;
                  eew_max         = EEW16;
                end
                SEW_32: begin
                  eew_vd          = EEW32;
                  eew_max         = EEW32;
                end
              endcase
            end
            US_MK: begin
              case(inst_funct3)
                SEW_8: begin
                  eew_vd          = EEW1;
                  eew_max         = EEW1;
                end
              endcase
            end
          endcase
        end
        CS: begin
          case(inst_funct3)
            SEW_8: begin
              eew_vd          = EEW8;
              eew_max         = EEW8;
            end
            SEW_16: begin
              eew_vd          = EEW16;
              eew_max         = EEW16;
            end
            SEW_32: begin
              eew_vd          = EEW32;
              eew_max         = EEW32;
            end
          endcase
        end
        IU,
        IO: begin
          case({inst_funct3,csr_sew})
            {SEW_8,SEW8}: begin
              eew_vd          = EEW8;
              eew_vs2         = EEW8;
              eew_max         = EEW8;
            end
            {SEW_8,SEW16}: begin
              eew_vd          = EEW16;
              eew_vs2         = EEW8;
              eew_max         = EEW16;
            end
            {SEW_8,SEW32}: begin
              eew_vd          = EEW32;
              eew_vs2         = EEW8;
              eew_max         = EEW32;
            end
            {SEW_16,SEW8}: begin
              eew_vd          = EEW8;
              eew_vs2         = EEW16;
              eew_max         = EEW16;
            end
            {SEW_16,SEW16}: begin
              eew_vd          = EEW16;
              eew_vs2         = EEW16;
              eew_max         = EEW16;
            end
            {SEW_16,SEW32}: begin
              eew_vd          = EEW32;
              eew_vs2         = EEW16;
              eew_max         = EEW32;
            end
            {SEW_32,SEW8}: begin
              eew_vd          = EEW8;
              eew_vs2         = EEW32;
              eew_max         = EEW32;
            end
            {SEW_32,SEW16}: begin
              eew_vd          = EEW16;
              eew_vs2         = EEW32;
              eew_max         = EEW32;
            end
            {SEW_32,SEW32}: begin
              eew_vd          = EEW32;
              eew_vs2         = EEW32;
              eew_max         = EEW32;
            end
          endcase
        end
      endcase
    end
  end

//  
// instruction encoding error check
//
  assign inst_encoding_correct = check_special&check_common;

  // check whether vd overlaps v0 when vm=0
  // check_vd_overlap_v0=1 means that vd does NOT overlap v0
  assign check_vd_overlap_v0 = (((inst_vm==1'b0)&(inst_vd!='b0)) | (inst_vm==1'b1));

  // check whether vd partially overlaps vs2 with EEW_vd<EEW_vs2
  // check_vd_part_overlap_vs2=1 means that vd group does NOT overlap vs2 group partially
  // used in regular index load/store
  always_comb begin
    check_vd_part_overlap_vs2     = 'b0;          
    
    case(emul_vs2)
      EMUL1: begin
        check_vd_part_overlap_vs2 = 1'b1;          
      end
      EMUL2: begin
        check_vd_part_overlap_vs2 = !((inst_vd[0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])));
      end
      EMUL4: begin
        check_vd_part_overlap_vs2 = !((inst_vd[1:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])));
      end
      EMUL8 : begin
        check_vd_part_overlap_vs2 = !((inst_vd[2:0]!='b0) & ((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])));
      end
    endcase
  end

  // vd cannot overlap vs2
  // check_vd_overlap_vs2=1 means that vd group does NOT overlap vs2 group fully
  // used in segment index load/store
  assign vd_index_start = {1'b0,inst_vd};

  always_comb begin
    case(emul_vd_nf)
      EMUL2:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d1);
      EMUL3:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d2);
      EMUL4:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d3);
      EMUL5:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d4);
      EMUL6:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d5);
      EMUL7:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d6);
      EMUL8:   vd_index_offset = (`REGFILE_INDEX_WIDTH)'('d7);
      default: vd_index_offset = 'b0;
    endcase
  end
  assign vd_index_end = {1'b0, inst_vd+vd_index_offset};

  always_comb begin                                                             
    check_vd_overlap_vs2 = 'b0;          
    
    case(emul_vs2)
      EMUL1: begin
        check_vd_overlap_vs2 = ({1'b0,inst_vs2}<vd_index_start) || 
                               ({1'b0,inst_vs2}>vd_index_end);          
      end
      EMUL2: begin
        check_vd_overlap_vs2 = ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:1]}<vd_index_start[`REGFILE_INDEX_WIDTH:1]) || 
                               ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:1]}>vd_index_end[`REGFILE_INDEX_WIDTH:1]);          
      end
      EMUL4: begin
        check_vd_overlap_vs2 = ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:2]}<vd_index_start[`REGFILE_INDEX_WIDTH:2]) || 
                               ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:2]}>vd_index_end[`REGFILE_INDEX_WIDTH:2]);          
      end
      EMUL8 : begin
        check_vd_overlap_vs2 = ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:3]}<vd_index_start[`REGFILE_INDEX_WIDTH:3]) || 
                               ({1'b0,inst_vs2[`REGFILE_INDEX_WIDTH-1:3]}>vd_index_end[`REGFILE_INDEX_WIDTH:3]);          
      end
    endcase
  end

  // check whether vs2 partially overlaps vd for EEW_vd:EEW_vs2=2:1
  // used in regular index load/store
  always_comb begin
    check_vs2_part_overlap_vd_2_1 = 'b0;

    case(emul_vd)
      EMUL1: begin
        check_vs2_part_overlap_vd_2_1 = 1'b1;
      end
      EMUL2: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])&(inst_vs2[0]!=1'b1));
      end
      EMUL4: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])&(inst_vs2[1:0]!=2'b10));
      end
      EMUL8: begin
        check_vs2_part_overlap_vd_2_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])&(inst_vs2[2:0]!=3'b100));
      end
    endcase
  end

  // check whether vs2 partially overlaps vd for EEW_vd:EEW_vs2=4:1
  // used in regular index load/store
  always_comb begin
    check_vs2_part_overlap_vd_4_1 = 'b0;

    case(emul_vd)
      EMUL1: begin
        check_vs2_part_overlap_vd_4_1 = 1'b1;
      end
      EMUL2: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:1]==inst_vs2[`REGFILE_INDEX_WIDTH-1:1])&(inst_vs2[0]!=1'b1));
      end
      EMUL4: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:2]==inst_vs2[`REGFILE_INDEX_WIDTH-1:2])&(inst_vs2[1:0]!=2'b11));
      end
      EMUL8: begin
        check_vs2_part_overlap_vd_4_1 = !((inst_vd[`REGFILE_INDEX_WIDTH-1:3]==inst_vs2[`REGFILE_INDEX_WIDTH-1:3])&(inst_vs2[2:0]!=3'b110));
      end
    endcase
  end

  // start to check special requirements for every instructions
  always_comb begin 
    check_special = 'b0;

    case(inst_funct6[2:0])
      UNIT_STRIDE: begin
        case(inst_umop)
          US_REGULAR: begin
            check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0 : 1'b1;
          end
          US_WHOLE_REGISTER: begin
            check_special = inst_vm&((inst_opcode==LOAD)||((inst_opcode==STORE)&(inst_funct3==SEW_8)));
          end
          US_MASK: begin
            check_special = inst_vm&(inst_funct3==SEW_8)&(inst_funct6[5:3]=='b0);
          end
          US_FAULT_FIRST: begin
            check_special = check_vd_overlap_v0&(inst_opcode==LOAD);
          end
        endcase
      end
      
      CONSTANT_STRIDE: begin
        check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0 : 1'b1;
      end
      
      UNORDERED_INDEX,
      ORDERED_INDEX: begin
        if (inst_nf==NF1) begin
          case({inst_funct3,csr_sew})
            // EEW_vs2:EEW_vd = 1:1
            {SEW_8,SEW8},
            {SEW_16,SEW16},
            {SEW_32,SEW32}: begin            
              check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0 : 1'b1;
            end
            // 2:1
            {SEW_16,SEW8},
            {SEW_32,SEW16},            
            // 4:1
            {SEW_32,SEW8}: begin            
              check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0&check_vd_part_overlap_vs2 : 1'b1;
            end
            // 1:2
            {SEW_8,SEW16},
            {SEW_16,SEW32}: begin            
              check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0&check_vs2_part_overlap_vd_2_1 : 1'b1;
            end
            // 1:4
            {SEW_8,SEW32}: begin            
              check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0&check_vs2_part_overlap_vd_4_1 : 1'b1;
            end
          endcase
        end
        else begin
          // segment indexed ld, vd group cannot overlap vs2 group fully
          check_special = (inst_opcode==LOAD) ? check_vd_overlap_v0&check_vd_overlap_vs2 : 1'b1;
        end        
      end
    endcase
  end

  //check common requirements for all instructions
  assign check_common = check_vd_align&check_vs2_align&check_vd_in_range&check_sew&check_lmul&check_evl_not_0&check_vstart_sle_evl;

  // check whether vd is aligned to emul_vd
  always_comb begin
    check_vd_align = 'b0; 

    case(emul_vd)
      EMUL_NONE,
      EMUL1: begin
        check_vd_align = 1'b1; 
      end
      EMUL2: begin
        check_vd_align = (inst_vd[0]==1'b0); 
      end
      EMUL4: begin
        check_vd_align = (inst_vd[1:0]==2'b0); 
      end
      EMUL8: begin
        check_vd_align = (inst_vd[2:0]==3'b0); 
      end
    endcase
  end

  // check whether vs2 is aligned to emul_vs2
  always_comb begin
    check_vs2_align = 'b0; 

    case(emul_vs2)
      EMUL_NONE,
      EMUL1: begin
        check_vs2_align = 1'b1; 
      end
      EMUL2: begin
        check_vs2_align = (inst_vs2[0]==1'b0); 
      end
      EMUL4: begin
        check_vs2_align = (inst_vs2[1:0]==2'b0); 
      end
      EMUL8: begin
        check_vs2_align = (inst_vs2[2:0]==3'b0); 
      end
    endcase
  end
  
  // check vd/vs3 is in 0-31 for segment load/store
  always_comb begin 
    case(emul_vd_nf)
      EMUL1:   check_vd_cmp = 'd31;
      EMUL2:   check_vd_cmp = 'd30;
      EMUL3:   check_vd_cmp = 'd29;
      EMUL4:   check_vd_cmp = 'd28;
      EMUL5:   check_vd_cmp = 'd27;
      EMUL6:   check_vd_cmp = 'd26;
      EMUL7:   check_vd_cmp = 'd25;
      EMUL8:   check_vd_cmp = 'd24;
      default: check_vd_cmp = 'b0;
    endcase
  end
  assign check_vd_in_range = (emul_vd_nf!=EMUL_NONE) ? inst_vd <= check_vd_cmp : 'b0;

  // check the validation of EEW
  assign check_sew = (eew_max != EEW_NONE);
    
  // check the validation of EMUL
  assign check_lmul = (emul_max != EMUL_NONE);

  // get evl
  always_comb begin
    evl = csr_vl;
    
    case(inst_funct6[2:0])
      UNIT_STRIDE: begin
        case(inst_umop)
          US_WHOLE_REGISTER: begin
            // evl = NFIELD*VLEN/EEW
            case(emul_max)
              EMUL1: begin
                case(eew_max)
                  EEW8: begin
                    evl = 1*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 1*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 1*`VLEN/32;
                  end
                endcase
              end
              EMUL2: begin
                case(eew_max)
                  EEW8: begin
                    evl = 2*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 2*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 2*`VLEN/32;
                  end
                endcase
              end
              EMUL4: begin
                case(eew_max)
                  EEW8: begin
                    evl = 4*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 4*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 4*`VLEN/32;
                  end
                endcase
              end
              EMUL8: begin
                case(eew_max)
                  EEW8: begin
                    evl = 8*`VLEN/8;
                  end
                  EEW16: begin
                    evl = 8*`VLEN/16;
                  end
                  EEW32: begin
                    evl = 8*`VLEN/32;
                  end
                endcase
              end
            endcase
          end
          US_MASK: begin       
            // evl = ceil(vl/8)
            evl = {3'b0,csr_vl[`VL_WIDTH-1:3]} + (csr_vl[2:0]!='b0);
          end
        endcase
      end
    endcase
  end
  
  // check evl is not 0
  assign check_evl_not_0 = evl!='b0;

  // check vstart < evl
  assign check_vstart_sle_evl = {1'b0,csr_vstart} < evl;

  `ifdef ASSERT_ON
    `ifdef TB_SUPPORT
      `rvv_forbid((inst_valid==1'b1)&(inst_encoding_correct==1'b0))
      else $warning("pc(0x%h) instruction will be discarded directly.\n",$sampled(inst.inst_pc));
    `else
      `rvv_forbid((inst_valid==1'b1)&(inst_encoding_correct==1'b0))
      else $warning("This instruction will be discarded directly.\n");
    `endif
  `endif
  
  // uop_index_remain as the base uop_index
  assign uop_index_base = uop_index_remain;

  // calculate the uop_index used in decoding uops 
  generate
    for(j=0;j<`NUM_DE_UOP;j++) begin: GET_UOP_INDEX
      assign uop_index_current[j] = {1'b0, uop_index_base} + j[`UOP_INDEX_WIDTH:0];
    end
  endgenerate

//
// split instruction to uops
//
  // generate uop valid
  always_comb begin        
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VALID
      if ((uop_index_current[i]<={1'b0,uop_index_max})&valid_lsu) 
        uop_valid[i]  = inst_encoding_correct;
      else
        uop_valid[i]  = 'b0;
    end
  end

`ifdef TB_SUPPORT
  // assign uop pc
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_PC
      uop_pc[i] = inst.inst_pc;
    end
  end
`endif

  // update uop funct3
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_FUNCT3
      uop_funct3[i] = inst_funct3;
    end
  end

  // update uop funct6
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_FUNCT6
      uop_funct6[i] = funct6_lsu;
    end
  end

  // allocate uop to execution unit
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_EXE_UNIT
      uop_exe_unit[i] = LSU;
    end
  end

  // update uop class
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_CLASS
      // initial 
      uop_class[i] = XXX;
      
      case(inst_opcode) 
        LOAD:begin
          case(inst_funct6[2:0])
            UNIT_STRIDE,
            CONSTANT_STRIDE: begin
              uop_class[i] = XXX;
            end
            UNORDERED_INDEX,
            ORDERED_INDEX: begin
              uop_class[i] = XVX;
            end
          endcase
        end

        STORE: begin
          case(inst_funct6[2:0])
            UNIT_STRIDE,
            CONSTANT_STRIDE: begin
              uop_class[i] = VXX;
            end
            UNORDERED_INDEX,
            ORDERED_INDEX: begin
              uop_class[i] = VVX;
            end
          endcase
        end
      endcase
    end
  end

  // update vector_csr and vstart
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VCSR
      // initial
      vector_csr[i] = vector_csr_lsu;

      // update vstart of every uop
      if(funct6_lsu.lsu_funct6.lsu_is_seg!=IS_SEGMENT) begin
        case({eew_vd,eew_vs2})
          // index load with eew_vd<eew_vs2
          {EEW8 ,EEW16}: begin
            vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:1],($clog2(`VLENB)'('b0))}) < csr_vstart ? 
                                      csr_vstart : 
                                      (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:1],($clog2(`VLENB)'('b0))});
          end
          {EEW16,EEW32}: begin
            vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:1],($clog2(`VLEN/`HWORD_WIDTH)'('b0))}) < csr_vstart ? 
                                      csr_vstart : 
                                      (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:1],($clog2(`VLEN/`HWORD_WIDTH)'('b0))});
          end
          {EEW8 ,EEW32}: begin
            vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:2],($clog2(`VLENB)'('b0))}) < csr_vstart ? 
                                      csr_vstart : 
                                      (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:2],($clog2(`VLENB)'('b0))});
          end
          // other situations
          default: begin
            case(eew_max)
              EEW8: begin
                vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLENB)'('b0))}) < csr_vstart ? 
                                          csr_vstart : 
                                          (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLENB)'('b0))});
              end
              EEW16: begin
                vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLEN/`HWORD_WIDTH)'('b0))}) < csr_vstart ? 
                                          csr_vstart : 
                                          (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLEN/`HWORD_WIDTH)'('b0))});
              end
              EEW32: begin
                vector_csr[i].vstart  = (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLEN/`WORD_WIDTH)'('b0))}) < csr_vstart ? 
                                          csr_vstart : 
                                          (`VSTART_WIDTH)'({uop_index[i][`UOP_INDEX_WIDTH-1:0],($clog2(`VLEN/`WORD_WIDTH)'('b0))});
              end
            endcase
          end
        endcase
      end
    end
  end
  
  // update vs_evl
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_EVL
      vs_evl[i] = evl;
    end
  end

  // update ignore_vma and ignore_vta
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_IGNORE
      ignore_vma[i] = 'b0;
      ignore_vta[i] = 'b0;
    end
  end

  // update force_vma_agnostic
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_FORCE_VMA
      //When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic.
      force_vma_agnostic[i] = (check_vd_overlap_vs2==1'b0)&(eew_vd!=eew_vs2)&(eew_vd!=EEW_NONE)&(eew_vs2!=EEW_NONE);
    end
  end

  // update force_vta_agnostic
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_FORCE_VTA
      force_vta_agnostic[i] = (eew_vd==EEW1) |   // Mask destination tail elements are always treated as tail-agnostic
      //When source and destination registers overlap and have different EEW, the instruction is mask- and tail-agnostic.
                                  ((check_vd_overlap_vs2==1'b0)&(eew_vd!=eew_vs2)&(eew_vd!=EEW_NONE)&(eew_vs2!=EEW_NONE));
    end
  end

  // update vm field
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_VM
      vm[i] = inst_vm;
    end
  end
  
  // some uop need v0 as the vector operand
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_V0
      v0_valid[i] = 'b1;
    end
  end
  
  // update vd_offset 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VD_OFFSET
      // initial
      vd_offset[i] = 'b0;

      case(inst_funct6[2:0])
        UNIT_STRIDE: begin
          case(inst_umop)
            US_REGULAR,          
            US_FAULT_FIRST: begin
              case({inst_nf,emul_vd})
                {NF2,EMUL4}: begin 
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd4;
                    5'd2   : vd_offset[i] = 3'd1;
                    5'd3   : vd_offset[i] = 3'd5;
                    5'd4   : vd_offset[i] = 3'd2;
                    5'd5   : vd_offset[i] = 3'd6;
                    5'd6   : vd_offset[i] = 3'd3;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF2,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd1;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF3,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd4;
                    5'd3   : vd_offset[i] = 3'd1;
                    5'd4   : vd_offset[i] = 3'd3;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF4,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd4;
                    5'd3   : vd_offset[i] = 3'd6;
                    5'd4   : vd_offset[i] = 3'd1;
                    5'd5   : vd_offset[i] = 3'd3;
                    5'd6   : vd_offset[i] = 3'd5;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase
                end
                default: 
                  vd_offset[i] = uop_index_current[i][2:0];
              endcase
            end
            US_WHOLE_REGISTER: begin
              vd_offset[i] = uop_index_current[i][2:0];
            end
            US_MASK: begin
              vd_offset[i] = 'b0;
            end
          endcase
        end

        CONSTANT_STRIDE: begin
          case({inst_nf,emul_vd})
            {NF2,EMUL4}: begin 
              case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                5'd1   : vd_offset[i] = 3'd4;
                5'd2   : vd_offset[i] = 3'd1;
                5'd3   : vd_offset[i] = 3'd5;
                5'd4   : vd_offset[i] = 3'd2;
                5'd5   : vd_offset[i] = 3'd6;
                5'd6   : vd_offset[i] = 3'd3;
                default: vd_offset[i] = uop_index_current[i][2:0];
              endcase   
            end
            {NF2,EMUL2}: begin
              case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                5'd1   : vd_offset[i] = 3'd2;
                5'd2   : vd_offset[i] = 3'd1;
                default: vd_offset[i] = uop_index_current[i][2:0];
              endcase   
            end
            {NF3,EMUL2}: begin
              case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                5'd1   : vd_offset[i] = 3'd2;
                5'd2   : vd_offset[i] = 3'd4;
                5'd3   : vd_offset[i] = 3'd1;
                5'd4   : vd_offset[i] = 3'd3;
                default: vd_offset[i] = uop_index_current[i][2:0];
              endcase   
            end
            {NF4,EMUL2}: begin
              case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                5'd1   : vd_offset[i] = 3'd2;
                5'd2   : vd_offset[i] = 3'd4;
                5'd3   : vd_offset[i] = 3'd6;
                5'd4   : vd_offset[i] = 3'd1;
                5'd5   : vd_offset[i] = 3'd3;
                5'd6   : vd_offset[i] = 3'd5;
                default: vd_offset[i] = uop_index_current[i][2:0];
              endcase
            end
            default: vd_offset[i] = uop_index_current[i][2:0];
          endcase
        end
        
        UNORDERED_INDEX,
        ORDERED_INDEX: begin
          case({eew_vs2,eew_vd})
            // EEW_vs2:EEW_vd=1:1
            {EEW8,EEW8},
            {EEW16,EEW16},
            {EEW32,EEW32},            
            // 1:2
            {EEW8,EEW16},
            {EEW16,EEW32},
            // 1:4
            {EEW8,EEW32}: begin            
              case({inst_nf,emul_vd})
                {NF2,EMUL4}: begin 
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd4;
                    5'd2   : vd_offset[i] = 3'd1;
                    5'd3   : vd_offset[i] = 3'd5;
                    5'd4   : vd_offset[i] = 3'd2;
                    5'd5   : vd_offset[i] = 3'd6;
                    5'd6   : vd_offset[i] = 3'd3;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF2,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd1;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF3,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd4;
                    5'd3   : vd_offset[i] = 3'd1;
                    5'd4   : vd_offset[i] = 3'd3;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase   
                end
                {NF4,EMUL2}: begin
                  case(uop_index_current[i][`UOP_INDEX_WIDTH-1:0])
                    5'd1   : vd_offset[i] = 3'd2;
                    5'd2   : vd_offset[i] = 3'd4;
                    5'd3   : vd_offset[i] = 3'd6;
                    5'd4   : vd_offset[i] = 3'd1;
                    5'd5   : vd_offset[i] = 3'd3;
                    5'd6   : vd_offset[i] = 3'd5;
                    default: vd_offset[i] = uop_index_current[i][2:0];
                  endcase
                end
                default: vd_offset[i] = uop_index_current[i][2:0];
              endcase
            end
            // 2:1
            {EEW16,EEW8},
            {EEW32,EEW16},
            // 4:1
            {EEW32,EEW8}: begin            
              case({emul_vs2,emul_vd})
                {EMUL1,EMUL1}: 
                  vd_offset[i] = uop_index_current[i][2:0];
                {EMUL2,EMUL1}:
                  vd_offset[i] = uop_index_current[i][3:1];
                {EMUL4,EMUL2}: begin
                  case(inst_nf)
                    NF2: begin
                      vd_offset[i] = {1'b0, uop_index_current[i][1], uop_index_current[i][2]};
                    end
                    NF3: begin
                      case(uop_index_current[i][`UOP_INDEX_WIDTH-1:1])
                        4'd1   : vd_offset[i] = 3'd2;
                        4'd2   : vd_offset[i] = 3'd4;
                        4'd3   : vd_offset[i] = 3'd1;
                        4'd4   : vd_offset[i] = 3'd3;
                        default: vd_offset[i] = uop_index_current[i][3:1];
                      endcase   
                    end
                    NF4: begin
                      vd_offset[i] = {uop_index_current[i][2:1], uop_index_current[i][3]};
                    end
                    default: vd_offset[i] = {1'b0, uop_index_current[i][2:1]};
                  endcase
                end
                {EMUL8,EMUL4}: begin 
                  if (inst_nf==NF2)
                    vd_offset[i] = {uop_index_current[i][1], uop_index_current[i][3:2]};
                  else
                    vd_offset[i] = {1'b0, uop_index_current[i][2:1]};
                end
                {EMUL4,EMUL1}: 
                  vd_offset[i] = uop_index_current[i][4:2];
                {EMUL8,EMUL2}: begin 
                  case(inst_nf)
                    NF2: begin
                      vd_offset[i] = {1'b0, uop_index_current[i][2], uop_index_current[i][3]};
                    end
                    NF3: begin
                      case(uop_index_current[i][`UOP_INDEX_WIDTH-1:2])
                        3'd1   : vd_offset[i] = 3'd2;
                        3'd2   : vd_offset[i] = 3'd4;
                        3'd3   : vd_offset[i] = 3'd1;
                        3'd4   : vd_offset[i] = 3'd3;
                        default: vd_offset[i] = uop_index_current[i][4:2];
                      endcase   
                    end
                    NF4: begin
                      vd_offset[i] = {uop_index_current[i][3:2], uop_index_current[i][4]};
                    end
                    default: vd_offset[i] = uop_index_current[i][4:2];
                  endcase
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update vd_index and eew 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VD
      vd_index[i] = inst_vd + {2'b0, vd_offset[i]};
      vd_eew[i]   = eew_vd;
    end
  end

  // update vd_valid and vs3_valid
  // some uop need vd as the vs3 vector operand
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VD_VS3_VALID
      // initial
      vs3_valid[i] = 'b0;
      vd_valid[i]  = 'b0;

      if(inst_opcode==STORE)
        vs3_valid[i] = 1'b1;
      else
        vd_valid[i]  = 1'b1;
    end
  end

  // update vs1 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS1
      vs1[i]             = 'b0;
      vs1_eew[i]         = EEW_NONE;
      vs1_index_valid[i] = 'b0;
    end
  end

  // some uop will use vs1 field as an opcode to decode  
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS1_OPCODE
      // initial
      vs1_opcode_valid[i] = 'b0;
    end
  end

  // update vs2 offset and valid  
  always_comb begin
    // initial
    vs2_offset = 'b0; 
    vs2_valid  = 'b0; 
    
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS2_OFFSET
      case(inst_funct6[2:0])
        UNORDERED_INDEX,
        ORDERED_INDEX: begin
          case({eew_vs2,eew_vd})
            // EEW_vs2:EEW_vd=1:1
            {EEW8,EEW8},
            {EEW16,EEW16},
            {EEW32,EEW32}: begin
              case(emul_vs2)
                EMUL2: begin
                  case(inst_nf)
                    NF2:     vs2_offset[i] = {2'b0, uop_index_current[i][1]};
                    NF3:     vs2_offset[i] = (uop_index_current[i]>='d3) ? 3'd1 : 3'b0;
                    NF4:     vs2_offset[i] = {2'b0, uop_index_current[i][2]};
                    default: vs2_offset[i] = {2'b0, uop_index_current[i][0]};
                  endcase
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL4: begin
                  vs2_offset[i] = (inst_nf==NF2) ? {1'b0, uop_index_current[i][2:1]} : {1'b0, uop_index_current[i][1:0]};
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL8: begin
                  vs2_offset[i] = uop_index_current[i][2:0];
                  vs2_valid[i]  = 1'b1; 
                end
                default: begin //EMUL1
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1; 
                end
              endcase
            end
            // 2:1
            {EEW16,EEW8},
            {EEW32,EEW16}: begin
              case(emul_vs2)
                EMUL2: begin
                  vs2_offset[i] = {2'b0, uop_index_current[i][0]};
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL4: begin
                  case(inst_nf)
                    NF2:     vs2_offset[i] = {1'b0, uop_index_current[i][2], uop_index_current[i][0]};
                    NF3:     vs2_offset[i] = {1'b0, uop_index_current[i][3:1] >= 3'd3, uop_index_current[i][0]};
                    NF4:     vs2_offset[i] = {1'b0, uop_index_current[i][3], uop_index_current[i][0]};
                    default: vs2_offset[i] = uop_index_current[i][2:0]; // NF1
                  endcase
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL8: begin
                  vs2_offset[i] = (inst_nf==NF2) ? {uop_index_current[i][3:2], uop_index_current[i][0]} : uop_index_current[i][2:0];
                  vs2_valid[i]  = 1'b1; 
                end
                default: begin //EMUL1
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1; 
                end
              endcase
            end
            // 4:1
            {EEW32,EEW8}: begin    
              case(emul_vs2)
                EMUL2: begin
                  vs2_offset[i] = {2'b0, uop_index_current[i][0]};
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL4: begin
                  vs2_offset[i] = {1'b0, uop_index_current[i][1:0]};
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL8: begin
                  case(inst_nf)
                    NF2:     vs2_offset[i] = {uop_index_current[i][3], uop_index_current[i][1:0]};
                    NF3:     vs2_offset[i] = {uop_index_current[i][4:2] >= 3'd3, uop_index_current[i][1:0]};
                    NF4:     vs2_offset[i] = {uop_index_current[i][4], uop_index_current[i][1:0]};
                    default: vs2_offset[i] = uop_index_current[i][2:0];  //NF1
                  endcase
                  vs2_valid[i]  = 1'b1; 
                end
                default: begin //EMUL1
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1; 
                end
              endcase
            end
            // 1:2
            {EEW8,EEW16},
            {EEW16,EEW32}: begin
              case(emul_vs2)
                EMUL1: begin
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL2: begin
                  vs2_offset[i] = (inst_nf==NF2) ? {2'b0, uop_index_current[i][2]} : {2'b0, uop_index_current[i][1]};
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL4: begin
                  vs2_offset[i] = {1'b0, uop_index_current[i][2:1]};
                  vs2_valid[i]  = 1'b1; 
                end
              endcase
            end
            // 1:4
            {EEW8,EEW32}: begin     
              case(emul_vs2)
                EMUL1: begin
                  vs2_offset[i] = 'b0;
                  vs2_valid[i]  = 1'b1; 
                end
                EMUL2: begin
                  vs2_offset[i] = {2'b0, uop_index_current[i][2]};
                  vs2_valid[i]  = 1'b1; 
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end

  // update vs2 index and eew 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_VS2
      vs2_index[i] = inst_vs2 + {2'b0, vs2_offset[i]}; 
      vs2_eew[i]   = eew_vs2; 
    end
  end

  // update rd_index and valid
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_RD
      rd_index[i]         = 'b0;
      rd_index_valid[i]   = 'b0;
    end
  end

  // update rs1_data and rs1_data_valid 
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_RS1
      rs1_data[i]         = 'b0;
      rs1_data_valid[i]   = 'b0;
    end
  end

  // update uop index
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: ASSIGN_UOP_INDEX
      uop_index[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0];
    end
  end

  // update last_uop valid
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP_LAST
      first_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == 'b0;
      last_uop_valid[i] = uop_index_current[i][`UOP_INDEX_WIDTH-1:0] == uop_index_max;
    end
  end

  // seg_field_index indicates the uop index for the same field in the segment.
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: GET_SEG_INDEX
      // default
      // unit-strid, constant-stride, and index with EEW_vs2<=EEW_vd
      if(inst_nf==NF2)
        seg_field_index[i] = {1'b0, uop_index_current[i][2:1]};
      else if(inst_nf==NF3)
        seg_field_index[i] = (uop_index_current[i]>=6'd3) ? 'd1 : 'b0;  
      else if(inst_nf==NF4)
        seg_field_index[i] = {2'b0,uop_index_current[i][2]};
      else
        seg_field_index[i] = 'b0;

      // EEW_vs2>EEW_vd for index load/store
      case(inst_funct6[2:0])
        UNORDERED_INDEX,
        ORDERED_INDEX: begin
          case({eew_vs2,eew_vd})
            // 2:1
            {EEW16,EEW8},
            {EEW32,EEW16}: begin
              case(emul_vs2)
                EMUL2: seg_field_index[i] = {2'b0, uop_index_current[i][0]};
                EMUL4: begin
                  case(inst_nf)
                    NF2:     seg_field_index[i] = {1'b0, uop_index_current[i][2], uop_index_current[i][0]};
                    NF3:     seg_field_index[i] = {1'b0, uop_index_current[i]>='d6, uop_index_current[i][0]};
                    NF4:     seg_field_index[i] = {1'b0, uop_index_current[i][3], uop_index_current[i][0]};
                    default: seg_field_index[i] = 'b0;
                  endcase
                end
                EMUL8: seg_field_index[i] = (inst_nf==NF2) ? {uop_index_current[i][3:2], uop_index_current[i][0]} : uop_index_current[i][2:0];
              endcase
            end
            // 4:1
            {EEW32,EEW8}: begin   
              case(emul_vs2)
                EMUL2: seg_field_index[i] = {2'b0, uop_index_current[i][0]};
                EMUL4: seg_field_index[i] = {1'b0, uop_index_current[i][1:0]};
                EMUL8: begin
                  case(inst_nf)
                    NF2:     seg_field_index[i] = {uop_index_current[i][3], uop_index_current[i][1:0]};
                    NF3:     seg_field_index[i] = {uop_index_current[i]>='d12, uop_index_current[i][1:0]};
                    NF4:     seg_field_index[i] = {uop_index_current[i][4], uop_index_current[i][1:0]};
                    default: seg_field_index[i] = uop_index_current[i][2:0];
                  endcase
                end
              endcase
            end
          endcase
        end
      endcase
    end
  end
  
  // pshrob_valid decide on whether this uop is pushed into ROB.
  always_comb begin
    for(int i=0;i<`NUM_DE_UOP;i++) begin: PSHROB_VLD
      // EEW_vs2>EEW_vd for index load/store
      case({eew_vs2,eew_vd})
        // 2:1
        {EEW16,EEW8},
        {EEW32,EEW16}: begin
          case(emul_vs2)
            EMUL2,
            EMUL4,
            EMUL8:   pshrob_valid[i] = uop_index_current[i][0];
            default: pshrob_valid[i] = 'b1;
          endcase
        end
        // 4:1
        {EEW32,EEW8}: begin   
          case(emul_vs2)
            EMUL2: pshrob_valid[i] = uop_index_current[i][0];
            EMUL4,
            EMUL8: pshrob_valid[i] = uop_index_current[i][1:0]==2'b11;
            default: pshrob_valid[i] = 'b1;
          endcase
        end
        default: pshrob_valid[i] = 'b1;
      endcase
    end
  end

  // assign result to output
  generate
    for(j=0;j<`NUM_DE_UOP;j++) begin: ASSIGN_RES
    `ifdef TB_SUPPORT
      assign uop[j].uop_pc              = uop_pc[j];
    `endif  
      assign uop[j].uop_funct3          = uop_funct3[j];
      assign uop[j].uop_funct6          = uop_funct6[j];
      assign uop[j].uop_exe_unit        = uop_exe_unit[j]; 
      assign uop[j].uop_class           = uop_class[j];   
      assign uop[j].vector_csr          = vector_csr[j];  
      assign uop[j].vs_evl              = vs_evl[j];            
      assign uop[j].ignore_vma          = ignore_vma[j];
      assign uop[j].ignore_vta          = ignore_vta[j];
      assign uop[j].force_vma_agnostic  = force_vma_agnostic[j];
      assign uop[j].force_vta_agnostic  = force_vta_agnostic[j];
      assign uop[j].vm                  = vm[j];                
      assign uop[j].v0_valid            = v0_valid[j];          
      assign uop[j].vd_index            = vd_index[j];          
      assign uop[j].vd_eew              = vd_eew[j];  
      assign uop[j].vd_valid            = vd_valid[j];
      assign uop[j].vs3_valid           = vs3_valid[j];         
      assign uop[j].vs1                 = vs1[j];              
      assign uop[j].vs1_eew             = vs1_eew[j];           
      assign uop[j].vs1_index_valid     = vs1_index_valid[j];
      assign uop[j].vs1_opcode_valid    = vs1_opcode_valid[j];
      assign uop[j].vs2_index 	        = vs2_index[j]; 	       
      assign uop[j].vs2_eew             = vs2_eew[j];
      assign uop[j].vs2_valid           = vs2_valid[j];
      assign uop[j].rd_index 	          = rd_index[j]; 	       
      assign uop[j].rd_index_valid      = rd_index_valid[j]; 
      assign uop[j].rs1_data            = rs1_data[j];           
      assign uop[j].rs1_data_valid      = rs1_data_valid[j];    
      assign uop[j].uop_index           = uop_index[j];         
      assign uop[j].first_uop_valid     = first_uop_valid[j];   
      assign uop[j].last_uop_valid      = last_uop_valid[j];    
      assign uop[j].seg_field_index     = seg_field_index[j];   
      assign uop[j].pshrob_valid        = pshrob_valid[j];   
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_decode_ctrl.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
//
// description:
// 1. control to pop data from Command Queue and push data into Uop Queue. 
//
// features:
// 1. decode_ctrl will push data to Uops Queue only when Uops Queue has 4 free spaces at least.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_decode_ctrl
(
  clk,
  rst_n,
  pkg_valid,
  uop_valid_de2uq,
  uop_de2uq,
  uop_index_remain,
  pop,
  push,
  dataout,
  fifo_full_uq2de, 
  fifo_almost_full_uq2de,
  trap_flush_rvv
);
//
// interface signals
//
  // global signals
  input   logic                                           clk;
  input   logic                                           rst_n;

  // decoded uops
  input   logic       [`NUM_DE_INST-1:0]                  pkg_valid;
  input   logic       [`NUM_DE_INST-1:0][`NUM_DE_UOP-1:0] uop_valid_de2uq;
  input   UOP_QUEUE_t [`NUM_DE_INST-1:0][`NUM_DE_UOP-1:0] uop_de2uq;
  
  // uop_index for decode_unit
  output  logic       [`UOP_INDEX_WIDTH-1:0]              uop_index_remain;
  
  // pop signals for command queue
  output  logic       [`NUM_DE_INST-1:0]                  pop;

  // signals from Uops Quue
  output  logic       [`NUM_DE_UOP-1:0]                   push;
  output  UOP_QUEUE_t [`NUM_DE_UOP-1:0]                   dataout;
  input   logic                                           fifo_full_uq2de;
  input   logic       [`NUM_DE_UOP-1:0]                   fifo_almost_full_uq2de;

  // trap-flush
  input   logic                                           trap_flush_rvv;

//
// internal signals
//
  // get last uop signal 
  logic [`NUM_DE_UOP-1:0]         uop1_last_valid;
  logic [`NUM_DE_INST-1:0]        last_uop_unit;
  logic [`NUM_DE_UOP-1:0]         get_unit1_last_signal;

  // compress uop_valid
  logic [`NUM_DE_UOP-1:0]         compress_valid;

  // fifo is ready when it has `NUM_DE_UOP free spaces at least
  logic                           fifo_ready;
  
  // signals in uop_index DFF 
  logic                           uop_index_clear;   
  logic                           uop_index_enable_unit0;
  logic                           uop_index_enable_unit1;
  logic                           uop_index_enable;
  logic [`UOP_INDEX_WIDTH-1:0]    uop_index_din;
  
  // used in getting push0-3
  logic [`NUM_DE_UOP-1:0]         push_valid;
  
  // for-loop
  genvar                          i;

//
// ctroller
//
  generate
    // get unit1 last uop signal
    for (i=0;i<`NUM_DE_UOP;i++) begin: GET_UOP1_LAST
      assign uop1_last_valid[i] = uop_de2uq[1][i].last_uop_valid;
    end

    for (i=0;i<`NUM_DE_UOP;i++) begin: GET_UNIT1_LAST
      assign get_unit1_last_signal[i] = |uop1_last_valid[(`NUM_DE_UOP-1-i):0];
    end

    if(`NUM_DE_UOP==6) begin
      // get unit0 last uop signal
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0001,
          6'b00_0011,
          6'b00_0111,
          6'b00_1111,
          6'b01_1111: last_uop_unit[0] = 'b1;
          6'b11_1111: last_uop_unit[0] = uop_de2uq[0][`NUM_DE_UOP-1].last_uop_valid;
          default   : last_uop_unit[0] = 'b0;
        endcase
      end
    
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: last_uop_unit[1] = get_unit1_last_signal[0];
          6'b00_0001: last_uop_unit[1] = get_unit1_last_signal[1];
          6'b00_0011: last_uop_unit[1] = get_unit1_last_signal[2];
          6'b00_0111: last_uop_unit[1] = get_unit1_last_signal[3];
          6'b00_1111: last_uop_unit[1] = get_unit1_last_signal[4];
          6'b01_1111: last_uop_unit[1] = get_unit1_last_signal[5]; 
          default   : last_uop_unit[1] = 'b0;
        endcase
      end

      // compress uop_valid
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0001: compress_valid = {uop_valid_de2uq[1][4:0],1'b1}; 
          6'b00_0011: compress_valid = {uop_valid_de2uq[1][3:0],2'b11}; 
          6'b00_0111: compress_valid = {uop_valid_de2uq[1][2:0],3'b111}; 
          6'b00_1111: compress_valid = {uop_valid_de2uq[1][1:0],4'b1111}; 
          6'b01_1111: compress_valid = {uop_valid_de2uq[1][0]  ,5'b1_1111}; 
          6'b11_1111: compress_valid = 6'b11_1111; 
          default   : compress_valid = 'b0; 
        endcase
      end

    end
    else begin //if(`NUM_DE_UOP==4)
      // get unit0 last uop signal
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0001,
          4'b0011,
          4'b0111: last_uop_unit[0] = 'b1;
          4'b1111: last_uop_unit[0] = uop_de2uq[0][`NUM_DE_UOP-1].last_uop_valid;
          default: last_uop_unit[0] = 'b0;
        endcase
      end
    
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0000: last_uop_unit[1] = get_unit1_last_signal[0];
          4'b0001: last_uop_unit[1] = get_unit1_last_signal[1];
          4'b0011: last_uop_unit[1] = get_unit1_last_signal[2];
          4'b0111: last_uop_unit[1] = get_unit1_last_signal[3];
          default: last_uop_unit[1] = 'b0;
        endcase
      end

      // compress uop_valid
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0001: compress_valid = {uop_valid_de2uq[1][2:0],1'b1}; 
          4'b0011: compress_valid = {uop_valid_de2uq[1][1:0],2'b11}; 
          4'b0111: compress_valid = {uop_valid_de2uq[1][0]  ,3'b111}; 
          4'b1111: compress_valid = 4'b1111; 
          default: compress_valid = 'b0; 
        endcase
      end

    end
  endgenerate

  // get fifo_ready
  assign fifo_ready = (compress_valid=='b0) ? 'b0 : ((compress_valid&fifo_almost_full_uq2de)=='b0);
      
  // get pop signal to Command Queue
  assign pop[0] =          pkg_valid[0]&((last_uop_unit[0]&fifo_ready) || (uop_valid_de2uq[0][`NUM_DE_UOP-1:0]=='b0));
  assign pop[1] = pop[0] ? pkg_valid[1]&((last_uop_unit[1]&fifo_ready) || (uop_valid_de2uq[1][`NUM_DE_UOP-1:0]=='b0)) : 'b0;
  
  // instantiate cdffr for uop_index
  // clear signal
  assign uop_index_clear = (pop[0]&(!pkg_valid[1])) | pop[1];
  
  // enable signal
  assign uop_index_enable_unit0 =          pkg_valid[0]&(uop_valid_de2uq[0][`NUM_DE_UOP-1:0]!='b0)&(last_uop_unit[0]=='b0)&fifo_ready;
  assign uop_index_enable_unit1 = pop[0] ? pkg_valid[1]&(uop_valid_de2uq[1][`NUM_DE_UOP-1:0]!='b0)&(last_uop_unit[1]=='b0)&fifo_ready : 'b0;
  assign uop_index_enable       = uop_index_enable_unit0 | uop_index_enable_unit1;  
  
  // uop index remain
  cdffr 
  #(
    .T         (logic[`UOP_INDEX_WIDTH-1:0])
  )
  uop_index_cdffr
  (
    .clk       (clk), 
    .rst_n     (rst_n), 
    .c         (uop_index_clear|trap_flush_rvv),
    .e         (uop_index_enable), 
    .d         (uop_index_din),
    .q         (uop_index_remain)
  ); 

  generate
    if(`NUM_DE_UOP==6) begin
      // datain signal
      always_comb begin
        // initial
        uop_index_din = uop_index_remain;    
        
        case(1'b1)
          uop_index_enable_unit0: 
            uop_index_din = uop_de2uq[0][`NUM_DE_UOP-1].uop_index + 1'b1;    
          uop_index_enable_unit1: begin
            case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
              6'b00_0000: uop_index_din = uop_de2uq[1][5].uop_index + 1'b1; 
              6'b00_0001: uop_index_din = uop_de2uq[1][4].uop_index + 1'b1; 
              6'b00_0011: uop_index_din = uop_de2uq[1][3].uop_index + 1'b1; 
              6'b00_0111: uop_index_din = uop_de2uq[1][2].uop_index + 1'b1; 
              6'b00_1111: uop_index_din = uop_de2uq[1][1].uop_index + 1'b1; 
              6'b01_1111: uop_index_din = uop_de2uq[1][0].uop_index + 1'b1; 
              6'b11_1111: uop_index_din = 'b0; 
            endcase
          end
        endcase
      end
    
      // push signal and push data into Uops Queue
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[0] = uop_valid_de2uq[1][0];
            dataout[0]    = uop_de2uq[1][0];
          end
          6'b00_0001, 
          6'b00_0011, 
          6'b00_0111, 
          6'b00_1111, 
          6'b01_1111, 
          6'b11_1111: begin 
            push_valid[0] = uop_valid_de2uq[0][0];
            dataout[0]    = uop_de2uq[0][0];
          end
          default: begin 
            push_valid[0] = 'b0;
            dataout[0]    = 'b0;
          end
        endcase
      end

      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[1] = uop_valid_de2uq[1][1];
            dataout[1]    = uop_de2uq[1][1];
          end
          6'b00_0001: begin
            push_valid[1] = uop_valid_de2uq[1][0];
            dataout[1]    = uop_de2uq[1][0];
          end
          6'b00_0011, 
          6'b00_0111, 
          6'b00_1111, 
          6'b01_1111, 
          6'b11_1111: begin 
            push_valid[1] = uop_valid_de2uq[0][1];
            dataout[1]    = uop_de2uq[0][1];
          end
          default: begin 
            push_valid[1] = 'b0;
            dataout[1]    = 'b0;
          end
        endcase
      end

      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[2] = uop_valid_de2uq[1][2];
            dataout[2]    = uop_de2uq[1][2];
          end
          6'b00_0001: begin
            push_valid[2] = uop_valid_de2uq[1][1];
            dataout[2]    = uop_de2uq[1][1];
          end
          6'b00_0011: begin 
            push_valid[2] = uop_valid_de2uq[1][0];
            dataout[2]    = uop_de2uq[1][0];
          end
          6'b00_0111, 
          6'b00_1111, 
          6'b01_1111, 
          6'b11_1111: begin 
            push_valid[2] = uop_valid_de2uq[0][2];
            dataout[2]    = uop_de2uq[0][2];
          end
          default: begin 
            push_valid[2] = 'b0;
            dataout[2]    = 'b0;
          end
        endcase
      end
    
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[3] = uop_valid_de2uq[1][3];
            dataout[3]    = uop_de2uq[1][3];
          end
          6'b00_0001: begin
            push_valid[3] = uop_valid_de2uq[1][2];
            dataout[3]    = uop_de2uq[1][2];
          end
          6'b00_0011: begin 
            push_valid[3] = uop_valid_de2uq[1][1];
            dataout[3]    = uop_de2uq[1][1];
          end
          6'b00_0111: begin
            push_valid[3] = uop_valid_de2uq[1][0];
            dataout[3]    = uop_de2uq[1][0];
          end
          6'b00_1111, 
          6'b01_1111, 
          6'b11_1111: begin 
            push_valid[3] = uop_valid_de2uq[0][3];
            dataout[3]    = uop_de2uq[0][3];
          end
          default: begin 
            push_valid[3] = 'b0;
            dataout[3]    = 'b0;
          end
        endcase
      end
    
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[4] = uop_valid_de2uq[1][4];
            dataout[4]    = uop_de2uq[1][4];
          end
          6'b00_0001: begin
            push_valid[4] = uop_valid_de2uq[1][3];
            dataout[4]    = uop_de2uq[1][3];
          end
          6'b00_0011: begin 
            push_valid[4] = uop_valid_de2uq[1][2];
            dataout[4]    = uop_de2uq[1][2];
          end
          6'b00_0111: begin
            push_valid[4] = uop_valid_de2uq[1][1];
            dataout[4]    = uop_de2uq[1][1];
          end
          6'b00_1111: begin 
            push_valid[4] = uop_valid_de2uq[1][0];
            dataout[4]    = uop_de2uq[1][0];
          end
          6'b01_1111, 
          6'b11_1111: begin 
            push_valid[4] = uop_valid_de2uq[0][4];
            dataout[4]    = uop_de2uq[0][4];
          end
          default: begin 
            push_valid[4] = 'b0;
            dataout[4]    = 'b0;
          end
        endcase
      end

      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          6'b00_0000: begin
            push_valid[5] = uop_valid_de2uq[1][5];
            dataout[5]    = uop_de2uq[1][5];
          end
          6'b00_0001: begin
            push_valid[5] = uop_valid_de2uq[1][4];
            dataout[5]    = uop_de2uq[1][4];
          end
          6'b00_0011: begin 
            push_valid[5] = uop_valid_de2uq[1][3];
            dataout[5]    = uop_de2uq[1][3];
          end
          6'b00_0111: begin
            push_valid[5] = uop_valid_de2uq[1][2];
            dataout[5]    = uop_de2uq[1][2];
          end
          6'b00_1111: begin 
            push_valid[5] = uop_valid_de2uq[1][1];
            dataout[5]    = uop_de2uq[1][1];
          end
          6'b01_1111: begin
            push_valid[5] = uop_valid_de2uq[1][0];
            dataout[5]    = uop_de2uq[1][0];
          end
          6'b11_1111: begin 
            push_valid[5] = uop_valid_de2uq[0][5];
            dataout[5]    = uop_de2uq[0][5];
          end
          default: begin 
            push_valid[5] = 'b0;
            dataout[5]    = 'b0;
          end
        endcase
      end

    end //`NUM_DE_UOP==6
    else begin //if(`NUM_DE_UOP==4)
      // datain signal
      always_comb begin
        // initial
        uop_index_din = uop_index_remain;    
        
        case(1'b1)
          uop_index_enable_unit0: 
            uop_index_din = uop_de2uq[0][`NUM_DE_UOP-1].uop_index + 1'b1;    
          uop_index_enable_unit1: begin
            case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
              4'b0000: uop_index_din = uop_de2uq[1][3].uop_index + 1'b1; 
              4'b0001: uop_index_din = uop_de2uq[1][2].uop_index + 1'b1; 
              4'b0011: uop_index_din = uop_de2uq[1][1].uop_index + 1'b1; 
              4'b0111: uop_index_din = uop_de2uq[1][0].uop_index + 1'b1; 
              4'b1111: uop_index_din = 'b0; 
            endcase
          end
        endcase
      end
      
      // push signal and push data into Uops Queue
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0000: begin
            push_valid[0] = uop_valid_de2uq[1][0];
            dataout[0]    = uop_de2uq[1][0];
          end
          4'b0001,
          4'b0011,
          4'b0111,
          4'b1111: begin
            push_valid[0] = uop_valid_de2uq[0][0];
            dataout[0]    = uop_de2uq[0][0];
          end
          default: begin
            push_valid[0] = 'b0;
            dataout[0]    = 'b0;
          end
        endcase
      end

      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0000: begin
            push_valid[1] = uop_valid_de2uq[1][1];
            dataout[1]    = uop_de2uq[1][1];
          end
          4'b0001: begin
            push_valid[1] = uop_valid_de2uq[1][0];
            dataout[1]    = uop_de2uq[1][0];
          end
          4'b0011,
          4'b0111,
          4'b1111: begin
            push_valid[1] = uop_valid_de2uq[0][1];
            dataout[1]    = uop_de2uq[0][1];
          end
          default: begin
            push_valid[1] = 'b0;
            dataout[1]    = 'b0;
          end
        endcase
      end
      
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0000: begin
            push_valid[2] = uop_valid_de2uq[1][2];
            dataout[2]    = uop_de2uq[1][2];
          end
          4'b0001: begin
            push_valid[2] = uop_valid_de2uq[1][1];
            dataout[2]    = uop_de2uq[1][1];
          end
          4'b0011: begin
            push_valid[2] = uop_valid_de2uq[1][0];
            dataout[2]    = uop_de2uq[1][0];
          end
          4'b0111,
          4'b1111: begin
            push_valid[2] = uop_valid_de2uq[0][2];
            dataout[2]    = uop_de2uq[0][2];
          end
          default: begin
            push_valid[2] = 'b0;
            dataout[2]    = 'b0;
          end
        endcase
      end
    
      always_comb begin
        case(uop_valid_de2uq[0][`NUM_DE_UOP-1:0])
          4'b0000: begin
            push_valid[3] = uop_valid_de2uq[1][3];
            dataout[3]    = uop_de2uq[1][3];
          end
          4'b0001: begin
            push_valid[3] = uop_valid_de2uq[1][2];
            dataout[3]    = uop_de2uq[1][2];
          end
          4'b0011: begin
            push_valid[3] = uop_valid_de2uq[1][1];
            dataout[3]    = uop_de2uq[1][1];
          end
          4'b0111: begin
            push_valid[3] = uop_valid_de2uq[1][0];
            dataout[3]    = uop_de2uq[1][0];
          end
          4'b1111: begin
            push_valid[3] = uop_valid_de2uq[0][3];
            dataout[3]    = uop_de2uq[0][3];
          end
          default: begin
            push_valid[3] = 'b0;
            dataout[3]    = 'b0;
          end
        endcase
      end
    
    end //`NUM_DE_UOP==4
  endgenerate

  generate 
    for (i=0;i<`NUM_DE_UOP;i++) begin: GET_PUSH
      assign push[i] = push_valid[i]&fifo_ready;
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_decode.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
//
// description: 
// 1. It will read instructions from Command Queue and decode the instructions to uops and write to Uop Queue.
//
// feature list:
// 1. One instruction can be decoded to 8 uops at most according to RISC-V spec.
// 2. Decoder will push 4 uops at most into Uops Queue, so decoder only decode to 4 uops at most per cycle.  
// 3. If the instruction is in wrong encoding, it will be discarded directly without applying a trap.
// 4. When decoding, if the elements of one uop all belongs to ????prestart????, this uop will be discarded.
// 5. The vstart of the instruction will be calculated to a new value for every decoded uops.
// 6. Fault-only-first load instruction will be regarded as regular unit-stride load instruction.
// 7. Vector segment vload/vstore instructions will be decoded to regular stride or indexed vload/vstore uops. 

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_decode
(
  clk,
  rst_n,
  inst_pkg_cq2de, 
  fifo_empty_cq2de,
  fifo_almost_empty_cq2de,
  pop_de2cq,
  push_de2uq,
  data_de2uq,
  fifo_full_uq2de, 
  fifo_almost_full_uq2de,
  trap_flush_rvv
);
//
// interface signals
//
  // global signal
  input   logic                         clk;
  input   logic                         rst_n;
  
  // signals from command queue
  input   RVVCmd  [`NUM_DE_INST-1:0]    inst_pkg_cq2de; 
  input   logic                         fifo_empty_cq2de;
  input   logic   [`NUM_DE_INST-1:0]    fifo_almost_empty_cq2de;
  output  logic   [`NUM_DE_INST-1:0]    pop_de2cq;

  // signals from Uops Quue
  output  logic   [`NUM_DE_UOP-1:0]     push_de2uq;
  output  UOP_QUEUE_t [`NUM_DE_UOP-1:0] data_de2uq;
  input   logic                         fifo_full_uq2de;
  input   logic   [`NUM_DE_UOP-1:0]     fifo_almost_full_uq2de;

  // trap-flush
  input   logic                         trap_flush_rvv;

//
// internal signals
//
  // instruction struct valid signal 
  logic       [`NUM_DE_INST-1:0]                  pkg_valid;
  
  // the decoded uops
  logic       [`NUM_DE_INST-1:0][`NUM_DE_UOP-1:0] uop_valid_de2uq;
  UOP_QUEUE_t [`NUM_DE_INST-1:0][`NUM_DE_UOP-1:0] uop_de2uq;
 
  // uop index from controller
  logic       [`UOP_INDEX_WIDTH-1:0]              uop_index_remain;
  
  // for-loop
  genvar                                          i;

//
// decode
//
  // get data valid signals
  assign pkg_valid[0] = !fifo_empty_cq2de;

  generate 
    for (i=1;i<`NUM_DE_INST;i=i+1) begin: GET_PKG_VALID
      assign pkg_valid[i] = !(|fifo_almost_empty_cq2de[i:0]);
    end
  endgenerate

  // decode unit
  rvv_backend_decode_unit u_decode_unit0
  (
    .inst_valid_cq2de       (pkg_valid[0]),
    .inst_cq2de             (inst_pkg_cq2de[0]),
    .uop_index_remain       (uop_index_remain),
    .uop_valid_de2uq        (uop_valid_de2uq[0]),
    .uop_de2uq              (uop_de2uq[0])
  );
   
  generate 
    for (i=1;i<`NUM_DE_INST;i=i+1) begin: DECODE_UNIT
      rvv_backend_decode_unit u_decode_unit1
      (
        .inst_valid_cq2de   (pkg_valid[i]),
        .inst_cq2de         (inst_pkg_cq2de[i]),
        .uop_index_remain   ({`UOP_INDEX_WIDTH{1'b0}}),
        .uop_valid_de2uq    (uop_valid_de2uq[i]),
        .uop_de2uq          (uop_de2uq[i])
      );    
    end
  endgenerate
  
  // decode controller
  rvv_backend_decode_ctrl u_decode_ctrl
  (
    .clk                    (clk),
    .rst_n                  (rst_n),
    .pkg_valid              (pkg_valid),
    .uop_valid_de2uq        (uop_valid_de2uq),
    .uop_de2uq              (uop_de2uq),
    .uop_index_remain       (uop_index_remain),
    .pop                    (pop_de2cq),
    .push                   (push_de2uq),
    .dataout                (data_de2uq),
    .fifo_full_uq2de        (fifo_full_uq2de), 
    .fifo_almost_full_uq2de (fifo_almost_full_uq2de),
    .trap_flush_rvv         (trap_flush_rvv)
  );

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_bypass.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_bypass
(
    uop_operand,
    rob_byp,
    vrf_byp,
    raw_uop_rob
);
// ---port definition-------------------------------------------------
    output UOP_OPN_t                  uop_operand;
    input  ROB_BYP_t [`ROB_DEPTH-1:0] rob_byp;
    input  UOP_OPN_t                  vrf_byp;
    input  RAW_UOP_ROB_t              raw_uop_rob;

// ---internal signal definition--------------------------------------
    logic [`ROB_DEPTH-1:0][`VLENB-1:0] vs1_sel; // one-hot code
    logic [`ROB_DEPTH-1:0][`VLENB-1:0] vs2_sel; // one-hot code
    logic [`ROB_DEPTH-1:0][`VLENB-1:0] vd_sel;  // one-hot code
    logic [`ROB_DEPTH-1:0][`VLENB-1:0] v0_sel;  // one-hot code
    logic [`ROB_DEPTH-1:0][`VLENB-1:0] agnostic; // one-hot code

// ---code start------------------------------------------------------
    genvar i,j;
    generate
        for (i=0; i<`ROB_DEPTH; i++) begin : gen_data_sel
            for (j=0; j<`VLENB; j++) begin
                assign vs1_sel[i][j]  = (raw_uop_rob.vs1_hit[i] == 1'b1) & 
                                        (rob_byp[i].byte_type[j] == BODY_ACTIVE |
                                         rob_byp[i].byte_type[j] == BODY_INACTIVE & rob_byp[i].inactive_one |
                                         rob_byp[i].byte_type[j] == TAIL & rob_byp[i].tail_one);

                assign vs2_sel[i][j]  = (raw_uop_rob.vs2_hit[i] == 1'b1) & 
                                        (rob_byp[i].byte_type[j] == BODY_ACTIVE |
                                         rob_byp[i].byte_type[j] == BODY_INACTIVE & rob_byp[i].inactive_one |
                                         rob_byp[i].byte_type[j] == TAIL & rob_byp[i].tail_one);

                assign vd_sel[i][j]   = (raw_uop_rob.vd_hit[i] == 1'b1) & 
                                        (rob_byp[i].byte_type[j] == BODY_ACTIVE |
                                         rob_byp[i].byte_type[j] == BODY_INACTIVE & rob_byp[i].inactive_one |
                                         rob_byp[i].byte_type[j] == TAIL & rob_byp[i].tail_one);

                assign v0_sel[i][j]   = (raw_uop_rob.v0_hit[i] == 1'b1) & 
                                        (rob_byp[i].byte_type[j] == BODY_ACTIVE |
                                         rob_byp[i].byte_type[j] == BODY_INACTIVE & rob_byp[i].inactive_one |
                                         rob_byp[i].byte_type[j] == TAIL & rob_byp[i].tail_one);

                assign agnostic[i][j] = (rob_byp[i].byte_type[j] == BODY_INACTIVE & rob_byp[i].inactive_one |
                                        rob_byp[i].byte_type[j] == TAIL & rob_byp[i].tail_one);
            end
        end

        for (j=0; j<`VLENB; j++) begin: bypass
            always_comb begin
                uop_operand.vs1[`BYTE_WIDTH*j+:`BYTE_WIDTH] = vrf_byp.vs1[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                uop_operand.vs2[`BYTE_WIDTH*j+:`BYTE_WIDTH] = vrf_byp.vs2[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                uop_operand.vd[`BYTE_WIDTH*j+:`BYTE_WIDTH]  = vrf_byp.vd[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                uop_operand.v0[`BYTE_WIDTH*j+:`BYTE_WIDTH]  = vrf_byp.v0[`BYTE_WIDTH*j+:`BYTE_WIDTH];

                for(int i=0;i<`ROB_DEPTH;i++) begin
                    if(vs1_sel[i][j]) 
                        uop_operand.vs1[`BYTE_WIDTH*j+:`BYTE_WIDTH] = agnostic[i][j] ? 8'hFF : rob_byp[i].w_data[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                    if(vs2_sel[i][j]) 
                        uop_operand.vs2[`BYTE_WIDTH*j+:`BYTE_WIDTH] = agnostic[i][j] ? 8'hFF : rob_byp[i].w_data[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                    if(vd_sel[i][j]) 
                        uop_operand.vd[`BYTE_WIDTH*j+:`BYTE_WIDTH]  = agnostic[i][j] ? 8'hFF : rob_byp[i].w_data[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                    if(v0_sel[i][j]) 
                        uop_operand.v0[`BYTE_WIDTH*j+:`BYTE_WIDTH]  = agnostic[i][j] ? 8'hFF : rob_byp[i].w_data[`BYTE_WIDTH*j+:`BYTE_WIDTH];
                end
            end
        end
    endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_ctrl.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Description:
// 1. the rvv_backend_dispatch_ctrl is responsible for push uop(s) to RS/ROB and pop uop(s) from UOP_Queue.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_ctrl
(
    raw_uop_rob,
    raw_uop_uop,
    arch_hazard,
    uop_ctrl,
    uop_valid_uop2dp,
    uop_ready_dp2uop,
    rs_valid_dp2alu,
    rs_ready_alu2dp,
    rs_valid_dp2pmtrdt,
    rs_ready_pmtrdt2dp,
    rs_valid_dp2mul,
    rs_ready_mul2dp,
    rs_valid_dp2div,
    rs_ready_div2dp,
    rs_valid_dp2lsu,
    rs_ready_lsu2dp,
    mapinfo_valid_dp2lsu,
    mapinfo_ready_lsu2dp,
    uop_valid_dp2rob,
    uop_ready_rob2dp
);
// ---port definition-------------------------------------------------
// ctrl input signal
    input   RAW_UOP_ROB_t [`NUM_DP_UOP-1:0] raw_uop_rob;
    input   RAW_UOP_UOP_t [`NUM_DP_UOP-1:1] raw_uop_uop;
    input   ARCH_HAZARD_t                   arch_hazard;
    input   UOP_CTRL_t    [`NUM_DP_UOP-1:0] uop_ctrl;
// handshake singals
    input   logic         [`NUM_DP_UOP-1:0] uop_valid_uop2dp;
    output  logic         [`NUM_DP_UOP-1:0] uop_ready_dp2uop;

    output  logic         [`NUM_DP_UOP-1:0] rs_valid_dp2alu;
    input   logic         [`NUM_DP_UOP-1:0] rs_ready_alu2dp;
    output  logic         [`NUM_DP_UOP-1:0] rs_valid_dp2pmtrdt;
    input   logic         [`NUM_DP_UOP-1:0] rs_ready_pmtrdt2dp;
    output  logic         [`NUM_DP_UOP-1:0] rs_valid_dp2mul;
    input   logic         [`NUM_DP_UOP-1:0] rs_ready_mul2dp;
    output  logic         [`NUM_DP_UOP-1:0] rs_valid_dp2div;
    input   logic         [`NUM_DP_UOP-1:0] rs_ready_div2dp;
    output  logic         [`NUM_DP_UOP-1:0] rs_valid_dp2lsu;
    input   logic         [`NUM_DP_UOP-1:0] rs_ready_lsu2dp;
    output  logic         [`NUM_DP_UOP-1:0] mapinfo_valid_dp2lsu;
    input   logic         [`NUM_DP_UOP-1:0] mapinfo_ready_lsu2dp;

    output  logic         [`NUM_DP_UOP-1:0] uop_valid_dp2rob;
    input   logic         [`NUM_DP_UOP-1:0] uop_ready_rob2dp;

// ---internal signal definition--------------------------------------
    logic [`NUM_DP_UOP-1:0] uop_valid;
    logic [`NUM_DP_UOP-1:0] rs_ready;

// ---code start------------------------------------------------------
    genvar i;
    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_uop_valid
            if (i==0)
              assign uop_valid[0] = uop_valid_uop2dp[0]      &
                                    ~raw_uop_rob[0].vs1_wait &
                                    ~raw_uop_rob[0].vs2_wait &
                                    ~raw_uop_rob[0].vd_wait  &
                                    ~raw_uop_rob[0].v0_wait  ;
            else if (i<`NUM_DP_UOP-1)
              assign uop_valid[i] = uop_valid[i-1]           &
                                    uop_valid_uop2dp[i]      &
                                    ~raw_uop_rob[i].vs1_wait &
                                    ~raw_uop_rob[i].vs2_wait &
                                    ~raw_uop_rob[i].vd_wait  &
                                    ~raw_uop_rob[i].v0_wait  &
                                    ~raw_uop_uop[i].vs1_wait &
                                    ~raw_uop_uop[i].vs2_wait &
                                    ~raw_uop_uop[i].vd_wait  &
                                    ~raw_uop_uop[i].v0_wait  ;
            else
              assign uop_valid[i] = uop_valid[i-1]           &
                                    uop_valid_uop2dp[i]      &
                                    ~raw_uop_rob[i].vs1_wait &
                                    ~raw_uop_rob[i].vs2_wait &
                                    ~raw_uop_rob[i].vd_wait  &
                                    ~raw_uop_rob[i].v0_wait  &
                                    ~raw_uop_uop[i].vs1_wait &
                                    ~raw_uop_uop[i].vs2_wait &
                                    ~raw_uop_uop[i].vd_wait  &
                                    ~raw_uop_uop[i].v0_wait  &
                                    ~arch_hazard.vr_limit    ;  
        end
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_rs_ready
          if (i==0)
            always_comb begin
                case (uop_ctrl[i].uop_exe_unit)
                    ALU: rs_ready[0] = rs_ready_alu2dp[0];
                    MUL,
                    MAC: rs_ready[0] = rs_ready_mul2dp[0];
                    CMP,
                    PMT,
                    RDT: rs_ready[0] = rs_ready_pmtrdt2dp[0];
                    DIV: rs_ready[0] = rs_ready_div2dp[0];
                    LSU: rs_ready[0] = rs_ready_lsu2dp[0]&mapinfo_ready_lsu2dp[0];
                    default: rs_ready[0] = 1'b0;
                endcase
            end
          else
            always_comb begin
                case (uop_ctrl[i].uop_exe_unit)
                    ALU: rs_ready[i] = rs_ready[i-1] & rs_ready_alu2dp[i];
                    MUL,
                    MAC: rs_ready[i] = rs_ready[i-1] & rs_ready_mul2dp[i];
                    CMP,
                    PMT,
                    RDT: rs_ready[i] = rs_ready[i-1] & rs_ready_pmtrdt2dp[i];
                    DIV: rs_ready[i] = rs_ready[i-1] & rs_ready_div2dp[i];
                    LSU: rs_ready[i] = rs_ready[i-1] & rs_ready_lsu2dp[i] & mapinfo_ready_lsu2dp[i];
                    default: rs_ready[i] = 1'b0;
                endcase
            end
        end
        for (i=0; i<`NUM_DP_UOP; i++) begin: gen_ctrl_output
            assign uop_ready_dp2uop[i]     = uop_valid[i]        &
                                             uop_ready_rob2dp[i] &
                                             rs_ready[i]         ;

            assign uop_valid_dp2rob[i]     = uop_ready_dp2uop[i] & 
                                             uop_ctrl[i].pshrob_valid;

            assign rs_valid_dp2alu[i]      = uop_ready_dp2uop[i] & 
                                             (uop_ctrl[i].uop_exe_unit == ALU);
            assign rs_valid_dp2pmtrdt[i]   = uop_ready_dp2uop[i] & 
                                             ((uop_ctrl[i].uop_exe_unit == PMT) || 
                                              (uop_ctrl[i].uop_exe_unit == RDT) || 
                                              (uop_ctrl[i].uop_exe_unit == CMP) );
            assign rs_valid_dp2mul[i]      = uop_ready_dp2uop[i] & 
                                             (uop_ctrl[i].uop_exe_unit == MUL || 
                                              uop_ctrl[i].uop_exe_unit == MAC );
            assign rs_valid_dp2div[i]      = uop_ready_dp2uop[i] & 
                                             (uop_ctrl[i].uop_exe_unit == DIV);
            assign rs_valid_dp2lsu[i]      = uop_ready_dp2uop[i] & 
                                             (uop_ctrl[i].uop_exe_unit == LSU);
            assign mapinfo_valid_dp2lsu[i] = uop_valid_dp2rob[i] & 
                                             (uop_ctrl[i].uop_exe_unit == LSU);
        end
    endgenerate
    
endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_operand.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_operand
(
  vrf_byp,
  uop_uop2dp,
  rd_data_vrf2dp,
  v0_mask_vrf2dp
);
// ---port definition-------------------------------------------------
  output  UOP_OPN_t   [`NUM_DP_UOP-1:0]             vrf_byp;
  input   UOP_QUEUE_t [`NUM_DP_UOP-1:0]             uop_uop2dp;
  input   logic       [`NUM_DP_VRF-1:0][`VLEN-1:0]  rd_data_vrf2dp;
  input   logic       [`VLEN-1:0]                   v0_mask_vrf2dp;

// get the operand from VRF
`ifdef ISSUE_3_READ_PORT_6  
  always_comb begin
    vrf_byp[0].v0  = v0_mask_vrf2dp;
    vrf_byp[0].vs1 = rd_data_vrf2dp[0];
    vrf_byp[0].vs2 = rd_data_vrf2dp[1];
    vrf_byp[0].vd  = rd_data_vrf2dp[2];
    vrf_byp[1].v0  = v0_mask_vrf2dp;
    vrf_byp[1].vs1 = rd_data_vrf2dp[3];
    vrf_byp[1].vs2 = rd_data_vrf2dp[4];
    vrf_byp[1].vd  = rd_data_vrf2dp[5];
    vrf_byp[2].v0  = v0_mask_vrf2dp;
    vrf_byp[2].vs1 = 'b0;
    vrf_byp[2].vs2 = 'b0;
    vrf_byp[2].vd  = 'b0;

    case(uop_uop2dp[2].uop_class)
      XXV,
      XVX,
      VXX: begin
        case(uop_uop2dp[0].uop_class)
          XXV,
          XVV: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[2];
            vrf_byp[2].vs2 = rd_data_vrf2dp[2];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          XXX,
          XVX,
          VXX,
          VVX: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[0];
            vrf_byp[2].vd  = rd_data_vrf2dp[0];
          end

          VVV: begin 
            case(uop_uop2dp[1].uop_class)
              XXV,
              XVV: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[5];
                vrf_byp[2].vs2 = rd_data_vrf2dp[5];
                vrf_byp[2].vd  = rd_data_vrf2dp[5];
              end

              XXX,
              XVX,
              VXX,
              VVX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = rd_data_vrf2dp[3];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end
            endcase
          end
        endcase
      end
      
      XVV,
      VVX: begin
        case(uop_uop2dp[0].uop_class)
          XXX,
          VXX: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[0];
          end

          XXV: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[2];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          XVX: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[2];
            vrf_byp[2].vd  = rd_data_vrf2dp[0];
          end

          XVV,
          VVX: begin
            case(uop_uop2dp[1].uop_class)
              XXX,
              VXX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = rd_data_vrf2dp[4];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end

              XXV: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[5];
                vrf_byp[2].vs2 = rd_data_vrf2dp[4];
                vrf_byp[2].vd  = rd_data_vrf2dp[5];
              end

              XVX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = rd_data_vrf2dp[5];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end   

              VVX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = uop_uop2dp[0].vs1_index_valid ? rd_data_vrf2dp[2] : rd_data_vrf2dp[0];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end

              XVV: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[5];
                vrf_byp[2].vs2 = uop_uop2dp[0].vs1_index_valid ? rd_data_vrf2dp[2] : rd_data_vrf2dp[0];
                vrf_byp[2].vd  = rd_data_vrf2dp[5];
              end
            endcase
          end

          VVV: begin 
            case(uop_uop2dp[1].uop_class)
              XXX,
              VXX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = rd_data_vrf2dp[4];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end

              XVX: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[3];
                vrf_byp[2].vs2 = rd_data_vrf2dp[5];
                vrf_byp[2].vd  = rd_data_vrf2dp[3];
              end

              XXV: begin
                vrf_byp[2].vs1 = rd_data_vrf2dp[4];
                vrf_byp[2].vs2 = rd_data_vrf2dp[5];
                vrf_byp[2].vd  = rd_data_vrf2dp[4];
              end
            endcase
          end
        endcase
      end

      VVV: begin
        case({uop_uop2dp[0].uop_class,uop_uop2dp[1].uop_class})
          {XXX,XXX},
          {XXX,XXV},
          {XXX,XVX},
          {XXX,VXX},
          {XXX,XVV},
          {XXX,VVX},
          {XXX,VVV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          {XXV,XXX},
          {XVX,XXX},
          {VXX,XXX},
          {XVV,XXX},
          {VVX,XXX},
          {VVV,XXX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[4];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end

          {XXV,VXX},
          {XXV,VVX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end
          
          {XXV,XXV},
          {XXV,XVX},
          {XXV,XVV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[5];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end
          
          {XVX,VXX},
          {XVX,VVX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[3];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          {XVX,XXV},
          {XVX,XVX},
          {XVX,XVV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[5];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          {VXX,VXX},
          {VXX,VVX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[3];
          end

          {VXX,XXV},
          {VXX,XVX},
          {VXX,XVV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[1];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end

          {XVV,VXX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[4];
            vrf_byp[2].vd  = rd_data_vrf2dp[2];
          end

          {XVV,XVX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[2];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end

          {XVV,XXV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[2];
            vrf_byp[2].vs2 = rd_data_vrf2dp[4];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end

          {VVX,VXX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[4];
            vrf_byp[2].vd  = rd_data_vrf2dp[0];
          end

          {VVX,XVX}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[3];
            vrf_byp[2].vs2 = rd_data_vrf2dp[0];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end

          {VVX,XXV}: begin
            vrf_byp[2].vs1 = rd_data_vrf2dp[0];
            vrf_byp[2].vs2 = rd_data_vrf2dp[4];
            vrf_byp[2].vd  = rd_data_vrf2dp[5];
          end
        endcase
      end
    endcase
  end   

`elsif ISSUE_2_READ_PORT_6  
  always_comb begin
    vrf_byp[0].v0  = v0_mask_vrf2dp;
    vrf_byp[0].vs1 = rd_data_vrf2dp[0];
    vrf_byp[0].vs2 = rd_data_vrf2dp[1];
    vrf_byp[0].vd  = rd_data_vrf2dp[2];
    vrf_byp[1].v0  = v0_mask_vrf2dp;
    vrf_byp[1].vs1 = rd_data_vrf2dp[3];
    vrf_byp[1].vs2 = rd_data_vrf2dp[4];
    vrf_byp[1].vd  = rd_data_vrf2dp[5];
  end

`else //ISSUE_2_READ_PORT_4
  always_comb begin
    vrf_byp[0].v0  = v0_mask_vrf2dp;
    vrf_byp[0].vs1 = 'b0;
    vrf_byp[0].vs2 = 'b0;
    vrf_byp[0].vd  = 'b0;
    vrf_byp[1].v0  = v0_mask_vrf2dp;
    vrf_byp[1].vs1 = 'b0;
    vrf_byp[1].vs2 = 'b0;
    vrf_byp[1].vd  = 'b0;

    case(uop_uop2dp[0].uop_class)
      VVV:begin
        vrf_byp[0].vd  = rd_data_vrf2dp[3];
        vrf_byp[0].vs1 = rd_data_vrf2dp[1];
        vrf_byp[0].vs2 = rd_data_vrf2dp[0];
      end                       
      XVV: begin
        vrf_byp[0].vs1 = rd_data_vrf2dp[1];
        vrf_byp[0].vs2 = rd_data_vrf2dp[0];
      end
      VVX: begin
        vrf_byp[0].vd  = rd_data_vrf2dp[1];
        vrf_byp[0].vs2 = rd_data_vrf2dp[0];
      end
      VXX: begin
        vrf_byp[0].vd  = rd_data_vrf2dp[0];
      end
      XVX: begin
        vrf_byp[0].vs2 = rd_data_vrf2dp[0];
      end
      XXV: begin
        vrf_byp[0].vs1 = rd_data_vrf2dp[0];
      end
    endcase

    case(uop_uop2dp[1].uop_class)
      VVV:begin
        vrf_byp[1].vd  = rd_data_vrf2dp[1];
        vrf_byp[1].vs1 = rd_data_vrf2dp[3];
        vrf_byp[1].vs2 = rd_data_vrf2dp[2];
      end
      XVV: begin
        vrf_byp[1].vs1 = rd_data_vrf2dp[3];
        vrf_byp[1].vs2 = rd_data_vrf2dp[2];
      end
      VVX: begin
        vrf_byp[1].vd  = rd_data_vrf2dp[3];
        vrf_byp[1].vs2 = rd_data_vrf2dp[2];
      end
      VXX: begin
        vrf_byp[1].vd = rd_data_vrf2dp[2];
      end
      XVX: begin
        vrf_byp[1].vs2 = rd_data_vrf2dp[2];
      end
      XXV: begin
        vrf_byp[1].vs1 = rd_data_vrf2dp[2];
      end
    endcase
  end
`endif

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_opr_byte_type.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Description:
// 1. rvv_backend_dispatch_opr_byte_type sub-module is for generating byte type for operand(s)
//    a. it is convenient for PU&RT to check if byte data shoud be updated or used for uop(s)

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_opr_byte_type
(
    operand_byte_type,
    uop_info,
    v0_data
);
// ---parameter definition--------------------------------------------
    localparam VLENB_WIDTH = $clog2(`VLENB);

// ---port definition-------------------------------------------------
    output UOP_OPN_BYTE_TYPE_t operand_byte_type;
    input  UOP_INFO_t          uop_info;
    input  logic [`VLEN-1:0]   v0_data;

// ---internal signal definition--------------------------------------
    EEW_e                               eew_max;
    logic  [1:0]                        eew_max_shift;
    
    logic  [1:0]                        vs2_eew_shift;
    logic  [`VSTART_WIDTH-1:0]          uop_vs2_start;
    logic  [`VSTART_WIDTH-1:0]          uop_vs2_offset;
    logic  [`VLENB-1:0][`VL_WIDTH-1:0]  vs2_ele_index;  // element index
    logic  [`VLENB-1:0]                 vs2_enable, vs2_enable_tmp;
    
    logic  [`VSTART_WIDTH-1:0]          ele_start;      // the index of start element in this uop
    logic  [1:0]                        vd_eew_shift;
    logic  [`VSTART_WIDTH-1:0]          uop_vd_start;
    logic  [`VSTART_WIDTH-1:0]          uop_vd_end;
    logic  [`VLENB-1:0][`VL_WIDTH-1:0]  vd_ele_index;   // element index
    logic  [`VLENB-1:0]                 vd_enable;

    logic  [`VSTART_WIDTH-1:0]          uop_v0_start;
    logic  [`VSTART_WIDTH-1:0]          uop_v0_start_offset;
    logic  [`VSTART_WIDTH-1:0]          uop_v0_end;
    logic  [`VSTART_WIDTH-1:0]          uop_v0_end_offset;
    logic  [`VLENB-1:0]                 v0_enable, v0_enable_tmp;

    // result
    BYTE_TYPE_t                         vs2;
    BYTE_TYPE_t                         vd;
    logic [`VLENB-1:0]                  v0_strobe;

    genvar i;
// ---code start------------------------------------------------------
    // find eew_max and shift amount
    always_comb begin
      if ((uop_info.vs1_eew==EEW32)||(uop_info.vs2_eew==EEW32)||(uop_info.vd_eew==EEW32)) begin
        eew_max       = EEW32;
        eew_max_shift = 2'h2;
      end
      else if ((uop_info.vs1_eew==EEW16)||(uop_info.vs2_eew==EEW16)||(uop_info.vd_eew==EEW16)) begin
        eew_max       = EEW16;
        eew_max_shift = 2'h1;
      end
      else if ((uop_info.vs1_eew==EEW8)||(uop_info.vs2_eew==EEW8)||(uop_info.vd_eew==EEW8)) begin
        eew_max       = EEW8;
        eew_max_shift = 2'h0;
      end
      else if ((uop_info.vs1_eew==EEW1)||(uop_info.vs2_eew==EEW1)||(uop_info.vd_eew==EEW1)) begin
        eew_max       = EEW1;
        eew_max_shift = 2'h0;
      end
      else begin
        eew_max       = EEW_NONE;
        eew_max_shift = 2'h0;
      end
    end

// for vs2 byte type
    generate
        always_comb begin
            case (uop_info.vs2_eew)
                EEW8:   vs2_eew_shift = 2'h0;
                EEW16:  vs2_eew_shift = 2'h1;
                EEW32:  vs2_eew_shift = 2'h2;
                default:vs2_eew_shift = 2'h0;
            endcase
        end

        // for RDT instruction, eew_max == vs2_eew
        assign uop_vs2_offset = (`VSTART_WIDTH)'(VLENB_WIDTH - vs2_eew_shift);

        always_comb begin
          case (uop_info.uop_exe_unit)
            RDT:begin
              uop_vs2_start = (`VSTART_WIDTH)'(uop_info.uop_index) << uop_vs2_offset ;
            end
            default:begin
              case({eew_max,uop_info.vs2_eew})
                {EEW32,EEW32},
                {EEW16,EEW16},
                {EEW8,EEW8}: begin
                  // regular and narrowing instruction
                  uop_vs2_start = (`VSTART_WIDTH)'(uop_info.uop_index) << uop_vs2_offset;
                end
                {EEW32,EEW16},
                {EEW16,EEW8}: begin
                  // widening instruction: EEW_vd:EEW_vs = 2:1
                  uop_vs2_start = (`VSTART_WIDTH)'(uop_info.uop_index[`UOP_INDEX_WIDTH-1:1]) << uop_vs2_offset;
                end
                {EEW32,EEW8}: begin
                  // widening instruction: EEW_vd:EEW_vs = 4:1
                  uop_vs2_start = (`VSTART_WIDTH)'(uop_info.uop_index[`UOP_INDEX_WIDTH-1:2]) << uop_vs2_offset;
                end
                default: begin
                  uop_vs2_start = 'b0;
                end
              endcase
            end
          endcase
        end

        assign vs2_enable_tmp  = v0_data[uop_vs2_start+:`VLENB]; 

        for (i=0; i<`VLENB; i++) begin : gen_vs2_byte_type
            // ele_index = uop_index * (VLEN/vs2_eew) + BYTE_INDEX[MSB:vs2_eew]
            assign vs2_enable[i] = uop_info.vm ? 1'b1 : vs2_enable_tmp[i >> vs2_eew_shift];
            assign vs2_ele_index[i] = (`VL_WIDTH)'(uop_vs2_start) + (i >> vs2_eew_shift);
            always_comb begin
                if (uop_info.ignore_vta&uop_info.ignore_vma)
                    vs2[i] = BODY_ACTIVE;       
                else if (vs2_ele_index[i] >= uop_info.vl) 
                    vs2[i] = TAIL; 
                else if (vs2_ele_index[i] < {1'b0, uop_info.vstart}) 
                    vs2[i] = NOT_CHANGE; // prestart
                else begin 
                    vs2[i] = (vs2_enable[i] || uop_info.ignore_vma) ? BODY_ACTIVE : BODY_INACTIVE;
                end
            end
        end
    endgenerate

// for vd byte type
    generate
        always_comb begin
            case (uop_info.vd_eew)
                EEW8:   vd_eew_shift = 2'h0;
                EEW16:  vd_eew_shift = 2'h1;
                EEW32:  vd_eew_shift = 2'h2;
                default:vd_eew_shift = 2'h0;
            endcase
        end
        
        always_comb begin
          case({eew_max,uop_info.vd_eew})
            {EEW32,EEW32},
            {EEW16,EEW16},
            {EEW8,EEW8}: begin
              ele_start           = (`VSTART_WIDTH)'(uop_info.uop_index) << (VLENB_WIDTH - vd_eew_shift);

              uop_v0_start_offset = 'b0; 
              uop_v0_end_offset   = (`VLENB >> vd_eew_shift) - 1'b1;
              uop_v0_start        = ele_start;
              uop_v0_end          = ele_start + uop_v0_end_offset;

              uop_vd_start        = uop_v0_start;
              uop_vd_end          = uop_v0_end;
            end
            {EEW32,EEW16},
            {EEW16,EEW8}: begin
              // narrowing instruction: EEW_vd:EEW_vs = 1:2
              ele_start           = (`VSTART_WIDTH)'(uop_info.uop_index[`UOP_INDEX_WIDTH-1:1] << (VLENB_WIDTH - vd_eew_shift));
              
              uop_v0_start_offset = uop_info.uop_index[0] ? (`VSTART_WIDTH)'(`VLENB >> eew_max_shift) : 'b0;
              uop_v0_end_offset   = uop_info.uop_index[0] ? (`VLENB >> vd_eew_shift)-1'b1 : (`VLENB >> eew_max_shift)-1'b1; 
              uop_v0_start        = ele_start + uop_v0_start_offset;
              uop_v0_end          = ele_start + uop_v0_end_offset;

              if (uop_info.uop_exe_unit==LSU) begin
                // index load/store with EEW_vd(vs3):EEW_vs2 = 1:2
                uop_vd_start      = ele_start;
                uop_vd_end        = ele_start + (`VLENB >> vd_eew_shift) - 1'b1;
              end
              else begin
                uop_vd_start      = uop_v0_start;
                uop_vd_end        = uop_v0_end;
              end
            end
            {EEW32,EEW8}: begin
              // narrowing instruction: EEW_vd:EEW_vs = 1:4
              ele_start = (`VSTART_WIDTH)'(uop_info.uop_index[`UOP_INDEX_WIDTH-1:2]) << VLENB_WIDTH;

              case(uop_info.uop_index[1:0])
                2'd3: begin
                  uop_v0_start_offset = `VLENB*3/4;
                  uop_v0_end_offset   = `VLENB*4/4 - 1;
                end
                2'd2: begin
                  uop_v0_start_offset = `VLENB*2/4;
                  uop_v0_end_offset   = `VLENB*3/4 - 1;
                end
                2'd1: begin
                  uop_v0_start_offset = `VLENB*1/4;
                  uop_v0_end_offset   = `VLENB*2/4 - 1;
                end
                default: begin
                  uop_v0_start_offset = 'b0;
                  uop_v0_end_offset   = `VLENB*1/4 - 1;
                end
              endcase
              uop_v0_start = ele_start + uop_v0_start_offset;
              uop_v0_end   = ele_start + uop_v0_end_offset;

              if (uop_info.uop_exe_unit==LSU) begin
                // index load/store with EEW_vd(vs3):EEW_vs2 = 1:4
                uop_vd_start          = ele_start;
                uop_vd_end            = ele_start + (`VLENB >> vd_eew_shift) - 1'b1;
              end
              else begin
                uop_vd_start          = uop_v0_start;
                uop_vd_end            = uop_v0_end;
              end
            end
            default: begin  // {EEW1,EEW1}
              ele_start           = 'b0; 

              uop_v0_start_offset = 'b0;
              uop_v0_end_offset   = 'b0;
              uop_v0_start        = uop_info.vstart; 
              uop_v0_end          = uop_info.vl;

              uop_vd_start        = uop_v0_start;
              uop_vd_end          = uop_v0_end;
            end
          endcase
        end

        assign v0_enable_tmp = v0_data[ele_start+:`VLENB]; 

        for (i=0; i<`VLENB; i++) begin : gen_vd_byte_type
          // ele_index = uop_index * (VLEN/vd_eew) + BYTE_INDEX[MSB:vd_eew]
          assign v0_enable[i] = uop_info.vm ? 1'b1 : v0_enable_tmp[i >> vd_eew_shift];
          assign vd_enable[i] = v0_enable[i];
          assign vd_ele_index[i] = (`VL_WIDTH)'(ele_start) + (i >> vd_eew_shift);

          always_comb begin
            if (uop_info.ignore_vta&uop_info.ignore_vma)
              v0_strobe[i] = 'b1;
            else if (vd_ele_index[i] >= uop_info.vl) 
              v0_strobe[i] = 'b0;
            else if ((vd_ele_index[i] < {1'b0, uop_info.vstart})||(vd_ele_index[i] < {1'b0, uop_v0_start})) 
              v0_strobe[i] = 'b0;
            else if (vd_ele_index[i] > {1'b0, uop_v0_end}) 
              v0_strobe[i] = 'b0;
            else 
              v0_strobe[i] = v0_enable[i] || uop_info.ignore_vma;
          end

          always_comb begin
            case (uop_info.uop_exe_unit)
              RDT:begin
                case(uop_info.vd_eew)
                  EEW32:vd[i] = i<4 ? BODY_ACTIVE : TAIL;
                  EEW16:vd[i] = i<2 ? BODY_ACTIVE : TAIL;
                  default:vd[i] = i<1 ? BODY_ACTIVE : TAIL;
                endcase
              end
              default:begin
                if (uop_info.ignore_vta&uop_info.ignore_vma)
                    vd[i] = BODY_ACTIVE;       
                else if (vd_ele_index[i] >= uop_info.vl) 
                    vd[i] = TAIL;       
                else if ((vd_ele_index[i] < {1'b0, uop_info.vstart})||(vd_ele_index[i] < {1'b0, uop_vd_start})) 
                    vd[i] = NOT_CHANGE;     // prestart
                else if (vd_ele_index[i] > {1'b0, uop_vd_end}) 
                    vd[i] = BODY_INACTIVE;
                else 
                    vd[i] = (vd_enable[i] || uop_info.ignore_vma) ? BODY_ACTIVE : BODY_INACTIVE;
              end
            endcase
          end
        end
    endgenerate

    assign operand_byte_type.vs2       = vs2;
    assign operand_byte_type.vd        = vd;
    assign operand_byte_type.v0_strobe = v0_strobe;

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_raw_uop_rob.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description:
// 1. the rvv_backend_dispatch_raw_uop_rob is a sub-module for rvv_backend_dispatch module
//    a. check RAW hazard between uop and ROB
//

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_raw_uop_rob
(
    raw_uop_rob,
    suc_uop,
    pre_uop
);

// ---port definition-------------------------------------------------
    output  RAW_UOP_ROB_t     raw_uop_rob;
    input   SUC_UOP_RAW_t     suc_uop;
    input   PRE_UOP_RAW_t [`ROB_DEPTH-1:0]  pre_uop;

// ---internal signal definition--------------------------------------
    logic [`ROB_DEPTH-1:0]    vs1_cmp;  // comparison result for vs1
    logic [`ROB_DEPTH-1:0]    vs2_cmp;  // comparison result for vs2
    logic [`ROB_DEPTH-1:0]    vd_cmp;   // comparison result for vd
    logic [`ROB_DEPTH-1:0]    v0_cmp;   // comparison result for v0

    logic [`ROB_DEPTH-1:0]    vs1_hit;  // set if the destination of pre_uop is the source of suc_uop
    logic [`ROB_DEPTH-1:0]    vs2_hit;  
    logic [`ROB_DEPTH-1:0]    vd_hit;   
    logic [`ROB_DEPTH-1:0]    v0_hit;   

    logic  [`ROB_DEPTH-1:0]   vs1_wait; // set if the destination of pre_uop is not valid when RAW occurs  
    logic  [`ROB_DEPTH-1:0]   vs2_wait;  
    logic  [`ROB_DEPTH-1:0]   vd_wait;   
    logic  [`ROB_DEPTH-1:0]   v0_wait;   
// ---code start------------------------------------------------------
    genvar i;
    generate
        for (i=0; i<`ROB_DEPTH; i++) begin : gen_compare_result
            assign vs1_cmp[i] = (suc_uop.vs1_index == pre_uop[i].w_index);
            assign vs2_cmp[i] = (suc_uop.vs2_index == pre_uop[i].w_index);
            assign vd_cmp[i]  = (suc_uop.vd_index  == pre_uop[i].w_index);
            assign v0_cmp[i]  = (`V0_INDEX         == pre_uop[i].w_index);
        end
    endgenerate

// conditions when RAW occurs: a & b & c
// a. compare result indicates src_index equal dst_index
// b. successor uop do need src vector register -> *_valid is asserted
// c. predecessor uop is a valid uop
    generate
        for (i=0; i<`ROB_DEPTH; i++) begin : gen_hit_result
            assign vs1_hit[i] = vs1_cmp[i] & suc_uop.vs1_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign vs2_hit[i] = vs2_cmp[i] & suc_uop.vs2_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign vd_hit[i]  = vd_cmp[i]  & suc_uop.vs3_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign v0_hit[i]  = v0_cmp[i]  & (~suc_uop.vm)     & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
        end
    endgenerate

    generate
        for (i=0; i<`ROB_DEPTH; i++) begin : gen_wait_result
            assign vs1_wait[i] = vs1_hit[i] & (~pre_uop[i].w_valid);
            assign vs2_wait[i] = vs2_hit[i] & (~pre_uop[i].w_valid);
            assign vd_wait[i]  = vd_hit[i]  & (~pre_uop[i].w_valid);
            assign v0_wait[i]  = v0_hit[i]  & (~pre_uop[i].w_valid);
        end
    endgenerate

// output result
    assign raw_uop_rob.vs1_hit = vs1_hit;
    assign raw_uop_rob.vs2_hit = vs2_hit;
    assign raw_uop_rob.vd_hit  = vd_hit;
    assign raw_uop_rob.v0_hit  = v0_hit;
    assign raw_uop_rob.vs1_wait = |vs1_wait;
    assign raw_uop_rob.vs2_wait = |vs2_wait;
    assign raw_uop_rob.vd_wait  = |vd_wait;
    assign raw_uop_rob.v0_wait  = |v0_wait;

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_raw_uop_uop.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description:
// 1. the rvv_backend_dispatch_raw_uop_uop is a sub-module for rvv_backend_dispatch module
//    a. check RAW hazard between suc_uop and pre_uop(s)
//

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_raw_uop_uop
(
    raw_uop_uop,
    suc_uop,
    pre_uop
);

// ---parameter definition--------------------------------------------
    parameter PREUOP_NUM = 1;

// ---port definition-------------------------------------------------
    output  RAW_UOP_UOP_t     raw_uop_uop;
    input   SUC_UOP_RAW_t     suc_uop;
    input   PRE_UOP_RAW_t [PREUOP_NUM-1:0]  pre_uop;

// ---internal signal definition--------------------------------------
    logic [PREUOP_NUM-1:0]    vs1_cmp;  // comparison result for vs1
    logic [PREUOP_NUM-1:0]    vs2_cmp;  // comparison result for vs2
    logic [PREUOP_NUM-1:0]    vd_cmp;   // comparison result for vd
    logic [PREUOP_NUM-1:0]    v0_cmp;   // comparison result for v0

    logic [PREUOP_NUM-1:0]    vs1_hit;  // set if the destination of pre_uop is the source of suc_uop
    logic [PREUOP_NUM-1:0]    vs2_hit;  
    logic [PREUOP_NUM-1:0]    vd_hit;   
    logic [PREUOP_NUM-1:0]    v0_hit;   

    logic  [PREUOP_NUM-1:0]   vs1_wait; // set if the destination of pre_uop is not valid when RAW occurs  
    logic  [PREUOP_NUM-1:0]   vs2_wait;  
    logic  [PREUOP_NUM-1:0]   vd_wait;   
    logic  [PREUOP_NUM-1:0]   v0_wait;   
// ---code start------------------------------------------------------
    genvar i;
    generate
        for (i=0; i<PREUOP_NUM; i++) begin : gen_compare_result
            assign vs1_cmp[i] = (suc_uop.vs1_index == pre_uop[i].w_index);
            assign vs2_cmp[i] = (suc_uop.vs2_index == pre_uop[i].w_index);
            assign vd_cmp[i]  = (suc_uop.vd_index  == pre_uop[i].w_index);
            assign v0_cmp[i]  = (`V0_INDEX         == pre_uop[i].w_index);
        end
    endgenerate

// conditions when RAW occurs: a & b & c
// a. compare result indicates src_index equal dst_index
// b. successor uop do need src vector register -> *_valid is asserted
// c. predecessor uop is a valid uop
    generate
        for (i=0; i<PREUOP_NUM; i++) begin : gen_hit_result
            assign vs1_hit[i] = vs1_cmp[i] & suc_uop.vs1_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign vs2_hit[i] = vs2_cmp[i] & suc_uop.vs2_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign vd_hit[i]  = vd_cmp[i]  & suc_uop.vs3_valid & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
            assign v0_hit[i]  = v0_cmp[i]  & (~suc_uop.vm)     & pre_uop[i].valid & (pre_uop[i].w_type==VRF);
        end
    endgenerate

    generate
        for (i=0; i<PREUOP_NUM; i++) begin : gen_wait_result
            assign vs1_wait[i] = vs1_hit[i] & (~pre_uop[i].w_valid);
            assign vs2_wait[i] = vs2_hit[i] & (~pre_uop[i].w_valid);
            assign vd_wait[i]  = vd_hit[i]  & (~pre_uop[i].w_valid);
            assign v0_wait[i]  = v0_hit[i]  & (~pre_uop[i].w_valid);
        end
    endgenerate

// output result
    assign raw_uop_uop.vs1_wait = |vs1_wait;
    assign raw_uop_uop.vs2_wait = |vs2_wait;
    assign raw_uop_uop.vd_wait  = |vd_wait;
    assign raw_uop_uop.v0_wait  = |v0_wait;

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch_structure_hazard.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description:
// 1. rvv_backend_dispatch_structure_hazard sub-module is used to check structure hazard
//    for uop(s)
//

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch_structure_hazard
(
    rd_index,
    arch_hazard,
    strct_uop
);

//---port definition--------------------------------------------------
    output logic [`NUM_DP_VRF-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_index;
    output ARCH_HAZARD_t                                     arch_hazard;
    input  STRCT_UOP_t [`NUM_DP_UOP-1:0]                     strct_uop;
//---internal signal definition---------------------------------------
//---code start-------------------------------------------------------
//determine rd_index for VRF read ports

    generate
`ifdef ISSUE_3_READ_PORT_6  
      // 6 read ports of VRF
      // rd0 : uop0.vs1 or uop2 
      // rd1 : uop0.vs2 or uop2
      // rd2 : uop0.vs3 or uop2
      // rd3 : uop1.vs1 or uop2
      // rd4 : uop1.vs2 or uop2
      // rd5 : uop1.vs3 or uop2
      // check structure hazard for uop2
      always_comb begin
        rd_index[0] = strct_uop[0].vs1_index;
        rd_index[1] = strct_uop[0].vs2_index;
        rd_index[2] = strct_uop[0].vd_index;
        rd_index[3] = strct_uop[1].vs1_index;
        rd_index[4] = strct_uop[1].vs2_index;
        rd_index[5] = strct_uop[1].vd_index;
        
        arch_hazard.vr_limit = 1'b1;

        case(strct_uop[2].uop_class)
          XXX: begin
            arch_hazard.vr_limit = 'b0;
          end

          XXV,
          XVX,
          VXX: begin
            case(strct_uop[0].uop_class)
              XXV,
              XVV: begin
                case(1'b1)
                  strct_uop[2].vs3_valid: rd_index[2] = strct_uop[2].vd_index;
                  strct_uop[2].vs2_valid: rd_index[2] = strct_uop[2].vs2_index;
                  default:                rd_index[2] = strct_uop[2].vs1_index;
                endcase
                arch_hazard.vr_limit = 'b0;
              end

              XXX,
              XVX,
              VXX,
              VVX: begin
                case(1'b1)
                  strct_uop[2].vs3_valid: rd_index[0] = strct_uop[2].vd_index;
                  strct_uop[2].vs2_valid: rd_index[0] = strct_uop[2].vs2_index;
                  default:                rd_index[0] = strct_uop[2].vs1_index;
                endcase
                arch_hazard.vr_limit = 'b0;
              end

              VVV: begin 
                case(strct_uop[1].uop_class)
                  XXV,
                  XVV: begin
                    case(1'b1)
                      strct_uop[2].vs3_valid: rd_index[5] = strct_uop[2].vd_index;
                      strct_uop[2].vs2_valid: rd_index[5] = strct_uop[2].vs2_index;
                      default:                rd_index[5] = strct_uop[2].vs1_index;
                    endcase
                    arch_hazard.vr_limit = 'b0;
                  end

                  XXX,
                  XVX,
                  VXX,
                  VVX: begin
                    case(1'b1)
                      strct_uop[2].vs3_valid: rd_index[3] = strct_uop[2].vd_index;
                      strct_uop[2].vs2_valid: rd_index[3] = strct_uop[2].vs2_index;
                      default:                rd_index[3] = strct_uop[2].vs1_index;
                    endcase
                    arch_hazard.vr_limit = 'b0;
                  end

                  //VVV: arch_hazard.vr_limit = 'b1;
                endcase
              end
            endcase
          end
          
          XVV,
          VVX: begin
            case(strct_uop[0].uop_class)
              XXX,
              VXX: begin
                rd_index[0] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                       strct_uop[2].vd_index ;
                rd_index[1] = strct_uop[2].vs2_index;
                arch_hazard.vr_limit = 'b0;
              end

              XXV: begin
                rd_index[2] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                       strct_uop[2].vd_index ;
                rd_index[1] = strct_uop[2].vs2_index ;
                arch_hazard.vr_limit = 'b0;
              end

              XVX: begin
                rd_index[0] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                       strct_uop[2].vd_index ;
                rd_index[2] = strct_uop[2].vs2_index ;
                arch_hazard.vr_limit = 'b0;
              end

              XVV,
              VVX: begin
                case(strct_uop[1].uop_class)
                  XXX,
                  VXX: begin
                    rd_index[3] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index ;
                    rd_index[4] = strct_uop[2].vs2_index ;
                    arch_hazard.vr_limit = 'b0;
                  end

                  XXV: begin
                    rd_index[5] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index ;
                    rd_index[4] = strct_uop[2].vs2_index ;
                    arch_hazard.vr_limit = 'b0;
                  end

                  XVX: begin
                    rd_index[3] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index ;
                    rd_index[5] = strct_uop[2].vs2_index ;
                    arch_hazard.vr_limit = 'b0;
                  end   

                  VVX: begin
                    if (strct_uop[0].vs1_valid=='b0) 
                      rd_index[0] = strct_uop[2].vs2_index;
                    else 
                      rd_index[2] = strct_uop[2].vs2_index;
                    
                    rd_index[3] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index;
                    arch_hazard.vr_limit = 'b0;
                  end

                  XVV: begin
                    if (strct_uop[0].vs1_valid=='b0) 
                      rd_index[0] = strct_uop[2].vs2_index;
                    else 
                      rd_index[2] = strct_uop[2].vs2_index;

                    rd_index[5] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index;
                    arch_hazard.vr_limit = 'b0;
                  end
                endcase
              end

              VVV: begin 
                case(strct_uop[1].uop_class)
                  XXX,
                  VXX: begin
                    rd_index[3] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index;
                    rd_index[4] = strct_uop[2].vs2_index ; 
                    arch_hazard.vr_limit = 'b0;
                  end

                  XVX: begin
                    rd_index[3] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index;
                    rd_index[5] = strct_uop[2].vs2_index ; 
                    arch_hazard.vr_limit = 'b0;
                  end

                  XXV: begin
                    rd_index[4] = strct_uop[2].vs1_valid ? strct_uop[2].vs1_index : 
                                                           strct_uop[2].vd_index;
                    rd_index[5] = strct_uop[2].vs2_index ; 
                    arch_hazard.vr_limit = 'b0;
                  end

                  VVV: begin
                    arch_hazard.vr_limit = 'b1;
                  end
                endcase
              end
            endcase
          end

          VVV: begin
            case({strct_uop[0].uop_class,strct_uop[1].uop_class})
              {XXX,XXX},
              {XXX,XXV},
              {XXX,XVX},
              {XXX,VXX},
              {XXX,XVV},
              {XXX,VVX},
              {XXX,VVV}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[1] = strct_uop[2].vs2_index;
                rd_index[2] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XXV,XXX},
              {XVX,XXX},
              {VXX,XXX},
              {XVV,XXX},
              {VVX,XXX},
              {VVV,XXX}: begin
                rd_index[3] = strct_uop[2].vs1_index;
                rd_index[4] = strct_uop[2].vs2_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XXV,VXX},
              {XXV,VVX}: begin
                rd_index[1] = strct_uop[2].vs2_index;
                rd_index[2] = strct_uop[2].vd_index;
                rd_index[3] = strct_uop[2].vs1_index;
                arch_hazard.vr_limit = 'b0;
              end
              
              {XXV,XXV},
              {XXV,XVX},
              {XXV,XVV}: begin
                rd_index[1] = strct_uop[2].vs2_index;
                rd_index[2] = strct_uop[2].vd_index;
                rd_index[5] = strct_uop[2].vs1_index;
                arch_hazard.vr_limit = 'b0;
              end
              
              {XVX,VXX},
              {XVX,VVX}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[2] = strct_uop[2].vd_index;
                rd_index[3] = strct_uop[2].vs2_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XVX,XXV},
              {XVX,XVX},
              {XVX,XVV}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[2] = strct_uop[2].vd_index;
                rd_index[5] = strct_uop[2].vs2_index;
                arch_hazard.vr_limit = 'b0;
              end

              {VXX,VXX},
              {VXX,VVX}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[1] = strct_uop[2].vs2_index;
                rd_index[3] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {VXX,XXV},
              {VXX,XVX},
              {VXX,XVV}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[1] = strct_uop[2].vs2_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XVV,VXX}: begin
                rd_index[2] = strct_uop[2].vd_index;
                rd_index[3] = strct_uop[2].vs1_index;
                rd_index[4] = strct_uop[2].vs2_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XVV,XVX}: begin
                rd_index[2] = strct_uop[2].vs2_index;
                rd_index[3] = strct_uop[2].vs1_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {XVV,XXV}: begin
                rd_index[2] = strct_uop[2].vs1_index;
                rd_index[4] = strct_uop[2].vs2_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {VVX,VXX}: begin
                rd_index[0] = strct_uop[2].vd_index;
                rd_index[3] = strct_uop[2].vs1_index;
                rd_index[4] = strct_uop[2].vs2_index;
                arch_hazard.vr_limit = 'b0;
              end

              {VVX,XVX}: begin
                rd_index[0] = strct_uop[2].vs2_index;
                rd_index[3] = strct_uop[2].vs1_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              {VVX,XXV}: begin
                rd_index[0] = strct_uop[2].vs1_index;
                rd_index[4] = strct_uop[2].vs2_index;
                rd_index[5] = strct_uop[2].vd_index;
                arch_hazard.vr_limit = 'b0;
              end

              default: begin
                arch_hazard.vr_limit = 'b1;
              end
            endcase
          end
        endcase
      end

`elsif ISSUE_2_READ_PORT_6  
      // 6 read ports of VRF
      // rd0 : uop0.vs1
      // rd1 : uop0.vs2
      // rd2 : uop0.vs3
      // rd3 : uop1.vs1
      // rd4 : uop1.vs2
      // rd5 : uop1.vs3
      assign rd_index[0] = strct_uop[0].vs1_index;
      assign rd_index[1] = strct_uop[0].vs2_index;
      assign rd_index[2] = strct_uop[0].vd_index;
      assign rd_index[3] = strct_uop[1].vs1_index;
      assign rd_index[4] = strct_uop[1].vs2_index;
      assign rd_index[5] = strct_uop[1].vd_index;

      //check structure hazard
      assign arch_hazard.vr_limit = 1'b0;

`else //ISSUE_2_READ_PORT_4
      // 4 read ports of VRF
      // rd0: uop0.vs2 or uop0.vs1 or uop0.vd
      // rd1: uop0.vs1 or uop1.vd
      // rd2: uop1.vs2 or uop1.vs1 or uop1.vd
      // rd3: uop1.vs1 or uop0.vd
      always_comb begin
        // read port[0] of VRF
        case(strct_uop[0].uop_class)
          VVV,
          XVV,                      
          VVX,
          XVX: begin
            rd_index[0] = strct_uop[0].vs2_index;
          end
          VXX: begin
            rd_index[0] = strct_uop[0].vd_index;
          end
          XXV: begin
            rd_index[0] = strct_uop[0].vs1_index;
          end
          default: begin
            rd_index[0] = 'x;
          end
        endcase
        // rd[1]
        case(strct_uop[0].uop_class)
          VVV,
          XVV:begin                       
            rd_index[1] = strct_uop[0].vs1_index;
          end
          VVX: begin
            rd_index[1] = strct_uop[0].vd_index;
          end
          VXX,
          XVX,
          XXV,
          XXX: begin
            rd_index[1] = strct_uop[1].uop_class==VVV ? strct_uop[1].vd_index : 'x;
          end
          default: begin
            rd_index[1] = strct_uop[1].uop_class==VVV ? strct_uop[1].vd_index : 'x;
          end
        endcase
        // rd[2]
        case(strct_uop[1].uop_class)
          VVV,
          XVV,                      
          VVX,
          XVX: begin
            rd_index[2] = strct_uop[1].vs2_index;
          end
          VXX: begin
            rd_index[2] = strct_uop[1].vd_index;
          end
          XXV: begin
            rd_index[2] = strct_uop[1].vs1_index;
          end
          default: begin
            rd_index[2] = 'x;
          end
        endcase
        // rd[3]
        case(strct_uop[1].uop_class)
          VVV,
          XVV:begin                       
            rd_index[3] = strct_uop[0].uop_class==VVV ? strct_uop[0].vd_index : strct_uop[1].vs1_index;
          end
          VVX: begin
            rd_index[3] = strct_uop[0].uop_class==VVV ? strct_uop[0].vd_index : strct_uop[1].vd_index;
          end
          VXX,
          XVX,
          XXV,
          XXX: begin
            rd_index[3] = strct_uop[0].uop_class==VVV ? strct_uop[0].vd_index : 'x;
          end
          default: begin
            rd_index[3] = strct_uop[0].uop_class==VVV ? strct_uop[0].vd_index : 'x;
          end
        endcase
      end

      //check structure hazard
      always_comb begin
        case({strct_uop[0].uop_class, strct_uop[1].uop_class})
          {VVV, VVV},
          {VVV, XVV},
          {VVV, VVX},
          {XVV, VVV},
          {VVX, VVV}: arch_hazard.vr_limit = 1'b1;
          default:    arch_hazard.vr_limit = 1'b0;
        endcase
      end

`endif
    endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_dispatch.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description:
// 1. Dispatch unit receives uop instructions from uop queue
// 2. Dispatch unit check rules to determine if the uops are sent to reservation stations(RS). 
//    There are two ways to solve: 
//     a. stall pipeline
//     b. foreward data from ROB
// 3. Dispatch unit read vector data from VRF for uops.
// 
// feature list:
// 1. Dispatch module can issue 2 uops at most.
//     a. Uop sequence must be in-order.
//     b. Issuing uop(s) use valid-ready handshake mechanism.
// 2. Dispatch rules
//     a. RAW data hazard: 
//         I. uop0 Vs rob_entry(s). if rob_entry.vd_valid is 'b0, then stall pipeline (do not issue uop0)
//         II.uop1 Vs rob_entry(s). if rob_entry.vd_valid is 'b0, then do not issue uop1
//         II.uop1 Vs uop0. if uop0.vd_valid is the src of uop1, then do not issue uop0
//     b. Structure hazard:
//         I. the src-operand number of uops is more than 4, then only issue uop0

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_DISPATCH__SVH
`include "rvv_backend_dispatch.svh"
`endif

module rvv_backend_dispatch
(
    clk,
    rst_n,
    uop_valid_uop2dp,
    uop_uop2dp,
    uop_ready_dp2uop,
    rs_valid_dp2alu,
    rs_dp2alu,
    rs_ready_alu2dp,
    rs_valid_dp2pmtrdt,
    rs_dp2pmtrdt,
    rs_ready_pmtrdt2dp,
    rs_valid_dp2mul,
    rs_dp2mul,
    rs_ready_mul2dp,
    rs_valid_dp2div,
    rs_dp2div,
    rs_ready_div2dp,
    rs_valid_dp2lsu,
    rs_dp2lsu,
    rs_ready_lsu2dp,
    mapinfo_valid_dp2lsu,
    mapinfo_dp2lsu,
    mapinfo_ready_lsu2dp,
    uop_valid_dp2rob,
    uop_dp2rob,
    uop_ready_rob2dp,
    uop_index_rob2dp,
    rd_index_dp2vrf,        
    rd_data_vrf2dp,
    v0_mask_vrf2dp,
    rob_entry
);  
// ---port definition-------------------------------------------------
// global signal
    input  logic           clk;
    input  logic           rst_n;

// Uops Queue to Dispatch unit
    input  logic        [`NUM_DP_UOP-1:0]         uop_valid_uop2dp;
    input  UOP_QUEUE_t  [`NUM_DP_UOP-1:0]         uop_uop2dp;
    output logic        [`NUM_DP_UOP-1:0]         uop_ready_dp2uop;

// Dispatch unit sends oprations to reservation stations
// Dispatch unit to ALU reservation station
// rs_*: reservation station
    output logic          [`NUM_DP_UOP-1:0]       rs_valid_dp2alu;
    output ALU_RS_t       [`NUM_DP_UOP-1:0]       rs_dp2alu;
    input  logic          [`NUM_DP_UOP-1:0]       rs_ready_alu2dp;

// Dispatch unit to PMT+RDT reservation station
    output logic          [`NUM_DP_UOP-1:0]       rs_valid_dp2pmtrdt;
    output PMT_RDT_RS_t   [`NUM_DP_UOP-1:0]       rs_dp2pmtrdt;
    input  logic          [`NUM_DP_UOP-1:0]       rs_ready_pmtrdt2dp;

// Dispatch unit to MUL reservation station
    output logic          [`NUM_DP_UOP-1:0]       rs_valid_dp2mul;
    output MUL_RS_t       [`NUM_DP_UOP-1:0]       rs_dp2mul;
    input  logic          [`NUM_DP_UOP-1:0]       rs_ready_mul2dp;

// Dispatch unit to DIV reservation station
    output logic          [`NUM_DP_UOP-1:0]       rs_valid_dp2div;
    output DIV_RS_t       [`NUM_DP_UOP-1:0]       rs_dp2div;
    input  logic          [`NUM_DP_UOP-1:0]       rs_ready_div2dp;

// Dispatch unit to LSU 
    // to LSU RS
    output logic          [`NUM_DP_UOP-1:0]       rs_valid_dp2lsu;
    output UOP_RVV2LSU_t  [`NUM_DP_UOP-1:0]       rs_dp2lsu;
    input  logic          [`NUM_DP_UOP-1:0]       rs_ready_lsu2dp;
    // to LSU MAP INFO
    output logic          [`NUM_DP_UOP-1:0]       mapinfo_valid_dp2lsu;
    output LSU_MAP_INFO_t [`NUM_DP_UOP-1:0]       mapinfo_dp2lsu;
    input  logic          [`NUM_DP_UOP-1:0]       mapinfo_ready_lsu2dp;

// Dispatch unit pushes operations to ROB unit    
    output logic          [`NUM_DP_UOP-1:0]       uop_valid_dp2rob;
    output DP2ROB_t       [`NUM_DP_UOP-1:0]       uop_dp2rob;
    input  logic          [`NUM_DP_UOP-1:0]       uop_ready_rob2dp;
    input  logic          [`ROB_DEPTH_WIDTH-1:0]  uop_index_rob2dp;

// Dispatch unit sends read request to VRF for vector data.
// Dispatch unit to VRF unit
// rd_data would be return from VRF at the current cycle.
    output logic [`NUM_DP_VRF-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_index_dp2vrf;          
    input  logic [`NUM_DP_VRF-1:0][`VLEN-1:0]                rd_data_vrf2dp;
    input  logic [`VLEN-1:0]                                 v0_mask_vrf2dp;

// Dispatch unit accept all ROB entry to determine if vs_data of RS is from ROB or not
// ROB unit to Dispatch unit
    input  ROB2DP_t     [`ROB_DEPTH-1:0]          rob_entry;

// ---internal signal definition--------------------------------------
    SUC_UOP_RAW_t       [`NUM_DP_UOP-1:0]   suc_uop;
    PRE_UOP_RAW_t       [`ROB_DEPTH-1:0]    pre_uop_rob;
    PRE_UOP_RAW_t       [`NUM_DP_UOP-2:0]   pre_uop_uop;
    RAW_UOP_ROB_t       [`NUM_DP_UOP-1:0]   raw_uop_rob; 
    // uop0 is the first uop so no need raw check between uops for it
    RAW_UOP_UOP_t       [`NUM_DP_UOP-1:1]   raw_uop_uop; 

    STRCT_UOP_t         [`NUM_DP_UOP-1:0]   strct_uop;
    ARCH_HAZARD_t                           arch_hazard;

    UOP_OPN_t           [`NUM_DP_UOP-1:0]   uop_operand;
    UOP_OPN_t           [`NUM_DP_UOP-1:0]   vrf_byp;
    ROB_BYP_t           [`ROB_DEPTH-1:0]    rob_byp;

    UOP_CTRL_t          [`NUM_DP_UOP-1:0]   uop_ctrl;

    UOP_INFO_t          [`NUM_DP_UOP-1:0]   uop_info;
    UOP_OPN_BYTE_TYPE_t [`NUM_DP_UOP-1:0]   uop_operand_byte_type;

    logic [`NUM_DP_UOP-1:0][`VL_WIDTH-1:0]             vlmax;
    logic [`NUM_DP_UOP-1:0][$clog2(`VSTART_WIDTH)-1:0] vlmax_shift;

    logic [`NUM_DP_UOP-1:0][`ROB_DEPTH_WIDTH-1:0]      rob_address;

// ---code start------------------------------------------------------
    genvar i;

    // vlmax = lmul * `VLENB / sew 
    generate
      for (i=0; i<`NUM_DP_UOP; i++) begin : gen_vlmax
        assign vlmax_shift[i] ={1'b0, uop_uop2dp[i].vector_csr.lmul[1:0]} + $clog2(`VLENB) - uop_uop2dp[i].vector_csr.sew - {uop_uop2dp[i].vector_csr.lmul[2],2'b00};
        assign vlmax[i] = (`VL_WIDTH)'(1) << vlmax_shift[i];
      end
    endgenerate

    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_suc_uop
            assign suc_uop[i].vs1_index = uop_uop2dp[i].vs1;
            assign suc_uop[i].vs1_valid = uop_uop2dp[i].vs1_index_valid;
            assign suc_uop[i].vs2_index = uop_uop2dp[i].vs2_index;
            assign suc_uop[i].vs2_valid = uop_uop2dp[i].vs2_valid;
            assign suc_uop[i].vd_index  = uop_uop2dp[i].vd_index;
            assign suc_uop[i].vs3_valid = uop_uop2dp[i].vs3_valid;
            assign suc_uop[i].vm        = uop_uop2dp[i].vm;
        end
    endgenerate
// RAW data hazard check between uop[*] and ROB
    generate
        for (i=0; i<`ROB_DEPTH; i++) begin : gen_pre_uop_rob
            assign pre_uop_rob[i].w_index = rob_entry[i].w_index;
            assign pre_uop_rob[i].w_type  = rob_entry[i].w_type;
            assign pre_uop_rob[i].w_valid = rob_entry[i].w_valid;
            assign pre_uop_rob[i].valid   = rob_entry[i].valid;
        end
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_raw_uop_rob
            rvv_backend_dispatch_raw_uop_rob #(
            ) u_raw_uop_rob (
                .raw_uop_rob  (raw_uop_rob[i]),
                .suc_uop      (suc_uop[i]),
                .pre_uop      (pre_uop_rob)
            );
        end
    endgenerate

// RAW data hazard check between uop(s)
    generate
        for (i=0; i<`NUM_DP_UOP-1; i++) begin : gen_pre_uop_uop
            assign pre_uop_uop[i].w_index = uop_uop2dp[i].vd_index;
            assign pre_uop_uop[i].w_valid = 1'b0;
            assign pre_uop_uop[i].w_type  = uop_uop2dp[i].rd_index_valid ? XRF : VRF;
            assign pre_uop_uop[i].valid   = uop_uop2dp[i].vd_valid & uop_valid_uop2dp[i];
        end
        for (i=1; i<`NUM_DP_UOP; i++) begin : gen_raw_uop_uop
            rvv_backend_dispatch_raw_uop_uop #(
                .PREUOP_NUM (i)
            ) u_raw_uop_uop (
                .raw_uop_uop  (raw_uop_uop[i]),
                .suc_uop      (suc_uop[i]),
                .pre_uop      (pre_uop_uop[i-1:0])
            );
        end
    endgenerate

// Structure hazard check and set read index for VRF
    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_strct_uop
            assign strct_uop[i].vs1_index = uop_uop2dp[i].vs1;
            assign strct_uop[i].vs1_valid = uop_uop2dp[i].vs1_index_valid;
            assign strct_uop[i].vs2_index = uop_uop2dp[i].vs2_index;
            assign strct_uop[i].vs2_valid = uop_uop2dp[i].vs2_valid;
            assign strct_uop[i].vd_index  = uop_uop2dp[i].vd_index;
            assign strct_uop[i].vs3_valid = uop_uop2dp[i].vs3_valid;
            assign strct_uop[i].uop_exe_unit = uop_uop2dp[i].uop_exe_unit;
            assign strct_uop[i].uop_class = uop_uop2dp[i].uop_class;
        end
    endgenerate

    rvv_backend_dispatch_structure_hazard #(
    ) u_structure_hazard (
        .rd_index     (rd_index_dp2vrf),
        .arch_hazard  (arch_hazard),
        .strct_uop    (strct_uop)
    );

// Bypass data for source operand of uop(s)
    generate
      for (i=0; i<`ROB_DEPTH; i++) begin : gen_rob_byp
        assign rob_byp[i].w_data    = rob_entry[i].w_data;
        assign rob_byp[i].byte_type = rob_entry[i].byte_type;

        `ifdef AGNOSTIC_ONE
          assign rob_byp[i].tail_one  = rob_entry[i].vector_csr.vtype.vta;
          assign rob_byp[i].inactive_one = rob_entry[i].vector_csr.vtype.vma;
        `else
          assign rob_byp[i].tail_one  = 1'b0;
          assign rob_byp[i].inactive_one = 1'b0;
        `endif
      end

      rvv_backend_dispatch_operand
      u_operand
      (
        .vrf_byp        (vrf_byp       ),
        .uop_uop2dp     (uop_uop2dp    ),
        .rd_data_vrf2dp (rd_data_vrf2dp),
        .v0_mask_vrf2dp (v0_mask_vrf2dp)
      );

      for (i=0;i<`NUM_DP_UOP;i++) begin: gen_bypass_data
        rvv_backend_dispatch_bypass 
        #(
        ) 
        u_bypass (
          .uop_operand  (uop_operand[i]),
          .rob_byp      (rob_byp),
          .vrf_byp      (vrf_byp[i]),
          .raw_uop_rob  (raw_uop_rob[i])
        );
      end
    endgenerate

// Control handshae mechanism for uop_queue <-> dispath, dispatch <-> rs and dispatch <-> rob
    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_uop_ctrl
            assign uop_ctrl[i].uop_exe_unit = uop_uop2dp[i].uop_exe_unit;
            assign uop_ctrl[i].pshrob_valid = uop_uop2dp[i].pshrob_valid;
        end
    endgenerate

    rvv_backend_dispatch_ctrl #(
    ) u_ctrl (
      // ctrl input signal
        .raw_uop_rob            (raw_uop_rob),
        .raw_uop_uop            (raw_uop_uop),
        .arch_hazard            (arch_hazard),
        .uop_ctrl               (uop_ctrl),
      // handshake signals
        .uop_valid_uop2dp       (uop_valid_uop2dp),
        .uop_ready_dp2uop       (uop_ready_dp2uop),
        .rs_valid_dp2alu        (rs_valid_dp2alu),
        .rs_ready_alu2dp        (rs_ready_alu2dp),
        .rs_valid_dp2pmtrdt     (rs_valid_dp2pmtrdt),
        .rs_ready_pmtrdt2dp     (rs_ready_pmtrdt2dp),
        .rs_valid_dp2mul        (rs_valid_dp2mul),
        .rs_ready_mul2dp        (rs_ready_mul2dp),
        .rs_valid_dp2div        (rs_valid_dp2div),
        .rs_ready_div2dp        (rs_ready_div2dp),
        .rs_valid_dp2lsu        (rs_valid_dp2lsu),
        .rs_ready_lsu2dp        (rs_ready_lsu2dp),
        .mapinfo_valid_dp2lsu   (mapinfo_valid_dp2lsu),
        .mapinfo_ready_lsu2dp   (mapinfo_ready_lsu2dp),
        .uop_valid_dp2rob       (uop_valid_dp2rob),
        .uop_ready_rob2dp       (uop_ready_rob2dp)
    );

// determine the type for each byte in uop's vector operands 
    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_opr_bype_type
            assign uop_info[i].uop_index  = (uop_uop2dp[i].uop_exe_unit==LSU)&(uop_uop2dp[i].uop_funct6.lsu_funct6.lsu_is_seg==IS_SEGMENT)? 
                                            (`UOP_INDEX_WIDTH)'(uop_uop2dp[i].seg_field_index) : uop_uop2dp[i].uop_index;
            assign uop_info[i].uop_exe_unit = uop_uop2dp[i].uop_exe_unit;
            assign uop_info[i].vd_eew     = uop_uop2dp[i].vd_eew;
            assign uop_info[i].vs1_eew    = uop_uop2dp[i].vs1_eew;
            assign uop_info[i].vs2_eew    = uop_uop2dp[i].vs2_eew;
            assign uop_info[i].vstart     = uop_uop2dp[i].vector_csr.vstart;
            assign uop_info[i].vl         = uop_uop2dp[i].vs_evl;
            assign uop_info[i].vm         = uop_uop2dp[i].vm;
            assign uop_info[i].ignore_vma = uop_uop2dp[i].ignore_vma;
            assign uop_info[i].ignore_vta = uop_uop2dp[i].ignore_vta;

            rvv_backend_dispatch_opr_byte_type #(
            ) u_opr_byte_type (
                .operand_byte_type (uop_operand_byte_type[i]),
                .uop_info          (uop_info[i]),
                .v0_data           (uop_operand[i].v0)
            );
        end
    endgenerate

// output signals for RS+ROB
    generate
        for (i=0; i<`NUM_DP_UOP; i++) begin : gen_output_sig
          // rob_address
            if (i==0)
              assign rob_address[0] = uop_index_rob2dp;
            else begin 
              //assign rob_address[i] = (uop_uop2dp[i].uop_exe_unit==RDT||uop_uop2dp[i].uop_exe_unit==CMP)&(!uop_uop2dp[i].first_uop_valid) ? rob_address[i-1] : rob_address[i-1]+1'b1;
              assign rob_address[i] = rob_address[i-1] + (`ROB_DEPTH_WIDTH)'(uop_uop2dp[i-1].pshrob_valid);
            end

          // ALU RS
`ifdef TB_SUPPORT
            assign rs_dp2alu[i].uop_pc        = uop_uop2dp[i].uop_pc; 
`endif
            assign rs_dp2alu[i].rob_entry     = rob_address[i]; 
            assign rs_dp2alu[i].uop_funct6    = uop_uop2dp[i].uop_funct6;
            assign rs_dp2alu[i].uop_funct3    = uop_uop2dp[i].uop_funct3;
            assign rs_dp2alu[i].vstart        = uop_uop2dp[i].vector_csr.vstart;
            assign rs_dp2alu[i].vl            = uop_uop2dp[i].vs_evl;
            assign rs_dp2alu[i].vm            = uop_uop2dp[i].vm;
            assign rs_dp2alu[i].vxrm          = uop_uop2dp[i].vector_csr.xrm;
            assign rs_dp2alu[i].v0_data       = uop_operand[i].v0;
            assign rs_dp2alu[i].v0_data_valid = uop_uop2dp[i].v0_valid;
            assign rs_dp2alu[i].vd_data       = uop_operand[i].vd;
            assign rs_dp2alu[i].vd_data_valid = uop_uop2dp[i].vs3_valid;
            assign rs_dp2alu[i].vd_eew        = uop_uop2dp[i].vd_eew;
            assign rs_dp2alu[i].vs1           = uop_uop2dp[i].vs1;
            assign rs_dp2alu[i].vs1_data      = uop_operand[i].vs1;
            assign rs_dp2alu[i].vs1_data_valid= uop_uop2dp[i].vs1_index_valid;
            assign rs_dp2alu[i].vs2_data      = uop_operand[i].vs2;
            assign rs_dp2alu[i].vs2_data_valid= uop_uop2dp[i].vs2_valid;
            assign rs_dp2alu[i].vs2_eew       = uop_uop2dp[i].vs2_eew;
            assign rs_dp2alu[i].rs1_data      = uop_uop2dp[i].rs1_data;
            assign rs_dp2alu[i].rs1_data_valid= uop_uop2dp[i].rs1_data_valid;
            assign rs_dp2alu[i].uop_index     = uop_uop2dp[i].uop_index;

          // PMTRDT RS
`ifdef TB_SUPPORT
            assign rs_dp2pmtrdt[i].uop_pc          = uop_uop2dp[i].uop_pc; 
`endif
            assign rs_dp2pmtrdt[i].rob_entry       = rob_address[i]; 
            assign rs_dp2pmtrdt[i].uop_exe_unit    = uop_uop2dp[i].uop_exe_unit; 
            assign rs_dp2pmtrdt[i].uop_funct6      = uop_uop2dp[i].uop_funct6;
            assign rs_dp2pmtrdt[i].uop_funct3      = uop_uop2dp[i].uop_funct3;
            assign rs_dp2pmtrdt[i].vstart          = uop_uop2dp[i].vector_csr.vstart;
            assign rs_dp2pmtrdt[i].vl              = uop_uop2dp[i].vs_evl;
            assign rs_dp2pmtrdt[i].vlmax           = vlmax[i];
            assign rs_dp2pmtrdt[i].vm              = uop_uop2dp[i].vm;
            assign rs_dp2pmtrdt[i].v0_data         = uop_operand[i].v0;
            assign rs_dp2pmtrdt[i].v0_data_valid   = uop_uop2dp[i].v0_valid;
            assign rs_dp2pmtrdt[i].vs1_data        = uop_operand[i].vs1;
            assign rs_dp2pmtrdt[i].vs1_eew         = uop_uop2dp[i].vs1_eew;
            assign rs_dp2pmtrdt[i].vs1_data_valid  = uop_uop2dp[i].vs1_index_valid;
            assign rs_dp2pmtrdt[i].vs2_data        = uop_operand[i].vs2;
            assign rs_dp2pmtrdt[i].vs2_eew         = uop_uop2dp[i].vs2_eew;
            assign rs_dp2pmtrdt[i].vs2_type        = uop_operand_byte_type[i].vs2;
            assign rs_dp2pmtrdt[i].vs2_data_valid  = uop_uop2dp[i].vs2_valid;
            assign rs_dp2pmtrdt[i].vs3_data        = uop_operand[i].vd;
            assign rs_dp2pmtrdt[i].vs3_data_valid  = uop_uop2dp[i].vs3_valid;
            assign rs_dp2pmtrdt[i].rs1_data        = uop_uop2dp[i].rs1_data;
            assign rs_dp2pmtrdt[i].rs1_data_valid  = uop_uop2dp[i].rs1_data_valid;
            assign rs_dp2pmtrdt[i].first_uop_valid = uop_uop2dp[i].first_uop_valid;
            assign rs_dp2pmtrdt[i].last_uop_valid  = uop_uop2dp[i].last_uop_valid;
            assign rs_dp2pmtrdt[i].uop_index       = uop_uop2dp[i].uop_index;
            
          // MUL/MAC RS
`ifdef TB_SUPPORT
            assign rs_dp2mul[i].uop_pc         = uop_uop2dp[i].uop_pc; 
`endif
            assign rs_dp2mul[i].rob_entry      = rob_address[i]; 
            assign rs_dp2mul[i].uop_funct6     = uop_uop2dp[i].uop_funct6;
            assign rs_dp2mul[i].uop_funct3     = uop_uop2dp[i].uop_funct3;
            assign rs_dp2mul[i].vxrm           = uop_uop2dp[i].vector_csr.xrm;
            assign rs_dp2mul[i].vs1_data       = uop_operand[i].vs1;
            assign rs_dp2mul[i].vs1_data_valid = uop_uop2dp[i].vs1_index_valid;
            assign rs_dp2mul[i].vs2_data       = uop_operand[i].vs2;
            assign rs_dp2mul[i].vs2_data_valid = uop_uop2dp[i].vs2_valid;
            assign rs_dp2mul[i].vs2_eew        = uop_uop2dp[i].vs2_eew;
            assign rs_dp2mul[i].vs3_data       = uop_operand[i].vd;
            assign rs_dp2mul[i].vs3_data_valid = uop_uop2dp[i].vs3_valid;
            assign rs_dp2mul[i].rs1_data       = uop_uop2dp[i].rs1_data;
            assign rs_dp2mul[i].rs1_data_valid = uop_uop2dp[i].rs1_data_valid;
            assign rs_dp2mul[i].uop_index      = uop_uop2dp[i].uop_index;

          // DIV RS
`ifdef TB_SUPPORT
            assign rs_dp2div[i].uop_pc        = uop_uop2dp[i].uop_pc; 
`endif
            assign rs_dp2div[i].rob_entry     = rob_address[i]; 
            assign rs_dp2div[i].uop_funct6    = uop_uop2dp[i].uop_funct6;
            assign rs_dp2div[i].uop_funct3    = uop_uop2dp[i].uop_funct3;
            assign rs_dp2div[i].vs1_data      = uop_operand[i].vs1;
            assign rs_dp2div[i].vs1_data_valid= uop_uop2dp[i].vs1_index_valid;
            assign rs_dp2div[i].vs2_data      = uop_operand[i].vs2;
            assign rs_dp2div[i].vs2_eew       = uop_uop2dp[i].vs2_eew;
            assign rs_dp2div[i].vs2_data_valid= uop_uop2dp[i].vs2_valid;
            assign rs_dp2div[i].rs1_data      = uop_uop2dp[i].rs1_data;
            assign rs_dp2div[i].rs1_data_valid= uop_uop2dp[i].rs1_data_valid;

          // LSU RS
`ifdef TB_SUPPORT
            assign rs_dp2lsu[i].uop_pc              = uop_uop2dp[i].uop_pc; 
`endif
            assign rs_dp2lsu[i].vidx_valid          = uop_uop2dp[i].vs2_valid;
            assign rs_dp2lsu[i].vidx_addr           = uop_uop2dp[i].vs2_index;
            assign rs_dp2lsu[i].vidx_data           = uop_operand[i].vs2;
            assign rs_dp2lsu[i].vregfile_read_valid = uop_uop2dp[i].vs3_valid;
            assign rs_dp2lsu[i].vregfile_read_addr  = uop_uop2dp[i].vd_index;
            assign rs_dp2lsu[i].vregfile_read_data  = uop_operand[i].vd;
            assign rs_dp2lsu[i].v0_valid            = uop_uop2dp[i].v0_valid;
            assign rs_dp2lsu[i].v0_data             = uop_operand_byte_type[i].v0_strobe;

          // LSU MAP INFO
`ifdef TB_SUPPORT
            assign mapinfo_dp2lsu[i].uop_pc              = uop_uop2dp[i].uop_pc; 
`endif
            assign mapinfo_dp2lsu[i].valid               = mapinfo_valid_dp2lsu[i];
            assign mapinfo_dp2lsu[i].rob_entry           = rob_address[i];
            assign mapinfo_dp2lsu[i].lsu_class           = uop_uop2dp[i].uop_funct6.lsu_funct6.lsu_is_store;
            assign mapinfo_dp2lsu[i].vregfile_write_addr = uop_uop2dp[i].vd_index;

          // ROB
`ifdef TB_SUPPORT
            assign uop_dp2rob[i].uop_pc         = uop_uop2dp[i].uop_pc; 
`endif
            assign uop_dp2rob[i].w_index        = uop_uop2dp[i].rd_index_valid ? uop_uop2dp[i].rd_index : uop_uop2dp[i].vd_index;
            assign uop_dp2rob[i].w_type         = uop_uop2dp[i].rd_index_valid ? XRF : VRF;
            assign uop_dp2rob[i].byte_type      = uop_operand_byte_type[i].vd;
            assign uop_dp2rob[i].vector_csr     = uop_uop2dp[i].vector_csr;
            assign uop_dp2rob[i].last_uop_valid = uop_uop2dp[i].last_uop_valid;
        end
    endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_div_unit_divider.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef DIV_DEFINE_SVH
`include "rvv_backend_div.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_div_unit_divider
(
  clk,
  rst_n,
  div_valid,
  opcode,
  src2_dividend,
  src1_divisor,
  result_quotient,
  result_remainder,
  result_valid,
  result_ready,
  trap_flush_rvv
);
//
// parameter
//
  parameter logic[7:0] DIV_WIDTH = `WORD_WIDTH;

//
// interface signals
//
  // global signals
  input   logic                 clk;
  input   logic                 rst_n;

  // opcode 
  input   DIV_SIGN_SRC_e        opcode;

  // operand 
  input   logic                 div_valid;
  input   logic [DIV_WIDTH-1:0] src2_dividend;
  input   logic [DIV_WIDTH-1:0] src1_divisor;

  // result
  output  logic [DIV_WIDTH-1:0] result_quotient;
  output  logic [DIV_WIDTH-1:0] result_remainder;
  output  logic                 result_valid;
  input   logic                 result_ready;

  // trap-flush
  input   logic                 trap_flush_rvv;

//
// internal signals
//
  // FSM
  enum  logic [1:0] {DIV_IDLE, DIV_WORKING, DIV_PRINT, DIV_UNREACHABLE}
      state, next_state;
  
  // number of leading zero bits
  logic [$clog2(DIV_WIDTH):0]   cnt_clzb;
  logic [$clog2(DIV_WIDTH):0]   clzb;
  logic [$clog2(DIV_WIDTH):0]   count_shift;

  // processing round for divider
  logic [DIV_WIDTH-1:0]         quotient_r1;
  logic [DIV_WIDTH-1:0]         quotient_r2;
  logic [DIV_WIDTH-1:0]         quotient_r3;
  logic [DIV_WIDTH-1:0]         remainder_r1;
  logic [DIV_WIDTH-1:0]         remainder_r2;
  logic [DIV_WIDTH-1:0]         remainder_r3;
  logic [$clog2(DIV_WIDTH):0]   count_r1;
  logic [$clog2(DIV_WIDTH):0]   count_r2;
  logic [$clog2(DIV_WIDTH):0]   count_r3;

  // register signals
  logic                         dividend_en;
  logic [DIV_WIDTH-1:0]         dividend_d;
  logic [DIV_WIDTH-1:0]         dividend_q;
  logic                         divisor_en;
  logic [DIV_WIDTH-1:0]         divisor_d;
  logic [DIV_WIDTH-1:0]         divisor_q;
  logic                         quotient_en;
  logic [DIV_WIDTH-1:0]         quotient_d;
  logic [DIV_WIDTH-1:0]         quotient_q;
  logic                         remainder_en;
  logic [DIV_WIDTH-1:0]         remainder_d;
  logic [DIV_WIDTH-1:0]         remainder_q;
  logic                         count_en;
  logic [$clog2(DIV_WIDTH):0]   count_d;
  logic [$clog2(DIV_WIDTH):0]   count_q;
  logic                         q_sgn_en;
  logic                         q_sgn_d;
  logic                         q_sgn_q;
  logic                         r_sgn_en;
  logic                         r_sgn_d;
  logic                         r_sgn_q;
`ifdef TB_SUPPORT
  logic                         res_reuse_valid_p0;
`endif
  
//
// register
//
  // dividend
  cdffr
  #(
    .T      (logic [DIV_WIDTH-1:0])
  )
  dividend
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (dividend_en),
    .c      (trap_flush_rvv),
    .d      (dividend_d),
    .q      (dividend_q)
  );
  // divisor
  cdffr
  #(
    .T      (logic [DIV_WIDTH-1:0])
  )
  divisor
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (divisor_en),
    .c      (trap_flush_rvv),
    .d      (divisor_d),
    .q      (divisor_q)
  );
  // quotient
  cdffr
  #(
    .T      (logic [DIV_WIDTH-1:0])
  )
  quotient
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (quotient_en),
    .c      (trap_flush_rvv),
    .d      (quotient_d),
    .q      (quotient_q)
  );
  // remainder
  cdffr
  #(
    .T      (logic [DIV_WIDTH-1:0])
  )
  remainder
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (remainder_en),
    .c      (trap_flush_rvv),
    .d      (remainder_d),
    .q      (remainder_q)
  );
  // count
  edff
  #(
  .T        (logic [$clog2(DIV_WIDTH):0])
  )
  count
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (count_en),
    .d      (count_d),
    .q      (count_q)
  );
  // record quotient sgn-bit
  cdffr
  q_sgn
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (q_sgn_en),
    .c      (trap_flush_rvv),
    .d      (q_sgn_d),
    .q      (q_sgn_q)
  );
  // record remainder sgn-bit
  cdffr
  r_sgn
  (
    .clk    (clk),
    .rst_n  (rst_n),
    .e      (r_sgn_en),
    .c      (trap_flush_rvv),
    .d      (r_sgn_d),
    .q      (r_sgn_q)
  );

//
// FSM
//
  always_ff @(posedge clk, negedge rst_n) begin
    if (rst_n=='b0) 
      state <= DIV_IDLE;
    else 
      state <= next_state;
  end
  
  // state transition
  always_comb begin
    next_state = state;

    case(state)
      DIV_IDLE: begin
        if(div_valid&(!trap_flush_rvv)) begin
          if ((count_en=='b1)&(count_d=='b1))
            next_state = DIV_PRINT;
          else
            next_state = DIV_WORKING;
        end
      end
      DIV_WORKING: begin
        if(trap_flush_rvv)
          next_state = DIV_IDLE;
        else if(div_valid) begin
          if ((count_en=='b1)&(count_d=='b1))
            next_state = DIV_PRINT;
          else
            next_state = DIV_WORKING;
        end
      end
      DIV_PRINT: begin
        if(trap_flush_rvv)
          next_state = DIV_IDLE;
        else if ((div_valid)&(result_ready))
          next_state = DIV_IDLE;
        else
          next_state = DIV_PRINT;
      end
      // Necessary to suppress FSM_COMPLETE errors
      DIV_UNREACHABLE: begin
        next_state = DIV_IDLE;
      end
      default: begin
        next_state = DIV_IDLE;
      end
    endcase
  end

  // count leading zero
  generate 
    if (DIV_WIDTH== 'd`WORD_WIDTH) begin
      assign clzb = f_clzb32(dividend_d);
      assign count_shift = 'd33 - clzb;            
    end
    else if (DIV_WIDTH== 'd`HWORD_WIDTH) begin
      assign clzb = f_clzb16(dividend_d);
      assign count_shift = 'd17 - clzb;            
    end
    else if (DIV_WIDTH== 'd`BYTE_WIDTH) begin
      assign clzb = f_clzb8(dividend_d);
      assign count_shift = 'd9 - clzb;            
    end

  endgenerate

  always_comb begin
    // initial
    dividend_en      = 'b0;
    dividend_d       = 'b0;
    divisor_en       = 'b0;
    divisor_d        = 'b0;
    quotient_en      = 'b0;
    quotient_d       = 'b0;
    remainder_en     = 'b0;
    remainder_d      = 'b0;
    count_en         = 'b0;
    count_d          = 'b0;
    q_sgn_en         = 'b0;
    q_sgn_d          = 'b0;         
    r_sgn_en         = 'b0;
    r_sgn_d          = 'b0;
    cnt_clzb         = 'b0;
    quotient_r1      = 'b0;
    quotient_r2      = 'b0;
    quotient_r3      = 'b0;
    remainder_r1     = 'b0;
    remainder_r2     = 'b0;
    remainder_r3     = 'b0;
    count_r1         = 'b0;
    count_r2         = 'b0;
    count_r3         = 'b0;
    result_quotient  = 'b0;
    result_remainder = 'b0;
    result_valid     = 'b0;
`ifdef TB_SUPPORT
    res_reuse_valid_p0 = 'b0;
`endif

    case(state)
      DIV_IDLE: begin
        if(div_valid) begin
          // check whether divisor is 0
          if(src1_divisor=='b0) begin
            dividend_en = 'b1;
            dividend_d  = 'b0;

            divisor_en = 'b1;
            divisor_d  = 'b0;

            quotient_en = 'b1;
            quotient_d  = '1;

            remainder_en = 'b1;
            remainder_d  = src2_dividend;

            q_sgn_en = 'b1;
            q_sgn_d  = 'b0;

            r_sgn_en = 'b1;
            r_sgn_d  = 'b0;

            count_en = 'b1;
            count_d  = 'b1;
          end
          // check whether is -2^(WIDTH-1)/-1. The result will overflow.
          else if ((opcode==DIV_SIGN)&(src2_dividend=={1'b1,{(DIV_WIDTH-1){1'b0}}})&(src1_divisor=='1)) begin
            dividend_en = 'b1;
            dividend_d  = 'b0;

            divisor_en = 'b1;
            divisor_d  = 'b0;

            quotient_en = 'b1;
            quotient_d  = {1'b1,{(DIV_WIDTH-1){1'b0}}};

            remainder_en = 'b1;
            remainder_d  = 'b0;

            q_sgn_en = 'b1;
            q_sgn_d  = 'b0;

            r_sgn_en = 'b1;
            r_sgn_d  = 'b0;

            count_en = 'b1;
            count_d  = 'b1;
          end
          // start to initialize
          else begin
            if(opcode==DIV_SIGN) begin
              // convert signed data to unsigned data
              dividend_d  = src2_dividend[DIV_WIDTH-1] ? (~(src2_dividend)+1) : src2_dividend;
              divisor_d  = src1_divisor[DIV_WIDTH-1] ? (~(src1_divisor )+1) : src1_divisor;
              
              q_sgn_d   = src2_dividend[DIV_WIDTH-1]^src1_divisor[DIV_WIDTH-1];
              r_sgn_d   = src2_dividend[DIV_WIDTH-1];
            end
            else begin
              dividend_d  = src2_dividend;
              divisor_d  = src1_divisor;

              q_sgn_d  = 'b0;
              r_sgn_d  = 'b0;
            end

            // check whether dividend and divisor equal to last source data
            if ((dividend_d==dividend_q)&(divisor_d==divisor_q)&(q_sgn_d==q_sgn_q)&(r_sgn_d==r_sgn_q)) begin
              dividend_en = 'b0; 
              divisor_en = 'b0;

              q_sgn_en  = 'b0;
              r_sgn_en  = 'b0;
              
              count_en = 'b1;
              count_d  = 'b1;

`ifdef TB_SUPPORT
              res_reuse_valid_p0 = 1'b1;
`endif
            end
            else begin
              dividend_en = 'b1; 
              divisor_en = 'b1;

              q_sgn_en  = 'b1;
              r_sgn_en  = 'b1;

              // count leading zero bits in dividend
              cnt_clzb  = clzb;
              count_en  = 'b1;
              count_d   = count_shift;            

              // initialize quotient and remainder
              quotient_en = 'b1;   
              quotient_d  = dividend_d<<cnt_clzb;

              remainder_en = 'b1;
              remainder_d  = 'b0;
            end
          end
        end
      end
      DIV_WORKING: begin
        if(div_valid) begin
          // processing
          f_div_step (remainder_q ,quotient_q ,divisor_q,remainder_r1,quotient_r1);
          f_div_step (remainder_r1,quotient_r1,divisor_q,remainder_r2,quotient_r2);
          f_div_step (remainder_r2,quotient_r2,divisor_q,remainder_r3,quotient_r3);
          
          count_r1 = count_q - 'd1;
          count_r2 = count_q - 'd2;
          count_r3 = count_q - 'd3;
          
          quotient_en = 'b1;   
          remainder_en = 'b1;
          count_en = 'b1;

          case({{($clog2(DIV_WIDTH)-1){1'b0}},1'b1})
            count_r1: begin
              quotient_d  = quotient_r1;
              remainder_d = remainder_r1;
              count_d     = 'b1; 
            end
            count_r2: begin
              quotient_d  = quotient_r2;
              remainder_d = remainder_r2;
              count_d     = 'b1;            
            end
            default: begin
              quotient_d  = quotient_r3;
              remainder_d = remainder_r3;
              count_d     = count_r3;            
            end
          endcase
        end  
      end
      // get result to ouput and wait for ready signal
      DIV_PRINT: begin
        result_valid = 'b1;
        
        result_quotient  = q_sgn_q ? ((~quotient_q )+'d1) : quotient_q;
        result_remainder = r_sgn_q ? ((~remainder_q)+'d1) : remainder_q;
    
        count_en = result_ready;
        count_d  = 'b0;
      end
    endcase
  end


`ifdef TB_SUPPORT
  `ifdef ASSERT_ON
    `rvv_forbid(result_valid&res_reuse_valid_p1&result_ready&(result_quotient!=(src2_dividend/src1_divisor)))
      else $warning("result_quotient(0x%h) should be 0x%h.\n",result_quotient,src2_dividend/src1_divisor);

    `rvv_forbid(result_valid&res_reuse_valid_p1&result_ready&(result_remainder!=(src2_dividend%src1_divisor)))
      else $warning("result_remainder(0x%h) should be 0x%h.\n",result_remainder,src2_dividend%src1_divisor);
  `endif
`endif

//
// function unit
//
  // count leading zero bits
  function [1:0] f_clzb2
  (   
    input logic [1:0] src
  );

    if (src==2'b00)
      f_clzb2 = 2'b10;
    else if (src==2'b01)
      f_clzb2 = 2'b01;
    else
      f_clzb2 = 2'b00;
  endfunction

  function [2:0] f_clzb4
  (
    input logic [3:0] src
  );

    logic [1:0] hi;
    logic [1:0] lo;

    hi = f_clzb2(src[3:2]);
    lo = f_clzb2(src[1:0]);
    if ((hi[1]==1'b1)&(lo[1]==1'b1))
      f_clzb4 = 3'b100;
    else if (hi[1]==1'b0)
      f_clzb4 = {1'b0,hi};
    else
      f_clzb4 = {2'b01,lo[0]};
  endfunction

  function [3:0] f_clzb8
  (
    input logic [7:0] src
  );

    logic [2:0] hi;
    logic [2:0] lo;

    hi = f_clzb4(src[7:4]);
    lo = f_clzb4(src[3:0]);
    if ((hi[2]==1'b1)&(lo[2]==1'b1))
      f_clzb8 = 4'b1000;
    else if (hi[2]==1'b0)
      f_clzb8 = {1'b0,hi};
    else
      f_clzb8 = {2'b01,lo[1:0]};
  endfunction

  function [4:0] f_clzb16
  (
    input logic [15:0] src
  );

    logic [3:0] hi;
    logic [3:0] lo;

    hi = f_clzb8(src[15:8]);
    lo = f_clzb8(src[7:0]);
    if ((hi[3]==1'b1)&(lo[3]==1'b1))
      f_clzb16 = 5'b1_0000;
    else if (hi[3]==1'b0)
      f_clzb16 = {1'b0,hi};
    else
      f_clzb16 = {2'b01,lo[2:0]};
  endfunction

  function [5:0] f_clzb32  
  (
    input logic [31:0] src
  );
    
    logic [4:0] hi;
    logic [4:0] lo;

    hi = f_clzb16(src[31:16]);
    lo = f_clzb16(src[15:0]);
    if ((hi[4]==1'b1)&(lo[4]==1'b1))
      f_clzb32 = 6'b10_0000;
    else if (hi[4]==1'b0)
      f_clzb32 = {1'b0,hi};
    else
      f_clzb32 = {2'b01,lo[3:0]};
  endfunction

  // div step: shift and subtract
  function void f_div_step
  (
    input  logic [DIV_WIDTH-1:0] remainder_in,
    input  logic [DIV_WIDTH-1:0] quotient_in,
    input  logic [DIV_WIDTH-1:0] divisor_in,
    output logic [DIV_WIDTH-1:0] remainder_out,
    output logic [DIV_WIDTH-1:0] quotient_out
  );

    logic [DIV_WIDTH-1:0] remainder_tmp;
    logic [DIV_WIDTH  :0] diff;
    
    remainder_tmp = {remainder_in[DIV_WIDTH-2:0],quotient_in[DIV_WIDTH-1]};
    diff = {1'b0,remainder_tmp} - {1'b0,divisor_in};

    if (diff[DIV_WIDTH]) begin
      remainder_out = remainder_tmp;
      quotient_out  = {quotient_in[DIV_WIDTH-2:0],1'b0};
    end
    else begin
      remainder_out = diff[DIV_WIDTH-1:0];
      quotient_out  = {quotient_in[DIV_WIDTH-2:0],1'b1};
    end
  endfunction

endmodule
// ----- 8< ----- FILE "./rvv_backend_div_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef DIV_DEFINE_SVH
`include "rvv_backend_div.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_div_unit
(
  clk,
  rst_n,
  div_uop_valid,
  div_uop,
  result_valid,
  result,
  result_ready,
  trap_flush_rvv
);
//
// interface signals
//
  // global signals
  input   logic     clk;
  input   logic     rst_n;

  // DIV RS handshake signals
  input   logic     div_uop_valid;
  input   DIV_RS_t  div_uop;

  // DIV send result signals to ROB
  output  logic     result_valid;
  output  PU2ROB_t  result;
  input   logic     result_ready;

  // trap-flush
  input   logic     trap_flush_rvv;

//
// internal signals
//
  // DIV_RS_t struct signals
  logic   [`ROB_DEPTH_WIDTH-1:0]  rob_entry;
  FUNCT6_u                        uop_funct6;
  logic   [`FUNCT3_WIDTH-1:0]     uop_funct3;
  logic   [`VLEN-1:0]             vs1_data;           
  logic                           vs1_data_valid; 
  logic   [`VLEN-1:0]             vs2_data;	        
  logic                           vs2_data_valid;  
  EEW_e                           vs2_eew;
  logic   [`XLEN-1:0] 	          rs1_data;        
  logic        	                  rs1_data_valid;

  // execute 
  logic                                                 uop_valid;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]               src2_data8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]  src2_data16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]      src2_data32;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]               src1_data8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]  src1_data16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]      src1_data32;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]               quotient8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]  quotient16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]      quotient32;
  logic   [`VLENB/2-1:0][`BYTE_WIDTH-1:0]               remainder8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0][`HWORD_WIDTH-1:0]  remainder16;
  logic   [`VLEN/`WORD_WIDTH-1:0][`WORD_WIDTH-1:0]      remainder32;
  logic   [`VLENB/2-1:0]                                result_valid8;
  logic   [`VLEN/`HWORD_WIDTH/2-1:0]                    result_valid16;
  logic   [`VLEN/`WORD_WIDTH-1:0]                       result_valid32;
  logic   [`VLEN-1:0]                                   result_data; 
  logic                                                 result_all_valid; 
  DIV_SIGN_SRC_e                                        opcode;

  // for-loop
  genvar                                                j;

//
// prepare source data to calculate    
//
  // split ALU_RS_t struct
  assign  rob_entry      = div_uop.rob_entry;
  assign  uop_funct6     = div_uop.uop_funct6;
  assign  uop_funct3     = div_uop.uop_funct3;
  assign  vs1_data       = div_uop.vs1_data;
  assign  vs1_data_valid = div_uop.vs1_data_valid;
  assign  vs2_data       = div_uop.vs2_data;
  assign  vs2_data_valid = div_uop.vs2_data_valid;
  assign  vs2_eew        = div_uop.vs2_eew;
  assign  rs1_data       = div_uop.rs1_data;
  assign  rs1_data_valid = div_uop.rs1_data_valid;
  
//  
// prepare source data 
//
  // prepare valid signal
  always_comb begin
    // initial the data
    uop_valid = 'b0;

    case(uop_funct3) 
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VDIVU,
          VDIV,
          VREMU,
          VREM: begin
            uop_valid = div_uop_valid&vs2_data_valid&vs1_data_valid;
          end
        endcase
      end
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VDIVU,
          VDIV,
          VREMU,
          VREM: begin
            uop_valid = div_uop_valid&vs2_data_valid&rs1_data_valid;
          end
        endcase
      end
    endcase
  end
 
  // prepare source data
  always_comb begin
    // initial the data
    src2_data8   = 'b0;
    src2_data16  = 'b0;
    src2_data32  = 'b0;
    src1_data8   = 'b0;
    src1_data16  = 'b0;
    src1_data32  = 'b0;

    case(uop_funct3) 
      OPMVV: begin
        case(uop_funct6.ari_funct6)
          VDIVU,
          VREMU: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  src2_data8[i] = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data8[i] = vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  src2_data16[i-`VLENB/2] = {8'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data16[i-`VLENB/2] = {8'b0,vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  src2_data32[i-`VLENB*3/4] = {24'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data32[i-`VLENB*3/4] = {24'b0,vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  src1_data16[i] = vs1_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  src2_data32[i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  src1_data32[i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs1_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  src1_data32[i] = vs1_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                end             
              end
            endcase
          end

          VDIV,
          VREM: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  src2_data8[i] = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data8[i] = vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  src2_data16[i-`VLENB/2] = {{8{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data16[i-`VLENB/2] = {{8{vs1_data[(i+1)*`BYTE_WIDTH-1]}},vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  src2_data32[i-`VLENB*3/4] = {{24{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data32[i-`VLENB*3/4] = {{24{vs1_data[(i+1)*`BYTE_WIDTH-1]}},vs1_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  src1_data16[i] = vs1_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  src2_data32[i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  src1_data32[i-`VLEN/`HWORD_WIDTH/2] = {{16{vs1_data[(i+1)*`HWORD_WIDTH-1]}},vs1_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  src1_data32[i] = vs1_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                end             
              end
            endcase
          end
        endcase
      end
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VDIVU,
          VREMU: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  src2_data8[i] = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data8[i] = rs1_data[0             +: `BYTE_WIDTH];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  src2_data16[i-`VLENB/2] = {8'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data16[i-`VLENB/2] = {8'b0,rs1_data[0             +: `BYTE_WIDTH]};
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  src2_data32[i-`VLENB*3/4] = {24'b0,vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data32[i-`VLENB*3/4] = {24'b0,rs1_data[0             +: `BYTE_WIDTH]};
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  src1_data16[i] = rs1_data[0              +: `HWORD_WIDTH];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  src2_data32[i-`VLEN/`HWORD_WIDTH/2] = {16'b0,vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  src1_data32[i-`VLEN/`HWORD_WIDTH/2] = {16'b0,rs1_data[0              +: `HWORD_WIDTH]};
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  src1_data32[i] = rs1_data[0             +: `WORD_WIDTH];
                end             
              end
            endcase
          end

          VDIV,
          VREM: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  src2_data8[i] = vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH];
                  src1_data8[i] = rs1_data[0             +: `BYTE_WIDTH];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  src2_data16[i-`VLENB/2] = {{8{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data16[i-`VLENB/2] = {{8{rs1_data[      `BYTE_WIDTH-1]}},rs1_data[0             +: `BYTE_WIDTH]};
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  src2_data32[i-`VLENB*3/4] = {{24{vs2_data[(i+1)*`BYTE_WIDTH-1]}},vs2_data[i*`BYTE_WIDTH +: `BYTE_WIDTH]};
                  src1_data32[i-`VLENB*3/4] = {{24{rs1_data[      `BYTE_WIDTH-1]}},rs1_data[0             +: `BYTE_WIDTH]};
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  src2_data16[i] = vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH];
                  src1_data16[i] = rs1_data[0              +: `HWORD_WIDTH];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  src2_data32[i-`VLEN/`HWORD_WIDTH/2] = {{16{vs2_data[(i+1)*`HWORD_WIDTH-1]}},vs2_data[i*`HWORD_WIDTH +: `HWORD_WIDTH]};
                  src1_data32[i-`VLEN/`HWORD_WIDTH/2] = {{16{rs1_data[      `HWORD_WIDTH-1]}},rs1_data[0              +: `HWORD_WIDTH]};
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  src2_data32[i] = vs2_data[i*`WORD_WIDTH +: `WORD_WIDTH];
                  src1_data32[i] = rs1_data[0             +: `WORD_WIDTH];
                end             
              end
            endcase
          end
        endcase
      end
    endcase
  end

  // get opcode for divider
  always_comb begin
    // initial the data
    opcode = DIV_SIGN;

    // prepare source data
    case(uop_funct3) 
      OPMVV,
      OPMVX: begin
        case(uop_funct6.ari_funct6)    
          VDIV,
          VREM: begin
            opcode = DIV_SIGN;
          end
          VDIVU,
          VREMU: begin
            opcode = DIV_ZERO;
          end
        endcase
      end
    endcase
  end

//    
// calculate the result
//
  generate
    for(j=0;j<`VLENB/2;j++) begin: DIVIDER8
      rvv_backend_div_unit_divider
      #(
        .DIV_WIDTH          (8'd`BYTE_WIDTH)
      )
      divider_8bit
      (
        .clk                (clk),
        .rst_n              (rst_n),
        .div_valid          (uop_valid&(vs2_eew==EEW8)),
        .opcode             (opcode), 
        .src2_dividend      (src2_data8[j]),
        .src1_divisor       (src1_data8[j]),
        .result_quotient    (quotient8[j]),
        .result_remainder   (remainder8[j]),
        .result_valid       (result_valid8[j]),
        .result_ready       (result_ready&result_valid),
        .trap_flush_rvv     (trap_flush_rvv)
      );     
    end
  endgenerate 

  generate
    for(j=0;j<`VLEN/`HWORD_WIDTH/2;j++) begin: DIVIDER16
      rvv_backend_div_unit_divider
      #(
        .DIV_WIDTH          (8'd`HWORD_WIDTH)
      )
      divider_16bit
      (
        .clk                (clk),
        .rst_n              (rst_n),
        .div_valid          (uop_valid&(vs2_eew!=EEW32)),
        .opcode             (opcode), 
        .src2_dividend      (src2_data16[j]),
        .src1_divisor       (src1_data16[j]),
        .result_quotient    (quotient16[j]),
        .result_remainder   (remainder16[j]),
        .result_valid       (result_valid16[j]),
        .result_ready       (result_ready&result_valid),
        .trap_flush_rvv     (trap_flush_rvv)
      );     
    end
  endgenerate 

  generate
    for(j=0;j<`VLEN/`WORD_WIDTH;j++) begin: DIVIDER32
      rvv_backend_div_unit_divider
      #(
        .DIV_WIDTH          (8'd`WORD_WIDTH)
      )
      divider_32bit
      (
        .clk                (clk),
        .rst_n              (rst_n),
        .div_valid          (uop_valid),
        .opcode             (opcode), 
        .src2_dividend      (src2_data32[j]),
        .src1_divisor       (src1_data32[j]),
        .result_quotient    (quotient32[j]),
        .result_remainder   (remainder32[j]),
        .result_valid       (result_valid32[j]),
        .result_ready       (result_ready&result_valid),
        .trap_flush_rvv     (trap_flush_rvv)
      );     
    end
  endgenerate

  // check whether all the results are gotten
  always_comb begin
    result_all_valid = 'b0;
    
    case(vs2_eew)
      EEW8: begin
        result_all_valid = ({result_valid8,result_valid16,result_valid32}=='1);
      end
      EEW16: begin
        result_all_valid = ({result_valid16,result_valid32}=='1);
      end
      EEW32: begin
        result_all_valid = (result_valid32=='1);
      end
    endcase
  end

  // assign to result_data
  always_comb begin
    // initial the data
    result_data = 'b0;

    case(uop_funct3) 
      OPMVV,
      OPMVX: begin
        case(uop_funct6.ari_funct6)
          VDIVU,
          VDIV: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = quotient8[i];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = quotient16[i-`VLENB/2][0 +: `BYTE_WIDTH];
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = quotient32[i-`VLENB*3/4][0 +: `BYTE_WIDTH];
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  result_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = quotient16[i];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  result_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = quotient32[i-`VLEN/`HWORD_WIDTH/2][0 +: `HWORD_WIDTH];
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = quotient32[i];
                end             
              end
            endcase
          end

          VREMU,
          VREM: begin
            case(vs2_eew)
              EEW8: begin
                for (int i=0;i<`VLENB/2;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = remainder8[i];
                end
                for (int i=`VLENB/2;i<`VLENB*3/4;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = remainder16[i-`VLENB/2][0 +: `BYTE_WIDTH];
                end
                for (int i=`VLENB*3/4;i<`VLENB;i++) begin
                  result_data[i*`BYTE_WIDTH +: `BYTE_WIDTH] = remainder32[i-`VLENB*3/4][0 +: `BYTE_WIDTH];
                end
              end
              EEW16: begin
                for (int i=0;i<`VLEN/`HWORD_WIDTH/2;i++) begin
                  result_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = remainder16[i];
                end
                for (int i=`VLEN/`HWORD_WIDTH/2;i<`VLEN/`HWORD_WIDTH;i++) begin
                  result_data[i*`HWORD_WIDTH +: `HWORD_WIDTH] = remainder32[i-`VLEN/`HWORD_WIDTH/2][0 +: `HWORD_WIDTH];
                end
              end             
              EEW32: begin
                for (int i=0;i<`VLEN/`WORD_WIDTH;i++) begin
                  result_data[i*`WORD_WIDTH +: `WORD_WIDTH] = remainder32[i];
                end             
              end
            endcase
          end
        endcase
      end
    endcase
  end

//
// submit result to ROB
//
`ifdef TB_SUPPORT
  assign result.uop_pc = div_uop.uop_pc;
`endif
  
  assign result.rob_entry = rob_entry;

  assign result.w_data = result_data;

  assign result_valid = result_all_valid;

  assign result.w_valid = result_all_valid;

  assign result.vsaturate = 'b0;

endmodule
// ----- 8< ----- FILE "./rvv_backend_div.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_div
( 
  clk,
  rst_n,
  pop_ex2rs,
  div_uop_rs2ex,
  fifo_empty_rs2ex,
  fifo_almost_empty_rs2ex,
  result_valid_ex2rob,
  result_ex2rob,
  result_ready_rob2div,
  trap_flush_rvv
);

//
// interface signals
//
  // global signals
  input   logic     clk;
  input   logic     rst_n;

  // DIV RS to DIV unit
  input   DIV_RS_t  [`NUM_DIV-1:0]  div_uop_rs2ex;
  input   logic                     fifo_empty_rs2ex;
  input   logic     [`NUM_DIV-1:0]  fifo_almost_empty_rs2ex;
  output  logic     [`NUM_DIV-1:0]  pop_ex2rs;

  // submit DIV result to ROB
  output  logic     [`NUM_DIV-1:0]  result_valid_ex2rob;
  output  PU2ROB_t  [`NUM_DIV-1:0]  result_ex2rob;
  input   logic     [`NUM_DIV-1:0]  result_ready_rob2div;

  // trap-flush
  input   logic                     trap_flush_rvv;

//
// internal signals
//
  // DIV RS to DIV unit
  logic             [`NUM_DIV-1:0]  div_uop_valid_rs2ex;    
  
  // for-loop
  genvar                            i;

//
// Instantiate rvv_backend_div_unit
//
  // generate valid signals
  assign div_uop_valid_rs2ex[0] = !fifo_empty_rs2ex;

  generate
    for (i=1;i<`NUM_DIV;i=i+1) begin: GET_UOP_VALID
      assign  div_uop_valid_rs2ex[i] = !fifo_almost_empty_rs2ex[i];
    end
  endgenerate

  // generate pop signals
  assign pop_ex2rs[0] = div_uop_valid_rs2ex[0]&result_valid_ex2rob[0]&result_ready_rob2div[0];
    
  generate
    for (i=1;i<`NUM_DIV;i=i+1) begin: POP_DIV_RS
      assign pop_ex2rs[i] = div_uop_valid_rs2ex[i]&result_valid_ex2rob[i]&result_ready_rob2div[i]&(pop_ex2rs[i-1:0]=='1);
    end
  endgenerate

  // instantiate
  generate
    for (i=0;i<`NUM_DIV;i++) begin: DIV_UNIT
      rvv_backend_div_unit u_div_unit
        (
          .clk            (clk),
          .rst_n          (rst_n),
          .div_uop_valid  (div_uop_valid_rs2ex[i]),
          .div_uop        (div_uop_rs2ex[i]),
          .result_valid   (result_valid_ex2rob[i]),
          .result         (result_ex2rob[i]),
          .result_ready   (result_ready_rob2div[i]),
          .trap_flush_rvv (trap_flush_rvv)
        );
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_lsu_remap.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_lsu_remap
(
  mapinfo,
  lsu_res,
  mapinfo_empty,
  mapinfo_almost_empty,
  lsu_res_empty,
  lsu_res_almost_empty,
  pop_mapinfo,
  pop_lsu_res,
  result_valid_lsu2rob,
  result_lsu2rob,
  result_ready_rob2lsu,
  trap_valid_rmp2rob,
  trap_rob_entry_rmp2rob,
  trap_ready_rob2rmp
);

//
// interface signals
//
  // MAP INFO and LSU RES
  input   LSU_MAP_INFO_t  [`NUM_LSU-1:0]  mapinfo;
  input   UOP_LSU_t       [`NUM_LSU-1:0]  lsu_res;
  input   logic                           mapinfo_empty;
  input   logic           [`NUM_LSU-1:0]  mapinfo_almost_empty;
  input   logic                           lsu_res_empty;
  input   logic           [`NUM_LSU-1:0]  lsu_res_almost_empty;
  output  logic           [`NUM_LSU-1:0]  pop_mapinfo;
  output  logic           [`NUM_LSU-1:0]  pop_lsu_res;

  // submit LSU result to ROB
  output  logic           [`NUM_LSU-1:0]  result_valid_lsu2rob;
  output  PU2ROB_t        [`NUM_LSU-1:0]  result_lsu2rob;
  input   logic           [`NUM_LSU-1:0]  result_ready_rob2lsu;

  // submit trap to ROB
  output  logic                           trap_valid_rmp2rob;
  output  logic   [`ROB_DEPTH_WIDTH-1:0]  trap_rob_entry_rmp2rob;
  input   logic                           trap_ready_rob2rmp;

//
// internal signals
//
  logic [`NUM_LSU-1:0]  mapinfo_valid;
  logic [`NUM_LSU-1:0]  lsu_res_valid;

  genvar                i;

//
// start 
//
  // valid signal
  assign mapinfo_valid[0] = !mapinfo_empty;
  assign lsu_res_valid[0] = !lsu_res_empty;

  generate
    for(i=1;i<`NUM_LSU;i++) begin: GET_VALID
      assign mapinfo_valid[i] = !mapinfo_almost_empty[i];
      assign lsu_res_valid[i] = !lsu_res_almost_empty[i];
    end
  endgenerate
  
  // result valid 
  generate
    for(i=0;i<`NUM_LSU;i++) begin: RES_VALID
      assign result_valid_lsu2rob[i] = mapinfo_valid[i]&lsu_res_valid[i]&mapinfo[i].valid&(!lsu_res[i].trap_valid)&(
                                       (mapinfo[i].lsu_class==IS_LOAD) & lsu_res[i].uop_lsu2rvv.vregfile_write_valid ||
                                       (mapinfo[i].lsu_class==IS_STORE) & lsu_res[i].uop_lsu2rvv.lsu_vstore_last);
    end
  endgenerate

  // remap
  generate
    for(i=0;i<`NUM_LSU;i++) begin: GET_RESULT
      `ifdef TB_SUPPORT
        assign result_lsu2rob[i].uop_pc    = mapinfo[i].uop_pc;
      `endif
        assign result_lsu2rob[i].rob_entry = mapinfo[i].rob_entry;
        assign result_lsu2rob[i].w_data    = lsu_res[i].uop_lsu2rvv.vregfile_write_data;
        assign result_lsu2rob[i].w_valid   = (mapinfo[i].lsu_class==IS_LOAD)&
                                             lsu_res[i].uop_lsu2rvv.vregfile_write_valid&
                                             (lsu_res[i].uop_lsu2rvv.vregfile_write_addr==mapinfo[i].vregfile_write_addr);
        assign result_lsu2rob[i].vsaturate = 'b0;
    end
  endgenerate

  always_comb begin
    trap_valid_rmp2rob = 'b0;
    trap_rob_entry_rmp2rob = 'b0;

    for (int j=0;j<`NUM_LSU;j++) begin
      if (lsu_res[j].trap_valid&lsu_res_valid[j]&mapinfo_valid[j]) begin
        trap_valid_rmp2rob     = 'b1;
        trap_rob_entry_rmp2rob = mapinfo[j].rob_entry;
      end
    end
  end

  // pop signal
  generate
    for(i=0;i<`NUM_LSU;i++) begin: GET_POP
      assign pop_mapinfo[i] = (!lsu_res[i].trap_valid)&result_valid_lsu2rob[i]&result_ready_rob2lsu[i]||
                                lsu_res[i].trap_valid&mapinfo_valid[i]&lsu_res_valid[i]&trap_ready_rob2rmp;
      assign pop_lsu_res[i] = pop_mapinfo[i];
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_mul_unit_mul8.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description: 
// 1. Perform a [15:0]Out = [7:0]In0 * [7:0]In1
//
// feature list:
// 1. input In0 and In1 are both 8-bit
// 2. output Out is 16-bit
// 3. support unsigned/signed inputs, but needs *is_signed
//    flag to identify


module rvv_backend_mul_unit_mul8 (
  out,
  in0, in0_is_signed,
  in1, in1_is_signed
);

input [7:0] in0;
input       in0_is_signed;
input [7:0] in1;
input       in1_is_signed;

output [15:0] out;

wire [8:0] in0_int = {in0_is_signed&in0[7],in0};
wire [8:0] in1_int = {in1_is_signed&in1[7],in1};

wire [17:0] out_int = {{9{in0_int[8]}},in0_int} * {{9{in1_int[8]}},in1_int};

assign out = out_int[0+:16];

endmodule
// ----- 8< ----- FILE "./rvv_backend_mac_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description: 
// 1. It will get uops from mac Reservation station and execute this uop.
//
// feature list:
// 1. 

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_mac_unit (
  // Outputs
  mac2rob_uop_valid, mac2rob_uop_data,
  // Inputs
  clk, rst_n, rs2mac_uop_valid, rs2mac_uop_data,
  mac_stg0_vld_en, mac_stg0_data_en
  );

input             clk;
input             rst_n;

input             rs2mac_uop_valid;
input MUL_RS_t    rs2mac_uop_data;

input             mac_stg0_vld_en;
input             mac_stg0_data_en;

output            mac2rob_uop_valid;
output PU2ROB_t   mac2rob_uop_data;

// Wires & Regs
logic [`ROB_DEPTH_WIDTH-1:0]  mac_uop_rob_entry;
logic [`FUNCT6_WIDTH-1:0]     mac_uop_funct6;
logic [`FUNCT3_WIDTH-1:0]     mac_uop_funct3;
logic [1:0]                   mac_uop_xrm;
logic [2:0]                   mac_top_vs_eew;
logic [`VLEN-1:0]             mac_uop_vs1_data;
logic [`VLEN-1:0]             mac_uop_vs2_data;
logic [`XLEN-1:0]             mac_uop_rs1_data;
logic [`VLEN-1:0]             mac_uop_vs3_data;
logic                         mac_uop_index;

logic                         is_vv; //1:op*vv; 0:op*vx
logic [`VLEN-1:0]             mac_src2;
logic [`VLEN-1:0]             mac_src1;
logic [`VLEN-1:0]             mac_addsrc;
logic                         mac_src2_is_signed;
logic                         mac_src1_is_signed;
logic                         mac_is_widen;
logic                         mac_keep_low_bits;
logic                         mac_mul_reverse;
logic                         is_vsmul;
logic                         is_vmac;

logic [`VLEN-1:0]             mac_src2_mux;
logic [`VLEN-1:0]             mac_src1_mux;
logic [15:0]                  mac_src2_is_signed_extend;
logic [15:0]                  mac_src1_is_signed_extend;

logic [7:0]                   mac8_in0[15:0];
logic [15:0]                  mac8_in0_is_signed;
logic [7:0]                   mac8_in1[15:0];
logic [15:0]                  mac8_in1_is_signed;
logic [15:0]                  mac8_out[63:0];

logic [15:0]                  mac8_out_d1[63:0];
logic [`VLEN-1:0]             mac_addsrc_d1;
logic [2*`VLEN-1:0]           mac_addsrc_widen_d1;

logic                         rs2mac_uop_valid_d1;
logic                         mac_src2_is_signed_d1;
logic                         mac_src1_is_signed_d1;
logic                         mac_is_widen_d1;
logic                         mac_keep_low_bits_d1;
logic                         mac_mul_reverse_d1;
logic                         is_vsmul_d1;
logic                         is_vmac_d1;
logic [1:0]                   mac_uop_xrm_d1;
logic [2:0]                   mac_top_vs_eew_d1;
logic [`ROB_DEPTH_WIDTH-1:0]  mac_uop_rob_entry_d1;

logic [15:0]                  mac_rslt_full_eew8_d1[15:0];
logic [2*`VLEN-1:0]           mac_rslt_eew8_widen_d1;
logic [`VLEN-1:0]             mac_rslt_eew8_no_widen_d1;
logic [15:0]                  vsmul_round_incr_eew8_d1;
logic [`VLEN-1:0]             vsmul_rslt_eew8_d1;
logic [15:0]                  vsmul_sat_eew8_d1;
logic [`VLEN-1:0]             mac_rslt_eew8_d1;
logic [`VLENB-1:0]            update_vxsat_eew8_d1;
logic [8:0]                   vmac_mul_add_eew8_no_widen_d1[0:15];
logic [8:0]                   vmac_mul_sub_eew8_no_widen_d1[0:15];
logic [`VLEN-1:0]             vmac_rslt_eew8_no_widen_d1;
logic [16:0]                  vmac_mul_add_eew8_widen_d1[0:15];
logic [16:0]                  vmac_mul_sub_eew8_widen_d1[0:15];
logic [2*`VLEN-1:0]           vmac_rslt_eew8_widen_d1;

logic [31:0]                  mac_rslt_full_eew16_d1[7:0];
logic [2*`VLEN-1:0]           mac_rslt_eew16_widen_d1;
logic [`VLEN-1:0]             mac_rslt_eew16_no_widen_d1;
logic [7:0]                   vsmul_round_incr_eew16_d1;
logic [`VLEN-1:0]             vsmul_rslt_eew16_d1;
logic [7:0]                   vsmul_sat_eew16_d1;
logic [`VLEN-1:0]             mac_rslt_eew16_d1;
logic [`VLENB-1:0]            update_vxsat_eew16_d1;
logic [16:0]                  vmac_mul_add_eew16_no_widen_d1[0:7];
logic [16:0]                  vmac_mul_sub_eew16_no_widen_d1[0:7];
logic [`VLEN-1:0]             vmac_rslt_eew16_no_widen_d1;
logic [32:0]                  vmac_mul_add_eew16_widen_d1[0:7];
logic [32:0]                  vmac_mul_sub_eew16_widen_d1[0:7];
logic [2*`VLEN-1:0]           vmac_rslt_eew16_widen_d1;

logic [63:0]                  mac_rslt_full_eew32_d1[3:0];
logic [2*`VLEN-1:0]           mac_rslt_eew32_widen_d1;
logic [`VLEN-1:0]             mac_rslt_eew32_no_widen_d1;
logic [3:0]                   vsmul_round_incr_eew32_d1;
logic [`VLEN-1:0]             vsmul_rslt_eew32_d1;
logic [3:0]                   vsmul_sat_eew32_d1;
logic [`VLEN-1:0]             mac_rslt_eew32_d1;
logic [`VLENB-1:0]            update_vxsat_eew32_d1;
logic [32:0]                  vmac_mul_add_eew32_no_widen_d1[0:3];
logic [32:0]                  vmac_mul_sub_eew32_no_widen_d1[0:3];
logic [`VLEN-1:0]             vmac_rslt_eew32_no_widen_d1;
logic [64:0]                  vmac_mul_add_eew32_widen_d1[0:4];
logic [64:0]                  vmac_mul_sub_eew32_widen_d1[0:4];
logic [2*`VLEN-1:0]           vmac_rslt_eew32_widen_d1;

`ifdef TB_SUPPORT
logic [`PC_WIDTH-1:0]         mac_uop_pc;
logic [`PC_WIDTH-1:0]         mac_uop_pc_d1;
`endif

//Int & Genvar
integer i,j;
genvar z,x,y;

// Input struct decode
assign mac_uop_rob_entry = rs2mac_uop_data.rob_entry;
assign mac_uop_funct6 = rs2mac_uop_data.uop_funct6.ari_funct6;
assign mac_uop_funct3 = rs2mac_uop_data.uop_funct3;
assign mac_uop_xrm = rs2mac_uop_data.vxrm;
assign mac_top_vs_eew = rs2mac_uop_data.vs2_eew;

assign mac_uop_vs1_data = rs2mac_uop_data.vs1_data;

assign mac_uop_vs2_data = rs2mac_uop_data.vs2_data;

assign mac_uop_vs3_data = rs2mac_uop_data.vs3_data;

assign mac_uop_rs1_data = rs2mac_uop_data.rs1_data;

assign mac_uop_index = rs2mac_uop_data.uop_index[0];

`ifdef TB_SUPPORT
assign mac_uop_pc = rs2mac_uop_data.uop_pc;
`endif

// Global EU control
always@(*) begin
  case ({rs2mac_uop_valid,mac_uop_funct3}) 
    {1'b1,OPMVV} : begin
      is_vv = 1'b1;
      case (mac_uop_funct6) 
        VMACC : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VNMSAC : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b1;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VMADD : begin
          mac_src2 = mac_uop_vs3_data; //vd
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = mac_uop_vs2_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VNMSUB : begin
          mac_src2 = mac_uop_vs3_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = mac_uop_vs2_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b1;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACCU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACC : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACCSU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VMUL: begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULH : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULHU : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULHSU : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMUL : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMULU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMULSU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {64'b0,mac_uop_vs1_data[mac_uop_index*64 +: 64]};
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        default : begin //default use VMUL
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end//end default
      endcase//end funct6
    end//end OPMVV
    {1'b1,OPMVX} : begin
      is_vv = 1'b0;
      case (mac_uop_funct6) 
        VMACC : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VNMSAC : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc =mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b1;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VMADD : begin
          mac_src2 = mac_uop_vs3_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs2_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VNMSUB : begin
          mac_src2 = mac_uop_vs3_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs2_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b1;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACCU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACC : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACCSU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VWMACCUS : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = mac_uop_vs3_data;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b1;
        end
        VMUL : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULH : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULHU : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VMULHSU : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMUL : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMULU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b0;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        VWMULSU : begin
          mac_src2 = {64'b0,mac_uop_vs2_data[mac_uop_index*64 +: 64]};
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b0;
          mac_is_widen = 1'b1;
          mac_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end
        default : begin //default use VMUL
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b1;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b0;
          is_vmac = 1'b0;
        end//end default
      endcase
    end//end OPMVX
    {1'b1,OPIVV} : begin
      is_vv = 1'b1;
      case (mac_uop_funct6) 
        VSMUL_VMVNRR : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b1;
          is_vmac = 1'b0;
        end
        default : begin //currently put default the same as VSMUL_VMVNRR
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = mac_uop_vs1_data;
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b1;
          is_vmac = 1'b0;
        end//end default
      endcase//end funct6
    end//end OPIVV
    {1'b1,OPIVX} : begin
      is_vv = 1'b0;
      case (mac_uop_funct6) 
        VSMUL_VMVNRR : begin
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b1;
          is_vmac = 1'b0;
        end
        default : begin //currently put default the same as VSMUL_VMVNRR
          mac_src2 = mac_uop_vs2_data;
          mac_src1 = {{(`VLEN-`XLEN){mac_uop_rs1_data[`XLEN-1]&&mac_src1_is_signed}},mac_uop_rs1_data}; //use rs1
          mac_addsrc = `VLEN'b0;
          mac_src2_is_signed = 1'b1;
          mac_src1_is_signed = 1'b1;
          mac_is_widen = 1'b0;
          mac_keep_low_bits = 1'b0;
          mac_mul_reverse = 1'b0;
          is_vsmul = 1'b1;
          is_vmac = 1'b0;
        end//end default
      endcase//end funct6
    end//end OPIVX
    default : begin
      is_vv = 1'b1;
      mac_src2 = `VLEN'b0;
      mac_src1 = `VLEN'b0;
      mac_addsrc = `VLEN'b0;
      mac_src2_is_signed = 1'b0;
      mac_src1_is_signed = 1'b0;
      mac_is_widen = 1'b0;
      mac_keep_low_bits = 1'b0;
      mac_mul_reverse = 1'b0;
      is_vsmul = 1'b0;
      is_vmac = 1'b0;
    end//end default
  endcase//end funct3
end

// Before using mac alu, 
//  1.group sub-elements' sign bit
// (TODO) let input is 0 when not use that EU
always@(*) begin
  case (mac_top_vs_eew) 
    EEW8 : begin
      mac_src2_mux = mac_src2;
      mac_src1_mux = is_vv ? mac_src1 : {16{mac_src1[7:0]}};
      mac_src2_is_signed_extend = {16{mac_src2_is_signed}};
      mac_src1_is_signed_extend = {16{mac_src1_is_signed}};
    end//end eew8
    EEW16 : begin
      mac_src2_mux = mac_src2;
      mac_src1_mux = is_vv ? mac_src1 : {8{mac_src1[15:0]}};
      mac_src2_is_signed_extend = {8{mac_src2_is_signed,1'b0}};
      mac_src1_is_signed_extend = {8{mac_src1_is_signed,1'b0}};
    end//end eew16
    EEW32 : begin
      mac_src2_mux = mac_src2;
      mac_src1_mux = is_vv ? mac_src1 : {4{mac_src1[31:0]}};
      mac_src2_is_signed_extend = {4{mac_src2_is_signed,3'b0}};
      mac_src1_is_signed_extend = {4{mac_src1_is_signed,3'b0}};
    end//end eew32
    default : begin //default use eew8
      mac_src2_mux = mac_src2;
      mac_src1_mux = is_vv ? mac_src1 : {16{mac_src1[7:0]}};
      mac_src2_is_signed_extend = {16{mac_src2_is_signed}};
      mac_src1_is_signed_extend = {16{mac_src1_is_signed}};
    end//end default
  endcase
end

// Before mac, always depart 128 bits into 16x8 sub-elements
always@(*) begin
  for (i=0; i<16; i=i+1) begin
      mac8_in0[i] = mac_src2_mux[i*8 +: 8];
      mac8_in1[i] = mac_src1_mux[i*8 +: 8];
      mac8_in0_is_signed[i] = mac_src2_is_signed_extend[i];
      mac8_in1_is_signed[i] = mac_src1_is_signed_extend[i];
  end
end

// mul alus with d1_reg
//  in a 4 of 4x4 tiled way for instantiation
generate 
  for (z=0; z<4; z=z+1) begin 
    for (x=0; x<4; x=x+1) begin
      for (y=0; y<4; y=y+1) begin
        rvv_backend_mul_unit_mul8 u_mul8 (
          .out(mac8_out[z*16+y*4+x]), //16bit out
          .in0(mac8_in0[z*4+x]), 
          .in0_is_signed(mac8_in0_is_signed[z*4+x]),
          .in1(mac8_in1[z*4+y]), 
          .in1_is_signed(mac8_in1_is_signed[z*4+y]));

        edff #(.T(logic [16-1:0])) u_mul8_delay (
          .q(mac8_out_d1[z*16+y*4+x]), 
          .clk(clk), 
          .rst_n(rst_n), 
          .e(mac_stg0_data_en),
          .d(mac8_out[z*16+y*4+x]));
      end
    end
  end
endgenerate

edff #(.T(logic [`VLEN-1:0])) u_addsrc_delay (.q(mac_addsrc_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_addsrc));
assign mac_addsrc_widen_d1 = {2{mac_addsrc_d1}}; //when widen, copy low half to high, for widen add
edff #(.T(logic)) u_valid_delay (.q(rs2mac_uop_valid_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_vld_en), .d(rs2mac_uop_valid));
edff #(.T(logic)) u_src2_is_signed_delay (.q(mac_src2_is_signed_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_src2_is_signed));
edff #(.T(logic)) u_src1_is_signed_delay (.q(mac_src1_is_signed_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_src1_is_signed));
edff #(.T(logic)) u_is_widen_delay (.q(mac_is_widen_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_is_widen));
edff #(.T(logic)) u_keep_low_bits_delay (.q(mac_keep_low_bits_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_keep_low_bits));
edff #(.T(logic)) u_is_vsmul_delay (.q(is_vsmul_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(is_vsmul));
edff #(.T(logic)) u_mul_reverse_delay (.q(mac_mul_reverse_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_mul_reverse));
edff #(.T(logic)) u_is_vmac_delay (.q(is_vmac_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(is_vmac));

edff #(.T(logic [2-1:0])) u_xrm_delay (.q(mac_uop_xrm_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_uop_xrm));
edff #(.T(logic [3-1:0])) u_eew_delay (.q(mac_top_vs_eew_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_top_vs_eew));


edff #(.T(logic [`ROB_DEPTH_WIDTH-1:0])) u_rob_entry_delay (.q(mac_uop_rob_entry_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_uop_rob_entry));

`ifdef TB_SUPPORT
edff #(.T(logic [`PC_WIDTH-1:0])) u_PC_delay (.q(mac_uop_pc_d1), .clk(clk), .rst_n(rst_n), .e(mac_stg0_data_en), .d(mac_uop_pc));
`endif


/////////////////////////////////////////////////
///////Enter d1_stage ///////////////////////////
/////////////////////////////////////////////////

// After mac, calculte eew8, eew16, eew32 results
// Here we have a ([15:0] [63:0] mac8_out_d1)
//eew8
//full rslt is 16bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    for (j=0; j<4; j=j+1) begin //x
        mac_rslt_full_eew8_d1[i*4+j] = mac8_out_d1[i*16+j*5];
        mac_rslt_eew8_widen_d1[16*(i*4+j) +: 16] = mac_rslt_full_eew8_d1[i*4+j];//widen, and convert to [255:0]
        mac_rslt_eew8_no_widen_d1[8*(i*4+j) +: 8] = mac_keep_low_bits_d1 ? mac_rslt_full_eew8_d1[i*4+j][7:0] : mac_rslt_full_eew8_d1[i*4+j][15:8];
        //Below are for rounding mul (vsmul.vv, vsmul.vx)
        //right shift bit is 7 not 8 !
        //(TODO) Improve to make this readable
        vsmul_round_incr_eew8_d1[i*4+j] = mac_uop_xrm_d1==2'd3 ? !mac_rslt_full_eew8_d1[i*4+j][7] && (|mac_rslt_full_eew8_d1[i*4+j][6:0]) : //ROD
                                          mac_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                          mac_uop_xrm_d1==2'd1 ? mac_rslt_full_eew8_d1[i*4+j][6] && (|(mac_rslt_full_eew8_d1[i*4+j][5:0]) || mac_rslt_full_eew8_d1[i*4+j][7]) : //RNE
                                                                 mac_rslt_full_eew8_d1[i*4+j][6]; //RNU
        vsmul_rslt_eew8_d1[8*(i*4+j) +:8]= mac_rslt_full_eew8_d1[i*4+j][15:14] == 2'b01 ? 8'h7f : //saturate
                                                                                      mac_rslt_full_eew8_d1[i*4+j][7+:8] + {7'b0,vsmul_round_incr_eew8_d1[i*4+j]};//right shift 7bit then +"1"
        vsmul_sat_eew8_d1[i*4+j] = mac_rslt_full_eew8_d1[i*4+j][15:14] == 2'b01;
        //Below are for vmac related instructions
        vmac_mul_add_eew8_no_widen_d1[i*4+j] = {1'b0,mac_addsrc_d1[8*(i*4+j) +: 8]} + {1'b0,mac_rslt_eew8_no_widen_d1[8*(i*4+j) +: 8]};//9bit
        vmac_mul_sub_eew8_no_widen_d1[i*4+j] = {1'b0,mac_addsrc_d1[8*(i*4+j) +: 8]} - {1'b0,mac_rslt_eew8_no_widen_d1[8*(i*4+j) +: 8]};
        vmac_rslt_eew8_no_widen_d1[8*(i*4+j) +:8] = mac_mul_reverse_d1 ? vmac_mul_sub_eew8_no_widen_d1[i*4+j][7:0] :
                                                                         vmac_mul_add_eew8_no_widen_d1[i*4+j][7:0];
        vmac_mul_add_eew8_widen_d1[i*4+j] = {1'b0,mac_addsrc_widen_d1[16*(i*4+j) +: 16]} + {1'b0,mac_rslt_eew8_widen_d1[16*(i*4+j) +: 16]};//17bit
        vmac_mul_sub_eew8_widen_d1[i*4+j] = {1'b0,mac_addsrc_widen_d1[16*(i*4+j) +: 16]} - {1'b0,mac_rslt_eew8_widen_d1[16*(i*4+j) +: 16]};
        vmac_rslt_eew8_widen_d1[16*(i*4+j) +: 16] = mac_mul_reverse_d1 ? vmac_mul_sub_eew8_widen_d1[i*4+j][15:0] :
                                                                        vmac_mul_add_eew8_widen_d1[i*4+j][15:0];
    end
  end
end
assign mac_rslt_eew8_d1 = is_vmac_d1 ? mac_is_widen_d1 ? vmac_rslt_eew8_widen_d1[`VLEN-1:0]    : //mac widen
                                                         vmac_rslt_eew8_no_widen_d1            : //mac normal
                                       is_vsmul_d1     ? vsmul_rslt_eew8_d1                    : //vsmul
                                       mac_is_widen_d1 ? mac_rslt_eew8_widen_d1[`VLEN-1:0]     : //mul widen
                                                         mac_rslt_eew8_no_widen_d1; //mul normal
assign update_vxsat_eew8_d1 = vsmul_sat_eew8_d1;
//eew16
//full rslt is 32bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    for (j=0; j<2; j=j+1) begin //x
      mac_rslt_full_eew16_d1[i*2+j] = {mac8_out_d1[i*16+j*10+5],16'b0} + 
                                   {{8{mac8_out_d1[i*16+j*10+4][15]&&mac_src1_is_signed_d1}},mac8_out_d1[i*16+j*10+4],8'b0} + 
                                   {{8{mac8_out_d1[i*16+j*10+1][15]&&mac_src2_is_signed_d1}},mac8_out_d1[i*16+j*10+1],8'b0} + 
                                   {16'b0,mac8_out_d1[i*16+j*10]};
      mac_rslt_eew16_widen_d1[32*(i*2+j) +: 32] = mac_rslt_full_eew16_d1[i*2+j];//widen, and convert to [255:0]
      mac_rslt_eew16_no_widen_d1[16*(i*2+j) +: 16] = mac_keep_low_bits_d1 ? mac_rslt_full_eew16_d1[i*2+j][15:0] : mac_rslt_full_eew16_d1[i*2+j][31:16];
      //Below are for rounding mac (vsmul.vv, vsmul.vx)
      //right shift bit is 16-1=15 not 16 !
      //(TODO) Improve to make this readable
      vsmul_round_incr_eew16_d1[i*2+j] = mac_uop_xrm_d1==2'd3 ? !mac_rslt_full_eew16_d1[i*2+j][15] && (|mac_rslt_full_eew16_d1[i*2+j][14:0]) : //ROD
                                         mac_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                         mac_uop_xrm_d1==2'd1 ? mac_rslt_full_eew16_d1[i*2+j][14] && (|(mac_rslt_full_eew16_d1[i*2+j][13:0]) || mac_rslt_full_eew16_d1[i*2+j][15]) : //RNE
                                                                mac_rslt_full_eew16_d1[i*2+j][14]; //RNU
      vsmul_rslt_eew16_d1[16*(i*2+j) +:16]= mac_rslt_full_eew16_d1[i*2+j][31:30] == 2'b01 ? 16'h7fff : //saturate
                                                                                       mac_rslt_full_eew16_d1[i*2+j][15+:16] + {15'b0,vsmul_round_incr_eew16_d1[i*2+j]};//right shift 15bit then +"1"
      vsmul_sat_eew16_d1[i*2+j] = mac_rslt_full_eew16_d1[i*2+j][31:30] == 2'b01;
      //Below are for vmac related instructions
      vmac_mul_add_eew16_no_widen_d1[i*2+j] = {1'b0,mac_addsrc_d1[16*(i*2+j) +: 16]} + {1'b0,mac_rslt_eew16_no_widen_d1[16*(i*2+j) +: 16]};//17bit
      vmac_mul_sub_eew16_no_widen_d1[i*2+j] = {1'b0,mac_addsrc_d1[16*(i*2+j) +: 16]} - {1'b0,mac_rslt_eew16_no_widen_d1[16*(i*2+j) +: 16]};
      vmac_rslt_eew16_no_widen_d1[16*(i*2+j) +:16] = mac_mul_reverse_d1 ? vmac_mul_sub_eew16_no_widen_d1[i*2+j][15:0] :
                                                                          vmac_mul_add_eew16_no_widen_d1[i*2+j][15:0];
      vmac_mul_add_eew16_widen_d1[i*2+j] = {1'b0,mac_addsrc_widen_d1[32*(i*2+j) +: 32]} + {1'b0,mac_rslt_eew16_widen_d1[32*(i*2+j) +: 32]};//33bit
      vmac_mul_sub_eew16_widen_d1[i*2+j] = {1'b0,mac_addsrc_widen_d1[32*(i*2+j) +: 32]} - {1'b0,mac_rslt_eew16_widen_d1[32*(i*2+j) +: 32]};
      vmac_rslt_eew16_widen_d1[32*(i*2+j) +: 32] = mac_mul_reverse_d1 ? vmac_mul_sub_eew16_widen_d1[i*2+j][31:0] :
                                                                       vmac_mul_add_eew16_widen_d1[i*2+j][31:0];
    end
  end
end
assign mac_rslt_eew16_d1 = is_vmac_d1 ? mac_is_widen_d1 ? vmac_rslt_eew16_widen_d1[`VLEN-1:0] : //mac widen
                                                          vmac_rslt_eew16_no_widen_d1         : //mac normal
                                        is_vsmul_d1     ? vsmul_rslt_eew16_d1                 : //vsmul
                                        mac_is_widen_d1 ? mac_rslt_eew16_widen_d1[`VLEN-1:0]  : //mul widen
                                                          mac_rslt_eew16_no_widen_d1; //mul normal
assign update_vxsat_eew16_d1 = {vsmul_sat_eew16_d1[7],1'b0,
                                vsmul_sat_eew16_d1[6],1'b0,
                                vsmul_sat_eew16_d1[5],1'b0,
                                vsmul_sat_eew16_d1[4],1'b0,
                                vsmul_sat_eew16_d1[3],1'b0,
                                vsmul_sat_eew16_d1[2],1'b0,
                                vsmul_sat_eew16_d1[1],1'b0,
                                vsmul_sat_eew16_d1[0],1'b0};
//eew32
//full rslt is 64bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    mac_rslt_full_eew32_d1[i] = {mac8_out_d1[i*16+15],48'b0} + 
                             {{8{mac8_out_d1[i*16+14][15]&&mac_src1_is_signed_d1}},mac8_out_d1[i*16+14],40'b0} + 
                             {{8{mac8_out_d1[i*16+11][15]&&mac_src2_is_signed_d1}},mac8_out_d1[i*16+11],40'b0} + 
                             {{16{mac8_out_d1[i*16+13][15]&& mac_src1_is_signed_d1}},mac8_out_d1[i*16+13],32'b0} + 
                             {16'b0,mac8_out_d1[i*16+10],32'b0} + 
                             {{16{mac8_out_d1[i*16+7][15]&&mac_src2_is_signed_d1}},mac8_out_d1[i*16+7],32'b0} + 
                             {{24{mac8_out_d1[i*16+12][15]&& mac_src1_is_signed_d1}},mac8_out_d1[i*16+12],24'b0} + 
                             {24'b0,mac8_out_d1[i*16+9],24'b0} +
                             {24'b0,mac8_out_d1[i*16+6],24'b0} + 
                             {{24{mac8_out_d1[i*16+3][15]&&mac_src2_is_signed_d1}},mac8_out_d1[i*16+3],24'b0} + 
                             {32'b0,mac8_out_d1[i*16+8],16'b0} + 
                             {32'b0,mac8_out_d1[i*16+5],16'b0} +
                             {32'b0,mac8_out_d1[i*16+2],16'b0} + 
                             {40'b0,mac8_out_d1[i*16+4],8'b0} + 
                             {40'b0,mac8_out_d1[i*16+1],8'b0} + 
                             {48'b0,mac8_out_d1[i*16]};
    mac_rslt_eew32_widen_d1[64*i +: 64] = mac_rslt_full_eew32_d1[i];//widen, and convert to [255:0]
    mac_rslt_eew32_no_widen_d1[32*i +: 32] = mac_keep_low_bits_d1 ? mac_rslt_full_eew32_d1[i][31:0] : mac_rslt_full_eew32_d1[i][63:32];
    //Below are for rounding mac (vsmul.vv, vsmul.vx)
    //right shift bit is 32-1=31 not 32 !
    //(TODO) Improve to make this readable
    vsmul_round_incr_eew32_d1[i] = mac_uop_xrm_d1==2'd3 ? !mac_rslt_full_eew32_d1[i][31] && (|mac_rslt_full_eew32_d1[i][30:0]) : //ROD
                                   mac_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                   mac_uop_xrm_d1==2'd1 ? mac_rslt_full_eew32_d1[i][30] && (|(mac_rslt_full_eew32_d1[i][29:0]) || mac_rslt_full_eew32_d1[i][31]) : //RNE
                                                          mac_rslt_full_eew32_d1[i][30]; //RNU      
    vsmul_rslt_eew32_d1[32*i +:32]= mac_rslt_full_eew32_d1[i][63:62] == 2'b01 ? 32'h7fff_ffff : //saturate
                                                                             mac_rslt_full_eew32_d1[i][31+:32] + {31'b0,vsmul_round_incr_eew32_d1[i]};//right shift 31bit then +"1"
    vsmul_sat_eew32_d1[i] = mac_rslt_full_eew32_d1[i][63:62] == 2'b01;
    //Below are for vmac related instructions
    vmac_mul_add_eew32_no_widen_d1[i] = {1'b0,mac_addsrc_d1[32*i +: 32]} + {1'b0,mac_rslt_eew32_no_widen_d1[32*i +: 32]};//33bit
    vmac_mul_sub_eew32_no_widen_d1[i] = {1'b0,mac_addsrc_d1[32*i +: 32]} - {1'b0,mac_rslt_eew32_no_widen_d1[32*i +: 32]};
    vmac_rslt_eew32_no_widen_d1[32*i +:32] = mac_mul_reverse_d1 ? vmac_mul_sub_eew32_no_widen_d1[i][31:0] :
                                                                  vmac_mul_add_eew32_no_widen_d1[i][31:0];
    vmac_mul_add_eew32_widen_d1[i] = {1'b0,mac_addsrc_widen_d1[64*i +: 64]} + {1'b0,mac_rslt_eew32_widen_d1[64*i +: 64]};//65bit
    vmac_mul_sub_eew32_widen_d1[i] = {1'b0,mac_addsrc_widen_d1[64*i +: 64]} - {1'b0,mac_rslt_eew32_widen_d1[64*i +: 64]};
    vmac_rslt_eew32_widen_d1[64*i +: 64] = mac_mul_reverse_d1 ? vmac_mul_sub_eew32_widen_d1[i][63:0] :
                                                               vmac_mul_add_eew32_widen_d1[i][63:0];
  end
end
assign mac_rslt_eew32_d1 = is_vmac_d1 ? mac_is_widen_d1 ? vmac_rslt_eew32_widen_d1[`VLEN-1:0] : //mac widen
                                                          vmac_rslt_eew32_no_widen_d1         : //mac normal
                                        is_vsmul_d1     ? vsmul_rslt_eew32_d1 : //vsmul
                                        mac_is_widen_d1 ? mac_rslt_eew32_widen_d1[`VLEN-1:0] : //mul widen
                                                          mac_rslt_eew32_no_widen_d1; //mul normal
assign update_vxsat_eew32_d1 = {vsmul_sat_eew32_d1[3],3'b0,
                                vsmul_sat_eew32_d1[2],3'b0,
                                vsmul_sat_eew32_d1[1],3'b0,
                                vsmul_sat_eew32_d1[0],3'b0};
//Output pack
assign mac2rob_uop_valid = rs2mac_uop_valid_d1;

assign mac2rob_uop_data.rob_entry = mac_uop_rob_entry_d1;
assign mac2rob_uop_data.w_data = mac_top_vs_eew_d1==EEW32 ? mac_rslt_eew32_d1 : 
                                 mac_top_vs_eew_d1==EEW16 ? mac_rslt_eew16_d1 :
                                                            mac_rslt_eew8_d1; //all possible cases are 8/16/32
assign mac2rob_uop_data.w_valid = rs2mac_uop_valid_d1;
assign mac2rob_uop_data.vsaturate = is_vsmul_d1 ? mac_top_vs_eew_d1==EEW32 ? update_vxsat_eew32_d1 :
                                                  mac_top_vs_eew_d1==EEW16 ? update_vxsat_eew16_d1 :
                                                                             update_vxsat_eew8_d1  :
                                                                             {`VLENB{1'b0}};
`ifdef TB_SUPPORT
assign mac2rob_uop_data.uop_pc = mac_uop_pc_d1;
`endif
endmodule
// ----- 8< ----- FILE "./rvv_backend_mul_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description: 
// 1. It will get uops from MUL Reservation station and execute this uop.
//
// feature list:
// 1. 

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_mul_unit (
  // Outputs
  mul2rob_uop_valid, mul2rob_uop_data,
  // Inputs
  clk, rst_n, rs2mul_uop_valid, rs2mul_uop_data,
  mul_stg0_vld_en, mul_stg0_data_en
  );

input             clk;
input             rst_n;

input             rs2mul_uop_valid;
input MUL_RS_t    rs2mul_uop_data;

input             mul_stg0_vld_en;
input             mul_stg0_data_en;

output            mul2rob_uop_valid;
output PU2ROB_t   mul2rob_uop_data;

// Wires & Regs
logic [`ROB_DEPTH_WIDTH-1:0]   mul_uop_rob_entry;
logic [`FUNCT6_WIDTH-1:0]      mul_uop_funct6;
logic [`FUNCT3_WIDTH-1:0]      mul_uop_funct3;
logic [1:0]                    mul_uop_xrm;
logic [2:0]                    mul_top_vs_eew;
logic [`VLEN-1:0]              mul_uop_vs1_data;
logic [`VLEN-1:0]              mul_uop_vs2_data;
logic [`XLEN-1:0]              mul_uop_rs1_data;
logic                          mul_uop_index;

logic                          is_vv; //1:op*vv; 0:op*vx
logic [`VLEN-1:0]              mul_src2;
logic [`VLEN-1:0]              mul_src1;
logic                          mul_src2_is_signed;
logic                          mul_src1_is_signed;
logic                          mul_is_widen;
logic                          mul_keep_low_bits;
logic                          is_vsmul;

logic [`VLEN-1:0]              mul_src2_mux;
logic [`VLEN-1:0]              mul_src1_mux;
logic [15:0]                   mul_src2_is_signed_extend;
logic [15:0]                   mul_src1_is_signed_extend;

logic [7:0]                    mul8_in0[15:0];
logic [15:0]                   mul8_in0_is_signed;
logic [7:0]                    mul8_in1[15:0];
logic [15:0]                   mul8_in1_is_signed;
logic [15:0]                   mul8_out[63:0];

logic [15:0]                   mul8_out_d1[63:0];

logic                          rs2mul_uop_valid_d1;
logic                          mul_src2_is_signed_d1;
logic                          mul_src1_is_signed_d1;
logic                          mul_is_widen_d1;
logic                          mul_keep_low_bits_d1;
logic                          is_vsmul_d1;
logic [1:0]                    mul_uop_xrm_d1;
logic [2:0]                    mul_top_vs_eew_d1;
logic [`ROB_DEPTH_WIDTH-1:0]   mul_uop_rob_entry_d1;

logic [15:0]                   mul_rslt_full_eew8_d1[15:0];
logic [2*`VLEN-1:0]            mul_rslt_eew8_widen_d1;
logic [`VLEN-1:0]              mul_rslt_eew8_no_widen_d1;
logic [15:0]                   vsmul_round_incr_eew8_d1;
logic [`VLEN-1:0]              vsmul_rslt_eew8_d1;
logic [15:0]                   vsmul_sat_eew8_d1;
logic [`VLEN-1:0]              mul_rslt_eew8_d1;
logic [`VLENB-1:0]             update_vxsat_eew8_d1;

logic [31:0]                   mul_rslt_full_eew16_d1[7:0];
logic [2*`VLEN-1:0]            mul_rslt_eew16_widen_d1;
logic [`VLEN-1:0]              mul_rslt_eew16_no_widen_d1;
logic [7:0]                    vsmul_round_incr_eew16_d1;
logic [`VLEN-1:0]              vsmul_rslt_eew16_d1;
logic [7:0]                    vsmul_sat_eew16_d1;
logic [`VLEN-1:0]              mul_rslt_eew16_d1;
logic [`VLENB-1:0]             update_vxsat_eew16_d1;

logic [63:0]                   mul_rslt_full_eew32_d1[3:0];
logic [2*`VLEN-1:0]            mul_rslt_eew32_widen_d1;
logic [`VLEN-1:0]              mul_rslt_eew32_no_widen_d1;
logic [3:0]                    vsmul_round_incr_eew32_d1;
logic [`VLEN-1:0]              vsmul_rslt_eew32_d1;
logic [3:0]                    vsmul_sat_eew32_d1;
logic [`VLEN-1:0]              mul_rslt_eew32_d1;
logic [`VLENB-1:0]             update_vxsat_eew32_d1;

`ifdef TB_SUPPORT
logic [`PC_WIDTH-1:0]          mul_uop_pc;
logic [`PC_WIDTH-1:0]          mul_uop_pc_d1;
`endif

//Int & Genvar
integer i,j;
genvar z,x,y;

// Input struct decode
assign mul_uop_rob_entry = rs2mul_uop_data.rob_entry;
assign mul_uop_funct6 = rs2mul_uop_data.uop_funct6.ari_funct6;
assign mul_uop_funct3 = rs2mul_uop_data.uop_funct3;
assign mul_uop_xrm = rs2mul_uop_data.vxrm;
assign mul_top_vs_eew = rs2mul_uop_data.vs2_eew;

assign mul_uop_vs1_data = rs2mul_uop_data.vs1_data;

assign mul_uop_vs2_data = rs2mul_uop_data.vs2_data;

assign mul_uop_rs1_data = rs2mul_uop_data.rs1_data;

assign mul_uop_index = rs2mul_uop_data.uop_index[0];

`ifdef TB_SUPPORT
assign mul_uop_pc = rs2mul_uop_data.uop_pc;
`endif

// Global EU control
always@(*) begin
  case ({rs2mul_uop_valid,mul_uop_funct3}) 
    {1'b1,OPMVV} : begin
      is_vv = 1'b1;
      case (mul_uop_funct6) 
        VMUL: begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b1;
          is_vsmul = 1'b0;
        end
        VMULH : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VMULHU : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b0;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VMULHSU : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VWMUL : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {64'b0,mul_uop_vs1_data[mul_uop_index*64 +: 64]};
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        VWMULU : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {64'b0,mul_uop_vs1_data[mul_uop_index*64 +: 64]};
          mul_src2_is_signed = 1'b0;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        VWMULSU : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {64'b0,mul_uop_vs1_data[mul_uop_index*64 +: 64]};
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        default : begin //default use VMUL
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b1;
          is_vsmul = 1'b0;
        end//end default
      endcase//end funct6
    end//end OPMVV
    {1'b1,OPMVX} : begin
      is_vv = 1'b0;
      case (mul_uop_funct6) 
        VMUL : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b1;
          is_vsmul = 1'b0;
        end
        VMULH : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VMULHU : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b0;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VMULHSU : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b0;
        end
        VWMUL : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        VWMULU : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b0;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        VWMULSU : begin
          mul_src2 = {64'b0,mul_uop_vs2_data[mul_uop_index*64 +: 64]};
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b0;
          mul_is_widen = 1'b1;
          mul_keep_low_bits = 1'b0;//if widen, keep_low doesnt matter
          is_vsmul = 1'b0;
        end
        default : begin //default use VMUL
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b1;
          is_vsmul = 1'b0;
        end//end default
      endcase
    end//end OPMVX
    {1'b1,OPIVV} : begin
      is_vv = 1'b1;
      case (mul_uop_funct6) 
        VSMUL_VMVNRR : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b1;
        end
        default : begin //currently put default the same as vsmul
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = mul_uop_vs1_data;
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b1;
        end//end default
      endcase//end funct6
    end//end OPIVV
    {1'b1,OPIVX} : begin
      is_vv = 1'b0;
      case (mul_uop_funct6) 
        VSMUL_VMVNRR : begin
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b1;
        end
        default : begin //currently put default the same as vsmul
          mul_src2 = mul_uop_vs2_data;
          mul_src1 = {{(`VLEN-`XLEN){mul_uop_rs1_data[`XLEN-1]&&mul_src1_is_signed}},mul_uop_rs1_data}; //use rs1
          mul_src2_is_signed = 1'b1;
          mul_src1_is_signed = 1'b1;
          mul_is_widen = 1'b0;
          mul_keep_low_bits = 1'b0;
          is_vsmul = 1'b1;
        end//end default
      endcase//end funct6
    end//end OPIVX
    default : begin
      is_vv = 1'b1;
      mul_src2 = `VLEN'b0;
      mul_src1 = `VLEN'b0;
      mul_src2_is_signed = 1'b0;
      mul_src1_is_signed = 1'b0;
      mul_is_widen = 1'b0;
      mul_keep_low_bits = 1'b0;
      is_vsmul = 1'b0;
    end//end default
  endcase//end funct3
end

// Before using MUL alu, 
//  1.group sub-elements' sign bit
// (TODO) let input is 0 when not use that EU
always@(*) begin
  case (mul_top_vs_eew) 
    EEW8 : begin
      mul_src2_mux = mul_src2;
      mul_src1_mux = is_vv ? mul_src1 : {16{mul_src1[7:0]}};
      mul_src2_is_signed_extend = {16{mul_src2_is_signed}};
      mul_src1_is_signed_extend = {16{mul_src1_is_signed}};
    end//end eew8
    EEW16 : begin
      mul_src2_mux = mul_src2;
      mul_src1_mux = is_vv ? mul_src1 : {8{mul_src1[15:0]}};
      mul_src2_is_signed_extend = {8{mul_src2_is_signed,1'b0}};
      mul_src1_is_signed_extend = {8{mul_src1_is_signed,1'b0}};
    end//end eew16
    EEW32 : begin
      mul_src2_mux = mul_src2;
      mul_src1_mux = is_vv ? mul_src1 : {4{mul_src1[31:0]}};
      mul_src2_is_signed_extend = {4{mul_src2_is_signed,3'b0}};
      mul_src1_is_signed_extend = {4{mul_src1_is_signed,3'b0}};
    end//end eew32
    default : begin //default use eew8
      mul_src2_mux = mul_src2;
      mul_src1_mux = is_vv ? mul_src1 : {16{mul_src1[7:0]}};
      mul_src2_is_signed_extend = {16{mul_src2_is_signed}};
      mul_src1_is_signed_extend = {16{mul_src1_is_signed}};
    end//end default
  endcase
end

// Before MUL, always depart 128 bits into 16x8 sub-elements
always@(*) begin
  for (i=0; i<16; i=i+1) begin
      mul8_in0[i] = mul_src2_mux[i*8 +: 8];
      mul8_in1[i] = mul_src1_mux[i*8 +: 8];
      mul8_in0_is_signed[i] = mul_src2_is_signed_extend[i];
      mul8_in1_is_signed[i] = mul_src1_is_signed_extend[i];
  end
end

// MUL alus with d1_reg
//  in a 4 of 4x4 tiled way for instantiation
generate 
  for (z=0; z<4; z=z+1) begin 
    for (x=0; x<4; x=x+1) begin
      for (y=0; y<4; y=y+1) begin
        rvv_backend_mul_unit_mul8 u_mul8 (
          .out(mul8_out[z*16+y*4+x]), //16bit out
          .in0(mul8_in0[z*4+x]), 
          .in0_is_signed(mul8_in0_is_signed[z*4+x]),
          .in1(mul8_in1[z*4+y]), 
          .in1_is_signed(mul8_in1_is_signed[z*4+y]));

        edff #(.T(logic [16-1:0])) u_mul8_delay (
          .q(mul8_out_d1[z*16+y*4+x]), 
          .clk(clk), 
          .rst_n(rst_n), 
          .e(mul_stg0_data_en),
          .d(mul8_out[z*16+y*4+x]));
      end
    end
  end
endgenerate

edff #(.T(logic)) u_valid_delay (.q(rs2mul_uop_valid_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_vld_en), .d(rs2mul_uop_valid));
edff #(.T(logic)) u_src2_is_signed_delay (.q(mul_src2_is_signed_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_src2_is_signed));
edff #(.T(logic)) u_src1_is_signed_delay (.q(mul_src1_is_signed_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_src1_is_signed));
edff #(.T(logic)) u_is_widen_delay (.q(mul_is_widen_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_is_widen));
edff #(.T(logic)) u_keep_low_bits_delay (.q(mul_keep_low_bits_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_keep_low_bits));
edff #(.T(logic)) u_is_vsmul_delay (.q(is_vsmul_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(is_vsmul));
edff #(.T(logic [2-1:0])) u_xrm_delay (.q(mul_uop_xrm_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_uop_xrm));
edff #(.T(logic [3-1:0])) u_eew_delay (.q(mul_top_vs_eew_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_top_vs_eew));

edff #(.T(logic [`ROB_DEPTH_WIDTH-1:0])) u_rob_entry_delay (.q(mul_uop_rob_entry_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_uop_rob_entry));

`ifdef TB_SUPPORT
edff #(.T(logic [`PC_WIDTH-1:0])) u_PC_delay (.q(mul_uop_pc_d1), .clk(clk), .rst_n(rst_n), .e(mul_stg0_data_en), .d(mul_uop_pc));
`endif

/////////////////////////////////////////////////
///////Enter d1_stage ///////////////////////////
/////////////////////////////////////////////////

// After MUL, calculte eew8, eew16, eew32 results
// Here we have a ([15:0] [63:0] mul8_out_d1)
//eew8
//full rslt is 16bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    for (j=0; j<4; j=j+1) begin //x
        mul_rslt_full_eew8_d1[i*4+j] = mul8_out_d1[i*16+j*5];
        mul_rslt_eew8_widen_d1[16*(i*4+j) +: 16] = mul_rslt_full_eew8_d1[i*4+j];//widen, and convert to [255:0]
        mul_rslt_eew8_no_widen_d1[8*(i*4+j) +: 8] = mul_keep_low_bits_d1 ? mul_rslt_full_eew8_d1[i*4+j][7:0] : mul_rslt_full_eew8_d1[i*4+j][15:8];
        //Below are for rounding mul (vsmul.vv, vsmul.vx)
        //right shift bit is 7 not 8 !
        //(TODO) Improve to make this readable
        vsmul_round_incr_eew8_d1[i*4+j] = mul_uop_xrm_d1==2'd3 ? !mul_rslt_full_eew8_d1[i*4+j][7] && (|mul_rslt_full_eew8_d1[i*4+j][6:0]) : //ROD
                                          mul_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                          mul_uop_xrm_d1==2'd1 ? mul_rslt_full_eew8_d1[i*4+j][6] && (|(mul_rslt_full_eew8_d1[i*4+j][5:0]) || mul_rslt_full_eew8_d1[i*4+j][7]) : //RNE
                                                                 mul_rslt_full_eew8_d1[i*4+j][6]; //RNU
        vsmul_rslt_eew8_d1[8*(i*4+j) +:8]= mul_rslt_full_eew8_d1[i*4+j][15:14] == 2'b01 ? 8'h7f : //saturate
                                                                                      mul_rslt_full_eew8_d1[i*4+j][7+:8] + {7'b0,vsmul_round_incr_eew8_d1[i*4+j]};//right shift 7bit then +"1"
        vsmul_sat_eew8_d1[i*4+j] = mul_rslt_full_eew8_d1[i*4+j][15:14] == 2'b01;
    end
  end
end
assign mul_rslt_eew8_d1 = is_vsmul_d1     ? vsmul_rslt_eew8_d1 : //vsmul
                          mul_is_widen_d1 ? mul_rslt_eew8_widen_d1[`VLEN-1:0] : //widen
                                            mul_rslt_eew8_no_widen_d1; //normal
assign update_vxsat_eew8_d1 = vsmul_sat_eew8_d1;
//eew16
//full rslt is 32bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    for (j=0; j<2; j=j+1) begin //x
      mul_rslt_full_eew16_d1[i*2+j] = {mul8_out_d1[i*16+j*10+5],16'b0} + 
                                   {{8{mul8_out_d1[i*16+j*10+4][15]&&mul_src1_is_signed_d1}},mul8_out_d1[i*16+j*10+4],8'b0} + 
                                   {{8{mul8_out_d1[i*16+j*10+1][15]&&mul_src2_is_signed_d1}},mul8_out_d1[i*16+j*10+1],8'b0} + 
                                   {16'b0,mul8_out_d1[i*16+j*10]};
      mul_rslt_eew16_widen_d1[32*(i*2+j) +: 32] = mul_rslt_full_eew16_d1[i*2+j];//widen, and convert to [255:0]
      mul_rslt_eew16_no_widen_d1[16*(i*2+j) +: 16] = mul_keep_low_bits_d1 ? mul_rslt_full_eew16_d1[i*2+j][15:0] : mul_rslt_full_eew16_d1[i*2+j][31:16];
      //Below are for rounding mul (vsmul.vv, vsmul.vx)
      //right shift bit is 16-1=15 not 16 !
      //(TODO) Improve to make this readable
      vsmul_round_incr_eew16_d1[i*2+j] = mul_uop_xrm_d1==2'd3 ? !mul_rslt_full_eew16_d1[i*2+j][15] && (|mul_rslt_full_eew16_d1[i*2+j][14:0]) : //ROD
                                         mul_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                         mul_uop_xrm_d1==2'd1 ? mul_rslt_full_eew16_d1[i*2+j][14] && (|(mul_rslt_full_eew16_d1[i*2+j][13:0]) || mul_rslt_full_eew16_d1[i*2+j][15]) : //RNE
                                                                mul_rslt_full_eew16_d1[i*2+j][14]; //RNU
      vsmul_rslt_eew16_d1[16*(i*2+j) +:16]= mul_rslt_full_eew16_d1[i*2+j][31:30] == 2'b01 ? 16'h7fff : //saturate
                                                                                       mul_rslt_full_eew16_d1[i*2+j][15+:16] + {15'b0,vsmul_round_incr_eew16_d1[i*2+j]};//right shift 15bit then +"1"
      vsmul_sat_eew16_d1[i*2+j] = mul_rslt_full_eew16_d1[i*2+j][31:30] == 2'b01;
    end
  end
end
assign mul_rslt_eew16_d1 = is_vsmul_d1     ? vsmul_rslt_eew16_d1 : //vsmul
                           mul_is_widen_d1 ? mul_rslt_eew16_widen_d1[`VLEN-1:0] : //widen
                                             mul_rslt_eew16_no_widen_d1; //normal
assign update_vxsat_eew16_d1 = {vsmul_sat_eew16_d1[7],1'b0,
                                vsmul_sat_eew16_d1[6],1'b0,
                                vsmul_sat_eew16_d1[5],1'b0,
                                vsmul_sat_eew16_d1[4],1'b0,
                                vsmul_sat_eew16_d1[3],1'b0,
                                vsmul_sat_eew16_d1[2],1'b0,
                                vsmul_sat_eew16_d1[1],1'b0,
                                vsmul_sat_eew16_d1[0],1'b0};
//eew32
//full rslt is 64bit
always@(*) begin
  for (i=0; i<4; i=i+1) begin //z
    mul_rslt_full_eew32_d1[i] = {mul8_out_d1[i*16+15],48'b0} + 
                             {{8{mul8_out_d1[i*16+14][15]&&mul_src1_is_signed_d1}},mul8_out_d1[i*16+14],40'b0} + 
                             {{8{mul8_out_d1[i*16+11][15]&&mul_src2_is_signed_d1}},mul8_out_d1[i*16+11],40'b0} + 
                             {{16{mul8_out_d1[i*16+13][15]&&mul_src1_is_signed_d1}},mul8_out_d1[i*16+13],32'b0} + 
                             {16'b0,mul8_out_d1[i*16+10],32'b0} + 
                             {{16{mul8_out_d1[i*16+7][15]&&mul_src2_is_signed_d1}},mul8_out_d1[i*16+7],32'b0} + 
                             {{24{mul8_out_d1[i*16+12][15]&&mul_src1_is_signed_d1}},mul8_out_d1[i*16+12],24'b0} + 
                             {24'b0,mul8_out_d1[i*16+9],24'b0} +
                             {24'b0,mul8_out_d1[i*16+6],24'b0} + 
                             {{24{mul8_out_d1[i*16+3][15]&&mul_src2_is_signed_d1}},mul8_out_d1[i*16+3],24'b0} + 
                             {32'b0,mul8_out_d1[i*16+8],16'b0} + 
                             {32'b0,mul8_out_d1[i*16+5],16'b0} +
                             {32'b0,mul8_out_d1[i*16+2],16'b0} + 
                             {40'b0,mul8_out_d1[i*16+4],8'b0} + 
                             {40'b0,mul8_out_d1[i*16+1],8'b0} + 
                             {48'b0,mul8_out_d1[i*16]};
    mul_rslt_eew32_widen_d1[64*i +: 64] = mul_rslt_full_eew32_d1[i];//widen, and convert to [255:0]
    mul_rslt_eew32_no_widen_d1[32*i +: 32] = mul_keep_low_bits_d1 ? mul_rslt_full_eew32_d1[i][31:0] : mul_rslt_full_eew32_d1[i][63:32];
    //Below are for rounding mul (vsmul.vv, vsmul.vx)
    //right shift bit is 32-1=31 not 32 !
    //(TODO) Improve to make this readable
    vsmul_round_incr_eew32_d1[i] = mul_uop_xrm_d1==2'd3 ? !mul_rslt_full_eew32_d1[i][31] && (|mul_rslt_full_eew32_d1[i][30:0]) : //ROD
                                   mul_uop_xrm_d1==2'd2 ? 1'b0  : //RDN
                                   mul_uop_xrm_d1==2'd1 ? mul_rslt_full_eew32_d1[i][30] && (|(mul_rslt_full_eew32_d1[i][29:0]) || mul_rslt_full_eew32_d1[i][31]) : //RNE
                                                          mul_rslt_full_eew32_d1[i][30]; //RNU      
    vsmul_rslt_eew32_d1[32*i +:32]= mul_rslt_full_eew32_d1[i][63:62] == 2'b01 ? 32'h7fff_ffff : //saturate
                                                                             mul_rslt_full_eew32_d1[i][31+:32] + {31'b0,vsmul_round_incr_eew32_d1[i]};//right shift 31bit then +"1"
    vsmul_sat_eew32_d1[i] = mul_rslt_full_eew32_d1[i][63:62] == 2'b01;
  end
end
assign mul_rslt_eew32_d1 = is_vsmul_d1     ? vsmul_rslt_eew32_d1 : //vsmul
                           mul_is_widen_d1 ? mul_rslt_eew32_widen_d1[`VLEN-1:0] : //widen
                                             mul_rslt_eew32_no_widen_d1; //normal
assign update_vxsat_eew32_d1 = {vsmul_sat_eew32_d1[3],3'b0,
                                vsmul_sat_eew32_d1[2],3'b0,
                                vsmul_sat_eew32_d1[1],3'b0,
                                vsmul_sat_eew32_d1[0],3'b0};

//Output pack
assign mul2rob_uop_valid = rs2mul_uop_valid_d1;

assign mul2rob_uop_data.rob_entry = mul_uop_rob_entry_d1;
assign mul2rob_uop_data.w_data = mul_top_vs_eew_d1==EEW32 ? mul_rslt_eew32_d1 : 
                                 mul_top_vs_eew_d1==EEW16 ? mul_rslt_eew16_d1 :
                                                            mul_rslt_eew8_d1; //all possible cases are 8/16/32
assign mul2rob_uop_data.w_valid = rs2mul_uop_valid_d1;
assign mul2rob_uop_data.vsaturate = is_vsmul_d1 ? mul_top_vs_eew_d1==EEW32 ? update_vxsat_eew32_d1 :
                                                  mul_top_vs_eew_d1==EEW16 ? update_vxsat_eew16_d1 :
                                                                             update_vxsat_eew8_d1  :
                                                                             {`VLENB{1'b0}};

`ifdef TB_SUPPORT
assign mul2rob_uop_data.uop_pc = mul_uop_pc_d1;
`endif
endmodule
// ----- 8< ----- FILE "./rvv_backend_mulmac.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description: 
// This is the top module of MUL/MAC wrapper
// Contains instantiation of MUL_ex and MAC_ex
// Contains ex arbiter
//
// feature list:
// 1. Instantiation of MUL ex and MAC ex
// 2. Arbitration to uop0/1 to use MUL or MAC
// 3. Pop MUL_RS 


`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_mulmac (
  //Outputs
  ex2rob_valid, ex2rob_data, ex2rs_fifo_pop,
  //Inputs
  clk, rst_n, rs2ex_uop_data, 
  rs2ex_fifo_empty, rs2ex_fifo_1left_to_empty, 
  rob2ex_ready, trap_flush_rvv
);

//global signals
input             clk;
input             rst_n;
input             trap_flush_rvv;

//MUL_RS to MUL_EX 
input MUL_RS_t [`NUM_MUL-1:0] rs2ex_uop_data;
input logic                   rs2ex_fifo_empty;
input logic                   rs2ex_fifo_1left_to_empty;
output logic [`NUM_MUL-1:0]   ex2rs_fifo_pop;

//MUL_EX to ROB
output  logic       [`NUM_MUL-1:0] ex2rob_valid;
output  PU2ROB_t    [`NUM_MUL-1:0] ex2rob_data;
input   logic       [`NUM_MUL-1:0] rob2ex_ready;

// Wires & Regs
logic [`NUM_MUL-1:0]          rs2mac_uop_valid;
logic [`NUM_MUL-1:0]          mac2rs_uop_ready;
MUL_RS_t [`NUM_MUL-1:0]       rs2mac_uop_data;

logic [`NUM_MUL-1:0]          mac2rob_uop_valid;
PU2ROB_t [`NUM_MUL-1:0]       mac2rob_uop_data;

logic [`NUM_MUL-1:0]          mac_stg0_vld_en;
logic [`NUM_MUL-1:0]          mac_stg0_data_en;
//Generate uop valid
// empty        0  |  0  |  1  |  1
// 1left2empty  0  |  1  |  0  |  1
// dataLeft     >1 |  1  | N/A |  0
assign rs2mac_uop_valid[0] = !rs2ex_fifo_empty && !trap_flush_rvv; //clear d0 when trap flush
assign rs2mac_uop_valid[1] = !(rs2ex_fifo_empty || rs2ex_fifo_1left_to_empty) && !trap_flush_rvv; //clear d0 when trap flush
assign rs2mac_uop_data[0] = rs2ex_uop_data[0];
assign rs2mac_uop_data[1] = rs2ex_uop_data[1];

// Inst of MUL-ex and MAC-ex
//MAC 0
rvv_backend_mac_unit u_mac0 (
  // Outputs
  .mac2rob_uop_valid(mac2rob_uop_valid[0]),
  .mac2rob_uop_data(mac2rob_uop_data[0]),
  // Inputs
  .clk(clk), 
  .rst_n(rst_n), 
  .rs2mac_uop_valid(rs2mac_uop_valid[0]), 
  .rs2mac_uop_data(rs2mac_uop_data[0]),
  .mac_stg0_vld_en (mac_stg0_vld_en[0]),
  .mac_stg0_data_en(mac_stg0_data_en[0]));

//MAC 1
rvv_backend_mac_unit u_mac1 (
  // Outputs
  .mac2rob_uop_valid(mac2rob_uop_valid[1]),
  .mac2rob_uop_data(mac2rob_uop_data[1]),
  // Inputs
  .clk(clk), 
  .rst_n(rst_n), 
  .rs2mac_uop_valid(rs2mac_uop_valid[1]), 
  .rs2mac_uop_data(rs2mac_uop_data[1]),
  .mac_stg0_vld_en (mac_stg0_vld_en[1]),
  .mac_stg0_data_en(mac_stg0_data_en[1]));

// Pop RS fifo generation
assign ex2rs_fifo_pop[0] = rs2mac_uop_valid[0] && mac2rs_uop_ready[0];
assign ex2rs_fifo_pop[1] = rs2mac_uop_valid[1] && mac2rs_uop_ready[1] && ex2rs_fifo_pop[0];//forbid pop1=1 while pop0=0

assign mac_stg0_data_en[0] = ex2rs_fifo_pop[0]; //generate stg_data_en for MAC0
assign mac_stg0_data_en[1] = ex2rs_fifo_pop[1]; //generate stg_data_en for MAC1

assign mac_stg0_vld_en[0] = ex2rs_fifo_pop[0] || mac2rob_uop_valid[0] && mac2rs_uop_ready[0]; //generate vld_en for MAC0 handshake
assign mac_stg0_vld_en[1] = ex2rs_fifo_pop[1] || mac2rob_uop_valid[1] && mac2rs_uop_ready[1]; //generate vld_en for MAC1 handshake

//Pack output to ROB
//high pack MAC 1; low pack MAC 0
assign ex2rob_valid[0] = mac2rob_uop_valid[0] && !trap_flush_rvv; //clear d1 when trap flush
assign ex2rob_data[0] = mac2rob_uop_data[0];
assign mac2rs_uop_ready[0] = !mac2rob_uop_valid[0] | rob2ex_ready[0];

assign ex2rob_valid[1] = mac2rob_uop_valid[1] && !trap_flush_rvv; //clear d1 when trap flush
assign ex2rob_data[1] = mac2rob_uop_data[1];
assign mac2rs_uop_ready[1] = !mac2rob_uop_valid[1] | rob2ex_ready[1];

endmodule
// ----- 8< ----- FILE "./rvv_backend_pmtrdt_unit.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description
// 1. the pmtrdt_unit module is responsible for one PMTRDT instruction.
//
// feature list:
// 1. Compare/Reduction/Compress instruction is optional based on parameters.
// 2. the latency of all instructions is 2-cycles.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif
`ifndef PMTRDT_DEFINE_SVH
`include "rvv_backend_pmtrdt.svh"
`endif

module rvv_backend_pmtrdt_unit
(
  clk,
  rst_n,

  pmtrdt_uop_valid,
  pmtrdt_uop,
  pmtrdt_uop_ready,

  pmtrdt_res_valid,
  pmtrdt_res,
  pmtrdt_res_ready,

  uop_data,
  uop_cnt,
  trap_flush_rvv
);
// ---parameter definition--------------------------------------------
  parameter GEN_RDT = 1'b0; // by default, NO Reduction unit
  parameter GEN_CMP = 1'b0; // by default, NO COMPARE unit
  parameter GEN_PMT = 1'b0; // by default, NO PERMUTATION unit

  localparam VLENB_WIDTH = $clog2(`VLENB);
// ---port definition-------------------------------------------------
// global signal
  input logic       clk;
  input logic       rst_n;

// the uop from PMTRDT RS
  input               pmtrdt_uop_valid;
  input PMT_RDT_RS_t  pmtrdt_uop;
  output logic        pmtrdt_uop_ready;

// the result to PMTRDT PU
  output logic        pmtrdt_res_valid;
  output PU2ROB_t     pmtrdt_res;
  input               pmtrdt_res_ready;

// all uop from PMTRDT RS for permuation
  input PMT_RDT_RS_t [`PMTRDT_RS_DEPTH-1:0] uop_data;
  input [$clog2(`PMTRDT_RS_DEPTH):0]        uop_cnt;

// trap-flush
  input               trap_flush_rvv;

// ---internal signal definition--------------------------------------
  // control signal
  PMTRDT_UOP_TYPE_t         uop_type, uop_type_q;

  RDT_CTRL_t                rdt_ctrl, rdt_ctrl_q; // RDT+CMP control signals
  logic                     rdt_ctrl_reg_en, rdt_ctrl_reg_clr;

  PMT_CTRL_t                pmt_ctrl, pmt_ctrl_q; // PMT control signals
  logic                     pmt_ctrl_reg_en, pmt_ctrl_reg_clr;

  COMPRESS_CTRL_t           compress_ctrl_ex0, compress_ctrl_ex1;
  logic                     compress_ctrl_push, compress_ctrl_pop;
  logic                     compress_ctrl_empty;

  // Reduction operation
  logic                     red_widen_sum_flag;
  logic [`VLEN-1:0]         widen_vs2;       // vs2 data after being widen if need
  BYTE_TYPE_t               widen_vs2_type;  // vs2 data btpe type after being widen if need
  logic [`VLENB/2-1:0][7:0] logic_src1_1stage, logic_src2_1stage; // and/or/xor operation: source value for reduction vs2[*]
  logic [`VLENB/2-1:0][8:0] sum_src1_1stage, sum_src2_1stage; // sum operation: source value for reduction vs2[*]
  logic [`VLENB/2-1:0]      sum_cin_1stage;
  logic [`VLENB/2-1:0][8:0] max_src1_1stage, max_src2_1stage; // max operation: source value for reduction vs2[*]
  logic [`VLENB/2-1:0]      max_cin_1stage;
  logic [`VLENB/2-1:0][8:0] min_src1_1stage, min_src2_1stage; // min operation: source value for reduction vs2[*]
  logic [`VLENB/2-1:0]      min_cin_1stage;
  logic [`VLENB/2-1:0][8:0] sum_res_1stage, max_res_1stage, min_res_1stage;
  logic [`VLENB/2-1:0][7:0] and_1stage, or_1stage, xor_1stage;
  logic [`VLENB/2-1:0]      less_than_1stage, great_than_1stage;
  logic [`VLENB/4-1:0][8:0] sum_src1_2stage, sum_src2_2stage; // sum operation: source value for reduction sum_res_1stage[*]
  logic [`VLENB/4-1:0]      sum_cin_2stage;
  logic [`VLENB/4-1:0][8:0] max_src1_2stage, max_src2_2stage; // max/min operation: source value for reduction max_res_1stage[*]
  logic [`VLENB/4-1:0]      max_cin_2stage;
  logic [`VLENB/4-1:0][8:0] min_src1_2stage, min_src2_2stage; // max/min operation: source value for reduction min_res_1stage[*]
  logic [`VLENB/4-1:0]      min_cin_2stage;
  logic [`VLENB/4-1:0][8:0] sum_res_2stage, max_res_2stage, min_res_2stage;
  logic [`VLENB/4-1:0][7:0] and_2stage, or_2stage, xor_2stage;
  logic [`VLENB/4-1:0]      less_than_2stage, great_than_2stage;
  logic                     sel_vs1; // operate vs1[0] if the last operation for reduction instruction
  logic [3:0][8:0]          src1_vd_1stage, src2_vs1_1stage;        // source value for reduction vs1[0] & vd[0]
  logic [3:0]               carry_in_vd_1stage;
  logic [3:0][8:0]          sum_vd_1stage;
  logic [3:0][7:0]          and_vd_1stage, or_vd_1stage, xor_vd_1stage;
  logic [3:0]               less_than_vd_1stage, great_than_vd_1stage;
  logic [3:0][8:0]          src1_vd_2stage, src2_vs1_2stage;        // source value for reduction vs1[0] & vd[0]
  logic [3:0]               carry_in_vd_2stage;
  logic [3:0][8:0]          sum_vd_2stage;
  logic [3:0][7:0]          and_vd_2stage, or_vd_2stage, xor_vd_2stage;
  logic [3:0]               less_than_vd_2stage, great_than_vd_2stage;
  logic [`VLENB/4-1:0][7:0] max_res_ex0, min_res_ex0;
  logic [`VLENB/4-1:0][7:0] sum_res_ex1, max_res_ex1, min_res_ex1, and_res_ex1, or_res_ex1, xor_res_ex1;
  logic [3:0][7:0]          max_vs1_ex0, min_vs1_ex0;
  logic [3:0][7:0]          sum_vs1_ex1, max_vs1_ex1, min_vs1_ex1, and_vs1_ex1, or_vs1_ex1, xor_vs1_ex1;
  logic                     red_res_en;
  logic [7:0]               sum_8b,  max_8b,  min_8b,  and_8b,  or_8b,  xor_8b;
  logic [15:0]              sum_16b, max_16b, min_16b, and_16b, or_16b, xor_16b;
  logic [31:0]              sum_32b, max_32b, min_32b, and_32b, or_32b, xor_32b;
  logic [1:0][15:0]         max_16b_1stage, min_16b_1stage;
  logic [3:0][7:0]          max_8b_1stage,  min_8b_1stage;
  logic [`VLEN-1:0]         pmtrdt_res_red; // pmtrdt result of reduction
  // Comparation operation
  logic [`VSTART_WIDTH-1:0] cmp_vstart_d, cmp_vstart_q;
  logic                     cmp_vstart_en;
  logic [`VLENB-1:0][8:0]   cmp_src1, cmp_src2; // source value for reduction/compare
  logic [`VLENB-1:0]        in_data, cin_data, bin_data; // vmadc/vmsbc mask data
  logic [`VLENB-1:0]        cmp_carry_in;
  logic [`VLENB-1:0][8:0]   cmp_sum;
  logic [`VLENB-1:0]        less_than, great_than_equal, equal, not_equal, out_data;
  logic [`VLENB-1:0]        cmp_res;
  logic [`VSTART_WIDTH-1:0] cmp_res_offset, cmp_res_en_offset;
  logic [`VLEN-1:0]         cmp_res_d, cmp_res_q;
  logic [2*`VLENB-1:0]      cmp_res_en;
  logic [`VLEN-1:0]         pmtrdt_res_cmp; // pmtrdt result of compare
  // Permutation operation
  // slide+gather instruction
  logic [`PMTRDT_RS_DEPTH-1:0]  rs_entry_valid;
  logic                         pmt_go, pmt_go_q; // start to execute pmt inst when all uop(s) are in RS
  logic [`UOP_INDEX_WIDTH-1:0]  pmt_uop_done_cnt_d, pmt_uop_done_cnt_q;
  logic [`VLENB-1:0][`XLEN+1:0] offset;
  logic [`VLENB-1:0][`XLEN+1:0] slide_down_offset;
  logic [`VLENB-1:0]            sel_scalar;
  BYTE_TYPE_t                   vd_type;
  logic [`VLMAX_MAX-1:0][7:0]   pmt_vs2_data, pmt_vs3_data;
  logic [`XLEN-1:0]         pmt_rs1_data;
  logic [`VLENB-1:0][7:0]   pmt_res_d, pmt_res_q;
  logic                     pmt_res_en;
  logic [`VLEN-1:0]         pmtrdt_res_pmt; // pmtrdt result of permutation
  // compress instruction
  logic [`VLENB-1:0]        compress_enable, compress_body;
  logic [`VLENB-1:0][VLENB_WIDTH:0] compress_offset;
  logic [`VLEN-1:0]         compress_mask_d, compress_mask_q; // register vs1_data for compress mask
  logic                     compress_mask_en;
  logic [VLENB_WIDTH:0]     compress_cnt_d, compress_cnt_q, compress_cnt_qq;   // compress counter
  logic [1:0][VLENB_WIDTH:0] valid_num;
  logic                     compress_cnt_ge_vlenb, compress_cnt_gt_vlenb;
  logic                     compress_cnt_en, compress_cnt_clr;
  logic [`VLENB-1:0][7:0]   compress_value;
  logic [2*`VLENB-1:0][7:0] compress_res_d, compress_res_q;
  logic [2*`VLENB-1:0]      compress_res_en;
  logic [`VLEN-1:0]         pmtrdt_res_compress; // pmtrdt result of vcompress instruction

  genvar i;
// ---code start------------------------------------------------------
// control signals based on uop
  // uop_type: permutation, reduction or compare
  always_comb begin
    case (pmtrdt_uop.uop_exe_unit)
      PMT: uop_type = PERMUTATION;
      RDT: uop_type = REDUCTION;
      default: uop_type = COMPARE;
    endcase
  end
  logic uop_type_reg_en, uop_type_reg_clr;
  assign uop_type_reg_en = pmtrdt_uop_valid & pmtrdt_uop_ready;
  assign uop_type_reg_clr = rdt_ctrl_q.compress ? !rdt_ctrl_reg_en & rdt_ctrl_q.last_uop_valid & compress_ctrl_ex1.last_uop_valid
                                                : !rdt_ctrl_reg_en & rdt_ctrl_q.last_uop_valid;
  cdffr #(.T(PMTRDT_UOP_TYPE_t)) uop_type_reg (.q(uop_type_q), .d(uop_type), .c(uop_type_reg_clr | trap_flush_rvv), .e(uop_type_reg_en), .clk(clk), .rst_n(rst_n));

  // rdt control signals
  // sign_opr: 0-unsigned, 1-signed
  always_comb begin
    case (pmtrdt_uop.uop_funct6)
      VMADC,
      VMSBC,
      VMSLTU,
      VMSLEU,
      VMSGTU,
      VREDMAXU,
      VREDMINU,
      VWREDSUMU: rdt_ctrl.sign_opr = 1'b0;
      default  : rdt_ctrl.sign_opr = 1'b1;
    endcase
  end

  // cmp_opr: great than / less than / equal / carry_out / borrow_out
  always_comb begin
    case (pmtrdt_uop.uop_funct6)
      VMSEQ: rdt_ctrl.cmp_opr = EQUAL;
      VMSNE: rdt_ctrl.cmp_opr = NOT_EQUAL;
      VMSLTU,
      VMSLT: rdt_ctrl.cmp_opr = LESS_THAN;
      VMSLEU,
      VMSLE: rdt_ctrl.cmp_opr = LESS_THAN_OR_EQUAL;
      VMSGTU,
      VMSGT: rdt_ctrl.cmp_opr = GREAT_THAN;
      VMADC: rdt_ctrl.cmp_opr = COUT;
      VMSBC: rdt_ctrl.cmp_opr = BOUT;
      default: rdt_ctrl.cmp_opr = NOT_EQUAL;
    endcase
  end

  // widen: vd EEW = 2*SEW
  assign rdt_ctrl.widen = (pmtrdt_uop.uop_funct6 == VWREDSUMU) ||
                          (pmtrdt_uop.uop_funct6 == VWREDSUM);

  // rdt_opr: reduction operation
  always_comb begin
    case (pmtrdt_uop.uop_funct6)
      VREDSUM,
      VWREDSUMU,
      VWREDSUM: rdt_ctrl.rdt_opr = SUM;
      VREDMAXU,
      VREDMAX:  rdt_ctrl.rdt_opr = MAX;
      VREDMINU,
      VREDMIN:  rdt_ctrl.rdt_opr = MIN;
      VREDAND:  rdt_ctrl.rdt_opr = AND;
      VREDOR:   rdt_ctrl.rdt_opr = OR;
      VREDXOR:  rdt_ctrl.rdt_opr = XOR;
      default:  rdt_ctrl.rdt_opr = SUM;
    endcase
  end

  assign rdt_ctrl.compress = pmtrdt_uop.uop_exe_unit == PMT && pmtrdt_uop.uop_funct6 == VCOMPRESS;

  // uop infomation
`ifdef TB_SUPPORT
  assign rdt_ctrl.uop_pc = pmtrdt_uop.uop_pc;
`endif
  assign rdt_ctrl.rob_entry = pmtrdt_uop.rob_entry;
  assign rdt_ctrl.vl     = pmtrdt_uop.vl;
  assign rdt_ctrl.vm     = pmtrdt_uop.vm;
  assign rdt_ctrl.vs1_eew        = pmtrdt_uop.vs1_eew;
  assign rdt_ctrl.v0_data        = pmtrdt_uop.v0_data;
  assign rdt_ctrl.vs3_data       = pmtrdt_uop.vs3_data;
  assign rdt_ctrl.last_uop_valid = pmtrdt_uop.last_uop_valid;

  // cmp_evl
  // prestart element: undisturbed
  // body element:
  //   active element: updated
  //   inactive element: undisturbed
  // tail element:
  //   tail element in CMP-unit: updated
  //   tail element not in CMP-unit: disturbed
  always_comb begin
    case (pmtrdt_uop.vs2_eew)
      EEW32: rdt_ctrl.cmp_evl = pmtrdt_uop.uop_index * (`VLENB/4) + (`VLENB/4);
      EEW16: rdt_ctrl.cmp_evl = pmtrdt_uop.uop_index * (`VLENB/2) + (`VLENB/2);
      default:rdt_ctrl.cmp_evl = pmtrdt_uop.uop_index * `VLENB + `VLENB;
    endcase
  end

  // when to clear rdt_ctrl reg?
  // if ex0 stage has no uop to execute!
  assign rdt_ctrl_reg_en = pmtrdt_uop_valid & pmtrdt_uop_ready;
  assign rdt_ctrl_reg_clr = rdt_ctrl_q.compress ? !rdt_ctrl_reg_en & rdt_ctrl_q.last_uop_valid & compress_ctrl_ex1.last_uop_valid
                                                : !rdt_ctrl_reg_en & rdt_ctrl_q.last_uop_valid;
  cdffr #(.T(RDT_CTRL_t)) rdt_ctrl_reg (.q(rdt_ctrl_q), .d(rdt_ctrl), .c(rdt_ctrl_reg_clr | trap_flush_rvv), .e(rdt_ctrl_reg_en), .clk(clk), .rst_n(rst_n));

  // pmt_opr: permutation operation
  always_comb begin
    case (pmtrdt_uop.uop_funct6)
      // VSLIDE1UP == VSLIDEUP_RGATHEREI16
      VSLIDE1UP: pmt_ctrl.pmt_opr = pmtrdt_uop.uop_funct3 == OPIVV ? GATHER : SLIDE_UP;
      //VSLIDEDOWN == VSLIDE1DOWN
      VSLIDE1DOWN:pmt_ctrl.pmt_opr = SLIDE_DOWN;
      VRGATHER:   pmt_ctrl.pmt_opr = GATHER;
      default:    pmt_ctrl.pmt_opr = GATHER;
    endcase
  end

  // uop infomation
`ifdef TB_SUPPORT
  assign pmt_ctrl.uop_pc    = uop_data[pmt_uop_done_cnt_q].uop_pc;
`endif
  assign pmt_ctrl.rob_entry = uop_data[pmt_uop_done_cnt_q].rob_entry;
  assign pmt_ctrl.vs3_data  = uop_data[pmt_uop_done_cnt_q].vs3_data;

  assign pmt_ctrl_reg_en    = pmt_go;
  assign pmt_ctrl_reg_clr   = !pmt_ctrl_reg_en;
  cdffr #(.T(PMT_CTRL_t)) pmt_ctrl_reg (.q(pmt_ctrl_q), .d(pmt_ctrl), .c(pmt_ctrl_reg_clr | trap_flush_rvv), .e(pmt_ctrl_reg_en), .clk(clk), .rst_n(rst_n));
  
// Reduction unit
  generate
    if (GEN_RDT == 1'b1) begin
      // logic_src1_1stage/logic_src2_1stage data for bit manipulation: and/or/xor
      for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_logic_src_bit_data
        // logic_src2_1stage data
        always_comb begin
          case (rdt_ctrl.rdt_opr)
            AND:begin
              logic_src2_1stage[4*i]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'hFF;
              logic_src2_1stage[4*i+1] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : 8'hFF;
              logic_src2_1stage[4*i+2] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'hFF;
              logic_src2_1stage[4*i+3] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : 8'hFF;
            end
            default:begin
              logic_src2_1stage[4*i]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'h00;
              logic_src2_1stage[4*i+1] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : 8'h00;
              logic_src2_1stage[4*i+2] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'h00;
              logic_src2_1stage[4*i+3] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : 8'h00;
            end
          endcase
        end

        // logic_src1_1stage data
        always_comb begin
          case (rdt_ctrl.rdt_opr)
            AND:begin
              logic_src1_1stage[4*i]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : 8'hFF;
              logic_src1_1stage[4*i+1] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : 8'hFF;
              logic_src1_1stage[4*i+2] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : 8'hFF;
              logic_src1_1stage[4*i+3] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : 8'hFF;
            end
            default:begin
              logic_src1_1stage[4*i]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : 8'h00;
              logic_src1_1stage[4*i+1] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : 8'h00;
              logic_src1_1stage[4*i+2] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : 8'h00;
              logic_src1_1stage[4*i+3] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : 8'h00;
            end
          endcase
        end
      end //for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_logic_src_bit_data

      // widen vs2 data & widen vs2 eew
      always_comb begin
        if (rdt_ctrl.widen) begin
          if (red_widen_sum_flag) begin // select high part of vs2_data
            case(pmtrdt_uop.vs2_eew)
              EEW16:begin
                for (int j=0; j<`VLENB/4; j++) begin
                  widen_vs2[16*(2*j)+:16]   = pmtrdt_uop.vs2_data[(`VLEN/2+16*j)+:16];
                  widen_vs2[16*(2*j+1)+:16] = rdt_ctrl.sign_opr ? {16{pmtrdt_uop.vs2_data[`VLEN/2+16*(j+1)-1]}}
                                                          : '0;
                  widen_vs2_type[4*j]   = pmtrdt_uop.vs2_type[`VLENB/2+2*j];
                  widen_vs2_type[4*j+1] = pmtrdt_uop.vs2_type[`VLENB/2+2*j+1];
                  widen_vs2_type[4*j+2] = pmtrdt_uop.vs2_type[`VLENB/2+2*j];
                  widen_vs2_type[4*j+3] = pmtrdt_uop.vs2_type[`VLENB/2+2*j+1];
                end
              end
              default:begin
                for (int j=0; j<`VLENB/2; j++) begin
                  widen_vs2[8*(2*j)+:8]   = pmtrdt_uop.vs2_data[(`VLEN/2+8*j)+:8];
                  widen_vs2[8*(2*j+1)+:8] = rdt_ctrl.sign_opr ? {8{pmtrdt_uop.vs2_data[`VLEN/2+8*(j+1)-1]}}
                                                        : '0;
                  widen_vs2_type[2*j]   = pmtrdt_uop.vs2_type[`VLENB/2+j];
                  widen_vs2_type[2*j+1] = pmtrdt_uop.vs2_type[`VLENB/2+j];
                end
              end
            endcase
          end else begin                // select low part of vs2_data
            case(pmtrdt_uop.vs2_eew)
              EEW16:begin
                for (int j=0; j<`VLENB/4; j++) begin
                  widen_vs2[16*(2*j)+:16]   = pmtrdt_uop.vs2_data[(16*j)+:16];
                  widen_vs2[16*(2*j+1)+:16] = rdt_ctrl.sign_opr ? {16{pmtrdt_uop.vs2_data[16*(j+1)-1]}}
                                                          : '0;
                  widen_vs2_type[4*j]   = pmtrdt_uop.vs2_type[2*j];
                  widen_vs2_type[4*j+1] = pmtrdt_uop.vs2_type[2*j+1];
                  widen_vs2_type[4*j+2] = pmtrdt_uop.vs2_type[2*j];
                  widen_vs2_type[4*j+3] = pmtrdt_uop.vs2_type[2*j+1];
                end
              end
              default:begin
                for (int j=0; j<`VLENB/2; j++) begin
                  widen_vs2[8*(2*j)+:8]   = pmtrdt_uop.vs2_data[(8*j)+:8];
                  widen_vs2[8*(2*j+1)+:8] = rdt_ctrl.sign_opr ? {8{pmtrdt_uop.vs2_data[8*(j+1)-1]}}
                                                        : '0;
                  widen_vs2_type[2*j]   = pmtrdt_uop.vs2_type[j];
                  widen_vs2_type[2*j+1] = pmtrdt_uop.vs2_type[j];
                end
              end
            endcase
          end
        end else begin
          widen_vs2      = pmtrdt_uop.vs2_data;
          widen_vs2_type = pmtrdt_uop.vs2_type;
        end
      end
  // sum_src1_1stage/sum_src2_1stage/sum_cin_1stage data
      for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_sum_src_1stage_data
        // sum_src2_1stage data
        always_comb begin
          sum_src2_1stage[4*i][7:0]   = widen_vs2_type[8*i]   == BODY_ACTIVE ? widen_vs2[8*(8*i)+:8]   : 8'h00; 
          sum_src2_1stage[4*i+1][7:0] = widen_vs2_type[8*i+1] == BODY_ACTIVE ? widen_vs2[8*(8*i+1)+:8] : 8'h00; 
          sum_src2_1stage[4*i+2][7:0] = widen_vs2_type[8*i+2] == BODY_ACTIVE ? widen_vs2[8*(8*i+2)+:8] : 8'h00; 
          sum_src2_1stage[4*i+3][7:0] = widen_vs2_type[8*i+3] == BODY_ACTIVE ? widen_vs2[8*(8*i+3)+:8] : 8'h00; 
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              sum_src2_1stage[4*i][8]   = 1'b0;
              sum_src2_1stage[4*i+1][8] = 1'b0;
              sum_src2_1stage[4*i+2][8] = 1'b0;
              sum_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              sum_src2_1stage[4*i][8]   = 1'b0;
              sum_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+1][7] : 1'b0;
              sum_src2_1stage[4*i+2][8] = 1'b0;
              sum_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+3][7] : 1'b0;
            end
            default:begin
              sum_src2_1stage[4*i][8]   = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i][7] : 1'b0;
              sum_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+1][7] : 1'b0;
              sum_src2_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+2][7] : 1'b0;
              sum_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_1stage[4*i+3][7] : 1'b0;
            end
          endcase
        end

        // sum_src1_1stage data
        always_comb begin
          sum_src1_1stage[4*i][7:0]   = widen_vs2_type[8*i+4] == BODY_ACTIVE ? widen_vs2[8*(8*i+4)+:8] : 8'h00;
          sum_src1_1stage[4*i+1][7:0] = widen_vs2_type[8*i+5] == BODY_ACTIVE ? widen_vs2[8*(8*i+5)+:8] : 8'h00;
          sum_src1_1stage[4*i+2][7:0] = widen_vs2_type[8*i+6] == BODY_ACTIVE ? widen_vs2[8*(8*i+6)+:8] : 8'h00;
          sum_src1_1stage[4*i+3][7:0] = widen_vs2_type[8*i+7] == BODY_ACTIVE ? widen_vs2[8*(8*i+7)+:8] : 8'h00;
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              sum_src1_1stage[4*i][8]   = 1'b0;
              sum_src1_1stage[4*i+1][8] = 1'b0;
              sum_src1_1stage[4*i+2][8] = 1'b0;
              sum_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              sum_src1_1stage[4*i][8]   = 1'b0;
              sum_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+1][7] : 1'b0;
              sum_src1_1stage[4*i+2][8] = 1'b0;
              sum_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+3][7] : 1'b0;
            end
            default:begin
              sum_src1_1stage[4*i][8]   = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i][7]   : 1'b0;
              sum_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+1][7] : 1'b0;
              sum_src1_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+2][7] : 1'b0;
              sum_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_1stage[4*i+3][7] : 1'b0;
            end
          endcase
        end

        // sum_cin_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              sum_cin_1stage[4*i]   = 1'b0;
              sum_cin_1stage[4*i+1] = sum_res_1stage[4*i][8];
              sum_cin_1stage[4*i+2] = sum_res_1stage[4*i+1][8];
              sum_cin_1stage[4*i+3] = sum_res_1stage[4*i+2][8];
            end
            EEW16:begin
              sum_cin_1stage[4*i]   = 1'b0;
              sum_cin_1stage[4*i+1] = sum_res_1stage[4*i][8];
              sum_cin_1stage[4*i+2] = 1'b0;
              sum_cin_1stage[4*i+3] = sum_res_1stage[4*i+2][8];
            end
            default:begin
              sum_cin_1stage[4*i]   = 1'b0; 
              sum_cin_1stage[4*i+1] = 1'b0; 
              sum_cin_1stage[4*i+2] = 1'b0; 
              sum_cin_1stage[4*i+3] = 1'b0; 
            end
          endcase
        end
      end // end for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_sum_src_1stage_data

  // max_src1_1stage/max_src2_1stage data
      for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_max_src_1stage_data
        // max_src2_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32: begin
              max_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'h00;
              max_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : 8'h00; 
              max_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'h00; 
              max_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
            end
            EEW16: begin
              max_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'h00;
              max_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
              max_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'h00; 
              max_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
            end
            default: begin
              max_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00);
              max_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
              max_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
              max_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h80 : 8'h00); 
            end
          endcase
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              max_src2_1stage[4*i][8]   = 1'b0;
              max_src2_1stage[4*i+1][8] = 1'b0;
              max_src2_1stage[4*i+2][8] = 1'b0;
              max_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              max_src2_1stage[4*i][8]   = 1'b0;
              max_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+1][7] : 1'b0;
              max_src2_1stage[4*i+2][8] = 1'b0;
              max_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+3][7] : 1'b0;
            end
            default:begin
              max_src2_1stage[4*i][8]   = rdt_ctrl.sign_opr ? max_src2_1stage[4*i][7] : 1'b0;
              max_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+1][7] : 1'b0;
              max_src2_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+2][7] : 1'b0;
              max_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_1stage[4*i+3][7] : 1'b0;
            end
          endcase
        end
        
        // max_src1_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : ~8'h00;
              max_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : ~8'h00;
              max_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : ~8'h00;
              max_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
            end
            EEW16:begin
              max_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : ~8'h00;
              max_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
              max_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : ~8'h00;
              max_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
            end
            default:begin
              max_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
              max_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
              max_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
              max_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00);
            end
          endcase
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_src1_1stage[4*i][8]   = 1'b0;
              max_src1_1stage[4*i+1][8] = 1'b0;
              max_src1_1stage[4*i+2][8] = 1'b0;
              max_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+3][7] : ~1'b0;
            end
            EEW16:begin
              max_src1_1stage[4*i][8]   = 1'b0;
              max_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+1][7] : ~1'b0;
              max_src1_1stage[4*i+2][8] = 1'b0;
              max_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+3][7] : ~1'b0;
            end
            default:begin
              max_src1_1stage[4*i][8]   = rdt_ctrl.sign_opr ? max_src1_1stage[4*i][7]   : ~1'b0;
              max_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+1][7] : ~1'b0;
              max_src1_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+2][7] : ~1'b0;
              max_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_1stage[4*i+3][7] : ~1'b0;
            end
          endcase
        end

        // max_cin_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_cin_1stage[4*i]   = 1'b1;
              max_cin_1stage[4*i+1] = max_res_1stage[4*i][8];
              max_cin_1stage[4*i+2] = max_res_1stage[4*i+1][8];
              max_cin_1stage[4*i+3] = max_res_1stage[4*i+2][8];
            end
            EEW16:begin
              max_cin_1stage[4*i]   = 1'b1; 
              max_cin_1stage[4*i+1] = max_res_1stage[4*i][8]; 
              max_cin_1stage[4*i+2] = 1'b1; 
              max_cin_1stage[4*i+3] = max_res_1stage[4*i+2][8]; 
            end
            default:begin
              max_cin_1stage[4*i]   = 1'b1;
              max_cin_1stage[4*i+1] = 1'b1;
              max_cin_1stage[4*i+2] = 1'b1;
              max_cin_1stage[4*i+3] = 1'b1;
            end
          endcase
        end
      end // end for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_max_src_1stage_data

  // min_src1_1stage/min_src2_1stage data
      for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_min_src_1stage_data
        // min_src2_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32: begin
              min_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'hFF;
              min_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : 8'hFF; 
              min_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'hFF; 
              min_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
            end
            EEW16: begin
              min_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : 8'hFF;
              min_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
              min_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : 8'hFF; 
              min_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
            end
            default: begin
              min_src2_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i]   == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i)+:8]   : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF);
              min_src2_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+1] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+1)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
              min_src2_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+2] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+2)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
              min_src2_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+3] == BODY_ACTIVE ? pmtrdt_uop.vs2_data[8*(8*i+3)+:8] : (rdt_ctrl.sign_opr ? 8'h7F : 8'hFF); 
            end
          endcase
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              min_src2_1stage[4*i][8]   = 1'b0;
              min_src2_1stage[4*i+1][8] = 1'b0;
              min_src2_1stage[4*i+2][8] = 1'b0;
              min_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              min_src2_1stage[4*i][8]   = 1'b0;
              min_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+1][7] : 1'b0;
              min_src2_1stage[4*i+2][8] = 1'b0;
              min_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+3][7] : 1'b0;
            end
            default:begin
              min_src2_1stage[4*i][8]   = rdt_ctrl.sign_opr ? min_src2_1stage[4*i][7] : 1'b0;
              min_src2_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+1][7] : 1'b0;
              min_src2_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+2][7] : 1'b0;
              min_src2_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_1stage[4*i+3][7] : 1'b0;
            end
          endcase
        end

        // min_src1_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : ~8'hFF;
              min_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : ~8'hFF;
              min_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : ~8'hFF;
              min_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
            end
            EEW16:begin
              min_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : ~8'hFF;
              min_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
              min_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : ~8'hFF;
              min_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
            end
            default:begin
              min_src1_1stage[4*i][7:0]   = pmtrdt_uop.vs2_type[8*i+4] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+4)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
              min_src1_1stage[4*i+1][7:0] = pmtrdt_uop.vs2_type[8*i+5] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+5)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
              min_src1_1stage[4*i+2][7:0] = pmtrdt_uop.vs2_type[8*i+6] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+6)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
              min_src1_1stage[4*i+3][7:0] = pmtrdt_uop.vs2_type[8*i+7] == BODY_ACTIVE ? ~pmtrdt_uop.vs2_data[8*(8*i+7)+:8] : (rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF);
            end
          endcase
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_src1_1stage[4*i][8]   = 1'b0;
              min_src1_1stage[4*i+1][8] = 1'b0;
              min_src1_1stage[4*i+2][8] = 1'b0;
              min_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+3][7] : ~1'b0;
            end
            EEW16:begin
              min_src1_1stage[4*i][8]   = 1'b0;
              min_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+1][7] : ~1'b0;
              min_src1_1stage[4*i+2][8] = 1'b0;
              min_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+3][7] : ~1'b0;
            end
            default:begin
              min_src1_1stage[4*i][8]   = rdt_ctrl.sign_opr ? min_src1_1stage[4*i][7]   : ~1'b0;
              min_src1_1stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+1][7] : ~1'b0;
              min_src1_1stage[4*i+2][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+2][7] : ~1'b0;
              min_src1_1stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_1stage[4*i+3][7] : ~1'b0;
            end
          endcase
        end

        // min_cin_1stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_cin_1stage[4*i]   = 1'b1;
              min_cin_1stage[4*i+1] = min_res_1stage[4*i][8];
              min_cin_1stage[4*i+2] = min_res_1stage[4*i+1][8];
              min_cin_1stage[4*i+3] = min_res_1stage[4*i+2][8];
            end
            EEW16:begin
              min_cin_1stage[4*i]   = 1'b1; 
              min_cin_1stage[4*i+1] = min_res_1stage[4*i][8]; 
              min_cin_1stage[4*i+2] = 1'b1; 
              min_cin_1stage[4*i+3] = min_res_1stage[4*i+2][8]; 
            end
            default:begin
              min_cin_1stage[4*i]   = 1'b1;
              min_cin_1stage[4*i+1] = 1'b1;
              min_cin_1stage[4*i+2] = 1'b1;
              min_cin_1stage[4*i+3] = 1'b1;
            end
          endcase
        end
      end // end for (i=0; i<`VLENB/(2*4); i++) begin : gen_rdt_min_src_1stage_data

      // `VLENB/2 9-bit-adder/and/or/xor for 1stage
      for (i=0; i<`VLENB/2; i++) begin : gen_rdt_arithmetic_unit_1stage
        assign sum_res_1stage[i] = sum_src2_1stage[i] + sum_src1_1stage[i] + sum_cin_1stage[i];
        assign max_res_1stage[i] = max_src2_1stage[i] + max_src1_1stage[i] + max_cin_1stage[i];
        assign min_res_1stage[i] = min_src2_1stage[i] + min_src1_1stage[i] + min_cin_1stage[i];
        assign and_1stage[i] = logic_src2_1stage[i] & logic_src1_1stage[i];
        assign or_1stage[i]  = logic_src2_1stage[i] | logic_src1_1stage[i];
        assign xor_1stage[i] = logic_src2_1stage[i] ^ logic_src1_1stage[i];
        assign less_than_1stage[i]  = min_res_1stage[i][8];
        assign great_than_1stage[i] = ~max_res_1stage[i][8];
      end

    // sum_src1_2stage/sum_src2_2stage/sum_cin_2stage data
      for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_sum_src_2stage_data
        // sum_src2_2stage data
        always_comb begin
          sum_src2_2stage[4*i][7:0]   = sum_res_1stage[4*i][7:0];
          sum_src2_2stage[4*i+1][7:0] = sum_res_1stage[4*i+1][7:0];
          sum_src2_2stage[4*i+2][7:0] = sum_res_1stage[4*i+2][7:0];
          sum_src2_2stage[4*i+3][7:0] = sum_res_1stage[4*i+3][7:0];
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              sum_src2_2stage[4*i][8]   = 1'b0;
              sum_src2_2stage[4*i+1][8] = 1'b0;
              sum_src2_2stage[4*i+2][8] = 1'b0;
              sum_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              sum_src2_2stage[4*i][8]   = 1'b0;
              sum_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+1][7] : 1'b0;
              sum_src2_2stage[4*i+2][8] = 1'b0;
              sum_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+3][7] : 1'b0;
            end
            default:begin
              sum_src2_2stage[4*i][8]   = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i][7] : 1'b0;
              sum_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+1][7] : 1'b0;
              sum_src2_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+2][7] : 1'b0;
              sum_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src2_2stage[4*i+3][7] : 1'b0;
            end
          endcase
        end
        
        //sum_src1_2stage data
        always_comb begin
          sum_src1_2stage[4*i][7:0]   = sum_res_1stage[`VLENB/4+4*i][7:0];
          sum_src1_2stage[4*i+1][7:0] = sum_res_1stage[`VLENB/4+4*i+1][7:0];
          sum_src1_2stage[4*i+2][7:0] = sum_res_1stage[`VLENB/4+4*i+2][7:0];
          sum_src1_2stage[4*i+3][7:0] = sum_res_1stage[`VLENB/4+4*i+3][7:0];
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              sum_src1_2stage[4*i][8]   = 1'b0;
              sum_src1_2stage[4*i+1][8] = 1'b0;
              sum_src1_2stage[4*i+2][8] = 1'b0;
              sum_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              sum_src1_2stage[4*i][8]   = 1'b0;
              sum_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+1][7] : 1'b0;
              sum_src1_2stage[4*i+2][8] = 1'b0;
              sum_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+3][7] : 1'b0;
            end
            default:begin
              sum_src1_2stage[4*i][8]   = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i][7] : 1'b0;
              sum_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+1][7] : 1'b0;
              sum_src1_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+2][7] : 1'b0;
              sum_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? sum_src1_2stage[4*i+3][7] : 1'b0;
            end
          endcase
        end
        
        //sum_cin_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              sum_cin_2stage[4*i]   = 1'b0;
              sum_cin_2stage[4*i+1] = sum_res_2stage[4*i][8];
              sum_cin_2stage[4*i+2] = sum_res_2stage[4*i+1][8];
              sum_cin_2stage[4*i+3] = sum_res_2stage[4*i+2][8];
            end
            EEW16:begin
              sum_cin_2stage[4*i]   = 1'b0;
              sum_cin_2stage[4*i+1] = sum_res_2stage[4*i][8];
              sum_cin_2stage[4*i+2] = 1'b0;
              sum_cin_2stage[4*i+3] = sum_res_2stage[4*i+2][8];
            end
            default:begin
              sum_cin_2stage[4*i]   = 1'b0;
              sum_cin_2stage[4*i+1] = 1'b0;
              sum_cin_2stage[4*i+2] = 1'b0;
              sum_cin_2stage[4*i+3] = 1'b0;
            end
          endcase
        end
      end //end for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_sum_src_2stage_data

    // max_src1_2stage/max_src2_2stage/max_cin_2stage data 
      for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_max_src_2stage_data
        // max_src2_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_src2_2stage[4*i][7:0]   = great_than_1stage[4*i+3] ? max_src2_1stage[4*i][7:0]   : ~max_src1_1stage[4*i][7:0];
              max_src2_2stage[4*i+1][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+1][7:0] : ~max_src1_1stage[4*i+1][7:0];
              max_src2_2stage[4*i+2][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+2][7:0] : ~max_src1_1stage[4*i+2][7:0];
              max_src2_2stage[4*i+3][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+3][7:0] : ~max_src1_1stage[4*i+3][7:0];
            end
            EEW16:begin
              max_src2_2stage[4*i][7:0]   = great_than_1stage[4*i+1] ? max_src2_1stage[4*i][7:0]   : ~max_src1_1stage[4*i][7:0];
              max_src2_2stage[4*i+1][7:0] = great_than_1stage[4*i+1] ? max_src2_1stage[4*i+1][7:0] : ~max_src1_1stage[4*i+1][7:0];
              max_src2_2stage[4*i+2][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+2][7:0] : ~max_src1_1stage[4*i+2][7:0];
              max_src2_2stage[4*i+3][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+3][7:0] : ~max_src1_1stage[4*i+3][7:0];
            end
            default:begin
              max_src2_2stage[4*i][7:0]   = great_than_1stage[4*i+0] ? max_src2_1stage[4*i][7:0]   : ~max_src1_1stage[4*i][7:0];
              max_src2_2stage[4*i+1][7:0] = great_than_1stage[4*i+1] ? max_src2_1stage[4*i+1][7:0] : ~max_src1_1stage[4*i+1][7:0];
              max_src2_2stage[4*i+2][7:0] = great_than_1stage[4*i+2] ? max_src2_1stage[4*i+2][7:0] : ~max_src1_1stage[4*i+2][7:0];
              max_src2_2stage[4*i+3][7:0] = great_than_1stage[4*i+3] ? max_src2_1stage[4*i+3][7:0] : ~max_src1_1stage[4*i+3][7:0];
            end
          endcase
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              max_src2_2stage[4*i][8]   = 1'b0;
              max_src2_2stage[4*i+1][8] = 1'b0;
              max_src2_2stage[4*i+2][8] = 1'b0;
              max_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              max_src2_2stage[4*i][8]   = 1'b0;
              max_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+1][7] : 1'b0;
              max_src2_2stage[4*i+2][8] = 1'b0;
              max_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+3][7] : 1'b0;
            end
            default:begin
              max_src2_2stage[4*i][8]   = rdt_ctrl.sign_opr ? max_src2_2stage[4*i][7] : 1'b0;
              max_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+1][7] : 1'b0;
              max_src2_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+2][7] : 1'b0;
              max_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src2_2stage[4*i+3][7] : 1'b0;
            end
          endcase
        end

        // max_src1_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_src1_2stage[4*i][7:0]   = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i][7:0]   : max_src1_1stage[`VLENB/4+4*i][7:0];
              max_src1_2stage[4*i+1][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+1][7:0] : max_src1_1stage[`VLENB/4+4*i+1][7:0];
              max_src1_2stage[4*i+2][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+2][7:0] : max_src1_1stage[`VLENB/4+4*i+2][7:0];
              max_src1_2stage[4*i+3][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+3][7:0] : max_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
            EEW16:begin
              max_src1_2stage[4*i][7:0]   = great_than_1stage[`VLENB/4+4*i+1] ? ~max_src2_1stage[`VLENB/4+4*i][7:0]   : max_src1_1stage[`VLENB/4+4*i][7:0];
              max_src1_2stage[4*i+1][7:0] = great_than_1stage[`VLENB/4+4*i+1] ? ~max_src2_1stage[`VLENB/4+4*i+1][7:0] : max_src1_1stage[`VLENB/4+4*i+1][7:0];
              max_src1_2stage[4*i+2][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+2][7:0] : max_src1_1stage[`VLENB/4+4*i+2][7:0];
              max_src1_2stage[4*i+3][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+3][7:0] : max_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
            default:begin
              max_src1_2stage[4*i][7:0]   = great_than_1stage[`VLENB/4+4*i+0] ? ~max_src2_1stage[`VLENB/4+4*i][7:0]   : max_src1_1stage[`VLENB/4+4*i][7:0];
              max_src1_2stage[4*i+1][7:0] = great_than_1stage[`VLENB/4+4*i+1] ? ~max_src2_1stage[`VLENB/4+4*i+1][7:0] : max_src1_1stage[`VLENB/4+4*i+1][7:0];
              max_src1_2stage[4*i+2][7:0] = great_than_1stage[`VLENB/4+4*i+2] ? ~max_src2_1stage[`VLENB/4+4*i+2][7:0] : max_src1_1stage[`VLENB/4+4*i+2][7:0];
              max_src1_2stage[4*i+3][7:0] = great_than_1stage[`VLENB/4+4*i+3] ? ~max_src2_1stage[`VLENB/4+4*i+3][7:0] : max_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
          endcase
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_src1_2stage[4*i][8]   = 1'b0;
              max_src1_2stage[4*i+1][8] = 1'b0;
              max_src1_2stage[4*i+2][8] = 1'b0;
              max_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+3][7] : ~1'b0;
            end
            EEW16:begin
              max_src1_2stage[4*i][8]   = 1'b0;
              max_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+1][7] : ~1'b0;
              max_src1_2stage[4*i+2][8] = 1'b0;
              max_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+3][7] : ~1'b0;
            end
            default:begin
              max_src1_2stage[4*i][8]   = rdt_ctrl.sign_opr ? max_src1_2stage[4*i][7] : ~1'b0;
              max_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+1][7] : ~1'b0;
              max_src1_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+2][7] : ~1'b0;
              max_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? max_src1_2stage[4*i+3][7] : ~1'b0;
            end
          endcase
        end

        // max_cin_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              max_cin_2stage[4*i]   = 1'b1;
              max_cin_2stage[4*i+1] = max_res_2stage[4*i][8];
              max_cin_2stage[4*i+2] = max_res_2stage[4*i+1][8];
              max_cin_2stage[4*i+3] = max_res_2stage[4*i+2][8];
            end
            EEW16:begin
              max_cin_2stage[4*i]   = 1'b1;
              max_cin_2stage[4*i+1] = max_res_2stage[4*i][8];
              max_cin_2stage[4*i+2] = 1'b1;
              max_cin_2stage[4*i+3] = max_res_2stage[4*i+2][8];
            end
            default:begin
              max_cin_2stage[4*i]   = 1'b1;
              max_cin_2stage[4*i+1] = 1'b1;
              max_cin_2stage[4*i+2] = 1'b1;
              max_cin_2stage[4*i+3] = 1'b1;
            end
          endcase
        end
      end // end for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_max_src_2stage_data

    // min_src1_2stage/min_src2_2stage/min_cin_2stage data
      for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_min_src_2stage_data
        // min_src2_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_src2_2stage[4*i][7:0]   = less_than_1stage[4*i+3] ? min_src2_1stage[4*i][7:0]   : ~min_src1_1stage[4*i][7:0];
              min_src2_2stage[4*i+1][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+1][7:0] : ~min_src1_1stage[4*i+1][7:0];
              min_src2_2stage[4*i+2][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+2][7:0] : ~min_src1_1stage[4*i+2][7:0];
              min_src2_2stage[4*i+3][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+3][7:0] : ~min_src1_1stage[4*i+3][7:0];
            end
            EEW16:begin
              min_src2_2stage[4*i][7:0]   = less_than_1stage[4*i+1] ? min_src2_1stage[4*i][7:0]   : ~min_src1_1stage[4*i][7:0];
              min_src2_2stage[4*i+1][7:0] = less_than_1stage[4*i+1] ? min_src2_1stage[4*i+1][7:0] : ~min_src1_1stage[4*i+1][7:0];
              min_src2_2stage[4*i+2][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+2][7:0] : ~min_src1_1stage[4*i+2][7:0];
              min_src2_2stage[4*i+3][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+3][7:0] : ~min_src1_1stage[4*i+3][7:0];
            end
            default:begin
              min_src2_2stage[4*i][7:0]   = less_than_1stage[4*i+0] ? min_src2_1stage[4*i][7:0]   : ~min_src1_1stage[4*i][7:0];
              min_src2_2stage[4*i+1][7:0] = less_than_1stage[4*i+1] ? min_src2_1stage[4*i+1][7:0] : ~min_src1_1stage[4*i+1][7:0];
              min_src2_2stage[4*i+2][7:0] = less_than_1stage[4*i+2] ? min_src2_1stage[4*i+2][7:0] : ~min_src1_1stage[4*i+2][7:0];
              min_src2_2stage[4*i+3][7:0] = less_than_1stage[4*i+3] ? min_src2_1stage[4*i+3][7:0] : ~min_src1_1stage[4*i+3][7:0];
            end
          endcase
          case (pmtrdt_uop.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
            EEW32:begin
              min_src2_2stage[4*i][8]   = 1'b0;
              min_src2_2stage[4*i+1][8] = 1'b0;
              min_src2_2stage[4*i+2][8] = 1'b0;
              min_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+3][7] : 1'b0;
            end
            EEW16:begin
              min_src2_2stage[4*i][8]   = 1'b0;
              min_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+1][7] : 1'b0;
              min_src2_2stage[4*i+2][8] = 1'b0;
              min_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+3][7] : 1'b0;
            end
            default:begin
              min_src2_2stage[4*i][8]   = rdt_ctrl.sign_opr ? min_src2_2stage[4*i][7] : 1'b0;
              min_src2_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+1][7] : 1'b0;
              min_src2_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+2][7] : 1'b0;
              min_src2_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src2_2stage[4*i+3][7] : 1'b0;
            end
          endcase
        end

        // min_src1_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_src1_2stage[4*i][7:0]   = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i][7:0]   : min_src1_1stage[`VLENB/4+4*i][7:0];
              min_src1_2stage[4*i+1][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+1][7:0] : min_src1_1stage[`VLENB/4+4*i+1][7:0];
              min_src1_2stage[4*i+2][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+2][7:0] : min_src1_1stage[`VLENB/4+4*i+2][7:0];
              min_src1_2stage[4*i+3][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+3][7:0] : min_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
            EEW16:begin
              min_src1_2stage[4*i][7:0]   = less_than_1stage[`VLENB/4+4*i+1] ? ~min_src2_1stage[`VLENB/4+4*i][7:0]   : min_src1_1stage[`VLENB/4+4*i][7:0];
              min_src1_2stage[4*i+1][7:0] = less_than_1stage[`VLENB/4+4*i+1] ? ~min_src2_1stage[`VLENB/4+4*i+1][7:0] : min_src1_1stage[`VLENB/4+4*i+1][7:0];
              min_src1_2stage[4*i+2][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+2][7:0] : min_src1_1stage[`VLENB/4+4*i+2][7:0];
              min_src1_2stage[4*i+3][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+3][7:0] : min_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
            default:begin
              min_src1_2stage[4*i][7:0]   = less_than_1stage[`VLENB/4+4*i+0] ? ~min_src2_1stage[`VLENB/4+4*i][7:0]   : min_src1_1stage[`VLENB/4+4*i][7:0];
              min_src1_2stage[4*i+1][7:0] = less_than_1stage[`VLENB/4+4*i+1] ? ~min_src2_1stage[`VLENB/4+4*i+1][7:0] : min_src1_1stage[`VLENB/4+4*i+1][7:0];
              min_src1_2stage[4*i+2][7:0] = less_than_1stage[`VLENB/4+4*i+2] ? ~min_src2_1stage[`VLENB/4+4*i+2][7:0] : min_src1_1stage[`VLENB/4+4*i+2][7:0];
              min_src1_2stage[4*i+3][7:0] = less_than_1stage[`VLENB/4+4*i+3] ? ~min_src2_1stage[`VLENB/4+4*i+3][7:0] : min_src1_1stage[`VLENB/4+4*i+3][7:0];
            end
          endcase
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_src1_2stage[4*i][8]   = 1'b0;
              min_src1_2stage[4*i+1][8] = 1'b0;
              min_src1_2stage[4*i+2][8] = 1'b0;
              min_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+3][7] : ~1'b0;
            end
            EEW16:begin
              min_src1_2stage[4*i][8]   = 1'b0;
              min_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+1][7] : ~1'b0;
              min_src1_2stage[4*i+2][8] = 1'b0;
              min_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+3][7] : ~1'b0;
            end
            default:begin
              min_src1_2stage[4*i][8]   = rdt_ctrl.sign_opr ? min_src1_2stage[4*i][7] : ~1'b0;
              min_src1_2stage[4*i+1][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+1][7] : ~1'b0;
              min_src1_2stage[4*i+2][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+2][7] : ~1'b0;
              min_src1_2stage[4*i+3][8] = rdt_ctrl.sign_opr ? min_src1_2stage[4*i+3][7] : ~1'b0;
            end
          endcase
        end

        // min_cin_2stage data
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              min_cin_2stage[4*i]   = 1'b1;
              min_cin_2stage[4*i+1] = min_res_2stage[4*i][8];
              min_cin_2stage[4*i+2] = min_res_2stage[4*i+1][8];
              min_cin_2stage[4*i+3] = min_res_2stage[4*i+2][8];
            end
            EEW16:begin
              min_cin_2stage[4*i]   = 1'b1;
              min_cin_2stage[4*i+1] = min_res_2stage[4*i][8];
              min_cin_2stage[4*i+2] = 1'b1;
              min_cin_2stage[4*i+3] = min_res_2stage[4*i+2][8];
            end
            default:begin
              min_cin_2stage[4*i]   = 1'b1;
              min_cin_2stage[4*i+1] = 1'b1;
              min_cin_2stage[4*i+2] = 1'b1;
              min_cin_2stage[4*i+3] = 1'b1;
            end
          endcase
        end
      end  // end for (i=0; i<`VLENB/(4*4); i++) begin : gen_rdt_min_src_2stage_data

      // `VLENB/4 9-bit-adder/and/or/xor for 2stage
      for (i=0; i<`VLENB/4; i++) begin : gen_rdt_arithmetic_unit_2stage
        assign sum_res_2stage[i] = sum_src2_2stage[i] + sum_src1_2stage[i] + sum_cin_2stage[i];
        assign max_res_2stage[i] = max_src2_2stage[i] + max_src1_2stage[i] + max_cin_2stage[i];
        assign min_res_2stage[i] = min_src2_2stage[i] + min_src1_2stage[i] + min_cin_2stage[i];
        assign less_than_2stage[i]  = min_res_2stage[i][8];
        assign great_than_2stage[i] = ~max_res_2stage[i][8];
      end
      for (i=0; i<`VLENB/(4*4); i++) begin: gen_rdt_logic_unit_2stage
        assign and_2stage[4*i]   = and_1stage[8*i]   & and_1stage[8*i+4];
        assign and_2stage[4*i+1] = and_1stage[8*i+1] & and_1stage[8*i+5];
        assign and_2stage[4*i+2] = and_1stage[8*i+2] & and_1stage[8*i+6];
        assign and_2stage[4*i+3] = and_1stage[8*i+3] & and_1stage[8*i+7];
        assign or_2stage[4*i]    = or_1stage[8*i]    | or_1stage[8*i+4];
        assign or_2stage[4*i+1]  = or_1stage[8*i+1]  | or_1stage[8*i+5];
        assign or_2stage[4*i+2]  = or_1stage[8*i+2]  | or_1stage[8*i+6];
        assign or_2stage[4*i+3]  = or_1stage[8*i+3]  | or_1stage[8*i+7];
        assign xor_2stage[4*i]   = xor_1stage[8*i]   ^ xor_1stage[8*i+4];
        assign xor_2stage[4*i+1] = xor_1stage[8*i+1] ^ xor_1stage[8*i+5];
        assign xor_2stage[4*i+2] = xor_1stage[8*i+2] ^ xor_1stage[8*i+6];
        assign xor_2stage[4*i+3] = xor_1stage[8*i+3] ^ xor_1stage[8*i+7];
      end

      // red_res_ex1 & red_vs1_ex1 operation for reduction
      // src1_vd_1stage/src2_vs1_1stage/carry_in_vd_1stage data
      // src2_vs1_1stage
      always_comb begin
        case (rdt_ctrl_q.rdt_opr)
          MAX:begin
            src2_vs1_1stage[0][7:0] = max_vs1_ex1[0][7:0];
            src2_vs1_1stage[1][7:0] = max_vs1_ex1[1][7:0];
            src2_vs1_1stage[2][7:0] = max_vs1_ex1[2][7:0];
            src2_vs1_1stage[3][7:0] = max_vs1_ex1[3][7:0];
          end
          MIN:begin
            src2_vs1_1stage[0][7:0] = min_vs1_ex1[0][7:0];
            src2_vs1_1stage[1][7:0] = min_vs1_ex1[1][7:0];
            src2_vs1_1stage[2][7:0] = min_vs1_ex1[2][7:0];
            src2_vs1_1stage[3][7:0] = min_vs1_ex1[3][7:0];
          end
          default:begin
            src2_vs1_1stage[0][7:0] = sum_vs1_ex1[0][7:0];
            src2_vs1_1stage[1][7:0] = sum_vs1_ex1[1][7:0];
            src2_vs1_1stage[2][7:0] = sum_vs1_ex1[2][7:0];
            src2_vs1_1stage[3][7:0] = sum_vs1_ex1[3][7:0];
          end
        endcase
        case (rdt_ctrl_q.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
          EEW32:begin
            src2_vs1_1stage[0][8] = 1'b0;
            src2_vs1_1stage[1][8] = 1'b0;
            src2_vs1_1stage[2][8] = 1'b0;
            src2_vs1_1stage[3][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[3][7] : 1'b0;
          end
          EEW16:begin
            src2_vs1_1stage[0][8] = 1'b0;
            src2_vs1_1stage[1][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[1][7] : 1'b0;
            src2_vs1_1stage[2][8] = 1'b0;
            src2_vs1_1stage[3][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[3][7] : 1'b0;
          end
          default:begin
            src2_vs1_1stage[0][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[0][7] : 1'b0;
            src2_vs1_1stage[1][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[1][7] : 1'b0;
            src2_vs1_1stage[2][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[2][7] : 1'b0;
            src2_vs1_1stage[3][8] = rdt_ctrl_q.sign_opr ? src2_vs1_1stage[3][7] : 1'b0;
          end
        endcase
      end

      // src1_vd_1stage data
      always_comb begin
        case (rdt_ctrl_q.rdt_opr)
          MAX:begin
            src1_vd_1stage[0][7:0] = ~max_res_ex1[0][7:0];
            src1_vd_1stage[1][7:0] = ~max_res_ex1[1][7:0];
            src1_vd_1stage[2][7:0] = ~max_res_ex1[2][7:0];
            src1_vd_1stage[3][7:0] = ~max_res_ex1[3][7:0];
          end
          MIN:begin
            src1_vd_1stage[0][7:0] = ~min_res_ex1[0][7:0];
            src1_vd_1stage[1][7:0] = ~min_res_ex1[1][7:0];
            src1_vd_1stage[2][7:0] = ~min_res_ex1[2][7:0];
            src1_vd_1stage[3][7:0] = ~min_res_ex1[3][7:0];
          end
          default:begin
            src1_vd_1stage[0][7:0] = sum_res_ex1[0][7:0];
            src1_vd_1stage[1][7:0] = sum_res_ex1[1][7:0];
            src1_vd_1stage[2][7:0] = sum_res_ex1[2][7:0];
            src1_vd_1stage[3][7:0] = sum_res_ex1[3][7:0];
          end
        endcase
        case (rdt_ctrl_q.rdt_opr)
          MAX,
          MIN:begin
            case (rdt_ctrl_q.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
              EEW32:begin
                src1_vd_1stage[0][8] = 1'b0;
                src1_vd_1stage[1][8] = 1'b0;
                src1_vd_1stage[2][8] = 1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : ~1'b0;
              end
              EEW16:begin
                src1_vd_1stage[0][8] = 1'b0;
                src1_vd_1stage[1][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[1][7] : ~1'b0;
                src1_vd_1stage[2][8] = 1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : ~1'b0;
              end
              default:begin
                src1_vd_1stage[0][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[0][7] : ~1'b0;
                src1_vd_1stage[1][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[1][7] : ~1'b0;
                src1_vd_1stage[2][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[2][7] : ~1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : ~1'b0;
              end
            endcase
          end
          default:begin
            case (rdt_ctrl_q.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
              EEW32:begin
                src1_vd_1stage[0][8] = 1'b0;
                src1_vd_1stage[1][8] = 1'b0;
                src1_vd_1stage[2][8] = 1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : 1'b0;
              end
              EEW16:begin
                src1_vd_1stage[0][8] = 1'b0;
                src1_vd_1stage[1][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[1][7] : 1'b0;
                src1_vd_1stage[2][8] = 1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : 1'b0;
              end
              default:begin
                src1_vd_1stage[0][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[0][7] : 1'b0;
                src1_vd_1stage[1][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[1][7] : 1'b0;
                src1_vd_1stage[2][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[2][7] : 1'b0;
                src1_vd_1stage[3][8] = rdt_ctrl_q.sign_opr ? src1_vd_1stage[3][7] : 1'b0;
              end
            endcase
          end
        endcase
      end

      // carry_in_vd_1stage data
      always_comb begin
        case (rdt_ctrl_q.rdt_opr)
          MAX,
          MIN:begin
            case (rdt_ctrl_q.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
              EEW32:begin
                carry_in_vd_1stage[0] = 1'b1;
                carry_in_vd_1stage[1] = sum_vd_1stage[0][8];
                carry_in_vd_1stage[2] = sum_vd_1stage[1][8];
                carry_in_vd_1stage[3] = sum_vd_1stage[2][8];
              end
              EEW16:begin
                carry_in_vd_1stage[0] = 1'b1;
                carry_in_vd_1stage[1] = sum_vd_1stage[0][8];
                carry_in_vd_1stage[2] = 1'b1;
                carry_in_vd_1stage[3] = sum_vd_1stage[2][8];
              end
              default:begin
                carry_in_vd_1stage[0] = 1'b1;
                carry_in_vd_1stage[1] = 1'b1;
                carry_in_vd_1stage[2] = 1'b1;
                carry_in_vd_1stage[3] = 1'b1;
              end
            endcase
          end
          default:begin
            case (rdt_ctrl_q.vs1_eew) // Reduction instruction: widen_vs2_eew == vs1_eew
              EEW32:begin
                carry_in_vd_1stage[0] = 1'b0;
                carry_in_vd_1stage[1] = sum_vd_1stage[0][8];
                carry_in_vd_1stage[2] = sum_vd_1stage[1][8];
                carry_in_vd_1stage[3] = sum_vd_1stage[2][8];
              end
              EEW16:begin
                carry_in_vd_1stage[0] = 1'b0;
                carry_in_vd_1stage[1] = sum_vd_1stage[0][8];
                carry_in_vd_1stage[2] = 1'b0;
                carry_in_vd_1stage[3] = sum_vd_1stage[2][8];
              end
              default:begin
                carry_in_vd_1stage[0] = 1'b0;
                carry_in_vd_1stage[1] = 1'b0;
                carry_in_vd_1stage[2] = 1'b0;
                carry_in_vd_1stage[3] = 1'b0;
              end
            endcase
          end
        endcase
      end

      // four 9-bit adder/and/or/xor for red_res_q & red_vs1_q
      for (i=0; i<4; i++) begin : gen_rdt_arithmetic_unit_vs1vd_1stage
        assign sum_vd_1stage[i] = src2_vs1_1stage[i] + src1_vd_1stage[i] + carry_in_vd_1stage[i];
        assign and_vd_1stage[i] = and_vs1_ex1[i] & and_res_ex1[i];
        assign or_vd_1stage[i]  = or_vs1_ex1[i]  | or_res_ex1[i];
        assign xor_vd_1stage[i] = xor_vs1_ex1[i] ^ xor_res_ex1[i];
        assign less_than_vd_1stage[i]  = sum_vd_1stage[i][8];
        assign great_than_vd_1stage[i] = ~sum_vd_1stage[i][8];
      end

      // VS1[0] & res_vd_1stage[0] operation for reduction
      // src1_vd_2stage/src2_vs1_2stage/carry_in_vd_2stage data
      // src2_vs1_2stage
      assign sel_vs1 = rdt_ctrl.last_uop_valid && !rdt_ctrl.widen ||
                       rdt_ctrl.last_uop_valid && rdt_ctrl.widen && red_widen_sum_flag;
      always_comb begin
        if (sel_vs1) begin
          case (pmtrdt_uop.vs1_eew)
            EEW32: begin
              src2_vs1_2stage[0][7:0] = pmtrdt_uop.vs1_data[8*0+:8];
              src2_vs1_2stage[1][7:0] = pmtrdt_uop.vs1_data[8*1+:8];
              src2_vs1_2stage[2][7:0] = pmtrdt_uop.vs1_data[8*2+:8];
              src2_vs1_2stage[3][7:0] = pmtrdt_uop.vs1_data[8*3+:8];
              src2_vs1_2stage[0][8]   = 1'b0;
              src2_vs1_2stage[1][8]   = 1'b0;
              src2_vs1_2stage[2][8]   = 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
            EEW16: begin
              src2_vs1_2stage[0][7:0] = pmtrdt_uop.vs1_data[8*0+:8];
              src2_vs1_2stage[1][7:0] = pmtrdt_uop.vs1_data[8*1+:8];
              case (rdt_ctrl.rdt_opr)
                MAX:begin
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                end
                MIN:begin
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                end
                AND:begin
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = 8'hFF;
                end
                default:begin
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = 8'h00;
                end
              endcase
              src2_vs1_2stage[0][8]   = 1'b0;
              src2_vs1_2stage[1][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[1][7] : 1'b0;
              src2_vs1_2stage[2][8]   = 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
            default: begin
              src2_vs1_2stage[0][7:0] = pmtrdt_uop.vs1_data[0+:8];
              case (rdt_ctrl.rdt_opr)
                MAX:begin
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[2][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                end
                MIN:begin
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[2][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                end
                AND:begin
                  src2_vs1_2stage[1][7:0] = 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = 8'hFF;
                end
                default:begin
                  src2_vs1_2stage[1][7:0] = 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = 8'h00;
                end
              endcase
              src2_vs1_2stage[0][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[0][7] : 1'b0;
              src2_vs1_2stage[1][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[1][7] : 1'b0;
              src2_vs1_2stage[2][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[2][7] : 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
          endcase
        end else begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:begin
              case (rdt_ctrl.rdt_opr)
                MAX:begin
                  src2_vs1_2stage[0][7:0] = 8'h00;
                  src2_vs1_2stage[1][7:0] = 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                end
                MIN:begin
                  src2_vs1_2stage[0][7:0] = 8'hFF;
                  src2_vs1_2stage[1][7:0] = 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                end
                AND:begin
                  src2_vs1_2stage[0][7:0] = 8'hFF;
                  src2_vs1_2stage[1][7:0] = 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = 8'hFF;
                end
                default:begin
                  src2_vs1_2stage[0][7:0] = 8'h00;
                  src2_vs1_2stage[1][7:0] = 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = 8'h00;
                end
              endcase
              src2_vs1_2stage[0][8]   = 1'b0;
              src2_vs1_2stage[1][8]   = 1'b0;
              src2_vs1_2stage[2][8]   = 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
            EEW16:begin
              case (rdt_ctrl.rdt_opr)
                MAX:begin
                  src2_vs1_2stage[0][7:0] = 8'h00;
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                end
                MIN:begin
                  src2_vs1_2stage[0][7:0] = 8'hFF;
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                end
                AND:begin
                  src2_vs1_2stage[0][7:0] = 8'hFF;
                  src2_vs1_2stage[1][7:0] = 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = 8'hFF;
                end
                default:begin
                  src2_vs1_2stage[0][7:0] = 8'h00;
                  src2_vs1_2stage[1][7:0] = 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = 8'h00;
                end
              endcase
              src2_vs1_2stage[0][8]   = 1'b0;
              src2_vs1_2stage[1][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[1][7] : 1'b0;
              src2_vs1_2stage[2][8]   = 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
            default:begin
              case (rdt_ctrl.rdt_opr)
                MAX:begin
                  src2_vs1_2stage[0][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[2][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h80 : 8'h00;
                end
                MIN:begin
                  src2_vs1_2stage[0][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[1][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[2][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                  src2_vs1_2stage[3][7:0] = rdt_ctrl.sign_opr ? 8'h7F : 8'hFF;
                end
                AND:begin
                  src2_vs1_2stage[0][7:0] = 8'hFF;
                  src2_vs1_2stage[1][7:0] = 8'hFF;
                  src2_vs1_2stage[2][7:0] = 8'hFF;
                  src2_vs1_2stage[3][7:0] = 8'hFF;
                end
                default:begin
                  src2_vs1_2stage[0][7:0] = 8'h00;
                  src2_vs1_2stage[1][7:0] = 8'h00;
                  src2_vs1_2stage[2][7:0] = 8'h00;
                  src2_vs1_2stage[3][7:0] = 8'h00;
                end
              endcase
              src2_vs1_2stage[0][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[0][7] : 1'b0;
              src2_vs1_2stage[1][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[1][7] : 1'b0;
              src2_vs1_2stage[2][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[2][7] : 1'b0;
              src2_vs1_2stage[3][8]   = rdt_ctrl.sign_opr ? src2_vs1_2stage[3][7] : 1'b0;
            end
          endcase
        end
      end

      // src1_vd_2stage data
      always_comb begin
        if (pmtrdt_uop.first_uop_valid && !red_widen_sum_flag) begin
          case (rdt_ctrl.rdt_opr)
            MAX:begin
              case (pmtrdt_uop.vs1_eew)
                EEW32:begin
                  src1_vd_2stage[0][7:0] = ~8'h00;
                  src1_vd_2stage[1][7:0] = ~8'h00;
                  src1_vd_2stage[2][7:0] = ~8'h00;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                end
                EEW16:begin
                  src1_vd_2stage[0][7:0] = ~8'h00;
                  src1_vd_2stage[1][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                  src1_vd_2stage[2][7:0] = ~8'h00;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                end
                default:begin
                  src1_vd_2stage[0][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                  src1_vd_2stage[1][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                  src1_vd_2stage[2][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h80 : ~8'h00;
                end
              endcase
            end
            MIN:begin
              case (pmtrdt_uop.vs1_eew)
                EEW32:begin
                  src1_vd_2stage[0][7:0] = ~8'hFF;
                  src1_vd_2stage[1][7:0] = ~8'hFF;
                  src1_vd_2stage[2][7:0] = ~8'hFF;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                end
                EEW16:begin
                  src1_vd_2stage[0][7:0] = ~8'hFF;
                  src1_vd_2stage[1][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                  src1_vd_2stage[2][7:0] = ~8'hFF;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                end
                default:begin
                  src1_vd_2stage[0][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                  src1_vd_2stage[1][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                  src1_vd_2stage[2][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                  src1_vd_2stage[3][7:0] = rdt_ctrl.sign_opr ? ~8'h7F : ~8'hFF;
                end
              endcase
            end
            AND:begin
              src1_vd_2stage[0][7:0] = 8'hFF;
              src1_vd_2stage[1][7:0] = 8'hFF;
              src1_vd_2stage[2][7:0] = 8'hFF;
              src1_vd_2stage[3][7:0] = 8'hFF;
            end
            default:begin
              src1_vd_2stage[0][7:0] = 8'h00;
              src1_vd_2stage[1][7:0] = 8'h00;
              src1_vd_2stage[2][7:0] = 8'h00;
              src1_vd_2stage[3][7:0] = 8'h00;
            end
          endcase
        end else begin
          case (rdt_ctrl.rdt_opr)
            MAX:begin
              case (pmtrdt_uop.vs1_eew)
                EEW32:begin
                  src1_vd_2stage[0][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
                EEW16:begin
                  src1_vd_2stage[0][7:0] = great_than_vd_1stage[1] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = great_than_vd_1stage[1] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
                default:begin
                  src1_vd_2stage[0][7:0] = great_than_vd_1stage[0] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = great_than_vd_1stage[1] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = great_than_vd_1stage[2] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = great_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
              endcase
            end
            MIN:begin
              case (pmtrdt_uop.vs1_eew)
                EEW32:begin
                  src1_vd_2stage[0][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
                EEW16:begin
                  src1_vd_2stage[0][7:0] = less_than_vd_1stage[1] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = less_than_vd_1stage[1] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
                default:begin
                  src1_vd_2stage[0][7:0] = less_than_vd_1stage[0] ? ~src2_vs1_1stage[0][7:0] : src1_vd_1stage[0][7:0];
                  src1_vd_2stage[1][7:0] = less_than_vd_1stage[1] ? ~src2_vs1_1stage[1][7:0] : src1_vd_1stage[1][7:0];
                  src1_vd_2stage[2][7:0] = less_than_vd_1stage[2] ? ~src2_vs1_1stage[2][7:0] : src1_vd_1stage[2][7:0];
                  src1_vd_2stage[3][7:0] = less_than_vd_1stage[3] ? ~src2_vs1_1stage[3][7:0] : src1_vd_1stage[3][7:0];
                end
              endcase
            end
            AND:begin
              src1_vd_2stage[0][7:0] = and_vd_1stage[0][7:0];
              src1_vd_2stage[1][7:0] = and_vd_1stage[1][7:0];
              src1_vd_2stage[2][7:0] = and_vd_1stage[2][7:0];
              src1_vd_2stage[3][7:0] = and_vd_1stage[3][7:0];
            end
            OR:begin
              src1_vd_2stage[0][7:0] = or_vd_1stage[0][7:0];
              src1_vd_2stage[1][7:0] = or_vd_1stage[1][7:0];
              src1_vd_2stage[2][7:0] = or_vd_1stage[2][7:0];
              src1_vd_2stage[3][7:0] = or_vd_1stage[3][7:0];
            end
            XOR:begin
              src1_vd_2stage[0][7:0] = xor_vd_1stage[0][7:0];
              src1_vd_2stage[1][7:0] = xor_vd_1stage[1][7:0];
              src1_vd_2stage[2][7:0] = xor_vd_1stage[2][7:0];
              src1_vd_2stage[3][7:0] = xor_vd_1stage[3][7:0];
            end
            default:begin
              src1_vd_2stage[0][7:0] = sum_vd_1stage[0][7:0];
              src1_vd_2stage[1][7:0] = sum_vd_1stage[1][7:0];
              src1_vd_2stage[2][7:0] = sum_vd_1stage[2][7:0];
              src1_vd_2stage[3][7:0] = sum_vd_1stage[3][7:0];
            end
          endcase
        end
        case (rdt_ctrl.rdt_opr)
          MAX,
          MIN:begin
            case (pmtrdt_uop.vs1_eew)
              EEW32:begin
                src1_vd_2stage[0][8] = 1'b0;
                src1_vd_2stage[1][8] = 1'b0;
                src1_vd_2stage[2][8] = 1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : ~1'b0;
              end
              EEW16:begin
                src1_vd_2stage[0][8] = 1'b0;
                src1_vd_2stage[1][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[1][7] : ~1'b0;
                src1_vd_2stage[2][8] = 1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : ~1'b0;
              end
              default:begin
                src1_vd_2stage[0][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[0][7] : ~1'b0;
                src1_vd_2stage[1][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[1][7] : ~1'b0;
                src1_vd_2stage[2][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[2][7] : ~1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : ~1'b0;
              end
            endcase
          end
          default:begin
            case (pmtrdt_uop.vs1_eew)
              EEW32:begin
                src1_vd_2stage[0][8] = 1'b0;
                src1_vd_2stage[1][8] = 1'b0;
                src1_vd_2stage[2][8] = 1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : 1'b0;
              end
              EEW16:begin
                src1_vd_2stage[0][8] = 1'b0;
                src1_vd_2stage[1][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[1][7] : 1'b0;
                src1_vd_2stage[2][8] = 1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : 1'b0;
              end
              default:begin
                src1_vd_2stage[0][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[0][7] : 1'b0;
                src1_vd_2stage[1][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[1][7] : 1'b0;
                src1_vd_2stage[2][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[2][7] : 1'b0;
                src1_vd_2stage[3][8] = rdt_ctrl.sign_opr ? src1_vd_2stage[3][7] : 1'b0;
              end
            endcase
          end
        endcase
      end

      // carry_in_vd_2stage data
      always_comb begin
        case (rdt_ctrl.rdt_opr)
          MAX,
          MIN:begin
            case (pmtrdt_uop.vs1_eew)
              EEW32:begin
                carry_in_vd_2stage[0] = 1'b1;
                carry_in_vd_2stage[1] = sum_vd_2stage[0][8];
                carry_in_vd_2stage[2] = sum_vd_2stage[1][8];
                carry_in_vd_2stage[3] = sum_vd_2stage[2][8];
              end
              EEW16:begin
                carry_in_vd_2stage[0] = 1'b1;
                carry_in_vd_2stage[1] = sum_vd_2stage[0][8];
                carry_in_vd_2stage[2] = 1'b1;
                carry_in_vd_2stage[3] = sum_vd_2stage[2][8];
              end
              default:begin
                carry_in_vd_2stage[0] = 1'b1;
                carry_in_vd_2stage[1] = 1'b1;
                carry_in_vd_2stage[2] = 1'b1;
                carry_in_vd_2stage[3] = 1'b1;
              end
            endcase
          end
          default:begin
            case (pmtrdt_uop.vs1_eew)
              EEW32:begin
                carry_in_vd_2stage[0] = 1'b0;
                carry_in_vd_2stage[1] = sum_vd_2stage[0][8];
                carry_in_vd_2stage[2] = sum_vd_2stage[1][8];
                carry_in_vd_2stage[3] = sum_vd_2stage[2][8];
              end
              EEW16:begin
                carry_in_vd_2stage[0] = 1'b0;
                carry_in_vd_2stage[1] = sum_vd_2stage[0][8];
                carry_in_vd_2stage[2] = 1'b0;
                carry_in_vd_2stage[3] = sum_vd_2stage[2][8];
              end
              default:begin
                carry_in_vd_2stage[0] = 1'b0;
                carry_in_vd_2stage[1] = 1'b0;
                carry_in_vd_2stage[2] = 1'b0;
                carry_in_vd_2stage[3] = 1'b0;
              end
            endcase
          end
        endcase
      end

      // four 9-bit-adder/and/or/xor for vs1[0] & vd[0]
      for (i=0; i<4; i++) begin : gen_rdt_arithmetic_unit_vs1vd_2stage
        assign sum_vd_2stage[i] = src2_vs1_2stage[i] + src1_vd_2stage[i] + carry_in_vd_2stage[i];
        assign and_vd_2stage[i] = src2_vs1_2stage[i][7:0] & src1_vd_2stage[i][7:0];
        assign or_vd_2stage[i]  = src2_vs1_2stage[i][7:0] | src1_vd_2stage[i][7:0];
        assign xor_vd_2stage[i] = src2_vs1_2stage[i][7:0] ^ src1_vd_2stage[i][7:0];
        assign less_than_vd_2stage[i]  = sum_vd_2stage[i][8];
        assign great_than_vd_2stage[i] = ~sum_vd_2stage[i][8];
      end
      assign red_res_en = pmtrdt_uop_valid & (pmtrdt_uop_ready | !red_widen_sum_flag);

      for (i=0; i<`VLENB/4; i++) begin : gen_reduction_result
        // max_res_ex0/min_res_ex0 based on vs1_eew
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:   max_res_ex0[i] = great_than_2stage[4*(i/4)+3] ? max_src2_2stage[i][7:0] : ~max_src1_2stage[i][7:0];
            EEW16:   max_res_ex0[i] = great_than_2stage[2*(i/2)+1] ? max_src2_2stage[i][7:0] : ~max_src1_2stage[i][7:0];
            default: max_res_ex0[i] = great_than_2stage[i]         ? max_src2_2stage[i][7:0] : ~max_src1_2stage[i][7:0];
          endcase
        end
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:   min_res_ex0[i] = less_than_2stage[4*(i/4)+3] ? min_src2_2stage[i][7:0] : ~min_src1_2stage[i][7:0];
            EEW16:   min_res_ex0[i] = less_than_2stage[2*(i/2)+1] ? min_src2_2stage[i][7:0] : ~min_src1_2stage[i][7:0];
            default: min_res_ex0[i] = less_than_2stage[i]         ? min_src2_2stage[i][7:0] : ~min_src1_2stage[i][7:0];
          endcase
        end

        edff #(.T(logic[7:0])) sum_res_reg (.q(sum_res_ex1[i]), .d(sum_res_2stage[i][7:0]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) max_res_reg (.q(max_res_ex1[i]), .d(max_res_ex0[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) min_res_reg (.q(min_res_ex1[i]), .d(min_res_ex0[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) and_res_reg (.q(and_res_ex1[i]), .d(and_2stage[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) or_res_reg  (.q(or_res_ex1[i]),  .d(or_2stage[i]),  .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) xor_res_reg (.q(xor_res_ex1[i]), .d(xor_2stage[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));

        // max_vs1_ex0/min_vs1_ex0 based on vs1_eew
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:   max_vs1_ex0[i] = great_than_vd_2stage[4*(i/4)+3] ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
            EEW16:   max_vs1_ex0[i] = great_than_vd_2stage[2*(i/2)+1] ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
            default: max_vs1_ex0[i] = great_than_vd_2stage[i]         ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
          endcase
        end
        always_comb begin
          case (pmtrdt_uop.vs1_eew)
            EEW32:   min_vs1_ex0[i] = less_than_vd_2stage[4*(i/4)+3] ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
            EEW16:   min_vs1_ex0[i] = less_than_vd_2stage[2*(i/2)+1] ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
            default: min_vs1_ex0[i] = less_than_vd_2stage[i]         ? src2_vs1_2stage[i][7:0] : ~src1_vd_2stage[i][7:0];
          endcase
        end

        edff #(.T(logic[7:0])) sum_vs1_reg (.q(sum_vs1_ex1[i]), .d(sum_vd_2stage[i][7:0]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) max_vs1_reg (.q(max_vs1_ex1[i]), .d(max_vs1_ex0[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) min_vs1_reg (.q(min_vs1_ex1[i]), .d(min_vs1_ex0[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) and_vs1_reg (.q(and_vs1_ex1[i]), .d(and_vd_2stage[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) or_vs1_reg  (.q(or_vs1_ex1[i]),  .d(or_vd_2stage[i]),  .e(red_res_en), .clk(clk), .rst_n(rst_n));
        edff #(.T(logic[7:0])) xor_vs1_reg (.q(xor_vs1_ex1[i]), .d(xor_vd_2stage[i]), .e(red_res_en), .clk(clk), .rst_n(rst_n));
      end

      // reduction result when vd_eew is 32b
      for (i=0; i<4; i++) begin
        assign sum_32b[8*i+:8] = sum_vd_1stage[i][7:0];
        assign max_32b[8*i+:8] = great_than_vd_1stage[3] ? src2_vs1_1stage[i][7:0] : ~src1_vd_1stage[i][7:0];
        assign min_32b[8*i+:8] = less_than_vd_1stage[3] ? src2_vs1_1stage[i][7:0] : ~src1_vd_1stage[i][7:0];
        assign and_32b[8*i+:8] = and_vd_1stage[i];
        assign or_32b[8*i+:8]  = or_vd_1stage[i];
        assign xor_32b[8*i+:8] = xor_vd_1stage[i];
      end
     
      // reduction result when vd_eew is 16b
      assign sum_16b = sum_32b[31:16] + sum_32b[15:0];
      for (i=0; i<2; i++) begin
        assign max_16b_1stage[i][7:0]  = great_than_vd_1stage[2*i+1] ? src2_vs1_1stage[2*i][7:0] : ~src1_vd_1stage[2*i][7:0];
        assign max_16b_1stage[i][15:8] = great_than_vd_1stage[2*i+1] ? src2_vs1_1stage[2*i+1][7:0] : ~src1_vd_1stage[2*i+1][7:0];
        assign min_16b_1stage[i][7:0]  = less_than_vd_1stage[2*i+1] ? src2_vs1_1stage[2*i][7:0] : ~src1_vd_1stage[2*i][7:0];
        assign min_16b_1stage[i][15:8] = less_than_vd_1stage[2*i+1] ? src2_vs1_1stage[2*i+1][7:0] : ~src1_vd_1stage[2*i+1][7:0];
      end
      assign and_16b = and_32b[31:16] & and_32b[15:0];
      assign or_16b  = or_32b[31:16]  | or_32b[15:0]; 
      assign xor_16b = xor_32b[31:16] ^ xor_32b[15:0];
      always_comb begin
        if (rdt_ctrl_q.sign_opr) begin
          max_16b = $signed(max_16b_1stage[0]) > $signed(max_16b_1stage[1]) 
                    ? max_16b_1stage[0] : max_16b_1stage[1]; 
          min_16b = $signed(min_16b_1stage[0]) < $signed(min_16b_1stage[1]) 
                    ? min_16b_1stage[0] : min_16b_1stage[1]; 
        end else begin
          max_16b = max_16b_1stage[0] > max_16b_1stage[1]
                    ? max_16b_1stage[0] : max_16b_1stage[1]; 
          min_16b = min_16b_1stage[0] < min_16b_1stage[1]
                    ? min_16b_1stage[0] : min_16b_1stage[1]; 
        end
      end

      // reduction result when vd_eew is 8b
      assign sum_8b = sum_32b[31:24] + sum_32b[23:16] + sum_32b[15:8] + sum_32b[7:0];
      for (i=0; i<4; i++) begin
        assign max_8b_1stage[i] = great_than_vd_1stage[i] ? src2_vs1_1stage[i][7:0] : ~src1_vd_1stage[i][7:0];
        assign min_8b_1stage[i] = less_than_vd_1stage[i] ? src2_vs1_1stage[i][7:0] : ~src1_vd_1stage[i][7:0];
      end
      assign and_8b = and_16b[15:8] & and_16b[7:0];
      assign or_8b  = or_16b[15:8]  | or_16b[7:0]; 
      assign xor_8b = xor_16b[15:8] ^ xor_16b[7:0];
      always_comb begin
        if (rdt_ctrl_q.sign_opr) begin
          max_8b = 8'h80;
          min_8b = 8'h7F;
        end else begin
          max_8b = 8'h00;
          min_8b = 8'hFF;
        end
        for (int j=0; j<4; j++) begin
          if (rdt_ctrl_q.sign_opr) begin
            max_8b = $signed(max_8b) > $signed(max_8b_1stage[j]) 
                      ? max_8b : max_8b_1stage[j]; 
            min_8b = $signed(min_8b) < $signed(min_8b_1stage[j]) 
                      ? min_8b : min_8b_1stage[j]; 
          end else begin
            max_8b = max_8b > max_8b_1stage[j]
                      ? max_8b : max_8b_1stage[j]; 
            min_8b = min_8b < min_8b_1stage[j]
                      ? min_8b : min_8b_1stage[j]; 
          end
        end
      end

      //pmtrdt_res_red data
      always_comb begin
        case (rdt_ctrl_q.vs1_eew)
          EEW32:begin
            case (rdt_ctrl_q.rdt_opr)
              SUM: pmtrdt_res_red = {{(`VLEN-32){1'b0}},sum_32b};
              MAX: pmtrdt_res_red = {{(`VLEN-32){1'b0}},max_32b};
              MIN: pmtrdt_res_red = {{(`VLEN-32){1'b0}},min_32b};
              AND: pmtrdt_res_red = {{(`VLEN-32){1'b0}},and_32b};
              OR:  pmtrdt_res_red = {{(`VLEN-32){1'b0}},or_32b};
              XOR: pmtrdt_res_red = {{(`VLEN-32){1'b0}},xor_32b};
              default: pmtrdt_res_red = '0;
            endcase
          end
          EEW16:begin
            case (rdt_ctrl_q.rdt_opr)
              SUM: pmtrdt_res_red = {{(`VLEN-16){1'b0}},sum_16b};
              MAX: pmtrdt_res_red = {{(`VLEN-16){1'b0}},max_16b};
              MIN: pmtrdt_res_red = {{(`VLEN-16){1'b0}},min_16b};
              AND: pmtrdt_res_red = {{(`VLEN-16){1'b0}},and_16b};
              OR:  pmtrdt_res_red = {{(`VLEN-16){1'b0}},or_16b};
              XOR: pmtrdt_res_red = {{(`VLEN-16){1'b0}},xor_16b};
              default: pmtrdt_res_red = '0;
            endcase
          end
          default:begin
            case (rdt_ctrl_q.rdt_opr)
              SUM: pmtrdt_res_red = {{(`VLEN-8){1'b0}},sum_8b};
              MAX: pmtrdt_res_red = {{(`VLEN-8){1'b0}},max_8b};
              MIN: pmtrdt_res_red = {{(`VLEN-8){1'b0}},min_8b};
              AND: pmtrdt_res_red = {{(`VLEN-8){1'b0}},and_8b};
              OR:  pmtrdt_res_red = {{(`VLEN-8){1'b0}},or_8b};
              XOR: pmtrdt_res_red = {{(`VLEN-8){1'b0}},xor_8b};
              default: pmtrdt_res_red = '0;
            endcase
          end
        endcase
      end
    end // end if (GEN_RDT == 1'b1)
  endgenerate

  // Compare unit
  generate
    if (GEN_CMP == 1'b1) begin
      // cin_data/bin_data
      always_comb begin
        case (pmtrdt_uop.vs2_eew) // vmadc/vmsbc inst: vd_eew == vs2_eew
          EEW32: in_data = {pmtrdt_uop.v0_data >> (pmtrdt_uop.uop_index*`VLENB/4)}; 
          EEW16: in_data = {pmtrdt_uop.v0_data >> (pmtrdt_uop.uop_index*`VLENB/2)};
          default: in_data = {pmtrdt_uop.v0_data >> (pmtrdt_uop.uop_index*`VLENB)};
        endcase
      end

      for (i=0; i<`VLENB/4; i++) begin
        always_comb begin
          case (pmtrdt_uop.vs2_eew) // vmadc/vmsbc inst: vd_eew == vs2_eew
            EEW32:begin
              cin_data[4*i]   = in_data[i]; 
              cin_data[4*i+1] = in_data[i]; 
              cin_data[4*i+2] = in_data[i]; 
              cin_data[4*i+3] = in_data[i]; 
            end
            EEW16:begin
              cin_data[4*i]   = in_data[2*i]; 
              cin_data[4*i+1] = in_data[2*i]; 
              cin_data[4*i+2] = in_data[2*i+1]; 
              cin_data[4*i+3] = in_data[2*i+1]; 
            end
            default:begin
              cin_data[4*i]   = in_data[4*i]; 
              cin_data[4*i+1] = in_data[4*i+1]; 
              cin_data[4*i+2] = in_data[4*i+2]; 
              cin_data[4*i+3] = in_data[4*i+3]; 
            end
          endcase
        end
      end
      assign bin_data = ~cin_data;

      // cmp_src1/cmp_src2/cmp_carry_in data
      for (i=0; i<`VLENB/4; i++) begin : gen_cmp_src_data
        // cmp_src2 data
        always_comb begin
          cmp_src2[4*i][7:0]   = pmtrdt_uop.vs2_data[8*(4*i)+:8]; 
          cmp_src2[4*i+1][7:0] = pmtrdt_uop.vs2_data[8*(4*i+1)+:8]; 
          cmp_src2[4*i+2][7:0] = pmtrdt_uop.vs2_data[8*(4*i+2)+:8]; 
          cmp_src2[4*i+3][7:0] = pmtrdt_uop.vs2_data[8*(4*i+3)+:8]; 
          case (pmtrdt_uop.vs2_eew)
            EEW32:begin
              cmp_src2[4*i][8]   = 1'b0;
              cmp_src2[4*i+1][8] = 1'b0;
              cmp_src2[4*i+2][8] = 1'b0;
              cmp_src2[4*i+3][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+3)+7] : 1'b0;
            end
            EEW16:begin
              cmp_src2[4*i][8]   = 1'b0;
              cmp_src2[4*i+1][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+1)+7] : 1'b0;
              cmp_src2[4*i+2][8] = 1'b0;
              cmp_src2[4*i+3][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+3)+7] : 1'b0;
            end
            default:begin
              cmp_src2[4*i][8]   = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i)+7] : 1'b0;
              cmp_src2[4*i+1][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+1)+7] : 1'b0;
              cmp_src2[4*i+2][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+2)+7] : 1'b0;
              cmp_src2[4*i+3][8] = rdt_ctrl.sign_opr ? pmtrdt_uop.vs2_data[8*(4*i+3)+7] : 1'b0;
            end
          endcase
        end

        // cmp_src1 data
        always_comb begin
          case (pmtrdt_uop.uop_funct3)
            OPIVX,
            OPIVI:begin
              case (pmtrdt_uop.vs2_eew)
                EEW32:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][7:0]   = pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+1][7:0] = pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i+2][7:0] = pmtrdt_uop.rs1_data[8*2+:8];
                      cmp_src1[4*i+3][7:0] = pmtrdt_uop.rs1_data[8*3+:8];
                      cmp_src1[4*i][8]     = 1'b0;
                      cmp_src1[4*i+1][8]   = 1'b0;
                      cmp_src1[4*i+2][8]   = 1'b0;
                      cmp_src1[4*i+3][8]   = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][7:0]   = ~pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+1][7:0] = ~pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i+2][7:0] = ~pmtrdt_uop.rs1_data[8*2+:8];
                      cmp_src1[4*i+3][7:0] = ~pmtrdt_uop.rs1_data[8*3+:8];
                      cmp_src1[4*i][8]     = 1'b0;
                      cmp_src1[4*i+1][8]   = 1'b0;
                      cmp_src1[4*i+2][8]   = 1'b0;
                      cmp_src1[4*i+3][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[8*3+7] : ~1'b0;
                    end
                  endcase
                end
                EEW16:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][7:0]   = pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+1][7:0] = pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i+2][7:0] = pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+3][7:0] = pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i][8]     = 1'b0;
                      cmp_src1[4*i+1][8]   = 1'b0;
                      cmp_src1[4*i+2][8]   = 1'b0;
                      cmp_src1[4*i+3][8]   = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][7:0]   = ~pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+1][7:0] = ~pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i+2][7:0] = ~pmtrdt_uop.rs1_data[8*0+:8];
                      cmp_src1[4*i+3][7:0] = ~pmtrdt_uop.rs1_data[8*1+:8];
                      cmp_src1[4*i][8]     = 1'b0;
                      cmp_src1[4*i+1][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[8*1+7] : ~1'b0;
                      cmp_src1[4*i+2][8]   = 1'b0;
                      cmp_src1[4*i+3][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[8*1+7] : ~1'b0;
                    end
                  endcase
                end
                default:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][7:0]   = pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+1][7:0] = pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+2][7:0] = pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+3][7:0] = pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i][8]     = 1'b0;
                      cmp_src1[4*i+1][8]   = 1'b0;
                      cmp_src1[4*i+2][8]   = 1'b0;
                      cmp_src1[4*i+3][8]   = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][7:0]   = ~pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+1][7:0] = ~pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+2][7:0] = ~pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i+3][7:0] = ~pmtrdt_uop.rs1_data[0+:8];
                      cmp_src1[4*i][8]     = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[7] : ~1'b0;
                      cmp_src1[4*i+1][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[7] : ~1'b0;
                      cmp_src1[4*i+2][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[7] : ~1'b0;
                      cmp_src1[4*i+3][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.rs1_data[7] : ~1'b0;
                    end
                  endcase
                end
              endcase
            end
            default:begin
              case (rdt_ctrl.cmp_opr)
                COUT:begin
                  cmp_src1[4*i][7:0]   = pmtrdt_uop.vs1_data[8*(4*i)+:8];
                  cmp_src1[4*i+1][7:0] = pmtrdt_uop.vs1_data[8*(4*i+1)+:8];
                  cmp_src1[4*i+2][7:0] = pmtrdt_uop.vs1_data[8*(4*i+2)+:8];
                  cmp_src1[4*i+3][7:0] = pmtrdt_uop.vs1_data[8*(4*i+3)+:8];
                end
                default: begin
                  cmp_src1[4*i][7:0]   = ~pmtrdt_uop.vs1_data[8*(4*i)+:8];
                  cmp_src1[4*i+1][7:0] = ~pmtrdt_uop.vs1_data[8*(4*i+1)+:8];
                  cmp_src1[4*i+2][7:0] = ~pmtrdt_uop.vs1_data[8*(4*i+2)+:8];
                  cmp_src1[4*i+3][7:0] = ~pmtrdt_uop.vs1_data[8*(4*i+3)+:8];
                end
              endcase
              case (pmtrdt_uop.vs2_eew) // compare instruction: vs1_eew == vs2_eew
                EEW32:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][8]   = 1'b0;
                      cmp_src1[4*i+1][8] = 1'b0;
                      cmp_src1[4*i+2][8] = 1'b0;
                      cmp_src1[4*i+3][8] = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][8]   = 1'b0;
                      cmp_src1[4*i+1][8] = 1'b0;
                      cmp_src1[4*i+2][8] = 1'b0;
                      cmp_src1[4*i+3][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+3)+7] : ~1'b0;
                    end
                  endcase
                end
                EEW16:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][8]   = 1'b0;
                      cmp_src1[4*i+1][8] = 1'b0;
                      cmp_src1[4*i+2][8] = 1'b0;
                      cmp_src1[4*i+3][8] = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][8]   = 1'b0;
                      cmp_src1[4*i+1][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+1)+7] : ~1'b0;
                      cmp_src1[4*i+2][8] = 1'b0;
                      cmp_src1[4*i+3][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+3)+7] : ~1'b0;
                    end
                  endcase
                end
                default:begin
                  case (rdt_ctrl.cmp_opr)
                    COUT:begin
                      cmp_src1[4*i][8]   = 1'b0;
                      cmp_src1[4*i+1][8] = 1'b0;
                      cmp_src1[4*i+2][8] = 1'b0;
                      cmp_src1[4*i+3][8] = 1'b0;
                    end
                    default:begin
                      cmp_src1[4*i][8]   = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i)+7] : ~1'b0;
                      cmp_src1[4*i+1][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+1)+7] : ~1'b0;
                      cmp_src1[4*i+2][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+2)+7] : ~1'b0;
                      cmp_src1[4*i+3][8] = rdt_ctrl.sign_opr ? ~pmtrdt_uop.vs1_data[8*(4*i+3)+7] : ~1'b0;
                    end
                  endcase
                end
              endcase
            end
          endcase
        end

        // cmp_carry_in data
        always_comb begin
          case (pmtrdt_uop.vs2_eew)
            EEW32:begin
              case (rdt_ctrl.cmp_opr)
                COUT: cmp_carry_in[4*i] = rdt_ctrl.vm ? 1'b0 : cin_data[4*i];
                BOUT: cmp_carry_in[4*i] = rdt_ctrl.vm ? 1'b1 : bin_data[4*i];
                default: cmp_carry_in[4*i]   = 1'b1;
              endcase
              cmp_carry_in[4*i+1] = cmp_sum[4*i][8];
              cmp_carry_in[4*i+2] = cmp_sum[4*i+1][8];
              cmp_carry_in[4*i+3] = cmp_sum[4*i+2][8];
            end
            EEW16:begin
              case (rdt_ctrl.cmp_opr)
                COUT:begin
                  cmp_carry_in[4*i]   = rdt_ctrl.vm ? 1'b0 : cin_data[4*i]; 
                  cmp_carry_in[4*i+2] = rdt_ctrl.vm ? 1'b0 : cin_data[4*i+2]; 
                end
                BOUT:begin
                  cmp_carry_in[4*i]   = rdt_ctrl.vm ? 1'b1 : bin_data[4*i]; 
                  cmp_carry_in[4*i+2] = rdt_ctrl.vm ? 1'b1 : bin_data[4*i+2]; 
                end
                default:begin
                  cmp_carry_in[4*i]   = 1'b1; 
                  cmp_carry_in[4*i+2] = 1'b1; 
                end
              endcase
              cmp_carry_in[4*i+1] = cmp_sum[4*i][8]; 
              cmp_carry_in[4*i+3] = cmp_sum[4*i+2][8]; 
            end
            default:begin
              case (rdt_ctrl.cmp_opr)
                COUT:begin
                  cmp_carry_in[4*i]   = rdt_ctrl.vm ? 1'b0 : cin_data[4*i];
                  cmp_carry_in[4*i+1] = rdt_ctrl.vm ? 1'b0 : cin_data[4*i+1];
                  cmp_carry_in[4*i+2] = rdt_ctrl.vm ? 1'b0 : cin_data[4*i+2];
                  cmp_carry_in[4*i+3] = rdt_ctrl.vm ? 1'b0 : cin_data[4*i+3];
                end
                BOUT:begin
                  cmp_carry_in[4*i]   = rdt_ctrl.vm ? 1'b1 : bin_data[4*i];
                  cmp_carry_in[4*i+1] = rdt_ctrl.vm ? 1'b1 : bin_data[4*i+1];
                  cmp_carry_in[4*i+2] = rdt_ctrl.vm ? 1'b1 : bin_data[4*i+2];
                  cmp_carry_in[4*i+3] = rdt_ctrl.vm ? 1'b1 : bin_data[4*i+3];
                end
                default:begin
                  cmp_carry_in[4*i]   = 1'b1;
                  cmp_carry_in[4*i+1] = 1'b1;
                  cmp_carry_in[4*i+2] = 1'b1;
                  cmp_carry_in[4*i+3] = 1'b1;
                end
              endcase
            end
          endcase
        end
      end // end for (i=0; i<`VLENB/4; i++) begin : gen_cmp_src_data

      // generate compare result for compare operation
      for (i=0; i<`VLENB; i++) begin : gen_compare_value
        assign cmp_sum[i]    = cmp_src2[i] + cmp_src1[i] + cmp_carry_in[i];
        assign less_than[i]  = cmp_sum[i][8];
        assign out_data[i]   = cmp_sum[i][8];
        assign great_than_equal[i] = ~cmp_sum[i][8]; 
        assign equal[i]      = cmp_sum[i][7:0] == '0;
        assign not_equal[i]  = cmp_sum[i][7:0] != '0;
      end

      // cmp_res data
      always_comb begin
        case (rdt_ctrl.cmp_opr)
          COUT,
          BOUT:begin
            case (pmtrdt_uop.vs2_eew)
              EEW32:begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = out_data[4*j+3]; 
                  cmp_res[j+`VLENB/4]   = out_data[4*j+3]; 
                  cmp_res[j+2*`VLENB/4] = out_data[4*j+3]; 
                  cmp_res[j+3*`VLENB/4] = out_data[4*j+3]; 
                end
              end
              EEW16:begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = out_data[2*j+1];
                  cmp_res[j+`VLENB/2] = out_data[2*j+1];
                end
              end
              default:begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = out_data[j];
                end
              end
            endcase
          end
          NOT_EQUAL:begin
            case (pmtrdt_uop.vs2_eew)
              EEW32: begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = |not_equal[4*j+:4]; 
                  cmp_res[j+`VLENB/4]   = |not_equal[4*j+:4]; 
                  cmp_res[j+2*`VLENB/4] = |not_equal[4*j+:4]; 
                  cmp_res[j+3*`VLENB/4] = |not_equal[4*j+:4]; 
                end
              end
              EEW16: begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = |not_equal[2*j+:2];
                  cmp_res[j+`VLENB/2] = |not_equal[2*j+:2];
                end
              end
              default: begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = not_equal[j];
                end
              end
            endcase
          end
          EQUAL:begin
            case (pmtrdt_uop.vs2_eew)
              EEW32: begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = &equal[4*j+:4];
                  cmp_res[j+`VLENB/4]   = &equal[4*j+:4];
                  cmp_res[j+2*`VLENB/4] = &equal[4*j+:4];
                  cmp_res[j+3*`VLENB/4] = &equal[4*j+:4];
                end
              end
              EEW16: begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = &equal[2*j+:2];
                  cmp_res[j+`VLENB/2] = &equal[2*j+:2];
                end
              end
              default: begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = equal[j];
                end
              end
            endcase
          end
          LESS_THAN:begin
            case (pmtrdt_uop.vs2_eew)
              EEW32: begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = less_than[4*j+3];
                  cmp_res[j+`VLENB/4]   = less_than[4*j+3];
                  cmp_res[j+2*`VLENB/4] = less_than[4*j+3];
                  cmp_res[j+3*`VLENB/4] = less_than[4*j+3];
                end
              end
              EEW16: begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = less_than[2*j+1];
                  cmp_res[j+`VLENB/2] = less_than[2*j+1];
                end
              end
              default: begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = less_than[j];
                end
              end
            endcase
          end
          LESS_THAN_OR_EQUAL:begin
            case (pmtrdt_uop.vs2_eew)
              EEW32: begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = less_than[4*j+3] | (&equal[4*j+:4]);
                  cmp_res[j+`VLENB/4]   = less_than[4*j+3] | (&equal[4*j+:4]);
                  cmp_res[j+2*`VLENB/4] = less_than[4*j+3] | (&equal[4*j+:4]);
                  cmp_res[j+3*`VLENB/4] = less_than[4*j+3] | (&equal[4*j+:4]);
                end
              end
              EEW16: begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = less_than[2*j+1] | (&equal[2*j+:2]);
                  cmp_res[j+`VLENB/2] = less_than[2*j+1] | (&equal[2*j+:2]);
                end
              end
              default: begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = less_than[j] | equal[j];
                end
              end
            endcase
          end
          default:begin //GREAT_THAN
            case (pmtrdt_uop.vs2_eew)
              EEW32: begin
                for (int j=0; j<`VLENB/4; j++) begin 
                  cmp_res[j]            = great_than_equal[4*j+3] & (|not_equal[4*j+:4]);
                  cmp_res[j+`VLENB/4]   = great_than_equal[4*j+3] & (|not_equal[4*j+:4]);
                  cmp_res[j+2*`VLENB/4] = great_than_equal[4*j+3] & (|not_equal[4*j+:4]);
                  cmp_res[j+3*`VLENB/4] = great_than_equal[4*j+3] & (|not_equal[4*j+:4]);
                end
              end
              EEW16: begin
                for (int j=0; j<`VLENB/2; j++) begin 
                  cmp_res[j]          = great_than_equal[2*j+1] & (|not_equal[2*j+:2]);
                  cmp_res[j+`VLENB/2] = great_than_equal[2*j+1] & (|not_equal[2*j+:2]);
                end
              end
              default: begin
                for (int j=0; j<`VLENB; j++) begin 
                  cmp_res[j] = great_than_equal[j] & not_equal[j];
                end
              end
            endcase
          end
        endcase
      end

      // cmp_res_offset/cmp_res_en_offset
      always_comb begin
        case (pmtrdt_uop.vs2_eew)
          EEW32: cmp_res_offset = pmtrdt_uop.uop_index * `VLENB/4;
          EEW16: cmp_res_offset = pmtrdt_uop.uop_index * `VLENB/2;
          default: cmp_res_offset = pmtrdt_uop.uop_index * `VLENB;
        endcase
      end
      assign cmp_res_en_offset = cmp_res_offset >> 2; // max eew is 32b or 4B, then VLEN/EEW_max = 4.

      // cmp_res_d/cmp_res_q
      always_comb begin
        case (pmtrdt_uop.vs2_eew)
          EEW32: cmp_res_en = (2*`VLENB)'('b1)  << cmp_res_en_offset;
          EEW16: cmp_res_en = (2*`VLENB)'('b11) << cmp_res_en_offset;
          default: cmp_res_en = (2*`VLENB)'('b1111) << cmp_res_en_offset;
        endcase
      end
      assign cmp_res_d = (`VLEN)'(cmp_res) << cmp_res_offset;
      for (i=0; i<(2*`VLENB); i++) begin
        edff #(.T(logic[`VLEN/32-1:0])) cmp_res_reg (.q(cmp_res_q[`VLEN/32*i+:`VLEN/32]), .d(cmp_res_d[`VLEN/32*i+:`VLEN/32]), .e(cmp_res_en[i] & pmtrdt_uop_valid & pmtrdt_uop_ready), .clk(clk), .rst_n(rst_n));
      end

      // cmp_vstart value is from the first uop of compare instruction
      assign cmp_vstart_d = pmtrdt_uop.vstart;
      assign cmp_vstart_en = pmtrdt_uop.first_uop_valid & pmtrdt_uop_valid & pmtrdt_uop_ready;
      edff #(.T(logic[`VSTART_WIDTH-1:0])) cmp_vstart_reg (.q(cmp_vstart_q), .d(cmp_vstart_d), .e(cmp_vstart_en), .clk(clk), .rst_n(rst_n));
      // pmtrdt_res_cmp
      for (i=0; i<`VLEN; i++) begin
        always_comb begin
          if (i < cmp_vstart_q)      pmtrdt_res_cmp[i] = rdt_ctrl_q.vs3_data[i];
          else if (i >= rdt_ctrl_q.cmp_evl) pmtrdt_res_cmp[i] = rdt_ctrl_q.vs3_data[i];
          else begin
            case (rdt_ctrl_q.cmp_opr)
              COUT,
              BOUT: pmtrdt_res_cmp[i] = cmp_res_q[i];
              default:
                if (rdt_ctrl_q.vm)         pmtrdt_res_cmp[i] = cmp_res_q[i];
                else if (rdt_ctrl_q.v0_data[i]) pmtrdt_res_cmp[i] = cmp_res_q[i];
                else                        pmtrdt_res_cmp[i] = rdt_ctrl_q.vs3_data[i];
            endcase
          end
        end
      end
    end // end if (GEN_CMP == 1'b1)
  endgenerate
  
// Permutation unit 
  // offset: select element
  generate
    if (GEN_PMT == 1'b1) begin
      // slide/gather instruction
      // vd data can be driven from all vs2 datas,
      // so PMT can not start to execute slide/gather uop
      // unless all uop(s) has been put in RS.
      assign rs_entry_valid = f_rs_decoder(uop_cnt);
      always_comb begin
        pmt_go = 1'b0;
        for (int j=0; j<`PMTRDT_RS_DEPTH; j++) begin
          pmt_go = pmt_go | (uop_data[j].last_uop_valid & rs_entry_valid[j]);
        end
        pmt_go = ~rdt_ctrl.compress & compress_ctrl_empty & (uop_type==PERMUTATION) & uop_data[0].first_uop_valid & pmt_go;
      end
      cdffr #(.T(logic)) pmt_go_reg (.q(pmt_go_q), .d(pmt_go), .c(trap_flush_rvv), .e(1'b1), .clk(clk), .rst_n(rst_n));

      for (i=0; i<`VLENB; i++) begin
        always_comb begin
          case(pmt_ctrl.pmt_opr)
            SLIDE_UP:begin
              if (pmtrdt_uop.uop_funct3 == OPMVX)
                case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                  EEW32:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i-4);
                  EEW16:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i-2);
                  default:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i-1);
                endcase
              else
                case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                  EEW32:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB + i - (4*pmtrdt_uop.rs1_data));
                  EEW16:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB + i - (2*pmtrdt_uop.rs1_data));
                  default:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+ i - pmtrdt_uop.rs1_data);
                endcase
            end
            SLIDE_DOWN:begin
              if (pmtrdt_uop.uop_funct3 == OPMVX)
                case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                  EEW32:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i+4);
                  EEW16:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i+2);
                  default:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB+i+1);
                endcase
              else
                case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                  EEW32:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB + i + (4*pmtrdt_uop.rs1_data));
                  EEW16:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB + i + (2*pmtrdt_uop.rs1_data));
                  default:offset[i] = (`XLEN+2)'(uop_data[pmt_uop_done_cnt_q].uop_index*`VLENB + i + pmtrdt_uop.rs1_data);
                endcase
            end
            GATHER:begin
              case (pmtrdt_uop.uop_funct3)
                OPIVX,
                OPIVI:begin
                  case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                    EEW32:offset[i] = (`XLEN+2)'(i%4 + {pmtrdt_uop.rs1_data,2'b0});
                    EEW16:offset[i] = (`XLEN+2)'(i%2 + {pmtrdt_uop.rs1_data,1'b0});
                    default:offset[i] = (`XLEN+2)'(pmtrdt_uop.rs1_data);
                  endcase
                end
                default:begin
                  case (pmtrdt_uop.vs1_eew)
                    EEW32: offset[i] = (`XLEN+2)'(i%4 + (4*{{(`XLEN-32){1'b0}}, uop_data[(pmt_uop_done_cnt_q*`VLENB/4+i/4)/(`VLENB/4)].vs1_data[32*((i/4)%(`VLENB/4))+:32]}));
                    EEW16: begin
                      case (pmtrdt_uop.vs2_eew) // vrgatherei16
                        EEW32:offset[i] = (`XLEN+2)'(i%4 + (4*{{(`XLEN-16){1'b0}}, uop_data[(pmt_uop_done_cnt_q*`VLENB/4+i/4)/(`VLENB/4)].vs1_data[16*((pmt_uop_done_cnt_q*`VLENB/4+i/4)%(`VLENB/2))+:16]}));
                        EEW16:offset[i] = (`XLEN+2)'(i%2 + (2*{{(`XLEN-16){1'b0}}, uop_data[(pmt_uop_done_cnt_q*`VLENB/2+i/2)/(`VLENB/2)].vs1_data[16*((i/2)%(`VLENB/2))+:16]}));
                        default:offset[i] = (`XLEN+2)'({{(`XLEN-16){1'b0}}, uop_data[(pmt_uop_done_cnt_q*`VLENB+i)/(`VLENB)].vs1_data[16*(i%(`VLENB/2))+:16]});
                      endcase
                    end
                    default: offset[i] = (`XLEN+2)'({{(`XLEN-8){1'b0}}, uop_data[(pmt_uop_done_cnt_q*`VLENB+i)/(`VLENB)].vs1_data[8*(i%(`VLENB))+:8]});
                  endcase
                end
              endcase
            end
            default: offset[i] = (`XLEN+2)'(i);
          endcase
        end
      end

      //select scalar value
      //for vslide1up, vd[0] = x[rs1]
      //for vslide1down, vd[vl-1] = x[rs1]
      always_comb begin
        if (pmtrdt_uop.uop_funct3 == OPMVX) begin
          case (pmt_ctrl.pmt_opr)
            SLIDE_UP:begin
              if (pmt_uop_done_cnt_q == 0)
                case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                  EEW32:sel_scalar = (`VLENB)'('hF);
                  EEW16:sel_scalar = (`VLENB)'('h3);
                  default:sel_scalar = (`VLENB)'('h1);
                endcase
              else
                sel_scalar = '0;
            end
            SLIDE_DOWN:begin
              case (pmtrdt_uop.vs2_eew) // Permutation instruction: vd_eew == vs2_eew
                EEW32:sel_scalar = (uop_data[pmt_uop_done_cnt_q].uop_index+1'b1)*(`VLENB/4) >= rdt_ctrl.vl ?
                                    (`VLENB)'('hF) << ((rdt_ctrl.vl-1)%(`VLENB/4))*4 : '0;
                EEW16:sel_scalar = (uop_data[pmt_uop_done_cnt_q].uop_index+1'b1)*(`VLENB/2) >= rdt_ctrl.vl ?
                                    (`VLENB)'('h3) << ((rdt_ctrl.vl-1)%(`VLENB/2))*2 : '0;
                default:sel_scalar = (uop_data[pmt_uop_done_cnt_q].uop_index+1'b1)*`VLENB >= rdt_ctrl.vl ?
                                    (`VLENB)'('h1) << ((rdt_ctrl.vl-1)%(`VLENB))*1 : '0;
              endcase
            end
            default:sel_scalar = '0;
          endcase
        end else begin
          sel_scalar = '0;
        end
      end

      always_comb begin
        if (pmtrdt_uop.vs2_eew == EEW8 && pmtrdt_uop.vs1_eew == EEW16)
          for (int j=0; j<`VLMAX_MAX/2; j++) begin
            pmt_vs2_data[j] = uop_data[j/(`VLENB/2)].vs2_data[8*(j%(`VLENB))+:8];
            pmt_vs2_data[j+`VLMAX_MAX/2] = '0;
          end
        else
          for (int j=0; j<`VLMAX_MAX; j++)
            pmt_vs2_data[j] = uop_data[j/(`VLENB)].vs2_data[8*(j%(`VLENB))+:8];
      end

      for (i=0; i<`VLMAX_MAX; i++) begin
        assign pmt_vs3_data[i] = uop_data[i/(`VLENB)].vs3_data[8*(i%(`VLENB))+:8];
      end

      // permutation instruction (vslide1up/vslide1down): rs1_eew == vs2_eew
      always_comb begin
        case (pmtrdt_uop.vs2_eew) 
          EEW32:pmt_rs1_data = {(`XLEN/32){pmtrdt_uop.rs1_data[31:0]}};
          EEW16:pmt_rs1_data = {(`XLEN/16){pmtrdt_uop.rs1_data[15:0]}};
          default:pmt_rs1_data = {(`XLEN/8){pmtrdt_uop.rs1_data[7:0]}};
        endcase
      end

      // pmt_res_d/pmt_res_q
      assign pmt_res_en = pmt_go;
      for (i=0; i<`VLENB; i++) begin
        always_comb begin
          slide_down_offset[i] = offset[i]-(pmtrdt_uop.uop_index*`VLENB);
          if (sel_scalar[i]) pmt_res_d[i] = pmt_rs1_data[8*(i%4)+:8];
          else
            case (pmt_ctrl.pmt_opr)
              SLIDE_UP:begin
                case (pmtrdt_uop.vs2_eew) // permutation instruction
                  EEW32: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(4*pmtrdt_uop.vlmax) ? pmt_vs3_data[pmt_uop_done_cnt_q*`VLENB+i] : pmt_vs2_data[offset[i][7:0]];
                  EEW16: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(2*pmtrdt_uop.vlmax) ? pmt_vs3_data[pmt_uop_done_cnt_q*`VLENB+i] : pmt_vs2_data[offset[i][7:0]];
                  default: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(pmtrdt_uop.vlmax) ? pmt_vs3_data[pmt_uop_done_cnt_q*`VLENB+i] : pmt_vs2_data[offset[i][7:0]];
                endcase
              end
              SLIDE_DOWN:begin
                case (pmtrdt_uop.vs2_eew)
                  EEW32: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(4*pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[slide_down_offset[i][7:0]];
                  EEW16: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(2*pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[slide_down_offset[i][7:0]];
                  default: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[slide_down_offset[i][7:0]];
                endcase
              end
              default: begin
                case (pmtrdt_uop.vs2_eew)
                  EEW32: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(4*pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[offset[i][7:0]];
                  EEW16: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(2*pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[offset[i][7:0]];
                  default: pmt_res_d[i] = offset[i] >= (`XLEN+2)'(pmtrdt_uop.vlmax) ? '0 : pmt_vs2_data[offset[i][7:0]];
                endcase
              end
            endcase
        end
        edff #(.T(logic[7:0])) pmt_res_reg (.q(pmt_res_q[i]), .d(pmt_res_d[i]), .e(pmt_res_en), .clk(clk), .rst_n(rst_n));
        assign pmtrdt_res_pmt[i*8+:8] = pmt_res_q[i];
      end

      // pmt_uop_done_cnt_d/pmt_uop_done_cnt_q
      assign pmt_uop_done_cnt_d = pmt_uop_done_cnt_q + 1'b1;
      cdffr #(.T(logic[`UOP_INDEX_WIDTH-1:0])) pmt_uop_done_cnt_reg (.q(pmt_uop_done_cnt_q), .d(pmt_uop_done_cnt_d), .c(uop_data[pmt_uop_done_cnt_q].last_uop_valid | trap_flush_rvv), .e(pmt_go), .clk(clk), .rst_n(rst_n));

  // Compress instruction
    // compress instruction is a specified instruction in PMT.
    // the vl of vd in compress can not be acknowledged untill decode vs1 value.
      // compress_mask_d is driven from shifted vs1_data based on vs2_eew
      always_comb begin
        case (pmtrdt_uop.vs2_eew) // vcompress instruction: vd_eew == vs2_eew
          EEW32:compress_mask_d = pmtrdt_uop.uop_index == '0 ? pmtrdt_uop.vs1_data >> (`VLENB/4) : compress_mask_q >> (`VLENB/4);
          EEW16:compress_mask_d = pmtrdt_uop.uop_index == '0 ? pmtrdt_uop.vs1_data >> (`VLENB/2) : compress_mask_q >> (`VLENB/2);
          default:compress_mask_d = pmtrdt_uop.uop_index == '0 ? pmtrdt_uop.vs1_data >> `VLENB : compress_mask_q >> `VLENB;
        endcase
      end
      assign compress_mask_en = pmtrdt_uop_valid & pmtrdt_uop_ready;
      edff #(.T(logic[`VLEN-1:0])) compress_mask_reg (.q(compress_mask_q), .d(compress_mask_d), .e(compress_mask_en), .clk(clk), .rst_n(rst_n));

      // compress_enable is from vs1_data[0+:N] based on vs2_eew
      // and then be extended to `VLENB bits.
      always_comb begin
        case (pmtrdt_uop.vs2_eew)
          EEW32:begin
            for (int j=0; j<`VLENB/4; j++) begin
              compress_enable[4*j+:4] = pmtrdt_uop.uop_index == '0 ? {4{pmtrdt_uop.vs1_data[j]}} : {4{compress_mask_q[j]}};
            end
          end
          EEW16:begin
            for (int j=0; j<`VLENB/2; j++) begin
              compress_enable[2*j+:2] = pmtrdt_uop.uop_index == '0 ? {2{pmtrdt_uop.vs1_data[j]}} : {2{compress_mask_q[j]}};
            end
          end
          default:compress_enable = pmtrdt_uop.uop_index == '0 ? pmtrdt_uop.vs1_data[`VLENB-1:0] : compress_mask_q[`VLENB-1:0];
        endcase
      end

      // compress_body is driven from vl & uop_index
      // 0: tail element; 1: body element
      always_comb begin
        case (pmtrdt_uop.vs2_eew)
          EEW32:compress_body = (pmtrdt_uop.vl > pmtrdt_uop.uop_index*`VLENB/4) ? ~({`VLENB{1'b1}} << (4*(pmtrdt_uop.vl - pmtrdt_uop.uop_index*`VLENB/4))) : '0;
          EEW16:compress_body = (pmtrdt_uop.vl > pmtrdt_uop.uop_index*`VLENB/2) ? ~({`VLENB{1'b1}} << (2*(pmtrdt_uop.vl - pmtrdt_uop.uop_index*`VLENB/2))) : '0;
          default:compress_body = (pmtrdt_uop.vl > pmtrdt_uop.uop_index*`VLENB) ? ~({`VLENB{1'b1}} << (pmtrdt_uop.vl - pmtrdt_uop.uop_index*`VLENB)) : '0;
        endcase
      end

      // compress_cnt indicates how much bytes have been compressed
      always_comb begin
        if (pmtrdt_uop.uop_index == '0) compress_cnt_d = f_sum(compress_enable & compress_body);
        else                            compress_cnt_d = compress_cnt_q + f_sum(compress_enable & compress_body);
      end
      assign compress_cnt_en = pmtrdt_uop_valid & pmtrdt_uop_ready & rdt_ctrl.compress;
      assign compress_cnt_clr =  ~compress_cnt_gt_vlenb & rdt_ctrl_q.last_uop_valid; 
      cdffr #(.T(logic[VLENB_WIDTH:0])) compress_cnt_reg (.q(compress_cnt_q), .d(compress_cnt_d), .c(~compress_cnt_en & compress_cnt_clr | trap_flush_rvv), .e(compress_cnt_en), .clk(clk), .rst_n(rst_n));
      cdffr #(.T(logic[VLENB_WIDTH:0])) compress_cnt_reg_reg (.q(compress_cnt_qq), .d(compress_cnt_q), .c(compress_cnt_clr | trap_flush_rvv), .e(1'b1), .clk(clk), .rst_n(rst_n));
      
      // set if compress more than or equal 16 byte and then write the result to ROB
      assign compress_cnt_ge_vlenb = compress_cnt_qq[VLENB_WIDTH] ^ compress_cnt_q[VLENB_WIDTH];
      assign compress_cnt_gt_vlenb = compress_cnt_ge_vlenb & (|compress_cnt_q[VLENB_WIDTH-1:0]);

      // compress_offset select elements of vs2_data and compress to compress_value
      assign compress_offset = f_compress_offset(compress_enable);
      for (i=0; i<`VLENB; i++) begin
        assign compress_value[i] = compress_offset[i] == '1 ? '0 : pmtrdt_uop.vs2_data[8*compress_offset[i]+:8];
      end

      // compress_res is driven by compress_value and compress_cnt.
      always_comb begin
        if (pmtrdt_uop.first_uop_valid) compress_res_d = (2*`VLENB*8)'(compress_value);
        else                            compress_res_d = f_circular_shift(compress_value, compress_cnt_q);
      end

      // compress_res_en
      always_comb begin
        if (compress_ctrl_push)
          if (pmtrdt_uop.first_uop_valid) compress_res_en = (2*`VLENB)'(f_pack_1s(compress_enable));
          else                            compress_res_en = f_circular_en(compress_enable,compress_cnt_q);
        else 
          compress_res_en = '0;
      end
      for (i=0; i<2*`VLENB; i++) edff #(.T(logic[7:0])) compress_res_reg (.q(compress_res_q[i]), .d(compress_res_d[i]), .e(compress_res_en[i]), .clk(clk), .rst_n(rst_n));

      // pmtrdt_res_compress
      assign valid_num[1] = compress_cnt_q[VLENB_WIDTH:0] - `VLENB;
      assign valid_num[0] = compress_cnt_q[VLENB_WIDTH:0];
      always_comb begin
        if (rdt_ctrl_q.last_uop_valid) begin
          if (compress_cnt_qq[VLENB_WIDTH]) 
            pmtrdt_res_compress = f_res_compress_merge(compress_ctrl_ex1.vs3_data, compress_res_q[`VLENB+:`VLENB], valid_num[1]);
          else
            pmtrdt_res_compress = f_res_compress_merge(compress_ctrl_ex1.vs3_data, compress_res_q[0+:`VLENB], valid_num[0]);
        end else begin
          if (compress_cnt_qq[VLENB_WIDTH])
            pmtrdt_res_compress = compress_res_q[2*`VLENB-1:`VLENB];
          else
            pmtrdt_res_compress = compress_res_q[`VLENB-1:0];
        end
      end

      // compress control fifo
      // based on the value of vs1, one or multiple uop(s) writes one vd.
      // the remaining elements of vd are treated as tail elements.
    `ifdef TB_SUPPORT
      assign compress_ctrl_ex0.uop_pc = pmtrdt_uop.uop_pc;
    `endif
      assign compress_ctrl_ex0.rob_entry      = pmtrdt_uop.rob_entry;
      assign compress_ctrl_ex0.vs3_data       = pmtrdt_uop.vs3_data;
      assign compress_ctrl_ex0.last_uop_valid = pmtrdt_uop.last_uop_valid;

      assign compress_ctrl_push = pmtrdt_uop_valid & pmtrdt_uop_ready & rdt_ctrl.compress;
      assign compress_ctrl_pop  = (compress_cnt_ge_vlenb | rdt_ctrl_q.last_uop_valid & rdt_ctrl_q.compress);

      multi_fifo #(
        .T            (COMPRESS_CTRL_t),
        .M            (1),
        .N            (1),
        .DEPTH        (`EMUL_MAX),
        .ASYNC_RSTN   (1)
      ) compress_ctrl_fifo (
        // global
          .clk          (clk),
          .rst_n        (rst_n),
        // write
          .push         (compress_ctrl_push),
          .datain       (compress_ctrl_ex0),
        // read
          .pop          (compress_ctrl_pop),
          .dataout      (compress_ctrl_ex1),
        // fifo status
          .full         (),
          .almost_full  (),
          .empty        (compress_ctrl_empty),
          .almost_empty (),
          .clear        (trap_flush_rvv),
          .fifo_data    (),
          .wptr         (),
          .rptr         (),
          .entry_count  ()
      );

    end // if (GEN_PMT == 1'b1) 
  endgenerate

// output result
  always_comb begin
    case (uop_type_q)
      PERMUTATION: pmtrdt_res_valid = rdt_ctrl_q.compress ? compress_ctrl_pop
                                                          : pmt_go_q;
      default: pmtrdt_res_valid = rdt_ctrl_q.last_uop_valid;
    endcase
  end

  always_comb begin
    `ifdef TB_SUPPORT
    // uop_pc
    case (uop_type_q)
      PERMUTATION: pmtrdt_res.uop_pc = rdt_ctrl_q.compress ? compress_ctrl_ex1.uop_pc : pmt_ctrl_q.uop_pc;
      default:     pmtrdt_res.uop_pc = rdt_ctrl_q.uop_pc; 
    endcase
    `endif
    
    // rob_entry
    case (uop_type_q)
      PERMUTATION:pmtrdt_res.rob_entry = rdt_ctrl_q.compress ? compress_ctrl_ex1.rob_entry : pmt_ctrl_q.rob_entry;
      default:    pmtrdt_res.rob_entry = rdt_ctrl_q.rob_entry;
    endcase

    // write valid
    pmtrdt_res.w_valid = 1'b1;

    // saturate
    pmtrdt_res.vsaturate = '0;

    // data
    case (uop_type_q)
      PERMUTATION: pmtrdt_res.w_data = rdt_ctrl_q.compress ? pmtrdt_res_compress : pmtrdt_res_pmt;
      REDUCTION:   pmtrdt_res.w_data = pmtrdt_res_red;
      COMPARE:     pmtrdt_res.w_data = pmtrdt_res_cmp;
      default:     pmtrdt_res.w_data = pmtrdt_res_cmp;
    endcase
  end

  // pmtrdt_uop_ready:
  // 1. CMP instruction - always 1
  // 2. RDT instruction
  //    VWREDSUMU&VWREDSUM - set 1 only if red_widen_sum_flag toggle to 1.
  //    the others         - clear 0
  // 3. PMT instruction - set 1 only if last_uop_valid is asserted.
  cdffr #(.T(logic)) wredsum_flag_reg (.q(red_widen_sum_flag), .d(~red_widen_sum_flag), .c(trap_flush_rvv), .e(rdt_ctrl.widen & pmtrdt_uop_valid), .clk(clk), .rst_n(rst_n));
  always_comb begin
    if (compress_ctrl_empty)
      case (uop_type)
        PERMUTATION: pmtrdt_uop_ready = rdt_ctrl.compress ? (compress_ctrl_ex1.last_uop_valid | ~rdt_ctrl_q.last_uop_valid)
                                                          : uop_data[pmt_uop_done_cnt_q].last_uop_valid || ~uop_data[0].first_uop_valid;
        REDUCTION:
          if (rdt_ctrl.widen) pmtrdt_uop_ready = red_widen_sum_flag;
          else                pmtrdt_uop_ready = 1'b1;
        default: pmtrdt_uop_ready = 1'b1;
      endcase
    else pmtrdt_uop_ready = rdt_ctrl.compress ? (compress_ctrl_ex1.last_uop_valid | ~rdt_ctrl_q.last_uop_valid)
                                              : pmt_go & uop_data[pmt_uop_done_cnt_q].last_uop_valid | ~uop_data[0].first_uop_valid;
  end

// ---function--------------------------------------------------------
// f_sum: sum how many bits are asserted.
  function [VLENB_WIDTH:0] f_sum;
    input [`VLENB-1:0] vector_bits;

    int                i;
    logic [VLENB_WIDTH:0] sum_val;
    begin
      sum_val = '0;
      for (i=0; i<`VLENB; i++) begin
        sum_val = sum_val + vector_bits[i];
      end
      f_sum = sum_val;
    end
  endfunction

// f_compress_offset: extract valid bit and put its index to offset 
  function [`VLENB-1:0][VLENB_WIDTH:0] f_compress_offset;
    input [`VLENB-1:0] enables;

    int                i,j;
    logic [`VLENB-1:0][VLENB_WIDTH:0] results;
    begin
      j = 0;
      for (i=0; i<`VLENB; i++) results[i] = '1;
      for (i=0; i<`VLENB; i++) begin
        if (enables[i]) begin
          results[j] = (VLENB_WIDTH+1)'(i);
          j++;
        end
      end
      f_compress_offset = results;
    end
  endfunction

// f_circular_shift: circular shift result to proper site 
  function [2*`VLENB-1:0][7:0] f_circular_shift;
    input [`VLENB-1:0][7:0] value; 
    input [VLENB_WIDTH:0]   shift;

    logic [`VLEN-1:0]       value_tmp;
    logic [`VLEN-1:0]       buf2,buf1,buf0;
    logic [1:0][`VLEN-1:0]  result;
    begin
      value_tmp = value;
      {buf2,buf1,buf0} = (3*`VLEN)'(value_tmp) << (shift*8);
      result = shift[VLENB_WIDTH] ? {buf1, buf2} : {buf1,buf0};
      f_circular_shift = result;
    end
  endfunction

// f_pack_1s: collect all 1s and pack themsigned(dest) < $signed(src2)
  function [`VLENB-1:0] f_pack_1s;
    input [`VLENB-1:0] value;
    
    int                i,j;
    logic [`VLENB-1:0] result;
    begin
      j = 0;
      result = '0;
      for (i=0; i<`VLENB; i++)
        if (value[i]) begin
          result[j] = 1'b1;
          j++;
        end
      f_pack_1s = result;
    end
  endfunction

// f_circular_en: circular shift enable signals
  function [2*`VLENB-1:0] f_circular_en;
    input [`VLENB-1:0]    value;
    input [VLENB_WIDTH:0] shift;

    logic [`VLENB-1:0]    value_pack_1s;
    logic [`VLENB-1:0]    en2,en1,en0;
    logic [1:0][`VLENB-1:0] result;
    begin
      value_pack_1s = f_pack_1s(value);
      {en2,en1,en0} = (3*`VLENB)'(value_pack_1s) << shift;
      result = shift[VLENB_WIDTH] ? {en1, en2} : {en1, en0};
      f_circular_en = result;
    end
  endfunction

// f_res_compress_merge: merge raw data with copmress result
  function [`VLEN-1:0] f_res_compress_merge;
    input [`VLENB-1:0][7:0] raw_data;
    input [`VLENB-1:0][7:0] res_data;
    input [VLENB_WIDTH:0] valid_num;

    int                     i;
    logic [`VLENB-1:0]      valid;
    logic [`VLENB-1:0][7:0] result;
    begin
      for (i=0; i<`VLENB; i++) begin
        if (i < valid_num) valid[i] = 1'b1;
        else               valid[i] = 1'b0;
        result[i] = valid[i] ? res_data[i] : raw_data[i];
      end
      f_res_compress_merge = result;
    end
  endfunction

// f_rs_decoder: decoder for reservation station
  function [`PMTRDT_RS_DEPTH-1:0] f_rs_decoder;
    input [$clog2(`PMTRDT_RS_DEPTH):0] cnt;

    logic [`PMTRDT_RS_DEPTH-1:0]       result;
    begin
      result = '1 << cnt;
      result = ~result;
      f_rs_decoder = result;
    end
  endfunction

endmodule
// ----- 8< ----- FILE "./rvv_backend_pmtrdt.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// description
// 1. the module is responsible for 3 kinds of vector instructions.
//    a. compare instruction.
//    b. reduction instruction.
//    c. permutation instruction.
//
// feature list:
// 1. pmtrdt unit[0] can support compare/reduction/compress intructions
//    a. compress instruction is a specified instruction in permutation.
//    b. vd EMUL for compare/reduction instruction is always 1.
// 2. the latency of the module is 2-cycle for each uop.

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend_pmtrdt
(
  clk,
  rst_n,

  pop_ex2rs,
  pmtrdt_uop_rs2ex,
  fifo_empty_rs2ex,
  fifo_almost_empty_rs2ex,
  all_uop_data,
  all_uop_cnt,

  result_valid_ex2rob,
  result_ex2rob,
  result_ready_rob2ex,

  trap_flush_rvv
);
// ---port definition-------------------------------------------------
// global signal
  input   logic           clk;
  input   logic           rst_n;

// PMTRDT RS to PMTRDT unit
  output  logic        [`NUM_PMTRDT-1:0]  pop_ex2rs;
  input   PMT_RDT_RS_t [`NUM_PMTRDT-1:0]  pmtrdt_uop_rs2ex;
  input   logic                           fifo_empty_rs2ex;
  input   logic        [`NUM_PMTRDT-1:0]  fifo_almost_empty_rs2ex;
  input   PMT_RDT_RS_t [`PMTRDT_RS_DEPTH-1:0] all_uop_data;
  input   logic        [$clog2(`PMTRDT_RS_DEPTH):0] all_uop_cnt;

// PMTRDT unit to ROB
  output  logic        [`NUM_PMTRDT-1:0]  result_valid_ex2rob;
  output  PU2ROB_t     [`NUM_PMTRDT-1:0]  result_ex2rob;
  input   logic        [`NUM_PMTRDT-1:0]  result_ready_rob2ex;

// trap-flush
  input   logic                           trap_flush_rvv;

// ---internal signal definition--------------------------------------
  logic         [`NUM_PMTRDT-1:0] pmtrdt_uop_valid;
  PMT_RDT_RS_t  [`NUM_PMTRDT-1:0] pmtrdt_uop;
  logic         [`NUM_PMTRDT-1:0] pmtrdt_uop_ready;

  logic         [`NUM_PMTRDT-1:0] pmtrdt_res_valid;
  PU2ROB_t      [`NUM_PMTRDT-1:0] pmtrdt_res;
  logic         [`NUM_PMTRDT-1:0] pmtrdt_res_ready;

  genvar i;
// ---code start------------------------------------------------------
  generate
    for (i=0; i<`NUM_PMTRDT; i++) begin
      assign pmtrdt_uop[i] = pmtrdt_uop_rs2ex[i];
      if (i==0)
        assign pmtrdt_uop_valid[0] = ~fifo_empty_rs2ex;
      else
        assign pmtrdt_uop_valid[i] = ~fifo_almost_empty_rs2ex[i];
      assign pop_ex2rs[i] = pmtrdt_uop_valid[i] & pmtrdt_uop_ready[i];

      assign result_valid_ex2rob[i] = pmtrdt_res_valid[i];
      assign result_ex2rob[i]       = pmtrdt_res[i];
      assign pmtrdt_res_ready[i]    = result_ready_rob2ex[i]; 
    end
  endgenerate

// instance the pmtrdt unit
  generate
    for (i=0; i<`NUM_PMTRDT; i++) begin : gen_pmtrdt_unit
        rvv_backend_pmtrdt_unit #(
          .GEN_RDT      (1'b1),
          .GEN_CMP      (1'b1),
          .GEN_PMT      (1'b1)
        ) u_pmtrdt_unit0 (
          .clk                (clk),
          .rst_n              (rst_n),
          .pmtrdt_uop_valid   (pmtrdt_uop_valid[i]),
          .pmtrdt_uop         (pmtrdt_uop[i]),
          .pmtrdt_uop_ready   (pmtrdt_uop_ready[i]),
          .pmtrdt_res_valid   (pmtrdt_res_valid[i]),
          .pmtrdt_res         (pmtrdt_res[i]),
          .pmtrdt_res_ready   (pmtrdt_res_ready[i]),
          .uop_data           (all_uop_data),
          .uop_cnt            (all_uop_cnt),
          .trap_flush_rvv     (trap_flush_rvv)
        );
    end
  endgenerate

endmodule
// ----- 8< ----- FILE "./rvv_backend_retire.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
/*
description:
1. It will get retired uops from ROB, and write the results back to VRF/XRF 

feature list:
1. This module is all combinational logic!!!
2. Input has 4 entries. The 4 entries have their dependency. 0(oldest) > 1 > 2 > 3(latest)
3. This module decodes the uop info from ROB
4. Write back to VRF
  4.1. Generate mask(strobe) based on Byte-enable locally
  4.2. Check vector write-after-write (WAW), and update mask to one-hot type
  4.3. Pack data to VRF struct
5. Write back to XRF
  5.1. Pack data to XRF struct
6. Check trap flag, clean the latter valid after trap uop
7. Write VCSR when trap occurs
8. There are 4 write ports for VRF, 4 write ports for XRF. RVS arbitrates write ports of XRF by itself
*/

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_retire(/*AUTOARG*/
   // Outputs
   rt2rob_write_ready, 
   rt2xrf_write_valid, rt2xrf_write_data, 
   rt2vrf_write_valid, rt2vrf_write_data, 
   rt2vcsr_write_valid, rt2vcsr_write_data, 
   rt2vxsat_write_valid, rt2vxsat_write_data,
   // Inputs
   rob2rt_write_valid, rob2rt_write_data,
   xrf2rt_write_ready, vcsr2rt_write_ready,
   vxsat2rt_write_ready
   );
// global signal
// Pure combinational logic, thus no clk no rst_n

// ROB dataout
    input   logic    [`NUM_RT_UOP-1:0]  rob2rt_write_valid;
    input   ROB2RT_t [`NUM_RT_UOP-1:0]  rob2rt_write_data;
    output  logic    [`NUM_RT_UOP-1:0]  rt2rob_write_ready;

// write back to XRF
    output  logic    [`NUM_RT_UOP-1:0]  rt2xrf_write_valid;
    output  RT2XRF_t [`NUM_RT_UOP-1:0]  rt2xrf_write_data;
    input   logic    [`NUM_RT_UOP-1:0]  xrf2rt_write_ready;

// write back to VRF
    output  logic    [`NUM_RT_UOP-1:0]  rt2vrf_write_valid;
    output  RT2VRF_t [`NUM_RT_UOP-1:0]  rt2vrf_write_data;//update vrf has no ready @output

// write to update vcsr
    output  logic                       rt2vcsr_write_valid;
    output  RVVConfigState              rt2vcsr_write_data;
    input   logic                       vcsr2rt_write_ready;

// vxsat
    output  logic                             rt2vxsat_write_valid;
    output  logic   [`VCSR_VXSAT_WIDTH-1:0]   rt2vxsat_write_data;
    input   logic                             vxsat2rt_write_ready;

////////////Wires & Regs  ///////////////
logic                            w_type0;
logic                            w_type1;
logic                            w_type2;
logic                            w_type3;

BYTE_TYPE_t                      vd_type0;
BYTE_TYPE_t                      vd_type1;
BYTE_TYPE_t                      vd_type2;
BYTE_TYPE_t                      vd_type3;

logic [`VLENB-1:0]               w_enB0;
logic [`VLENB-1:0]               w_enB1;
logic [`VLENB-1:0]               w_enB2;
logic [`VLENB-1:0]               w_enB3;

logic [`REGFILE_INDEX_WIDTH-1:0] w_addr0;
logic [`REGFILE_INDEX_WIDTH-1:0] w_addr1;
logic [`REGFILE_INDEX_WIDTH-1:0] w_addr2;
logic [`REGFILE_INDEX_WIDTH-1:0] w_addr3;

logic                            w_valid0;
logic                            w_valid1;
logic                            w_valid2;
logic                            w_valid3;

logic [`VLEN-1:0]                w_data0;
logic [`VLEN-1:0]                w_data1;
logic [`VLEN-1:0]                w_data2;
logic [`VLEN-1:0]                w_data3;

logic                            trap_flag0;
logic                            trap_flag1;
logic                            trap_flag2;
logic                            trap_flag3;

RVVConfigState                  w_vcsr0;
RVVConfigState                  w_vcsr1;
RVVConfigState                  w_vcsr2;
RVVConfigState                  w_vcsr3;

logic [`VLENB-1:0]              w_vxsaturate0;
logic [`VLENB-1:0]              w_vxsaturate1;
logic [`VLENB-1:0]              w_vxsaturate2;
logic [`VLENB-1:0]              w_vxsaturate3;

logic [`VCSR_VXSAT_WIDTH-1:0]    w_vxsat0;
logic [`VCSR_VXSAT_WIDTH-1:0]    w_vxsat1;
logic [`VCSR_VXSAT_WIDTH-1:0]    w_vxsat2;
logic [`VCSR_VXSAT_WIDTH-1:0]    w_vxsat3;

logic [`NUM_RT_UOP-1:0]          rob2rt_is_to_vrf;

logic [`VLENB-1:0]               waw2_in_enB0;
logic [`REGFILE_INDEX_WIDTH-1:0] waw2_in_addr0;
logic [`VLENB-1:0]               waw2_in_enB1;
logic [`REGFILE_INDEX_WIDTH-1:0] waw2_in_addr1;
logic [`VLENB-1:0]               w_enB0_waw2_int;

logic [`VLENB-1:0]               waw3_in_enB0;
logic [`REGFILE_INDEX_WIDTH-1:0] waw3_in_addr0;
logic [`VLENB-1:0]               waw3_in_enB1;
logic [`REGFILE_INDEX_WIDTH-1:0] waw3_in_addr1;
logic [`VLENB-1:0]               waw3_in_enB2;
logic [`REGFILE_INDEX_WIDTH-1:0] waw3_in_addr2;
logic [`VLENB-1:0]               w_enB0_waw3_int;
logic [`VLENB-1:0]               w_enB1_waw3_int;

logic [`VLENB-1:0]               waw4_in_enB0;
logic [`REGFILE_INDEX_WIDTH-1:0] waw4_in_addr0;
logic [`VLENB-1:0]               waw4_in_enB1;
logic [`REGFILE_INDEX_WIDTH-1:0] waw4_in_addr1;
logic [`VLENB-1:0]               waw4_in_enB2;
logic [`REGFILE_INDEX_WIDTH-1:0] waw4_in_addr2;
logic [`VLENB-1:0]               waw4_in_enB3;
logic [`REGFILE_INDEX_WIDTH-1:0] waw4_in_addr3;
logic [`VLENB-1:0]               w_enB0_waw4_int;
logic [`VLENB-1:0]               w_enB1_waw4_int;
logic [`VLENB-1:0]               w_enB2_waw4_int;

logic [`VLENB-1:0]               w_enB1_waw3_int_tmp;
logic [`VLENB-1:0]               w_enB1_waw4_int_tmp;
logic [`VLENB-1:0]               w_enB2_waw4_int_tmp;

logic [`VLENB-1:0]               w_enB0_mux;
logic [`VLENB-1:0]               w_enB1_mux;
logic [`VLENB-1:0]               w_enB2_mux;
logic [`VLENB-1:0]               w_enB3_mux;

logic                            w_valid0_chkTrap;
logic                            w_valid1_chkTrap;
logic                            w_valid2_chkTrap;
logic                            w_valid3_chkTrap;

logic                            retire_has_trap;
logic                            retire_has_vxsat;
logic                            vxsat2rt_ready_int;

genvar                           j;

/////////////////////////////////
////////////Decode///////////////
/////////////////////////////////
assign w_type0 = rob2rt_write_data[0].w_type; //0:vrf 1:xrf
assign w_type1 = rob2rt_write_data[1].w_type;
assign w_type2 = rob2rt_write_data[2].w_type;
assign w_type3 = rob2rt_write_data[3].w_type;

assign vd_type0 = rob2rt_write_data[0].vd_type;
assign vd_type1 = rob2rt_write_data[1].vd_type;
assign vd_type2 = rob2rt_write_data[2].vd_type;
assign vd_type3 = rob2rt_write_data[3].vd_type;

assign w_addr0 = rob2rt_write_data[0].w_index;
assign w_addr1 = rob2rt_write_data[1].w_index;
assign w_addr2 = rob2rt_write_data[2].w_index;
assign w_addr3 = rob2rt_write_data[3].w_index;

assign w_valid0 = rob2rt_write_data[0].w_valid;
assign w_valid1 = rob2rt_write_data[1].w_valid;
assign w_valid2 = rob2rt_write_data[2].w_valid;
assign w_valid3 = rob2rt_write_data[3].w_valid;

assign w_data0 = rob2rt_write_data[0].w_data;
assign w_data1 = rob2rt_write_data[1].w_data;
assign w_data2 = rob2rt_write_data[2].w_data;
assign w_data3 = rob2rt_write_data[3].w_data;

assign trap_flag0 = rob2rt_write_data[0].trap_flag;
assign trap_flag1 = rob2rt_write_data[1].trap_flag;
assign trap_flag2 = rob2rt_write_data[2].trap_flag;
assign trap_flag3 = rob2rt_write_data[3].trap_flag;

assign w_vcsr0 = rob2rt_write_data[0].vector_csr;
assign w_vcsr1 = rob2rt_write_data[1].vector_csr;
assign w_vcsr2 = rob2rt_write_data[2].vector_csr;
assign w_vcsr3 = rob2rt_write_data[3].vector_csr;

generate
  for (j=0;j<`VLENB;j++) begin: GET_SAT
    assign w_vxsaturate0[j] = (vd_type0[j]==BODY_ACTIVE) ? rob2rt_write_data[0].vxsaturate[j] : 1'b0;
    assign w_vxsaturate1[j] = (vd_type1[j]==BODY_ACTIVE) ? rob2rt_write_data[1].vxsaturate[j] : 1'b0;
    assign w_vxsaturate2[j] = (vd_type2[j]==BODY_ACTIVE) ? rob2rt_write_data[2].vxsaturate[j] : 1'b0;
    assign w_vxsaturate3[j] = (vd_type3[j]==BODY_ACTIVE) ? rob2rt_write_data[3].vxsaturate[j] : 1'b0;
  end
endgenerate

assign w_vxsat0 = w_vxsaturate0!='b0;
assign w_vxsat1 = w_vxsaturate1!='b0;
assign w_vxsat2 = w_vxsaturate2!='b0;
assign w_vxsat3 = w_vxsaturate3!='b0;

/////////////////////////////////
////////////Main  ///////////////
/////////////////////////////////
//1. Check whether uop is a VRF req
assign rob2rt_is_to_vrf[0] = rob2rt_write_valid[0] && !w_type0 && w_valid0;
assign rob2rt_is_to_vrf[1] = rob2rt_write_valid[1] && !w_type1 && w_valid1;
assign rob2rt_is_to_vrf[2] = rob2rt_write_valid[2] && !w_type2 && w_valid2;
assign rob2rt_is_to_vrf[3] = rob2rt_write_valid[3] && !w_type3 && w_valid3;

//2. Mask update if the bit is body-active
always@(*) begin
  for(int i=0; i<`VLENB; i=i+1) begin
    w_enB0[i] = (rob2rt_write_data[0].vd_type[i] == 2'b11);
    w_enB1[i] = (rob2rt_write_data[1].vd_type[i] == 2'b11);
    w_enB2[i] = (rob2rt_write_data[2].vd_type[i] == 2'b11);
    w_enB3[i] = (rob2rt_write_data[3].vd_type[i] == 2'b11);
  end
end

//3. Shared resources for Write-After-Write (WAW) check 
//  3.1. Submodule: WAW among 2 uops
always@(*) begin
  for(int i=0; i<`VLENB; i=i+1) begin
    if (waw2_in_addr0 == waw2_in_addr1) begin//check waw01
      w_enB0_waw2_int[i] = waw2_in_enB0[i] && !waw2_in_enB1[i];
    end
    else begin
      w_enB0_waw2_int[i] = waw2_in_enB0[i];
    end
  end //end for
end

//  3.2. Submodule: WAW among 3 uops
always@(*) begin
  for(int i=0; i<`VLENB; i=i+1) begin
    if (waw3_in_addr1 == waw3_in_addr2) begin //check waw12 first
      w_enB1_waw3_int[i] = waw3_in_enB1[i] && !waw3_in_enB2[i];
      w_enB1_waw3_int_tmp[i] = waw3_in_enB1[i] || waw3_in_enB2[i]; //tmp perform OR to cover 12
      if (waw3_in_addr0 == waw3_in_addr1) begin //waw012 all happens
        w_enB0_waw3_int[i] = waw3_in_enB0[i] && !w_enB1_waw3_int_tmp[i];
      end
      else begin //only waw12
        w_enB0_waw3_int[i] = waw3_in_enB0[i];
      end
    end //end addr1==addr2
    else if (waw3_in_addr0 == waw3_in_addr2) begin //check waw02
      w_enB0_waw3_int[i] = waw3_in_enB0[i] && !waw3_in_enB2[i];
      w_enB1_waw3_int[i] = waw3_in_enB1[i];
    end
    else if (waw3_in_addr0 == waw3_in_addr1) begin //check waw01
      w_enB0_waw3_int[i] = waw3_in_enB0[i] && !waw3_in_enB1[i];
      w_enB1_waw3_int[i] = waw3_in_enB1[i];
    end
    else begin
      w_enB0_waw3_int[i] = waw3_in_enB0[i];
      w_enB1_waw3_int[i] = waw3_in_enB1[i];
    end
  end//end for
end//end always

//  3.3. Submodule: WAW among 4 uops
always@(*) begin
  for(int i=0; i<`VLENB; i=i+1) begin
    if (waw4_in_addr2 == waw4_in_addr3) begin//check waw23 first
      w_enB2_waw4_int[i] = waw4_in_enB2[i] && !waw4_in_enB3[i];
      w_enB2_waw4_int_tmp[i] = waw4_in_enB2[i] || waw4_in_enB3[i]; //tmp perform OR to cover 23
      if (waw4_in_addr1 == waw4_in_addr2) begin //2=3, 1=2
        w_enB1_waw4_int[i] = waw4_in_enB1[i] && !w_enB2_waw4_int_tmp[i];
        w_enB1_waw4_int_tmp[i] = waw4_in_enB1[i] || w_enB2_waw4_int_tmp[i];//tmp perform OR to cover 123
        if (waw4_in_addr0 == waw4_in_addr1) begin //2=3, 1=2, 0=1 #case1
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !w_enB1_waw4_int_tmp[i];
        end
        else begin//2=3, 1=2, 0!=1 #case2
          w_enB0_waw4_int[i] = waw4_in_enB0[i];
        end
      end
      else if (waw4_in_addr0 == waw4_in_addr2) begin //2=3, 1!=2, 0=2 #case3
        w_enB0_waw4_int[i] = waw4_in_enB0[i] && !w_enB2_waw4_int_tmp[i];
        w_enB1_waw4_int[i] = waw4_in_enB1[i];
      end
      else if (waw4_in_addr0 == waw4_in_addr1) begin //2=3, 1!=2, 0=1 #case4
        w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB1[i];
        w_enB1_waw4_int[i] = waw4_in_enB1[i];
      end
      else begin //2=3, 0!=1!=2 #case5
        w_enB0_waw4_int[i] = waw4_in_enB0[i];
        w_enB1_waw4_int[i] = waw4_in_enB1[i];
      end
    end//end 2=3 if
    else begin //2!=3
      w_enB2_waw4_int[i] = waw4_in_enB2[i];
      if (waw4_in_addr1 == waw4_in_addr2) begin //2!=3, 1=2
        w_enB1_waw4_int[i] = waw4_in_enB1[i] && !waw4_in_enB2[i];
        w_enB1_waw4_int_tmp[i] = waw4_in_enB1[i] || waw4_in_enB2[i]; //tmp perform OR to cover 12
        if (waw4_in_addr0 == waw4_in_addr1) begin //2!=3, 1=2, 0=1 #case6
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !w_enB1_waw4_int_tmp[i]; 
        end
        else if (waw4_in_addr0 == waw4_in_addr3) begin //2!=3, 1=2, 0=3 #case7
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB3[i];
        end
        else begin //2!=3, 1=2, 0!=1 && 0!=3 # case8
          w_enB0_waw4_int[i] = waw4_in_enB0[i];
        end
      end
      else if (waw4_in_addr1 == waw4_in_addr3) begin //2!=3, 1!=2, 1=3
        w_enB1_waw4_int[i] = waw4_in_enB1[i] && !waw4_in_enB3[i];
        w_enB1_waw4_int_tmp[i] = waw4_in_enB1[i] || waw4_in_enB3[i]; //tmp perform OR to cover 13
        if (waw4_in_addr0 == waw4_in_addr2) begin //2!=3, 1!=2, 1=3, 0=2 #case9
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB2[i];
        end
        else if (waw4_in_addr0 == waw4_in_addr1) begin //2!=3, 1!=2, 1=3, 0=1 #case10
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !w_enB1_waw4_int_tmp[i];
        end
        else begin //2!=3, 1!=2, 1=3, 0!=1 #case11
          w_enB0_waw4_int[i] = waw4_in_enB0[i];
        end
      end
      else begin //2!=3, 1!=2, 1!=3
        w_enB1_waw4_int[i] = waw4_in_enB1[i];
        if (waw4_in_addr0 == waw4_in_addr3) begin //2!=3, 1!=2, 1!=3, 0=3 #case12
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB3[i];
        end
        else if (waw4_in_addr0 == waw4_in_addr2) begin //2!=3, 1!=2, 1!=3, 0=2 #case13
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB2[i];
        end
        else if (waw4_in_addr0 == waw4_in_addr1) begin //2!=3, 1!=2, 1!=3, 0=1 #case14
          w_enB0_waw4_int[i] = waw4_in_enB0[i] && !waw4_in_enB1[i];
        end
        else begin //4 all different #case15
          w_enB0_waw4_int[i] = waw4_in_enB0[i];
        end
      end
    end//end 2!=3 if
  end//end for
end//end always

//4. Combine vrf group and WAW check
always@(*) begin
  case (rob2rt_is_to_vrf)
    4'b0000, 4'b0001, 4'b0010, 4'b0100, 4'b1000 : begin //only 1 uop is to vrf, not need WAW
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0;
      w_enB1_mux = w_enB1;
      w_enB2_mux = w_enB2;
      w_enB3_mux = w_enB3;
    end
    4'b0011 : begin //uop 0/1 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB0;
      waw2_in_addr0 = w_addr0;
      waw2_in_enB1 = w_enB1;
      waw2_in_addr1 = w_addr1;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB1_mux = w_enB1;
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b0101 : begin //uop 0/2 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB0;
      waw2_in_addr0 = w_addr0;
      waw2_in_enB1 = w_enB2;
      waw2_in_addr1 = w_addr2;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB1_mux = w_enB1; 
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b0110 : begin //uop 1/2 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB1;
      waw2_in_addr0 = w_addr1;
      waw2_in_enB1 = w_enB2;
      waw2_in_addr1 = w_addr2;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0;
      w_enB1_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b0111 : begin //uop 0/1/2 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = w_enB0;
      waw3_in_addr0 = w_addr0;
      waw3_in_enB1 = w_enB1;
      waw3_in_addr1 = w_addr1;
      waw3_in_enB2 = w_enB2;
      waw3_in_addr2 = w_addr2;
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw3_int; //0 marks for the lowest out of WAW3
      w_enB1_mux = w_enB1_waw3_int; //1 marks for the 2nd lowest out of WAW3 
      w_enB2_mux = w_enB2;
      w_enB3_mux = w_enB3;
    end
    4'b1001 : begin //uop 0/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB0;
      waw2_in_addr0 = w_addr0;
      waw2_in_enB1 = w_enB3;
      waw2_in_addr1 = w_addr3;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB1_mux = w_enB1; 
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b1010 : begin //uop 1/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB1;
      waw2_in_addr0 = w_addr1;
      waw2_in_enB1 = w_enB3;
      waw2_in_addr1 = w_addr3;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0; 
      w_enB1_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b1011 : begin //uop 0/1/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = w_enB0;
      waw3_in_addr0 = w_addr0;
      waw3_in_enB1 = w_enB1;
      waw3_in_addr1 = w_addr1;
      waw3_in_enB2 = w_enB3;
      waw3_in_addr2 = w_addr3;
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw3_int; //0 marks for the lowest out of WAW3
      w_enB1_mux = w_enB1_waw3_int; //1 marks for the 2nd lowest out of WAW3
      w_enB2_mux = w_enB2; 
      w_enB3_mux = w_enB3;
    end
    4'b1100 : begin //uop 2/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = w_enB2;
      waw2_in_addr0 = w_addr2;
      waw2_in_enB1 = w_enB3;
      waw2_in_addr1 = w_addr3;
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0; 
      w_enB1_mux = w_enB1; 
      w_enB2_mux = w_enB0_waw2_int; //0 marks for the lower out of WAW2
      w_enB3_mux = w_enB3;
    end
    4'b1101 : begin //uop 0/2/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = w_enB0;
      waw3_in_addr0 = w_addr0;
      waw3_in_enB1 = w_enB2;
      waw3_in_addr1 = w_addr2;
      waw3_in_enB2 = w_enB3;
      waw3_in_addr2 = w_addr3;
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0_waw3_int; //0 marks for the lowest out of WAW3
      w_enB1_mux = w_enB1; 
      w_enB2_mux = w_enB1_waw3_int; //1 marks for the 2nd lowest out of WAW3
      w_enB3_mux = w_enB3;
    end
    4'b1110 : begin //uop 1/2/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = w_enB1;
      waw3_in_addr0 = w_addr1;
      waw3_in_enB1 = w_enB2;
      waw3_in_addr1 = w_addr2;
      waw3_in_enB2 = w_enB3;
      waw3_in_addr2 = w_addr3;
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0; 
      w_enB1_mux = w_enB0_waw3_int; //0 marks for the lowest out of WAW3
      w_enB2_mux = w_enB1_waw3_int; //1 marks for the 2nd lowest out of WAW3
      w_enB3_mux = w_enB3;
    end
    4'b1111 : begin //uop 0/1/2/3 are to vrf
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = w_enB0;
      waw4_in_addr0 = w_addr0;
      waw4_in_enB1 = w_enB1;
      waw4_in_addr1 = w_addr1;
      waw4_in_enB2 = w_enB2;
      waw4_in_addr2 = w_addr2;
      waw4_in_enB3 = w_enB3;
      waw4_in_addr3 = w_addr3;
      //Output mux
      w_enB0_mux = w_enB0_waw4_int;
      w_enB1_mux = w_enB1_waw4_int;
      w_enB2_mux = w_enB2_waw4_int;
      w_enB3_mux = w_enB3;
    end
    default : begin
      //Input mux
      //WAW2 part
      waw2_in_enB0 = {`VLENB{1'b0}};
      waw2_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw2_in_enB1 = {`VLENB{1'b0}};
      waw2_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW3 part
      waw3_in_enB0 = {`VLENB{1'b0}};
      waw3_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB1 = {`VLENB{1'b0}};
      waw3_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw3_in_enB2 = {`VLENB{1'b0}};
      waw3_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //WAW4 part
      waw4_in_enB0 = {`VLENB{1'b0}};
      waw4_in_addr0 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB1 = {`VLENB{1'b0}};
      waw4_in_addr1 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB2 = {`VLENB{1'b0}};
      waw4_in_addr2 = {`REGFILE_INDEX_WIDTH{1'b0}};
      waw4_in_enB3 = {`VLENB{1'b0}};
      waw4_in_addr3 = {`REGFILE_INDEX_WIDTH{1'b0}};
      //Output mux
      w_enB0_mux = w_enB0;
      w_enB1_mux = w_enB1;
      w_enB2_mux = w_enB2;
      w_enB3_mux = w_enB3;
    end
  endcase
end

`ifdef TB_SUPPORT
`ifdef ASSERT_ON
  logic [`NUM_RT_UOP-1:0] [`NUM_RT_UOP-1:0] vidx_eq;
  logic [`NUM_RT_UOP-1:0] [`NUM_RT_UOP-1:0] vstrobe_conflict;

  genvar gv_i, gv_j;
  generate
    for(gv_i=0; gv_i<`NUM_RT_UOP; gv_i++) begin: gen_upper_uops
      for(gv_j=0; gv_j<`NUM_RT_UOP; gv_j++) begin: gen_lower_uops
        if(gv_i > gv_j) begin: gen_check
          assign vidx_eq[gv_i][gv_j] = (rt2vrf_write_valid[gv_i] && rt2vrf_write_valid[gv_j] &&
                                        rt2vrf_write_data[gv_i].rt_index === rt2vrf_write_data[gv_j].rt_index);
          assign vstrobe_conflict[gv_i][gv_j] = vidx_eq[gv_i][gv_j] && |(rt2vrf_write_data[gv_i].rt_strobe & rt2vrf_write_data[gv_j].rt_strobe);
          VRFWriteStrobeConflict: `rvv_forbid(vstrobe_conflict[gv_i][gv_j])
            else $error("Uop %0d write to vrf[%0d] with strobe = 0x%4h\nUop %0d write to vrf[%0d] with strobe = 0x%4h\n",
                        gv_i, $sampled(rt2vrf_write_data[gv_i].rt_index), $sampled(rt2vrf_write_data[gv_i].rt_strobe),
                        gv_j, $sampled(rt2vrf_write_data[gv_j].rt_index), $sampled(rt2vrf_write_data[gv_j].rt_strobe));
        end else begin: gen_ignore_check
          assign vidx_eq[gv_i][gv_j] = '0;
          assign vstrobe_conflict[gv_i][gv_j] = '0;
        end
      end
    end
  endgenerate 

`endif // ASSERT_ON
`endif // TB_SUPPORT

//5. OutValid generation & OutData pack
//  5.1. When trap, clean the latter valid
assign w_valid0_chkTrap = !trap_flag0 && w_valid0;
assign w_valid1_chkTrap = !trap_flag0 && w_valid1;
assign w_valid2_chkTrap = !(trap_flag0 || trap_flag1) && w_valid2;
assign w_valid3_chkTrap = !(trap_flag0 || trap_flag1 || trap_flag2) && w_valid3;

//  5.2. To VRF
assign rt2vrf_write_valid[0] = rob2rt_write_valid[0] && w_valid0_chkTrap && !w_type0;
assign rt2vrf_write_valid[1] = rob2rt_write_valid[1] && w_valid1_chkTrap && !w_type1;
assign rt2vrf_write_valid[2] = rob2rt_write_valid[2] && w_valid2_chkTrap && !w_type2;
assign rt2vrf_write_valid[3] = rob2rt_write_valid[3] && w_valid3_chkTrap && !w_type3;
//Data
assign rt2vrf_write_data[0].rt_data = w_data0;
assign rt2vrf_write_data[1].rt_data = w_data1;
assign rt2vrf_write_data[2].rt_data = w_data2;
assign rt2vrf_write_data[3].rt_data = w_data3;
//Addr
assign rt2vrf_write_data[0].rt_index = w_addr0;
assign rt2vrf_write_data[1].rt_index = w_addr1;
assign rt2vrf_write_data[2].rt_index = w_addr2;
assign rt2vrf_write_data[3].rt_index = w_addr3;
//Byte Mask
assign rt2vrf_write_data[0].rt_strobe = w_enB0_mux;
assign rt2vrf_write_data[1].rt_strobe = w_enB1_mux;
assign rt2vrf_write_data[2].rt_strobe = w_enB2_mux;
assign rt2vrf_write_data[3].rt_strobe = w_enB3_mux;
`ifdef TB_SUPPORT
//pc
assign rt2vrf_write_data[0].uop_pc = rob2rt_write_data[0].uop_pc;
assign rt2vrf_write_data[1].uop_pc = rob2rt_write_data[1].uop_pc;
assign rt2vrf_write_data[2].uop_pc = rob2rt_write_data[2].uop_pc;
assign rt2vrf_write_data[3].uop_pc = rob2rt_write_data[3].uop_pc;
`endif

//  5.3. To XRF
assign rt2xrf_write_valid[0] = rob2rt_write_valid[0] && w_valid0_chkTrap && w_type0;
assign rt2xrf_write_valid[1] = rob2rt_write_valid[1] && w_valid1_chkTrap && w_type1;
assign rt2xrf_write_valid[2] = rob2rt_write_valid[2] && w_valid2_chkTrap && w_type2;
assign rt2xrf_write_valid[3] = rob2rt_write_valid[3] && w_valid3_chkTrap && w_type3;
//Data
assign rt2xrf_write_data[0].rt_data = w_data0[`XLEN-1:0];
assign rt2xrf_write_data[1].rt_data = w_data1[`XLEN-1:0];
assign rt2xrf_write_data[2].rt_data = w_data2[`XLEN-1:0];
assign rt2xrf_write_data[3].rt_data = w_data3[`XLEN-1:0];
//Addr
assign rt2xrf_write_data[0].rt_index = w_addr0;
assign rt2xrf_write_data[1].rt_index = w_addr1;
assign rt2xrf_write_data[2].rt_index = w_addr2;
assign rt2xrf_write_data[3].rt_index = w_addr3;
`ifdef TB_SUPPORT
//pc
assign rt2xrf_write_data[0].uop_pc = rob2rt_write_data[0].uop_pc;
assign rt2xrf_write_data[1].uop_pc = rob2rt_write_data[1].uop_pc;
assign rt2xrf_write_data[2].uop_pc = rob2rt_write_data[2].uop_pc;
assign rt2xrf_write_data[3].uop_pc = rob2rt_write_data[3].uop_pc;
`endif
//  5.4. To VCSR
//In our current arch, only uop0 can contain a trap in each cycle
//Valid
assign retire_has_trap = trap_flag0;
assign rt2vcsr_write_valid = rob2rt_write_valid[0] && retire_has_trap;
//Data
assign rt2vcsr_write_data =  w_vcsr0;

//  5.5. To vxsat
assign retire_has_vxsat = (w_valid3_chkTrap && w_vxsat3) || (w_valid2_chkTrap && w_vxsat2) || (w_valid1_chkTrap && w_vxsat1) || (w_valid0_chkTrap && w_vxsat0);
assign rt2vxsat_write_valid = (rob2rt_write_valid[3] && w_valid3_chkTrap && w_vxsat3) || 
                              (rob2rt_write_valid[2] && w_valid2_chkTrap && w_vxsat2) || 
                              (rob2rt_write_valid[1] && w_valid1_chkTrap && w_vxsat1) || 
                              (rob2rt_write_valid[0] && w_valid0_chkTrap && w_vxsat0);
assign rt2vxsat_write_data = w_vxsat3 || w_vxsat2 || w_vxsat1 || w_vxsat0;

//6. Ready generation
//Rob can only issue two cases:
//  a. all uops are valid without trap
//  b. uop0 contains trap

//this int is 1 when: 
//  a. 4 uops have no vxsat update; 
//  b. has vxsat update while vxsat rdy == 1
assign vxsat2rt_ready_int = !retire_has_vxsat || vxsat2rt_write_ready; 

assign rt2rob_write_ready[0] = retire_has_trap ? vcsr2rt_write_ready :   //use vcrs rdy
                                       w_type0 ? xrf2rt_write_ready[0] : //xrf rdy but check vxsat
                                                 vxsat2rt_ready_int;                           //vrf rdy but check vxsat, equals to (1'b1 && vxsat2rt_ready_int)
assign rt2rob_write_ready[1] = w_type1 ? xrf2rt_write_ready[1] :         //xrf rdy but check vxsat
                                         vxsat2rt_ready_int;                                   //vrf rdy but check vxsat, equals to (1'b1 && vxsat2rt_ready_int)
assign rt2rob_write_ready[2] = w_type2 ? xrf2rt_write_ready[2] :
                                         vxsat2rt_ready_int;
assign rt2rob_write_ready[3] = w_type3 ? xrf2rt_write_ready[3] : 
                                         vxsat2rt_ready_int ;
/////////////////////////////////

endmodule
// ----- 8< ----- FILE "./rvv_backend_rob.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
/*
description: 
1. the ROB module receives uop information from Dispatch unit and uop result from Processor Unit (PU).
2. the ROB module provides all status for dispatch unit to foreward operand from ROB.
3. the ROB module send retire request to retire unit.
4. the ROB module receives trap information from LSU and flush buffer(s)

feature list:
1. the ROB can receive 2 uop information form Dispatch unit at most per cycle.
2. the ROB can receive 9 uop result from PU at most per cycle.
    a. However, U-arch of RVV limit the result number from 9 to 8.
3. the ROB can send 4 retire uops to writeback unit at most per cycle.
4. the ROB infomation for dispatch need to be sorted, which depends on program order.
*/

`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_rob
(
    clk,
    rst_n,
    uop_valid_dp2rob,
    uop_dp2rob,
    uop_ready_rob2dp,
    rob_empty,
    uop_index_rob2dp,
    wr_valid_alu2rob,
    wr_alu2rob,
    wr_ready_rob2alu,
    wr_valid_pmtrdt2rob,
    wr_pmtrdt2rob,
    wr_ready_rob2pmtrdt,
    wr_valid_mul2rob,
    wr_mul2rob,
    wr_ready_rob2mul,
    wr_valid_div2rob,
    wr_div2rob,
    wr_ready_rob2div,
    wr_valid_lsu2rob,
    wr_lsu2rob,
    wr_ready_rob2lsu,
    rd_valid_rob2rt,
    rd_rob2rt,
    rd_ready_rt2rob,
    uop_rob2dp,
    trap_valid_rmp2rob,
    trap_rob_entry_rmp2rob,
    trap_ready_rob2rmp,
    trap_ready_rvv2rvs,
    trap_flush_rvv
);  
// global signal
    input   logic                   clk;
    input   logic                   rst_n;

// push uop infomation to ROB
// Dispatch to ROB
    input   logic     [`NUM_DP_UOP-1:0] uop_valid_dp2rob;
    input   DP2ROB_t  [`NUM_DP_UOP-1:0] uop_dp2rob;
    output  logic     [`NUM_DP_UOP-1:0] uop_ready_rob2dp;
    output  logic                       rob_empty;
    output  logic     [`ROB_DEPTH_WIDTH-1:0] uop_index_rob2dp;

// push uop result to ROB
// ALU to ROB
    input   logic     [`NUM_ALU-1:0]    wr_valid_alu2rob;
    input   PU2ROB_t  [`NUM_ALU-1:0]    wr_alu2rob;
    output  logic     [`NUM_ALU-1:0]    wr_ready_rob2alu;

// PMT+RED to ROB
    input   logic     [`NUM_PMTRDT-1:0] wr_valid_pmtrdt2rob;
    input   PU2ROB_t  [`NUM_PMTRDT-1:0] wr_pmtrdt2rob;
    output  logic     [`NUM_PMTRDT-1:0] wr_ready_rob2pmtrdt;

// MUL to ROB
    input   logic     [`NUM_MUL-1:0]    wr_valid_mul2rob;
    input   PU2ROB_t  [`NUM_MUL-1:0]    wr_mul2rob;
    output  logic     [`NUM_MUL-1:0]    wr_ready_rob2mul;

// DIV to ROB
    input   logic     [`NUM_DIV-1:0]    wr_valid_div2rob;
    input   PU2ROB_t  [`NUM_DIV-1:0]    wr_div2rob;
    output  logic     [`NUM_DIV-1:0]    wr_ready_rob2div;

// LSU to ROB
    input   logic     [`NUM_LSU-1:0]    wr_valid_lsu2rob;
    input   PU2ROB_t  [`NUM_LSU-1:0]    wr_lsu2rob;
    output  logic     [`NUM_LSU-1:0]    wr_ready_rob2lsu;

// retire uops
// pop vd_data from ROB and write to VRF
    output  logic     [`NUM_RT_UOP-1:0] rd_valid_rob2rt;
    output  ROB2RT_t  [`NUM_RT_UOP-1:0] rd_rob2rt;
    input   logic     [`NUM_RT_UOP-1:0] rd_ready_rt2rob;

// bypass all rob entries to Dispatch unit
// rob_entries must be in program order instead of entry_index
    output  ROB2DP_t  [`ROB_DEPTH-1:0]  uop_rob2dp;

// trap signal handshake
    input   logic                           trap_valid_rmp2rob;
    input   logic   [`ROB_DEPTH_WIDTH-1:0]  trap_rob_entry_rmp2rob;
    output  logic                           trap_ready_rob2rmp;
    output  logic                           trap_ready_rvv2rvs;
    output  logic                           trap_flush_rvv;

// ---internal signal definition--------------------------------------
  // Uop info
    DP2ROB_t  [`NUM_RT_UOP-1:0]         uop_rob2rt;
    logic     [`NUM_RT_UOP-1:0]         uop_valid_rob2rt;
    DP2ROB_t  [`ROB_DEPTH-1:0]          uop_info;
    logic     [`ROB_DEPTH-1:0]          entry_valid;

    logic     [`ROB_DEPTH_WIDTH-1:0]    uop_wptr;
    logic     [`ROB_DEPTH_WIDTH-1:0]    uop_rptr;
    logic                               uop_info_fifo_full;
    logic     [`NUM_DP_UOP-1:0]         uop_info_fifo_almost_full;

  // Uop result
    RES_ROB_t [`ROB_DEPTH-1:0]          res_mem;
    logic     [`ROB_DEPTH-1:0]          uop_done;

  // trap
    logic     [`ROB_DEPTH-1:0]          trap_flag;

  // retire uops
    logic     [`NUM_RT_UOP-1:0]         uop_retire_valid;

  // temp signal
    logic     [`ROB_DEPTH_WIDTH-1:0]    wind_uop_wptr [`ROB_DEPTH-1:0];
    logic     [`ROB_DEPTH_WIDTH-1:0]    wind_uop_rptr [`ROB_DEPTH-1:0];

    genvar                              i,j;
// ---code start------------------------------------------------------
  // Uop info FIFO
    multi_fifo #(
        .T            (DP2ROB_t),
        .M            (`NUM_DP_UOP),
        .N            (`NUM_RT_UOP),
        .DEPTH        (`ROB_DEPTH),
        .CHAOS_PUSH   (1'b1),
        .ASYNC_RSTN   (1'b1),
        .FULL_PUSH    (1'b1)
    ) u_uop_info_fifo (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // push side
        .push         (uop_valid_dp2rob & uop_ready_rob2dp),
        .datain       (uop_dp2rob),
        .full         (uop_info_fifo_full),
        .almost_full  (uop_info_fifo_almost_full),
      // pop side
        .pop          (rd_valid_rob2rt & rd_ready_rt2rob),
        .dataout      (uop_rob2rt),
        .empty        (rob_empty),
        .almost_empty (),
      // fifo info
        .clear        (trap_flush_rvv),
        .fifo_data    (uop_info),
        .wptr         (uop_wptr),
        .rptr         (uop_rptr),
        .entry_count  ()
    );

    assign uop_index_rob2dp = uop_wptr;
    assign uop_ready_rob2dp[0] = ~uop_info_fifo_full;
    generate
        for (i=1; i<`NUM_DP_UOP; i++) begin : gen_ready_rob2dp
            assign uop_ready_rob2dp[i] = ~uop_info_fifo_almost_full[i];
        end
    endgenerate

  // entry valid
  // set if DP push uop into ROB
  // clear if RT pop uop from ROB
  // reset once flush ROB
    multi_fifo #(
        .T            (logic),
        .M            (`NUM_DP_UOP),
        .N            (`NUM_RT_UOP),
        .DEPTH        (`ROB_DEPTH),
        .POP_CLEAR    (1'b1),
        .ASYNC_RSTN   (1'b1),
        .CHAOS_PUSH   (1'b1),
        .FULL_PUSH    (1'b1)
    ) u_uop_valid_fifo (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // push side
        .push         (uop_valid_dp2rob & uop_ready_rob2dp),
        .datain       (uop_valid_dp2rob),
        .full         (),
        .almost_full  (),
      // pop side
        .pop          (rd_valid_rob2rt & rd_ready_rt2rob),
        .dataout      (uop_valid_rob2rt),
        .empty        (),
        .almost_empty (),
      // fifo info
        .clear        (trap_flush_rvv),
        .fifo_data    (entry_valid),
        .wptr         (),
        .rptr         (),
        .entry_count  ()
    );

  // update PU result to result memory
    always_ff @(posedge clk, negedge rst_n) begin
        if (!rst_n)
          res_mem <= 'b0;
        else begin
            for (int k=0; k<`NUM_ALU; k++) begin
                if (wr_valid_alu2rob[k] && wr_ready_rob2alu[k]) begin
                  `ifdef TB_SUPPORT
                    res_mem[wr_alu2rob[k].rob_entry].uop_pc <= wr_alu2rob[k].uop_pc;
                  `endif                
                    res_mem[wr_alu2rob[k].rob_entry].w_valid <= wr_alu2rob[k].w_valid;
                    res_mem[wr_alu2rob[k].rob_entry].w_data  <= wr_alu2rob[k].w_data;
                    res_mem[wr_alu2rob[k].rob_entry].vsaturate <= wr_alu2rob[k].vsaturate;
                end
            end
            for (int k=0; k<`NUM_PMTRDT; k++) begin
                if (wr_valid_pmtrdt2rob[k] && wr_ready_rob2pmtrdt[k]) begin
                  `ifdef TB_SUPPORT
                    res_mem[wr_pmtrdt2rob[k].rob_entry].uop_pc <= wr_pmtrdt2rob[k].uop_pc;
                  `endif                
                    res_mem[wr_pmtrdt2rob[k].rob_entry].w_valid <= wr_pmtrdt2rob[k].w_valid;
                    res_mem[wr_pmtrdt2rob[k].rob_entry].w_data  <= wr_pmtrdt2rob[k].w_data;
                    res_mem[wr_pmtrdt2rob[k].rob_entry].vsaturate <= wr_pmtrdt2rob[k].vsaturate;
                end
            end
            for (int k=0; k<`NUM_MUL; k++) begin
                if (wr_valid_mul2rob[k] && wr_ready_rob2mul[k]) begin
                  `ifdef TB_SUPPORT
                    res_mem[wr_mul2rob[k].rob_entry].uop_pc  <= wr_mul2rob[k].uop_pc;
                  `endif                
                    res_mem[wr_mul2rob[k].rob_entry].w_valid <= wr_mul2rob[k].w_valid;
                    res_mem[wr_mul2rob[k].rob_entry].w_data  <= wr_mul2rob[k].w_data;
                    res_mem[wr_mul2rob[k].rob_entry].vsaturate <= wr_mul2rob[k].vsaturate;
                end
            end
            for (int k=0; k<`NUM_DIV; k++) begin
                if (wr_valid_div2rob[k] && wr_ready_rob2div[k]) begin
                  `ifdef TB_SUPPORT
                    res_mem[wr_div2rob[k].rob_entry].uop_pc  <= wr_div2rob[k].uop_pc;
                  `endif                
                    res_mem[wr_div2rob[k].rob_entry].w_valid <= wr_div2rob[k].w_valid;
                    res_mem[wr_div2rob[k].rob_entry].w_data  <= wr_div2rob[k].w_data;
                    res_mem[wr_div2rob[k].rob_entry].vsaturate <= wr_div2rob[k].vsaturate;
                end
            end
            for (int k=0; k<`NUM_LSU; k++) begin
                if (wr_valid_lsu2rob[k] && wr_ready_rob2lsu[k]) begin
                  `ifdef TB_SUPPORT
                    res_mem[wr_lsu2rob[k].rob_entry].uop_pc  <= wr_lsu2rob[k].uop_pc;
                  `endif                
                    res_mem[wr_lsu2rob[k].rob_entry].w_valid <= wr_lsu2rob[k].w_valid;
                    res_mem[wr_lsu2rob[k].rob_entry].w_data  <= wr_lsu2rob[k].w_data;
                    res_mem[wr_lsu2rob[k].rob_entry].vsaturate <= wr_lsu2rob[k].vsaturate;
                end
            end
        end
    end
    
    // readys for PUs are always 1
    generate
        for (i=0; i<`NUM_ALU; i++) assign wr_ready_rob2alu[i] = 1'b1;
        for (i=0; i<`NUM_PMTRDT; i++) assign wr_ready_rob2pmtrdt[i] = 1'b1;
        for (i=0; i<`NUM_MUL; i++) assign wr_ready_rob2mul[i] = 1'b1;
        for (i=0; i<`NUM_DIV; i++) assign wr_ready_rob2div[i] = 1'b1;
        for (i=0; i<`NUM_LSU; i++) assign wr_ready_rob2lsu[i] = 1'b1;
    endgenerate

  // uop done
  // set if PU update uop result
  // clear if RT pop uop reuslt from ROB
  // reset once flush ROB.

  // wind back pointer
     generate
         for (i=0; i<`ROB_DEPTH; i++) assign wind_uop_rptr[i] = uop_rptr+i;
         for (i=0; i<`ROB_DEPTH; i++) assign wind_uop_wptr[i] = uop_wptr+i;
     endgenerate
    
     always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            uop_done <= '0;
        else if (trap_flush_rvv)
            uop_done <= '0;
        else begin
            for (int k=0; k<`NUM_RT_UOP; k++) begin
                if (rd_valid_rob2rt[k] && rd_ready_rt2rob[k])
                    uop_done[wind_uop_rptr[k]] <= 1'b0;
            end
            for (int k=0; k<`NUM_ALU; k++) begin
                if (wr_valid_alu2rob[k] && wr_ready_rob2alu[k])
                    uop_done[wr_alu2rob[k].rob_entry] <= 1'b1;
            end
            for (int k=0; k<`NUM_PMTRDT; k++) begin
                if (wr_valid_pmtrdt2rob[k] && wr_ready_rob2pmtrdt[k])
                    uop_done[wr_pmtrdt2rob[k].rob_entry] <= 1'b1;
            end
            for (int k=0; k<`NUM_MUL; k++) begin
                if (wr_valid_mul2rob[k] && wr_ready_rob2mul[k])
                    uop_done[wr_mul2rob[k].rob_entry] <= 1'b1;
            end
            for (int k=0; k<`NUM_DIV; k++) begin
                if (wr_valid_div2rob[k] && wr_ready_rob2div[k])
                    uop_done[wr_div2rob[k].rob_entry] <= 1'b1;
            end
            for (int k=0; k<`NUM_LSU; k++) begin
                if (wr_valid_lsu2rob[k] && wr_ready_rob2lsu[k])
                    uop_done[wr_lsu2rob[k].rob_entry] <= 1'b1;
            end
        end
    end

  `ifdef ASSERT_ON 
    logic [`ROB_DEPTH-1:0][`NUM_PU-1:0] res_sel; // one hot code for each entry
    generate
        for (i=0; i<`ROB_DEPTH; i++) begin
            for (j=0; j<`NUM_ALU; j++)    
                assign res_sel[i][j]                                        = wr_valid_alu2rob[j]    && wr_ready_rob2alu[j]    && (wr_alu2rob[j].rob_entry == i);
            for (j=0; j<`NUM_PMTRDT; j++) 
                assign res_sel[i][j+`NUM_ALU]                               = wr_valid_pmtrdt2rob[j] && wr_ready_rob2pmtrdt[j] && (wr_pmtrdt2rob[j].rob_entry == i);
            for (j=0; j<`NUM_MUL; j++)    
                assign res_sel[i][j+`NUM_PMTRDT+`NUM_ALU]                   = wr_valid_mul2rob[j]    && wr_ready_rob2mul[j]    && (wr_mul2rob[j].rob_entry == i);
            for (j=0; j<`NUM_DIV; j++)    
                assign res_sel[i][j+`NUM_MUL+`NUM_PMTRDT+`NUM_ALU]          = wr_valid_div2rob[j]    && wr_ready_rob2div[j]    && (wr_div2rob[j].rob_entry == i);
            for (j=0; j<`NUM_LSU; j++)    
                assign res_sel[i][j+`NUM_DIV+`NUM_MUL+`NUM_PMTRDT+`NUM_ALU] = wr_valid_lsu2rob[j]    && wr_ready_rob2lsu[j]    && (wr_lsu2rob[j].rob_entry == i);

            `rvv_expect($onehot0(res_sel[i])) else $error("ROB: Multiple PU results write same entry: index %d, PU %d\n", i, $sampled(res_sel[i]));
        end
    endgenerate
  `endif

  // trap flag
  // write trap to ROB when trap occurs
  // flush all fifo when the uop triggering trap is the oldest uop in ROB
  always_ff @(posedge clk or negedge rst_n) begin
      if (!rst_n)
          trap_flag <= '0;
      else if (trap_flush_rvv)
          trap_flag <= '0;
      else if (trap_valid_rmp2rob & trap_ready_rob2rmp)
          trap_flag[trap_rob_entry_rmp2rob] <= 1'b1;
  end

  // trap ready is always 1
  assign trap_ready_rob2rmp = 1'b1;

  // retire uop(s)
  generate
      for (i=0; i<`NUM_RT_UOP; i++) begin : gen_rob2rt
        // retire_uop valid
          if (i==0) begin
            assign uop_retire_valid[0] = uop_valid_rob2rt[0] & (uop_done[wind_uop_rptr[0]]|trap_flag[wind_uop_rptr[i]]);
            assign rd_valid_rob2rt[0] = rd_ready_rt2rob[0] && uop_retire_valid[0];
          end
          else begin
            assign uop_retire_valid[i] = uop_valid_rob2rt[i] & uop_done[wind_uop_rptr[i]];
            assign rd_valid_rob2rt[i] = rd_ready_rt2rob[i] && uop_retire_valid[i] && rd_valid_rob2rt[i-1] && ~trap_flag[wind_uop_rptr[i]-1'b1];
          end

        // retire_uop data
`ifdef TB_SUPPORT          
          assign rd_rob2rt[i].uop_pc  = uop_rob2rt[i].uop_pc;
          assign rd_rob2rt[i].last_uop_valid = uop_rob2rt[i].last_uop_valid;
`endif          
          assign rd_rob2rt[i].w_valid = res_mem[wind_uop_rptr[i]].w_valid & uop_done[wind_uop_rptr[i]];
          assign rd_rob2rt[i].w_index = uop_rob2rt[i].w_index;
          assign rd_rob2rt[i].w_data  = res_mem[wind_uop_rptr[i]].w_data;
          assign rd_rob2rt[i].w_type  = uop_rob2rt[i].w_type;
          assign rd_rob2rt[i].vd_type = uop_rob2rt[i].byte_type;
          assign rd_rob2rt[i].trap_flag = trap_flag[wind_uop_rptr[i]];
          assign rd_rob2rt[i].vector_csr = uop_rob2rt[i].vector_csr;
          assign rd_rob2rt[i].vxsaturate = res_mem[wind_uop_rptr[i]].vsaturate;
      end
  endgenerate
  
  // trap handle ready and flush signal
  assign trap_ready_rvv2rvs = rd_rob2rt[0].trap_flag & rd_ready_rt2rob[0] & uop_retire_valid[0];
  assign trap_flush_rvv = trap_ready_rvv2rvs;

  // bypass ROB info to Dispatch
  generate
      for (i=0; i<`ROB_DEPTH; i++) begin : gen_rob2dp
`ifdef TB_SUPPORT
          assign uop_rob2dp[i].uop_pc  = uop_info[i].uop_pc;
`endif
          assign uop_rob2dp[i].valid   = entry_valid[i];
          assign uop_rob2dp[i].w_valid = res_mem[wind_uop_rptr[i]].w_valid & uop_done[wind_uop_rptr[i]];
          assign uop_rob2dp[i].w_index = uop_info[i].w_index;
          assign uop_rob2dp[i].w_type  = uop_info[i].w_type;
          assign uop_rob2dp[i].w_data  = res_mem[wind_uop_rptr[i]].w_data;
          assign uop_rob2dp[i].byte_type = uop_info[i].byte_type;
          assign uop_rob2dp[i].vector_csr = uop_info[i].vector_csr;
      end
  endgenerate
  
endmodule
// ----- 8< ----- FILE "./rvv_backend_vrf_reg.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// rvv_vrf_reg - 32 vector regsiter for V standard extention
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif
module rvv_backend_vrf_reg (/*AUTOARG*/
   // Outputs
   vreg,
   // Inputs
   wen, wdata, clk, rst_n
   );

  output logic [`NUM_VRF-1:0][`VLEN-1:0]  vreg;

  input  logic [`NUM_VRF-1:0][`VLENB-1:0] wen; // byte enable
  input  logic [`NUM_VRF-1:0][`VLEN-1:0]  wdata;
  input  logic                            clk;
  input  logic                            rst_n;

// -- 32 vector registers --------------------------------------------
genvar i,j;
generate
  for (i=0; i<`NUM_VRF; i=i+1) begin
    for (j=0; j<`VLENB; j=j+1) begin
      edff #(
        .T      (logic [`BYTE_WIDTH-1:0])
      )
      vrf_unit1_reg (
        .q      (vreg[i][j*`BYTE_WIDTH +: `BYTE_WIDTH]),
        .e      (wen[i][j]),
        .d      (wdata[i][j*`BYTE_WIDTH +: `BYTE_WIDTH]),
        .clk    (clk),
        .rst_n  (rst_n)
        );
    `ifdef ASSERT_ON
      `rvv_forbid($isunknown(vreg[i][j*`BYTE_WIDTH +: `BYTE_WIDTH]))
        else $error("VREG: data is unknow at vreg[%0d][%0d:%0d]",i,8*j+7,8*j);
    `endif //ASSERT_ON
    end //end for loop j
  end //end for loop i
endgenerate


endmodule
// ----- 8< ----- FILE "./rvv_backend_vrf.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
/*
description: 
1. the VRF contains 32xVLEN register file. It support 4 read ports and 4 write ports

feature list:
*/
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif

module rvv_backend_vrf(/*AUTOARG*/
   // Outputs
   vrf2dp_rd_data, vrf2dp_v0_data,
   // Inputs
   clk, rst_n, dp2vrf_rd_index, 
   rt2vrf_wr_valid, rt2vrf_wr_data
   );  
// global signal
input   logic                   clk;
input   logic                   rst_n;
    
// Dispatch unit to VRF unit
// Vs_data would be return from VRF at the current cycle.
input   logic     [`NUM_DP_VRF-1:0][`REGFILE_INDEX_WIDTH-1:0] dp2vrf_rd_index;

// VRF to Dispatch read data
output  logic     [`NUM_DP_VRF-1:0][`VLEN-1:0]  vrf2dp_rd_data;
output  logic                      [`VLEN-1:0]  vrf2dp_v0_data;

// Write back to VRF
input   logic     [`NUM_RT_UOP-1:0] rt2vrf_wr_valid;
input   RT2VRF_t  [`NUM_RT_UOP-1:0] rt2vrf_wr_data;

// Wires & Regs
genvar  j,k;

//
// code start
//
logic [`NUM_RT_UOP-1:0]                           wr_valid;
logic [`NUM_RT_UOP-1:0][`REGFILE_INDEX_WIDTH-1:0] wr_addr;
logic [`NUM_RT_UOP-1:0][`VLEN-1:0]                wr_data;
logic [`NUM_RT_UOP-1:0][`VLENB-1:0]               wr_we;              // byte enable
logic [`NUM_RT_UOP-1:0][`VLEN-1:0]                wr_web;             // bit enable
logic [`NUM_RT_UOP-1:0][`NUM_VRF-1:0][`VLENB-1:0] vrf_wr_wen;
logic [`NUM_RT_UOP-1:0][`NUM_VRF-1:0][`VLEN-1:0]  vrf_wr_data;
logic [`NUM_VRF-1:0][`VLENB-1:0]                  vrf_wr_wen_full;
logic [`NUM_VRF-1:0][`VLEN-1:0]                   vrf_wr_data_full;
logic [`NUM_DP_VRF-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_addr;
logic [`NUM_VRF-1:0][`VLEN-1:0]                   vrf_rd_data_full;   // full 32 VLEN data from VRF

// RT2VRF data unpack
generate
  for (j=0;j<`NUM_RT_UOP;j++) begin: GET_WT_DATA
    assign wr_valid[j] = rt2vrf_wr_valid[j];
    assign wr_addr[j]  = rt2vrf_wr_data[j].rt_index;
    assign wr_data[j]  = rt2vrf_wr_data[j].rt_data;
    assign wr_we[j]    = rt2vrf_wr_data[j].rt_strobe;

    // generate write bit-enable
    for(k=0;k<`VLENB;k++) begin: GET_WE_BIT
      assign wr_web[j][k*`BYTE_WIDTH +: `BYTE_WIDTH] = {`BYTE_WIDTH{wr_we[j][k]}};
    end

    // access VRF. Only write will update input
    always_comb begin
      vrf_wr_wen[j]  = 'b0;
      vrf_wr_data[j] = 'b0;

      if(wr_valid[j]) begin
        vrf_wr_wen[j][wr_addr[j]] = wr_we[j];
        vrf_wr_data[j][wr_addr[j]] = wr_data[j]&wr_web[j];
      end
    end
  end
endgenerate

// merge all retire data
always_comb begin
  vrf_wr_wen_full = 'b0;
  vrf_wr_data_full = 'b0;

  for(int i=0; i<`NUM_VRF; i++) begin
    for(int h=0; h<`NUM_RT_UOP; h++) begin
      vrf_wr_wen_full[i] = vrf_wr_wen_full[i] | vrf_wr_wen[h][i];
      vrf_wr_data_full[i] = vrf_wr_data_full[i] | vrf_wr_data[h][i];
    end
  end
end

//VRF core
rvv_backend_vrf_reg
vrf_reg (
  //Outputs
  .vreg   (vrf_rd_data_full),
  //Inputs
  .clk    (clk), 
  .rst_n  (rst_n),
  .wen    (vrf_wr_wen_full),
  .wdata  (vrf_wr_data_full)
);

// VRF2DP data pack
assign vrf2dp_v0_data = vrf_rd_data_full[0];

generate
  for (j=0;j<`NUM_DP_VRF;j++) begin: GET_RD_DATA
    assign rd_addr[j]        = dp2vrf_rd_index[j];
    assign vrf2dp_rd_data[j] = vrf_rd_data_full[rd_addr[j]];
  end
endgenerate


endmodule
// ----- 8< ----- FILE "./rvv_backend.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
`ifndef HDL_VERILOG_RVV_DESIGN_RVV_SVH
`include "rvv_backend.svh"
`endif
`ifndef RVV_ASSERT__SVH
`include "rvv_backend_sva.svh"
`endif

module rvv_backend
(
    clk,
    rst_n,

    insts_valid_rvs2cq,
    insts_rvs2cq,
    insts_ready_cq2rvs,
    remaining_count_cq2rvs,

    uop_lsu_valid_rvv2lsu,
    uop_lsu_rvv2lsu,
    uop_lsu_ready_lsu2rvv,

    uop_lsu_valid_lsu2rvv,
    uop_lsu_lsu2rvv,
    uop_lsu_ready_rvv2lsu,

    rt_xrf_rvv2rvs,
    rt_xrf_valid_rvv2rvs,
    rt_xrf_ready_rvs2rvv,

    wr_vxsat_valid,
    wr_vxsat,
    wr_vxsat_ready,

    trap_valid_rvs2rvv,
    trap_ready_rvv2rvs,    

    vcsr_valid,
    vector_csr,
    vcsr_ready,
    
  `ifdef TB_SUPPORT
    rd_valid_rob2rt_o,
  `endif

    rvv_idle,

    rd_rob2rt_o
);
// global signal
    input   logic                                     clk;
    input   logic                                     rst_n;

// vector instruction and scalar operand input. 
    input   logic             [`ISSUE_LANE-1:0]       insts_valid_rvs2cq;
    input   RVVCmd            [`ISSUE_LANE-1:0]       insts_rvs2cq;
    output  logic             [`ISSUE_LANE-1:0]       insts_ready_cq2rvs;  
    output  logic             [$clog2(`CQ_DEPTH):0]   remaining_count_cq2rvs;

// load/store unit interface
  // RVV send LSU uop to RVS
    output  logic             [`NUM_LSU-1:0]          uop_lsu_valid_rvv2lsu;
    output  UOP_RVV2LSU_t     [`NUM_LSU-1:0]          uop_lsu_rvv2lsu;
    input   logic             [`NUM_LSU-1:0]          uop_lsu_ready_lsu2rvv;
  // LSU feedback to RVV
    input   logic             [`NUM_LSU-1:0]          uop_lsu_valid_lsu2rvv;
    input   UOP_LSU2RVV_t     [`NUM_LSU-1:0]          uop_lsu_lsu2rvv;
    output  logic             [`NUM_LSU-1:0]          uop_lsu_ready_rvv2lsu;

// RT to XRF. RVS arbitrates write ports of XRF by itself.
    output  logic             [`NUM_RT_UOP-1:0]       rt_xrf_valid_rvv2rvs;
    output  RT2XRF_t          [`NUM_RT_UOP-1:0]       rt_xrf_rvv2rvs;
    input   logic             [`NUM_RT_UOP-1:0]       rt_xrf_ready_rvs2rvv;

// RT to VCSR.vxsat
    output  logic                                     wr_vxsat_valid;
    output  logic             [`VCSR_VXSAT_WIDTH-1:0] wr_vxsat;
    input   logic                                     wr_vxsat_ready;

// exception handler
  // trap signal handshake
    input   logic                                     trap_valid_rvs2rvv;
    output  logic                                     trap_ready_rvv2rvs;    
  // the vcsr of last retired uop in last cycle
    output  logic                                     vcsr_valid;
    output  RVVConfigState                            vector_csr;
    input   logic                                     vcsr_ready;

// retire information
  `ifdef TB_SUPPORT
    output  logic     [`NUM_RT_UOP-1:0]               rd_valid_rob2rt_o;
  `endif

// rvv_backend is not active.(IDLE)
    output  logic                                     rvv_idle;
    output ROB2RT_t [`NUM_RT_UOP-1:0]                 rd_rob2rt_o;

`ifdef TB_BRINGUP
  // inst queue
  logic [5:0] src1_idx [3:0]; 
  logic [5:0] src2_idx [3:0]; 
  logic [5:0] dest_idx [3:0];
  logic inst_valid [3:0];
  logic [31:0] inst_queue [3:0];
  always_ff @(posedge clk) begin
    if(!rst_n) begin 
      insts_ready_cq2rvs[0] <= 1'b0;
      insts_ready_cq2rvs[1] <= 1'b0;
      insts_ready_cq2rvs[2] <= 1'b0;
      insts_ready_cq2rvs[3] <= 1'b0;
      rt_xrf_valid_wb2rvs[0] <= 1'b0;
      rt_xrf_valid_wb2rvs[1] <= 1'b0;
      rt_xrf_valid_wb2rvs[2] <= 1'b0;
      rt_xrf_valid_wb2rvs[3] <= 1'b0;
    end else begin
      insts_ready_cq2rvs[0] <= 1'b1;
      insts_ready_cq2rvs[1] <= 1'b1;
      insts_ready_cq2rvs[2] <= 1'b0;
      insts_ready_cq2rvs[3] <= 1'b0;
      rt_xrf_valid_wb2rvs[0] <= 1'b0;
      rt_xrf_valid_wb2rvs[1] <= 1'b0;
      rt_xrf_valid_wb2rvs[2] <= 1'b0;
      rt_xrf_valid_wb2rvs[3] <= 1'b0;
    end
  end

  always_ff @(posedge clk) begin
    if(!rst_n) begin 
      inst_valid[0] <= 1'b0;
      inst_valid[1] <= 1'b0;
      inst_valid[2] <= 1'b0;
      inst_valid[3] <= 1'b0;
    end else begin
      inst_valid[0] <= insts_ready_cq2rvs[0] & insts_valid_rvs2cq[0];
      inst_valid[1] <= insts_ready_cq2rvs[1] & insts_valid_rvs2cq[1];
      inst_valid[2] <= insts_ready_cq2rvs[2] & insts_valid_rvs2cq[2];
      inst_valid[3] <= insts_ready_cq2rvs[3] & insts_valid_rvs2cq[3];
      inst_queue[0] <= (insts_ready_cq2rvs[0] & insts_valid_rvs2cq[0]) ? {insts_rvs2cq[0].bits,insts_rvs2cq[0].opcode,5'b0} : inst_queue[0];
      inst_queue[1] <= (insts_ready_cq2rvs[1] & insts_valid_rvs2cq[1]) ? {insts_rvs2cq[1].bits,insts_rvs2cq[1].opcode,5'b0} : inst_queue[1];
      inst_queue[2] <= (insts_ready_cq2rvs[2] & insts_valid_rvs2cq[2]) ? {insts_rvs2cq[2].bits,insts_rvs2cq[2].opcode,5'b0} : inst_queue[2];
      inst_queue[3] <= (insts_ready_cq2rvs[3] & insts_valid_rvs2cq[3]) ? {insts_rvs2cq[3].bits,insts_rvs2cq[3].opcode,5'b0} : inst_queue[3];
    end
  end

  always_comb begin
    for(int i=0;i<4;i++) begin
      src1_idx[i] = inst_queue[i][19:15];
      src2_idx[i] = inst_queue[i][24:20];
      dest_idx[i] = inst_queue[i][11:7];
    end
  end

  // vrf
  logic [127:0] vreg [31:0];
  logic [127:0] vreg_init_data [31:0];
  logic [3:0] rt_last_uop;
  always_ff @(posedge clk) begin
    if(!rst_n) begin 
      for(int i=0; i<32; i++) begin
        vreg[i] <= vreg_init_data[i];
      end
      for(int i=0; i<4; i++) begin
        rt_last_uop[i] <= 1'b0;
      end
    end else begin
      for(int i=0; i<4; i++) begin
        if(inst_valid[i]) begin
            for(int elm_idx=0; elm_idx<16; elm_idx++) begin
              // sew 8b, lmul 1, vl=16
              vreg[dest_idx[i]][elm_idx*8+:8] <= vreg[src1_idx[i]][elm_idx*8+:8] + vreg[src2_idx[i]][elm_idx*8+:8];
            end
          rt_last_uop[i] <= 1'b1;
        end else begin
          rt_last_uop[i] <= 1'b0;
        end
      end
    end
  end

  initial begin
    forever begin
      @(posedge clk);
      for(int i=0; i<3; i++) begin
        if(insts_valid_rvs2cq[i] && insts_ready_cq2rvs[i]) begin
          $display("[RTL INFO] @ %0t Got a instruction packet in insts_rvs2cq[%0d]", $time, i);
          $display("insts_rvs2cq[i].pc    = 0x%8x", insts_rvs2cq[i].inst_pc);
          $display("insts_rvs2cq[i].insts = 0x%8x", {insts_rvs2cq[i].bits,insts_rvs2cq[i].opcode,5'b0});
        end
      end
    end
  end
`else
// ---internal signals definition-------------------------------------
  // RVV frontend to command queue
    logic                                 cq_full;
    logic        [`ISSUE_LANE-1:0]        cq_almost_full;
    logic        [`ISSUE_LANE-1:0]        insts_ready;
    logic        [$clog2(`CQ_DEPTH):0]    used_count_cq;
  // Command queue to Decode
    RVVCmd       [`NUM_DE_INST-1:0]       inst_pkg_cq2de;
    logic                                 fifo_empty_cq2de;
    logic        [`NUM_DE_INST-1:0]       fifo_almost_empty_cq2de;
    logic        [`NUM_DE_INST-1:0]       pop_de2cq;
  // Decode to uop queue
    logic        [`NUM_DE_UOP-1:0]        push_de2uq;
    UOP_QUEUE_t  [`NUM_DE_UOP-1:0]        data_de2uq;
    logic                                 fifo_full_uq2de; 
    logic        [`NUM_DE_UOP-1:0]        fifo_almost_full_uq2de;
  // Uop queue to dispatch
    logic                                 uq_empty;
    logic        [`NUM_DP_UOP-1:0]        uq_almost_empty;
    logic        [`NUM_DP_UOP-1:0]        uop_valid_uop2dp;
    UOP_QUEUE_t  [`NUM_DP_UOP-1:0]        uop_uop2dp;
    logic        [`NUM_DP_UOP-1:0]        uop_ready_dp2uop;

  // Dispatch to RS
    // ALU_RS
    logic                                 alu_rs_full;
    logic        [`NUM_DP_UOP-1:0]        alu_rs_almost_full;
    logic        [`NUM_DP_UOP-1:0]        rs_valid_dp2alu;
    ALU_RS_t     [`NUM_DP_UOP-1:0]        rs_dp2alu;
    logic        [`NUM_DP_UOP-1:0]        rs_ready_alu2dp;
    // PMTRDT_RS 
    logic                                 pmtrdt_rs_full;
    logic        [`NUM_DP_UOP-1:0]        pmtrdt_rs_almost_full;
    logic        [`NUM_DP_UOP-1:0]        rs_valid_dp2pmtrdt;
    PMT_RDT_RS_t [`NUM_DP_UOP-1:0]        rs_dp2pmtrdt;
    logic        [`NUM_DP_UOP-1:0]        rs_ready_pmtrdt2dp;
    // MUL_RS
    logic                                 mul_rs_full;
    logic        [`NUM_DP_UOP-1:0]        mul_rs_almost_full;
    logic        [`NUM_DP_UOP-1:0]        rs_valid_dp2mul;
    MUL_RS_t     [`NUM_DP_UOP-1:0]        rs_dp2mul;
    logic        [`NUM_DP_UOP-1:0]        rs_ready_mul2dp;
    // DIV_RS
    logic                                 div_rs_full;
    logic        [`NUM_DP_UOP-1:0]        div_rs_almost_full;
    logic        [`NUM_DP_UOP-1:0]        rs_valid_dp2div;
    DIV_RS_t     [`NUM_DP_UOP-1:0]        rs_dp2div;
    logic        [`NUM_DP_UOP-1:0]        rs_ready_div2dp;
    // LSU_RS
    logic                                 lsu_rs_full;
    logic        [`NUM_DP_UOP-1:0]        lsu_rs_almost_full;
    logic                                 lsu_rs_empty;
    logic        [`NUM_LSU-1:0]           lsu_rs_almost_empty;
    logic        [`NUM_DP_UOP-1:0]        rs_valid_dp2lsu;
    UOP_RVV2LSU_t [`NUM_DP_UOP-1:0]       rs_dp2lsu;
    logic        [`NUM_DP_UOP-1:0]        rs_ready_lsu2dp;
    // LSU MAP INFO
    logic                                 mapinfo_full;
    logic        [`NUM_DP_UOP-1:0]        mapinfo_almost_full;
    logic        [`NUM_DP_UOP-1:0]        mapinfo_valid_dp2lsu;
    LSU_MAP_INFO_t  [`NUM_DP_UOP-1:0]     mapinfo_dp2lsu;
    logic        [`NUM_DP_UOP-1:0]        mapinfo_ready_lsu2dp;
  // Dispatch to ROB
    logic        [`NUM_DP_UOP-1:0]        uop_valid_dp2rob;
    DP2ROB_t     [`NUM_DP_UOP-1:0]        uop_dp2rob;
    logic        [`NUM_DP_UOP-1:0]        uop_ready_rob2dp;
    logic        [`ROB_DEPTH_WIDTH-1:0]   uop_index_rob2dp;
  
  // RS to excution unit
  // ALU_RS to ALU
    logic        [`NUM_ALU-1:0]           pop_alu2rs;
    ALU_RS_t     [`NUM_ALU-1:0]           uop_rs2alu;
    logic                                 fifo_empty_rs2alu;
    logic        [`NUM_ALU-1:0]           fifo_almost_empty_rs2alu;
  // PMTRDT_RS to PMTRDT
    logic        [`NUM_PMTRDT-1:0]        pop_pmtrdt2rs;
    PMT_RDT_RS_t [`NUM_PMTRDT-1:0]        uop_rs2pmtrdt;
    logic                                 fifo_empty_rs2pmtrdt;
    logic        [`NUM_PMTRDT-1:0]        fifo_almost_empty_rs2pmtrdt;
    PMT_RDT_RS_t [`PMTRDT_RS_DEPTH-1:0]   all_uop_rs2pmtrdt;
    logic        [$clog2(`PMTRDT_RS_DEPTH):0] valid_cnt_rs2pmtrdt;
  // MUL_RS to MUL
    logic        [`NUM_MUL-1:0]           pop_mul2rs;
    MUL_RS_t     [`NUM_MUL-1:0]           uop_rs2mul;
    logic                                 fifo_empty_rs2mul;
    logic        [`NUM_MUL-1:0]           fifo_almost_empty_rs2mul;
  // DIV_RS to DIV
    logic        [`NUM_DIV-1:0]           pop_div2rs;
    DIV_RS_t     [`NUM_DIV-1:0]           uop_rs2div;
    logic                                 fifo_empty_rs2div;
    logic        [`NUM_DIV-1:0]           fifo_almost_empty_rs2div;
  // LSU mapinfo
    logic        [`NUM_LSU-1:0]           pop_mapinfo;
    LSU_MAP_INFO_t  [`NUM_LSU-1:0]        mapinfo;
    logic                                 mapinfo_empty;
    logic        [`NUM_LSU-1:0]           mapinfo_almost_empty;
  // LSU result
    logic        [`NUM_LSU-1:0]           pop_lsu_res;
    UOP_LSU_t    [`NUM_LSU-1:0]           lsu_res;
    logic                                 lsu_res_full;
    logic        [`NUM_LSU-1:0]           lsu_res_almost_full;
    logic                                 lsu_res_empty;
    logic        [`NUM_LSU-1:0]           lsu_res_almost_empty;
    logic        [`NUM_LSU-1:0]           uop_lsu_valid;
    UOP_LSU_t    [`NUM_LSU-1:0]           uop_lsu;
    logic        [`NUM_LSU-1:0]           uop_lsu_ready;
    logic                                 trap_valid_rmp2rob;
    logic        [`ROB_DEPTH_WIDTH-1:0]   trap_rob_entry_rmp2rob;

  // execution unit submit result to ROB
  // ALU to ROB
    logic        [`NUM_ALU-1:0]           wr_valid_alu2rob;
    PU2ROB_t     [`NUM_ALU-1:0]           wr_alu2rob;
    logic        [`NUM_ALU-1:0]           wr_ready_rob2alu;
  // PMTRDT to ROB
    logic        [`NUM_PMTRDT-1:0]        wr_valid_pmtrdt2rob;
    PU2ROB_t     [`NUM_PMTRDT-1:0]        wr_pmtrdt2rob;
    logic        [`NUM_PMTRDT-1:0]        wr_ready_rob2pmtrdt;
  // MUL to ROB
    logic        [`NUM_MUL-1:0]           wr_valid_mul2rob;
    PU2ROB_t     [`NUM_MUL-1:0]           wr_mul2rob;
    logic        [`NUM_MUL-1:0]           wr_ready_rob2mul;
  // DIV to ROB
    logic        [`NUM_DIV-1:0]           wr_valid_div2rob;
    PU2ROB_t     [`NUM_DIV-1:0]           wr_div2rob;
    logic        [`NUM_DIV-1:0]           wr_ready_rob2div;
  // LSU to ROB
    logic        [`NUM_LSU-1:0]           wr_valid_lsu2rob;
    PU2ROB_t     [`NUM_LSU-1:0]           wr_lsu2rob;
    logic        [`NUM_LSU-1:0]           wr_ready_rob2lsu;
  // DP to VRF
    logic [`NUM_DP_VRF-1:0][`REGFILE_INDEX_WIDTH-1:0] rd_index_dp2vrf;          
    logic [`NUM_DP_VRF-1:0][`VLEN-1:0]                rd_data_vrf2dp;
    logic [`VLEN-1:0]                                 v0_mask_vrf2dp;
  // ROB to dispatch
    ROB2DP_t     [`ROB_DEPTH-1:0]         uop_rob2dp;
    logic                                 rob_empty;
  // ROB to RT
    logic        [`NUM_RT_UOP-1:0]        rd_valid_rob2rt;
    ROB2RT_t     [`NUM_RT_UOP-1:0]        rd_rob2rt;
    logic        [`NUM_RT_UOP-1:0]        rd_ready_rt2rob;
  // RT to VRF
    logic        [`NUM_RT_UOP-1:0]        wr_valid_rt2vrf;
    RT2VRF_t     [`NUM_RT_UOP-1:0]        wr_data_rt2vrf;

  // trap handler
    logic                                 trap_en;
    logic                                 is_trapping;
    logic                                 trap_ready_rob2rmp;   
    logic                                 trap_flush_rvv;

    genvar i;

// ---code start------------------------------------------------------
  // Command queue
    multi_fifo #(
        .T            (RVVCmd),
        .M            (`ISSUE_LANE),
        .N            (`NUM_DE_INST),
        .DATAOUT_REG  (1'b1),
        .ASYNC_RSTN   (1'b1),
        .DEPTH        (`CQ_DEPTH)
    ) u_command_queue (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // write
        .push         (insts_valid_rvs2cq & insts_ready_cq2rvs),
        .datain       (insts_rvs2cq),
      // read
        .pop          (pop_de2cq),
        .dataout      (inst_pkg_cq2de),
      // fifo status
        .full         (cq_full),
        .almost_full  (cq_almost_full),
        .empty        (fifo_empty_cq2de),
        .almost_empty (fifo_almost_empty_cq2de),
        .clear        (trap_flush_rvv),
        .fifo_data    (),
        .wptr         (),
        .rptr         (),
        .entry_count  (used_count_cq)
    );

    assign insts_ready[0] = ~cq_full;
    generate
      for (i=1;i<`ISSUE_LANE;i++) begin: cmq_ready
        assign insts_ready[i] = !cq_almost_full[i];
      end
    endgenerate

    assign insts_ready_cq2rvs = is_trapping ? 'b0 : insts_ready;

    // output the remaining count in CQ
    assign remaining_count_cq2rvs = `CQ_DEPTH - used_count_cq;

  `ifdef ASSERT_ON
    PushToCMDQueue: `rvv_expect((insts_valid_rvs2cq & insts_ready_cq2rvs) inside {4'b1111, 4'b0111, 4'b0011, 4'b0001, 4'b0000})
      else $error("Push to command queue out-of-order: %4b.", $sampled(insts_valid_rvs2cq & insts_ready_cq2rvs));

    PopFromCMDQueue: `rvv_expect(pop_de2cq inside {2'b11, 2'b01, 2'b00})
      else $error("Pop from command queue out-of-order: %2b.", $sampled(pop_de2cq));
  `endif // ASSERT_ON

  // Decode unit
    rvv_backend_decode #(
    ) u_decode (
      // global
        .clk                      (clk),
        .rst_n                    (rst_n),
      // cq2de
        .inst_pkg_cq2de           (inst_pkg_cq2de),
        .fifo_empty_cq2de         (fifo_empty_cq2de),
        .fifo_almost_empty_cq2de  (fifo_almost_empty_cq2de),
        .pop_de2cq                (pop_de2cq),
      // de2uq
        .push_de2uq               (push_de2uq),
        .data_de2uq               (data_de2uq),
        .fifo_full_uq2de          (fifo_full_uq2de),
        .fifo_almost_full_uq2de   (fifo_almost_full_uq2de),
      // trap-flush
        .trap_flush_rvv           (trap_flush_rvv)
    );

  // Uop queue
    multi_fifo #(
        .T                (UOP_QUEUE_t),
        .M                (`NUM_DE_UOP),
        .N                (`NUM_DP_UOP),
        .ASYNC_RSTN       (1'b1),
        .DEPTH            (`UQ_DEPTH)
    ) u_uop_queue (
      // global
        .clk              (clk),
        .rst_n            (rst_n),
      // write
        .push             (push_de2uq),
        .datain           (data_de2uq),
      // read
        .pop              (uop_valid_uop2dp & uop_ready_dp2uop),
        .dataout          (uop_uop2dp),
      // fifo status
        .full             (fifo_full_uq2de),
        .almost_full      (fifo_almost_full_uq2de),
        .empty            (uq_empty),
        .almost_empty     (uq_almost_empty),
        .clear            (trap_flush_rvv),
        .fifo_data        (),
        .wptr             (),
        .rptr             (),
        .entry_count      ()
    );
   
    assign uop_valid_uop2dp[0] = ~uq_empty;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: uop_queue_valid
        assign uop_valid_uop2dp[i] = !uq_almost_empty[i];
      end
    endgenerate

  `ifdef ASSERT_ON
    `ifdef ISSUE_3_READ_PORT_6 
      PushToUopQueue: `rvv_expect(push_de2uq inside {6'b111111, 6'b011111, 6'b001111, 6'b000111, 6'b000011, 6'b000001, 6'b000000})
        else $error("Push to uops queue out-of-order: %6b", $sampled(push_de2uq));

      PopFromUopQueue: `rvv_expect((uop_valid_uop2dp & uop_ready_dp2uop) inside {3'b111, 3'b011, 3'b001,3'b000})
        else $error("Pop from uops queue out-of-order: %3b", $sampled(uop_valid_uop2dp & uop_ready_dp2uop));
    `else //ISSUE_2
      PushToUopQueue: `rvv_expect(push_de2uq inside {4'b1111, 4'b0111, 4'b0011, 4'b0001, 4'b0000})
        else $error("Push to uops queue out-of-order: %4b", $sampled(push_de2uq));

      PopFromUopQueue: `rvv_expect((uop_valid_uop2dp & uop_ready_dp2uop) inside {2'b11, 2'b01, 2'b00})
        else $error("Pop from uops queue out-of-order: %2b", $sampled(uop_valid_uop2dp & uop_ready_dp2uop));
    `endif
  `endif // ASSERT_ON

  // Dispatch unit
    rvv_backend_dispatch #(
    ) u_dispatch (
      // global
        .clk                (clk),
        .rst_n              (rst_n),
      // Uop queue to dispatch
        .uop_valid_uop2dp   (uop_valid_uop2dp),
        .uop_uop2dp         (uop_uop2dp),
        .uop_ready_dp2uop   (uop_ready_dp2uop),
      // Dispatch to RS
        // ALU_RS
        .rs_valid_dp2alu    (rs_valid_dp2alu),
        .rs_dp2alu          (rs_dp2alu),
        .rs_ready_alu2dp    (rs_ready_alu2dp),
        // PMTRDT_RS 
        .rs_valid_dp2pmtrdt (rs_valid_dp2pmtrdt),
        .rs_dp2pmtrdt       (rs_dp2pmtrdt),
        .rs_ready_pmtrdt2dp (rs_ready_pmtrdt2dp),
        // MUL_RS
        .rs_valid_dp2mul    (rs_valid_dp2mul),
        .rs_dp2mul          (rs_dp2mul),
        .rs_ready_mul2dp    (rs_ready_mul2dp),
        // DIV_RS
        .rs_valid_dp2div    (rs_valid_dp2div),
        .rs_dp2div          (rs_dp2div),
        .rs_ready_div2dp    (rs_ready_div2dp),
        // LSU_RS
        .rs_valid_dp2lsu      (rs_valid_dp2lsu),
        .rs_dp2lsu            (rs_dp2lsu),
        .rs_ready_lsu2dp      (rs_ready_lsu2dp),
        // LSU MAP INFO
        .mapinfo_valid_dp2lsu (mapinfo_valid_dp2lsu),
        .mapinfo_dp2lsu       (mapinfo_dp2lsu),
        .mapinfo_ready_lsu2dp (mapinfo_ready_lsu2dp),
      // Dispatch to ROB
        .uop_valid_dp2rob   (uop_valid_dp2rob),
        .uop_dp2rob         (uop_dp2rob),
        .uop_ready_rob2dp   (uop_ready_rob2dp),
        .uop_index_rob2dp   (uop_index_rob2dp),
      // VRF to dispatch
        .rd_index_dp2vrf    (rd_index_dp2vrf),
        .rd_data_vrf2dp     (rd_data_vrf2dp),
        .v0_mask_vrf2dp     (v0_mask_vrf2dp),
      // ROB to dispatch
        .rob_entry          (uop_rob2dp)
    );

  // RS, Reserve station
    // ALU RS
    multi_fifo #(
        .T            (ALU_RS_t),
        .M            (`NUM_DP_UOP),
        .N            (`NUM_ALU),
        .ASYNC_RSTN   (1'b1),
        .DEPTH        (`ALU_RS_DEPTH),
        .CHAOS_PUSH   (1'b1),
        .DATAOUT_REG  (1'b1)
    ) u_alu_rs (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // write
        .push         (rs_valid_dp2alu),
        .datain       (rs_dp2alu),
      // read
        .pop          (pop_alu2rs),
        .dataout      (uop_rs2alu),
      // fifo status
        .full         (alu_rs_full),
        .almost_full  (alu_rs_almost_full),
        .empty        (fifo_empty_rs2alu),
        .almost_empty (fifo_almost_empty_rs2alu),
        .clear        (trap_flush_rvv),
        .fifo_data    (),
        .wptr         (),
        .rptr         (),
        .entry_count  ()
    );

    assign rs_ready_alu2dp[0] = ~alu_rs_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: alu_rs_ready
        assign rs_ready_alu2dp[i] = !alu_rs_almost_full[i];
      end
    endgenerate

  `ifdef ASSERT_ON
    PopFromAluRSQueue: `rvv_expect((pop_alu2rs) inside {2'b11, 2'b01, 2'b00})
      else $error("Pop from ALU Reservation Station out-of-order: %2b", $sampled(pop_alu2rs));
  `endif // ASSERT_ON

    // PMTRDT RS, Permutation + Reduction
    multi_fifo #(
        .T                (PMT_RDT_RS_t),
        .M                (`NUM_DP_UOP),
        .N                (`NUM_PMTRDT),
        .ASYNC_RSTN       (1'b1),
        .DEPTH            (`PMTRDT_RS_DEPTH),
        .CHAOS_PUSH       (1'b1),
        .DATAOUT_REG      (1'b1)
    ) u_pmtrdt_rs (
      // global
        .clk              (clk),
        .rst_n            (rst_n),
      // write
        .push             (rs_valid_dp2pmtrdt),
        .datain           (rs_dp2pmtrdt),
      // read
        .pop              (pop_pmtrdt2rs),
        .dataout          (uop_rs2pmtrdt),
      // fifo status
        .full             (pmtrdt_rs_full),
        .almost_full      (pmtrdt_rs_almost_full),
        .empty            (fifo_empty_rs2pmtrdt),
        .almost_empty     (fifo_almost_empty_rs2pmtrdt),
        .clear            (trap_flush_rvv),
        .fifo_data        (all_uop_rs2pmtrdt),
        .wptr             (),
        .rptr             (),
        .entry_count      (valid_cnt_rs2pmtrdt)
    );

    assign rs_ready_pmtrdt2dp[0] = ~pmtrdt_rs_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: pmtrdt_rs_ready
        assign rs_ready_pmtrdt2dp[i] = !pmtrdt_rs_almost_full[i];
      end
    endgenerate

  `ifdef ASSERT_ON
     PopFromPmtrdtRSQueue: `rvv_expect((pop_pmtrdt2rs) inside {1'b1, 1'b0})
       else $error("Pop from PMTRDT Reservation Station out-of-order: %1b", $sampled(pop_pmtrdt2rs));
  `endif // ASSERT_ON

    // MUL RS, Multiply + Multiply-accumulate
    multi_fifo #(
        .T              (MUL_RS_t),
        .M              (`NUM_DP_UOP),
        .N              (`NUM_MUL),
        .DEPTH          (`MUL_RS_DEPTH),
        .ASYNC_RSTN     (1'b1),
        .CHAOS_PUSH     (1'b1)
    ) u_mul_rs (
      // global
        .clk            (clk),
        .rst_n          (rst_n),
      // write
        .push           (rs_valid_dp2mul),
        .datain         (rs_dp2mul),
      // read
        .pop            (pop_mul2rs),
        .dataout        (uop_rs2mul),
      // fifo status
        .full           (mul_rs_full),
        .almost_full    (mul_rs_almost_full),
        .empty          (fifo_empty_rs2mul),
        .almost_empty   (fifo_almost_empty_rs2mul),
        .clear          (trap_flush_rvv),
        .fifo_data      (),
        .wptr           (),
        .rptr           (),
        .entry_count    ()
    );

    assign rs_ready_mul2dp[0] = ~mul_rs_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: mul_rs_ready
        assign rs_ready_mul2dp[i] = !mul_rs_almost_full[i];
      end
    endgenerate

  `ifdef ASSERT_ON
    // PopFromMulRSQueue: `rvv_expect((pop_mul2rs) inside {2'b11, 2'b01, 2'b00})
    //   else $error("Pop from MUL Reservation Station out-of-order: %2b", $sampled(pop_mul2rs));
  `endif // ASSERT_ON

    // DIV RS
    multi_fifo #(
        .T              (DIV_RS_t),
        .M              (`NUM_DP_UOP),
        .N              (`NUM_DIV),
        .DEPTH          (`DIV_RS_DEPTH),
        .ASYNC_RSTN     (1'b1),
        .CHAOS_PUSH     (1'b1)
    ) u_div_rs (
      // global
        .clk            (clk),
        .rst_n          (rst_n),
      // write
        .push           (rs_valid_dp2div),
        .datain         (rs_dp2div),
      // read
        .pop            (pop_div2rs),
        .dataout        (uop_rs2div),
      // fifo status
        .full           (div_rs_full),
        .almost_full    (div_rs_almost_full),
        .empty          (fifo_empty_rs2div),
        .almost_empty   (fifo_almost_empty_rs2div),
        .clear          (trap_flush_rvv),
        .fifo_data      (),
        .wptr           (),
        .rptr           (),
        .entry_count    ()
    );

    assign rs_ready_div2dp[0] = ~div_rs_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: div_rs_ready
        assign rs_ready_div2dp[i] = !div_rs_almost_full[i];
      end
    endgenerate

  `ifdef ASSERT_ON
     PopFromDivRSQueue: `rvv_expect((pop_div2rs) inside {1'b1, 1'b0})
       else $error("Pop from DIV Reservation Station out-of-order: %1b", $sampled(pop_div2rs));
  `endif // ASSERT_ON

    // LSU RS
    multi_fifo #(
        .T            (UOP_RVV2LSU_t),
        .M            (`NUM_DP_UOP),
        .N            (`NUM_LSU),
        .DEPTH        (`LSU_RS_DEPTH),
        .ASYNC_RSTN   (1'b1),
        .CHAOS_PUSH   (1'b1)
    ) u_lsu_rs (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // write
        .push         (rs_valid_dp2lsu),
        .datain       (rs_dp2lsu),
      // read
        .pop          (uop_lsu_valid_rvv2lsu & uop_lsu_ready_lsu2rvv),
        .dataout      (uop_lsu_rvv2lsu),
      // fifo status
        .full         (lsu_rs_full),
        .almost_full  (lsu_rs_almost_full),
        .empty        (lsu_rs_empty),
        .almost_empty (lsu_rs_almost_empty),
        .clear        (trap_flush_rvv),
        .fifo_data    (),
        .wptr         (),
        .rptr         (),
        .entry_count  ()
    );
    // LSU RS full signal for dispatch unit
    assign rs_ready_lsu2dp[0] = ~lsu_rs_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: lsu_rs_ready
        assign rs_ready_lsu2dp[i] = !lsu_rs_almost_full[i];
      end
    endgenerate

    // output valid and data to LSU
    assign uop_lsu_valid_rvv2lsu[0] = ~lsu_rs_empty;
    generate
      for (i=1;i<`NUM_LSU;i++) begin: gen_uop_lsu_valid
        assign uop_lsu_valid_rvv2lsu[i] = ~lsu_rs_almost_empty[i];
      end
    endgenerate

    // LSU MAP INFO
    multi_fifo #(
        .T            (LSU_MAP_INFO_t),
        .M            (`NUM_DP_UOP),
        .N            (`NUM_LSU),
        .DEPTH        (`LSU_RS_DEPTH),
        .ASYNC_RSTN   (1'b1),
        .CHAOS_PUSH   (1'b1)
    ) u_lsu_map_info (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // write
        .push         (mapinfo_valid_dp2lsu),
        .datain       (mapinfo_dp2lsu),
      // read
        .pop          (pop_mapinfo),
        .dataout      (mapinfo),
      // fifo status
        .full         (mapinfo_full),
        .almost_full  (mapinfo_almost_full),
        .empty        (mapinfo_empty),
        .almost_empty (mapinfo_almost_empty),
        .clear        (trap_flush_rvv),
        .fifo_data    (),
        .wptr         (),
        .rptr         (),
        .entry_count  ()
    );

    assign mapinfo_ready_lsu2dp[0] = ~mapinfo_full;
    generate
      for (i=1;i<`NUM_DP_UOP;i++) begin: mapinfo_ready
        assign mapinfo_ready_lsu2dp[i] = !mapinfo_almost_full[i];
      end
    endgenerate

  // trap handler
    // make sure all lsu uops before the trapping uop have been pushed into LSU_RES_FIFO
    assign trap_en = trap_valid_rvs2rvv & (uop_lsu_valid_lsu2rvv=='b0) & (!lsu_res_full) & (!is_trapping);

    cdffr
    trap_valid
    (
      .clk            (clk),
      .rst_n          (rst_n),
      .e              (trap_en),
      .c              (trap_flush_rvv),
      .d              (1'b1),
      .q              (is_trapping)
    );

  // LSU feedback result
    assign uop_lsu_valid = trap_en ? 'b1 : uop_lsu_valid_lsu2rvv;

    generate
      assign uop_lsu[0].trap_valid = trap_en;
      assign uop_lsu[0].uop_lsu2rvv = trap_en ? 'b0 : uop_lsu_lsu2rvv[0];

      for (i=1;i<`NUM_LSU;i++) begin: get_uop_lsu
        assign uop_lsu[i].trap_valid = 'b0;
        assign uop_lsu[i].uop_lsu2rvv = uop_lsu_lsu2rvv[i];
      end
    endgenerate

    multi_fifo #(
        .T            (UOP_LSU_t),
        .M            (`NUM_LSU),
        .N            (`NUM_LSU),
        .DEPTH        (`NUM_LSU*2),
        .ASYNC_RSTN   (1'b1),
        .CHAOS_PUSH   (1'b1)
    ) u_lsu_res (
      // global
        .clk          (clk),
        .rst_n        (rst_n),
      // write
        .push         (uop_lsu_valid&uop_lsu_ready_rvv2lsu),
        .datain       (uop_lsu),
      // read
        .pop          (pop_lsu_res),
        .dataout      (lsu_res),
      // fifo status
        .full         (lsu_res_full),
        .almost_full  (lsu_res_almost_full),
        .empty        (lsu_res_empty),
        .almost_empty (lsu_res_almost_empty),
        .clear        (trap_flush_rvv),
        .fifo_data    (),
        .wptr         (),
        .rptr         (),
        .entry_count  ()
    );
    // ready signal for LSU
    assign uop_lsu_ready[0] = !lsu_res_full;
    generate
      for (i=1;i<`NUM_LSU;i++) begin: lsu_res_ready
        assign uop_lsu_ready[i] = !lsu_res_almost_full[i];
      end
    endgenerate

    assign uop_lsu_ready_rvv2lsu = is_trapping ? 'b0 : uop_lsu_ready;

  // PU, Process unit
    // ALU
    rvv_backend_alu #(
    ) u_alu (
      // ALU_RS to ALU
        .clk                        (clk),
        .rst_n                      (rst_n),
        .pop_ex2rs                  (pop_alu2rs),
        .alu_uop_rs2ex              (uop_rs2alu),
        .fifo_empty_rs2ex           (fifo_empty_rs2alu),
        .fifo_almost_empty_rs2ex    (fifo_almost_empty_rs2alu),
      // ALU to ROB  
        .result_valid_ex2rob        (wr_valid_alu2rob),
        .result_ex2rob              (wr_alu2rob),
        .result_ready_rob2alu       (wr_ready_rob2alu),
      // trap-flush
        .trap_flush_rvv             (trap_flush_rvv)
    );

    // PMTRDT
    rvv_backend_pmtrdt #(
    ) u_pmtrdt (
        .clk                        (clk),
        .rst_n                      (rst_n),
      // PMTRDT_RS to PMTRDT
        .pop_ex2rs                  (pop_pmtrdt2rs),
        .pmtrdt_uop_rs2ex           (uop_rs2pmtrdt),
        .fifo_empty_rs2ex           (fifo_empty_rs2pmtrdt),
        .fifo_almost_empty_rs2ex    (fifo_almost_empty_rs2pmtrdt),
        .all_uop_data               (all_uop_rs2pmtrdt),
        .all_uop_cnt                (valid_cnt_rs2pmtrdt),
      // PMTRDT to ROB
        .result_valid_ex2rob        (wr_valid_pmtrdt2rob),
        .result_ex2rob              (wr_pmtrdt2rob),
        .result_ready_rob2ex        (wr_ready_rob2pmtrdt),
      // trap-flush
        .trap_flush_rvv             (trap_flush_rvv)
    );
    
    // MULMAC
    rvv_backend_mulmac u_mulmac (
      .clk                        (clk),
      .rst_n                      (rst_n),
    // MUL_RS to MULMAC
      .ex2rs_fifo_pop             (pop_mul2rs),
      .rs2ex_uop_data             (uop_rs2mul),
      .rs2ex_fifo_empty           (fifo_empty_rs2mul),
      .rs2ex_fifo_1left_to_empty  (fifo_almost_empty_rs2mul[1]),
    //MULMAC to ROB
      .ex2rob_valid               (wr_valid_mul2rob),
      .ex2rob_data                (wr_mul2rob),
      .rob2ex_ready               (wr_ready_rob2mul),
    // trap-flush
      .trap_flush_rvv             (trap_flush_rvv)
    );
    
    // DIV
    rvv_backend_div u_div
    (  
      .clk                      (clk),
      .rst_n                    (rst_n),
      // DIV_RS to DIV
      .pop_ex2rs                (pop_div2rs),
      .div_uop_rs2ex            (uop_rs2div),
      .fifo_empty_rs2ex         (fifo_empty_rs2div),
      .fifo_almost_empty_rs2ex  (fifo_almost_empty_rs2div),
      // DIV to ROB
      .result_valid_ex2rob      (wr_valid_div2rob),
      .result_ex2rob            (wr_div2rob),
      .result_ready_rob2div     (wr_ready_rob2div),
      // trap-flush
      .trap_flush_rvv           (trap_flush_rvv)
    );

    // LSU remap
    rvv_backend_lsu_remap
    u_lsu_remap
    (
      .mapinfo                (mapinfo),
      .lsu_res                (lsu_res),
      .mapinfo_empty          (mapinfo_empty),
      .mapinfo_almost_empty   (mapinfo_almost_empty),
      .lsu_res_empty          (lsu_res_empty),
      .lsu_res_almost_empty   (lsu_res_almost_empty),
      .pop_mapinfo            (pop_mapinfo),
      .pop_lsu_res            (pop_lsu_res),
      .result_valid_lsu2rob   (wr_valid_lsu2rob),
      .result_lsu2rob         (wr_lsu2rob),      
      .result_ready_rob2lsu   (wr_ready_rob2lsu),
      .trap_valid_rmp2rob     (trap_valid_rmp2rob),
      .trap_rob_entry_rmp2rob (trap_rob_entry_rmp2rob),
      .trap_ready_rob2rmp     (trap_ready_rob2rmp)
    );

  // ROB, Re-Order Buffer
    rvv_backend_rob #(
    ) u_rob (
      // global signal
        .clk                    (clk),
        .rst_n                  (rst_n),
      // Dispatch to ROB
        .uop_valid_dp2rob       (uop_valid_dp2rob),
        .uop_dp2rob             (uop_dp2rob),
        .uop_ready_rob2dp       (uop_ready_rob2dp),
        .rob_empty              (rob_empty),
        .uop_index_rob2dp       (uop_index_rob2dp),
      // ALU to ROB
        .wr_valid_alu2rob       (wr_valid_alu2rob),
        .wr_alu2rob             (wr_alu2rob),
        .wr_ready_rob2alu       (wr_ready_rob2alu),
      // PMTRDT to ROB
        .wr_valid_pmtrdt2rob    (wr_valid_pmtrdt2rob),
        .wr_pmtrdt2rob          (wr_pmtrdt2rob),
        .wr_ready_rob2pmtrdt    (wr_ready_rob2pmtrdt),
      // MUL to ROB
        .wr_valid_mul2rob       (wr_valid_mul2rob),
        .wr_mul2rob             (wr_mul2rob),
        .wr_ready_rob2mul       (wr_ready_rob2mul),
      // DIV to ROB
        .wr_valid_div2rob       (wr_valid_div2rob),
        .wr_div2rob             (wr_div2rob),
        .wr_ready_rob2div       (wr_ready_rob2div),
      // LSU to ROB
        .wr_valid_lsu2rob       (wr_valid_lsu2rob),
        .wr_lsu2rob             (wr_lsu2rob),
        .wr_ready_rob2lsu       (wr_ready_rob2lsu),
      // ROB to RT
        .rd_valid_rob2rt        (rd_valid_rob2rt),
        .rd_rob2rt              (rd_rob2rt),
        .rd_ready_rt2rob        (rd_ready_rt2rob),
      // ROB to DP
        .uop_rob2dp             (uop_rob2dp),
      // Trap
        .trap_valid_rmp2rob     (trap_valid_rmp2rob),
        .trap_rob_entry_rmp2rob (trap_rob_entry_rmp2rob),
        .trap_ready_rob2rmp     (trap_ready_rob2rmp),
        .trap_ready_rvv2rvs     (trap_ready_rvv2rvs),
        .trap_flush_rvv         (trap_flush_rvv)
    );

  // RT, Retire
    rvv_backend_retire #(
    ) u_retire (
      // ROB to RT
        .rob2rt_write_valid     (rd_valid_rob2rt),
        .rob2rt_write_data      (rd_rob2rt),
        .rt2rob_write_ready     (rd_ready_rt2rob),
      // RT to RVS.XRF
        .rt2xrf_write_valid     (rt_xrf_valid_rvv2rvs),
        .rt2xrf_write_data      (rt_xrf_rvv2rvs),
        .xrf2rt_write_ready     (rt_xrf_ready_rvs2rvv),
      // RT to VRF
        .rt2vrf_write_valid     (wr_valid_rt2vrf),
        .rt2vrf_write_data      (wr_data_rt2vrf),
      // write to update vcsr   
        .rt2vcsr_write_valid    (vcsr_valid),
        .rt2vcsr_write_data     (vector_csr),
        .vcsr2rt_write_ready    (vcsr_ready),
      // update to vxsat
        .rt2vxsat_write_valid   (wr_vxsat_valid),
        .rt2vxsat_write_data    (wr_vxsat),
        .vxsat2rt_write_ready   (wr_vxsat_ready)
    );

  // VRF, Vector Register File
    rvv_backend_vrf #(
    ) u_vrf (
      // global signal
        .clk             (clk),
        .rst_n           (rst_n),
      // DP to VRF
        .dp2vrf_rd_index (rd_index_dp2vrf),
      // VRF to DP
        .vrf2dp_rd_data  (rd_data_vrf2dp),
        .vrf2dp_v0_data  (v0_mask_vrf2dp),
      // RT to VRF
        .rt2vrf_wr_valid (wr_valid_rt2vrf),
        .rt2vrf_wr_data  (wr_data_rt2vrf)
    );

  // retire information
`ifdef TB_SUPPORT
  assign rd_valid_rob2rt_o = rd_valid_rob2rt & rd_ready_rt2rob;
`endif

  // rvv_backend IDLE
  assign rvv_idle = fifo_empty_cq2de&uq_empty&rob_empty;
  assign rd_rob2rt_o = rd_rob2rt;

`endif // TB_BRINGUP

endmodule
// ----- 8< ----- FILE "./RvvCore.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module RvvCore #(parameter N = 4,
                 parameter CMD_BUFFER_MAX_CAPACITY = 16,
                 type RegDataT=logic [31:0],
                 type VRegDataT=logic [127:0],
                 type RegAddrT=logic [4:0],
                 type MaskT=logic [15:0]
                 )
(
  input clk,
  input rstn,

  input logic [`VSTART_WIDTH-1:0] vstart,
  input logic [1:0] vxrm,
  input logic vxsat,
  input logic [2:0] frm,

  // Instruction input.
  input logic [N-1:0] inst_valid,
  input RVVInstruction [N-1:0] inst_data,
  output logic [N-1:0] inst_ready,

  // Register file input
  input logic [(2*N)-1:0] reg_read_valid,
  input RegDataT [(2*N)-1:0] reg_read_data,

  // Floating point register file input
  input RegDataT [N-1:0] freg_read_data,

  // Scalar Regfile writeback for configuration functions.
  output logic [N-1:0] reg_write_valid,
  output RegAddrT [N-1:0] reg_write_addr,
  output RegDataT [N-1:0] reg_write_data,

  // Scalar Regfile writeback for non-configuration functions.
  output logic async_rd_valid,
  output RegAddrT async_rd_addr,
  output RegDataT async_rd_data,
  input logic async_rd_ready,

  // Floating Point Regfile writeback.
  output logic async_frd_valid,
  output RegAddrT async_frd_addr,
  output RegDataT async_frd_data,
  input logic async_frd_ready,

  // RVV to LSU
  output  logic     [`NUM_LSU-1:0] uop_lsu_valid_rvv2lsu,
  output  logic     [`NUM_LSU-1:0] uop_lsu_idx_valid_rvv2lsu,
  output  RegAddrT  [`NUM_LSU-1:0] uop_lsu_idx_addr_rvv2lsu,
  output  VRegDataT [`NUM_LSU-1:0] uop_lsu_idx_data_rvv2lsu,
  output  logic     [`NUM_LSU-1:0] uop_lsu_vregfile_valid_rvv2lsu,
  output  RegAddrT  [`NUM_LSU-1:0] uop_lsu_vregfile_addr_rvv2lsu,
  output  VRegDataT [`NUM_LSU-1:0] uop_lsu_vregfile_data_rvv2lsu,
  output  logic     [`NUM_LSU-1:0] uop_lsu_v0_valid_rvv2lsu,
  output  MaskT     [`NUM_LSU-1:0] uop_lsu_v0_data_rvv2lsu,
  input   logic     [`NUM_LSU-1:0] uop_lsu_ready_lsu2rvv,

  // LSU to RVV
  input  logic     [`NUM_LSU-1:0] uop_lsu_valid_lsu2rvv,
  input  RegAddrT  [`NUM_LSU-1:0] uop_lsu_addr_lsu2rvv,
  input  VRegDataT [`NUM_LSU-1:0] uop_lsu_wdata_lsu2rvv,
  input  logic     [`NUM_LSU-1:0] uop_lsu_last_lsu2rvv,
  output logic     [`NUM_LSU-1:0] uop_lsu_ready_rvv2lsu,

  // Vector CSR writeback
  output vcsr_valid,
  output RVVConfigState vector_csr,
  input vcsr_ready,

  // Config state
  output config_state_valid,
  output RVVConfigState config_state,

  // Idle
  output logic rvv_idle,
  output logic [$clog2(2*N + 1)-1:0] queue_capacity,

  // Writeback from reorder buffer
  output ROB2RT_t [`NUM_RT_UOP-1:0] rd_rob2rt_o,

  // Trap output
  output logic trap_valid_o,
  output RVVInstruction trap_data_o,

  // VXSAT update from backend (fixes C3 bug: previously dead-end wires)
  output logic                            wr_vxsat_valid_o,
  output logic    [`VCSR_VXSAT_WIDTH-1:0] wr_vxsat_o
);
  logic [N-1:0] frontend_cmd_valid;
  RVVCmd [N-1:0] frontend_cmd_data;
  logic [$clog2(2*N + 1)-1:0] queue_capacity_internal;
  RvvFrontEnd#(.N(N)) frontend(
      .clk(clk),
      .rstn(rstn),
      .vstart_i(vstart),
      .vxrm_i(vxrm),
      .vxsat_i(vxsat),
      .frm_i(frm),
      .inst_valid_i(inst_valid),
      .inst_data_i(inst_data),
      .inst_ready_o(inst_ready),
      .reg_read_valid_i(reg_read_valid),
      .reg_read_data_i(reg_read_data),
      .reg_write_valid_o(reg_write_valid),
      .reg_write_addr_o(reg_write_addr),
      .reg_write_data_o(reg_write_data),
      .cmd_valid_o(frontend_cmd_valid),
      .cmd_data_o(frontend_cmd_data),
      .queue_capacity_i(queue_capacity_internal),
      .queue_capacity_o(queue_capacity),
      .trap_valid_o(trap_valid_o),
      .trap_data_o(trap_data_o),
      .config_state_valid(config_state_valid),
      .config_state(config_state)
  );

  // Backpressure from backend fifo
  logic   [$clog2(`CQ_DEPTH):0] remaining_count_cq2rvs;
  // Back-pressure frontend
  always_comb begin
    if (remaining_count_cq2rvs > 2*N) begin
      queue_capacity_internal = 2*N;
    end else begin
      queue_capacity_internal = remaining_count_cq2rvs;
    end
  end

  // Back-end ============================================================

  // LSU Tie-offs
  // RVV send LSU uop to RVS
    UOP_RVV2LSU_t     [`NUM_LSU-1:0]          uop_lsu_rvv2lsu;
    always_comb begin
      for (int i = 0; i < `NUM_LSU; i++) begin
        uop_lsu_idx_valid_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vidx_valid;
        uop_lsu_idx_addr_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vidx_addr;
        uop_lsu_idx_data_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vidx_data;
        uop_lsu_vregfile_valid_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vregfile_read_valid;
        uop_lsu_vregfile_addr_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vregfile_read_addr;
        uop_lsu_vregfile_data_rvv2lsu[i] = uop_lsu_rvv2lsu[i].vregfile_read_data;
        uop_lsu_v0_valid_rvv2lsu[i] = uop_lsu_rvv2lsu[i].v0_valid;
        uop_lsu_v0_data_rvv2lsu[i] = uop_lsu_rvv2lsu[i].v0_data;
      end
    end

  // LSU feedback to RVV
    UOP_LSU2RVV_t     [`NUM_LSU-1:0]          uop_lsu_lsu2rvv;
    always_comb begin
      for (int i = 0; i < `NUM_LSU; i++) begin
        // TODO(derekjchow): Modify me
        uop_lsu_lsu2rvv[i].vregfile_write_valid = (
            uop_lsu_valid_lsu2rvv[i] && !uop_lsu_last_lsu2rvv[i]);
        uop_lsu_lsu2rvv[i].vregfile_write_addr = uop_lsu_addr_lsu2rvv[i];
        uop_lsu_lsu2rvv[i].vregfile_write_data = uop_lsu_wdata_lsu2rvv[i];
        uop_lsu_lsu2rvv[i].lsu_vstore_last = (
            uop_lsu_valid_lsu2rvv[i] && uop_lsu_last_lsu2rvv[i]);
      `ifdef TB_SUPPORT
        uop_lsu_lsu2rvv[i].uop_pc = 0;
        uop_lsu_lsu2rvv[i].uop_index = 0;
      `endif
      end
    end

  // Scalar regfile write-back tie-offs
  // TODO(derekjchow): Properly arbitrate write-back tie-offs by extending
  // interface. For time being, only accept from slot 0.
  logic    [`NUM_RT_UOP-1:0] rt_xrf_valid_rvv2rvs;
  RT2XRF_t [`NUM_RT_UOP-1:0] rt_xrf_rvv2rvs;
  logic    [`NUM_RT_UOP-1:0] rt_xrf_ready_rvs2rvv;
  always_comb begin
    rt_xrf_ready_rvs2rvv[0] = async_rd_ready;
    async_rd_valid = rt_xrf_valid_rvv2rvs[0];
    async_rd_addr = rt_xrf_rvv2rvs[0].rt_index;
    async_rd_data = rt_xrf_rvv2rvs[0].rt_data;
    for (int i = 1; i < `NUM_RT_UOP; i++) begin
      rt_xrf_ready_rvs2rvv[i] = 0;
    end
  end

  // Backpressure
  logic wr_vxsat_ready;
  always_comb begin
    // TODO(derekjchow): Actually accept
    wr_vxsat_ready = 1;
  end

  // CSR Update, unused for now
  logic                            wr_vxsat_valid;
  logic    [`VCSR_VXSAT_WIDTH-1:0] wr_vxsat;

  // Trap handling tie-off
  logic  trap_valid_rvs2rvv;
  logic  trap_ready_rvv2rvs;
  always_comb begin
    trap_valid_rvs2rvv = 0;
  end

  // Tie-off floating point writeback until implemented.
  assign async_frd_valid = 0;
  assign async_frd_addr = 0;
  assign async_frd_data = 0;

  ROB2RT_t [`NUM_RT_UOP-1:0] rd_rob2rt;
  assign rd_rob2rt_o = rd_rob2rt;

  logic   [`ISSUE_LANE-1:0] insts_ready_cq2rvs;
  logic rvv_backend_idle;
  assign rvv_idle = rvv_backend_idle && (frontend_cmd_valid == 0);
  rvv_backend backend(
      .clk(clk),
      .rst_n(rstn),
      .insts_valid_rvs2cq(frontend_cmd_valid),
      .insts_rvs2cq(frontend_cmd_data),
      .insts_ready_cq2rvs(insts_ready_cq2rvs),
      .remaining_count_cq2rvs(remaining_count_cq2rvs),

      .uop_lsu_valid_rvv2lsu(uop_lsu_valid_rvv2lsu),
      .uop_lsu_rvv2lsu(uop_lsu_rvv2lsu),
      .uop_lsu_ready_lsu2rvv(uop_lsu_ready_lsu2rvv),

      .uop_lsu_valid_lsu2rvv(uop_lsu_valid_lsu2rvv),
      .uop_lsu_lsu2rvv(uop_lsu_lsu2rvv),
      .uop_lsu_ready_rvv2lsu(uop_lsu_ready_rvv2lsu),

      .rt_xrf_rvv2rvs(rt_xrf_rvv2rvs),
      .rt_xrf_valid_rvv2rvs(rt_xrf_valid_rvv2rvs),
      .rt_xrf_ready_rvs2rvv(rt_xrf_ready_rvs2rvv),
      .wr_vxsat_valid(wr_vxsat_valid),
      .wr_vxsat(wr_vxsat),
      .wr_vxsat_ready(wr_vxsat_ready),
      .trap_valid_rvs2rvv(trap_valid_rvs2rvv),
      .trap_ready_rvv2rvs(trap_ready_rvv2rvs),
      .vcsr_valid(vcsr_valid),
      .vector_csr(vector_csr),
      .vcsr_ready(vcsr_ready),
`ifdef TB_SUPPORT
      .rd_valid_rob2rt_o(),
`endif
      .rvv_idle(rvv_backend_idle),
      .rd_rob2rt_o(rd_rob2rt)
  );

  // Connect vxsat signals to outputs (fixes C3 bug)
  assign wr_vxsat_valid_o = wr_vxsat_valid;
  assign wr_vxsat_o = wr_vxsat;

endmodule
// ----- 8< ----- FILE "./RvvCoreWrapper.sv" ----- 8< -----

// Generated by CIRCT firtool-1.114.0-2-g6cf2492e1
module RvvCoreWrapper(
    input clk,
    input rstn,
    input logic [6:0] vstart,
    input logic [1:0] vxrm,
    input logic vxsat,
    input logic [2:0] frm,
    input inst_0_valid,
    input [31:0] inst_0_bits_pc,
    input [1:0] inst_0_bits_opcode,
    input [24:0] inst_0_bits_bits,
    input inst_1_valid,
    input [31:0] inst_1_bits_pc,
    input [1:0] inst_1_bits_opcode,
    input [24:0] inst_1_bits_bits,
    input inst_2_valid,
    input [31:0] inst_2_bits_pc,
    input [1:0] inst_2_bits_opcode,
    input [24:0] inst_2_bits_bits,
    input inst_3_valid,
    input [31:0] inst_3_bits_pc,
    input [1:0] inst_3_bits_opcode,
    input [24:0] inst_3_bits_bits,
    input rs_0_valid,
    input [31:0] rs_0_data,
    input rs_1_valid,
    input [31:0] rs_1_data,
    input rs_2_valid,
    input [31:0] rs_2_data,
    input rs_3_valid,
    input [31:0] rs_3_data,
    input rs_4_valid,
    input [31:0] rs_4_data,
    input rs_5_valid,
    input [31:0] rs_5_data,
    input rs_6_valid,
    input [31:0] rs_6_data,
    input rs_7_valid,
    input [31:0] rs_7_data,
    input [31:0] frs_0,
    input [31:0] frs_1,
    input [31:0] frs_2,
    input [31:0] frs_3,
    output inst_0_ready,
    output inst_1_ready,
    output inst_2_ready,
    output inst_3_ready,
    output rd_0_valid,
    output [4:0] rd_0_bits_addr,
    output [31:0] rd_0_bits_data,
    output rd_1_valid,
    output [4:0] rd_1_bits_addr,
    output [31:0] rd_1_bits_data,
    output rd_2_valid,
    output [4:0] rd_2_bits_addr,
    output [31:0] rd_2_bits_data,
    output rd_3_valid,
    output [4:0] rd_3_bits_addr,
    output [31:0] rd_3_bits_data,
    output async_rd_valid,
    output [4:0] async_rd_bits_addr,
    output [31:0] async_rd_bits_data,
    input async_rd_ready,
    output async_frd_valid,
    output [4:0] async_frd_bits_addr,
    output [31:0] async_frd_bits_data,
    input async_frd_ready,
    output rvv2lsu_0_valid,
    output rvv2lsu_0_bits_idx_valid,
    output [4:0] rvv2lsu_0_bits_idx_bits_addr,
    output [128-1:0] rvv2lsu_0_bits_idx_bits_data,
    output rvv2lsu_0_bits_vregfile_valid,
    output [4:0] rvv2lsu_0_bits_vregfile_bits_addr,
    output [128-1:0] rvv2lsu_0_bits_vregfile_bits_data,
    output rvv2lsu_0_bits_mask_valid,
    output [(128/8)-1:0] rvv2lsu_0_bits_mask_bits,
    input rvv2lsu_0_ready,
    output rvv2lsu_1_valid,
    output rvv2lsu_1_bits_idx_valid,
    output [4:0] rvv2lsu_1_bits_idx_bits_addr,
    output [128-1:0] rvv2lsu_1_bits_idx_bits_data,
    output rvv2lsu_1_bits_vregfile_valid,
    output [4:0] rvv2lsu_1_bits_vregfile_bits_addr,
    output [128-1:0] rvv2lsu_1_bits_vregfile_bits_data,
    output rvv2lsu_1_bits_mask_valid,
    output [(128/8)-1:0] rvv2lsu_1_bits_mask_bits,
    input rvv2lsu_1_ready,
    input lsu2rvv_0_valid,
    input [4:0] lsu2rvv_0_bits_addr,
    input [128-1:0] lsu2rvv_0_bits_data,
    input  lsu2rvv_0_bits_last,
    output lsu2rvv_0_ready,
    input lsu2rvv_1_valid,
    input [4:0] lsu2rvv_1_bits_addr,
    input [128-1:0] lsu2rvv_1_bits_data,
    input  lsu2rvv_1_bits_last,
    output lsu2rvv_1_ready,
    output vcsr_valid,
    output [6:0] vcsr_vstart,
    output [1:0] vcsr_xrm,
    output vcsr_vxsat,
    input vcsr_ready,
    output configStateValid,
    output [7:0] configVl,
    output [6:0] configVstart,
    output configMa,
    output configTa,
    output [1:0] configXrm,
    output [2:0] configSew,
    output [2:0] configLmul,
    output [2:0] configLmulOrig,
    output configVill,
    output logic rvv_idle,
    output logic [3:0] queue_capacity,

    output rd_rob2rt_o_0_w_valid,
    output [4:0] rd_rob2rt_o_0_w_index,
    output [127:0] rd_rob2rt_o_0_w_data,
    output rd_rob2rt_o_0_w_type,
    output [15:0] rd_rob2rt_o_0_vd_type,
    output rd_rob2rt_o_0_trap_flag,
    output rd_rob2rt_o_0_vector_csr_vl,
    output rd_rob2rt_o_0_vector_csr_vstart,
    output rd_rob2rt_o_0_vector_csr_ma,
    output rd_rob2rt_o_0_vector_csr_ta,
    output rd_rob2rt_o_0_vector_csr_xrm,
    output rd_rob2rt_o_0_vector_csr_sew,
    output rd_rob2rt_o_0_vector_csr_lmul,
    output rd_rob2rt_o_0_vector_csr_lmul_orig,
    output rd_rob2rt_o_0_vector_csr_vill,
    output [15:0] rd_rob2rt_o_0_vxsaturate,
    output [31:0] rd_rob2rt_o_0_uop_pc,
    output rd_rob2rt_o_0_last_uop_valid,
            
    output rd_rob2rt_o_1_w_valid,
    output [4:0] rd_rob2rt_o_1_w_index,
    output [127:0] rd_rob2rt_o_1_w_data,
    output rd_rob2rt_o_1_w_type,
    output [15:0] rd_rob2rt_o_1_vd_type,
    output rd_rob2rt_o_1_trap_flag,
    output rd_rob2rt_o_1_vector_csr_vl,
    output rd_rob2rt_o_1_vector_csr_vstart,
    output rd_rob2rt_o_1_vector_csr_ma,
    output rd_rob2rt_o_1_vector_csr_ta,
    output rd_rob2rt_o_1_vector_csr_xrm,
    output rd_rob2rt_o_1_vector_csr_sew,
    output rd_rob2rt_o_1_vector_csr_lmul,
    output rd_rob2rt_o_1_vector_csr_lmul_orig,
    output rd_rob2rt_o_1_vector_csr_vill,
    output [15:0] rd_rob2rt_o_1_vxsaturate,
    output [31:0] rd_rob2rt_o_1_uop_pc,
    output rd_rob2rt_o_1_last_uop_valid,
            
    output rd_rob2rt_o_2_w_valid,
    output [4:0] rd_rob2rt_o_2_w_index,
    output [127:0] rd_rob2rt_o_2_w_data,
    output rd_rob2rt_o_2_w_type,
    output [15:0] rd_rob2rt_o_2_vd_type,
    output rd_rob2rt_o_2_trap_flag,
    output rd_rob2rt_o_2_vector_csr_vl,
    output rd_rob2rt_o_2_vector_csr_vstart,
    output rd_rob2rt_o_2_vector_csr_ma,
    output rd_rob2rt_o_2_vector_csr_ta,
    output rd_rob2rt_o_2_vector_csr_xrm,
    output rd_rob2rt_o_2_vector_csr_sew,
    output rd_rob2rt_o_2_vector_csr_lmul,
    output rd_rob2rt_o_2_vector_csr_lmul_orig,
    output rd_rob2rt_o_2_vector_csr_vill,
    output [15:0] rd_rob2rt_o_2_vxsaturate,
    output [31:0] rd_rob2rt_o_2_uop_pc,
    output rd_rob2rt_o_2_last_uop_valid,
            
    output rd_rob2rt_o_3_w_valid,
    output [4:0] rd_rob2rt_o_3_w_index,
    output [127:0] rd_rob2rt_o_3_w_data,
    output rd_rob2rt_o_3_w_type,
    output [15:0] rd_rob2rt_o_3_vd_type,
    output rd_rob2rt_o_3_trap_flag,
    output rd_rob2rt_o_3_vector_csr_vl,
    output rd_rob2rt_o_3_vector_csr_vstart,
    output rd_rob2rt_o_3_vector_csr_ma,
    output rd_rob2rt_o_3_vector_csr_ta,
    output rd_rob2rt_o_3_vector_csr_xrm,
    output rd_rob2rt_o_3_vector_csr_sew,
    output rd_rob2rt_o_3_vector_csr_lmul,
    output rd_rob2rt_o_3_vector_csr_lmul_orig,
    output rd_rob2rt_o_3_vector_csr_vill,
    output [15:0] rd_rob2rt_o_3_vxsaturate,
    output [31:0] rd_rob2rt_o_3_uop_pc,
    output rd_rob2rt_o_3_last_uop_valid,
            
    output trap_valid,
    output [31:0] trap_bits_pc,
    output [1:0] trap_bits_opcode,
    output [24:0] trap_bits_bits,
    output wr_vxsat_valid_o,
    output wr_vxsat_o
);
  logic [4-1:0] inst_valid;
  assign inst_valid[0] = inst_0_valid;
  assign inst_valid[1] = inst_1_valid;
  assign inst_valid[2] = inst_2_valid;
  assign inst_valid[3] = inst_3_valid;
  RVVInstruction [4-1:0] inst_data;
  assign inst_data[0].pc = inst_0_bits_pc;
  assign inst_data[0].opcode = RVVOpCode'(inst_0_bits_opcode);
  assign inst_data[0].bits = inst_0_bits_bits;
  assign inst_data[1].pc = inst_1_bits_pc;
  assign inst_data[1].opcode = RVVOpCode'(inst_1_bits_opcode);
  assign inst_data[1].bits = inst_1_bits_bits;
  assign inst_data[2].pc = inst_2_bits_pc;
  assign inst_data[2].opcode = RVVOpCode'(inst_2_bits_opcode);
  assign inst_data[2].bits = inst_2_bits_bits;
  assign inst_data[3].pc = inst_3_bits_pc;
  assign inst_data[3].opcode = RVVOpCode'(inst_3_bits_opcode);
  assign inst_data[3].bits = inst_3_bits_bits;
  logic [4-1:0] inst_ready;
  logic [2*4-1:0] reg_read_valid;
  assign reg_read_valid[0] = rs_0_valid;
  assign reg_read_valid[1] = rs_1_valid;
  assign reg_read_valid[2] = rs_2_valid;
  assign reg_read_valid[3] = rs_3_valid;
  assign reg_read_valid[4] = rs_4_valid;
  assign reg_read_valid[5] = rs_5_valid;
  assign reg_read_valid[6] = rs_6_valid;
  assign reg_read_valid[7] = rs_7_valid;
  logic [2*4-1:0][31:0] reg_read_data;
  assign reg_read_data[0] = rs_0_data;
  assign reg_read_data[1] = rs_1_data;
  assign reg_read_data[2] = rs_2_data;
  assign reg_read_data[3] = rs_3_data;
  assign reg_read_data[4] = rs_4_data;
  assign reg_read_data[5] = rs_5_data;
  assign reg_read_data[6] = rs_6_data;
  assign reg_read_data[7] = rs_7_data;
  logic [4-1:0][31:0] freg_read_data;
  assign freg_read_data[0] = frs_0;
  assign freg_read_data[1] = frs_1;
  assign freg_read_data[2] = frs_2;
  assign freg_read_data[3] = frs_3;
  logic [2-1:0] uop_lsu_valid_rvv2lsu;
  logic [2-1:0] uop_lsu_idx_valid_rvv2lsu;
  logic [2-1:0][4:0] uop_lsu_idx_addr_rvv2lsu;
  logic [2-1:0][128-1:0] uop_lsu_idx_data_rvv2lsu;
  logic [2-1:0] uop_lsu_vregfile_valid_rvv2lsu;
  logic [2-1:0][4:0] uop_lsu_vregfile_addr_rvv2lsu;
  logic [2-1:0][128-1:0] uop_lsu_vregfile_data_rvv2lsu;
  logic [2-1:0] uop_lsu_v0_valid_rvv2lsu;
  logic [2-1:0][(128/8)-1:0] uop_lsu_v0_data_rvv2lsu;
  logic [2-1:0] uop_lsu_ready_lsu2rvv;
  assign rvv2lsu_0_valid = uop_lsu_valid_rvv2lsu[0];
  assign rvv2lsu_0_bits_idx_valid = uop_lsu_idx_valid_rvv2lsu[0];
  assign rvv2lsu_0_bits_idx_bits_addr = uop_lsu_idx_addr_rvv2lsu[0];
  assign rvv2lsu_0_bits_idx_bits_data = uop_lsu_idx_data_rvv2lsu[0];
  assign rvv2lsu_0_bits_vregfile_valid = uop_lsu_vregfile_valid_rvv2lsu[0];
  assign rvv2lsu_0_bits_vregfile_bits_addr = uop_lsu_vregfile_addr_rvv2lsu[0];
  assign rvv2lsu_0_bits_vregfile_bits_data = uop_lsu_vregfile_data_rvv2lsu[0];
  assign rvv2lsu_0_bits_mask_valid = uop_lsu_v0_valid_rvv2lsu[0];
  assign rvv2lsu_0_bits_mask_bits = uop_lsu_v0_data_rvv2lsu[0];
  assign uop_lsu_ready_lsu2rvv[0] = rvv2lsu_0_ready;

  assign rvv2lsu_1_valid = uop_lsu_valid_rvv2lsu[1];
  assign rvv2lsu_1_bits_idx_valid = uop_lsu_idx_valid_rvv2lsu[1];
  assign rvv2lsu_1_bits_idx_bits_addr = uop_lsu_idx_addr_rvv2lsu[1];
  assign rvv2lsu_1_bits_idx_bits_data = uop_lsu_idx_data_rvv2lsu[1];
  assign rvv2lsu_1_bits_vregfile_valid = uop_lsu_vregfile_valid_rvv2lsu[1];
  assign rvv2lsu_1_bits_vregfile_bits_addr = uop_lsu_vregfile_addr_rvv2lsu[1];
  assign rvv2lsu_1_bits_vregfile_bits_data = uop_lsu_vregfile_data_rvv2lsu[1];
  assign rvv2lsu_1_bits_mask_valid = uop_lsu_v0_valid_rvv2lsu[1];
  assign rvv2lsu_1_bits_mask_bits = uop_lsu_v0_data_rvv2lsu[1];
  assign uop_lsu_ready_lsu2rvv[1] = rvv2lsu_1_ready;
  logic [2-1:0] uop_lsu_valid_lsu2rvv;
  logic  [2-1:0][4:0]  uop_lsu_addr_lsu2rvv;
  logic  [2-1:0][128-1:0] uop_lsu_wdata_lsu2rvv;
  logic  [2-1:0] uop_lsu_last_lsu2rvv;
  logic  [2-1:0] uop_lsu_ready_rvv2lsu;
  assign uop_lsu_valid_lsu2rvv[0] = lsu2rvv_0_valid;
  assign uop_lsu_addr_lsu2rvv[0] = lsu2rvv_0_bits_addr;
  assign uop_lsu_wdata_lsu2rvv[0] = lsu2rvv_0_bits_data;
  assign uop_lsu_last_lsu2rvv[0] = lsu2rvv_0_bits_last;
  assign lsu2rvv_0_ready = uop_lsu_ready_rvv2lsu[0];

  assign uop_lsu_valid_lsu2rvv[1] = lsu2rvv_1_valid;
  assign uop_lsu_addr_lsu2rvv[1] = lsu2rvv_1_bits_addr;
  assign uop_lsu_wdata_lsu2rvv[1] = lsu2rvv_1_bits_data;
  assign uop_lsu_last_lsu2rvv[1] = lsu2rvv_1_bits_last;
  assign lsu2rvv_1_ready = uop_lsu_ready_rvv2lsu[1];
  logic [4-1:0] reg_write_valid;
  logic [4-1:0][4:0] reg_write_addr;
  logic [4-1:0][31:0] reg_write_data;
  RVVConfigState vector_csr;
  assign vcsr_vstart = vector_csr.vstart;
  assign vcsr_xrm = vector_csr.xrm;
  assign vcsr_vxsat = vector_csr.xsat;
  RVVConfigState config_state;
  ROB2RT_t [3:0] rd_rob2rt_o;
  RVVInstruction trap_data;
  RvvCore#(.N (4)) core(
      .clk(clk),
      .rstn(rstn),
      .vstart(vstart),
      .vxrm(vxrm),
      .vxsat(vxsat),
      .frm(frm),
      .inst_valid(inst_valid),
      .inst_data(inst_data),
      .inst_ready(inst_ready),
      .reg_read_valid(reg_read_valid),
      .reg_read_data(reg_read_data),
      .freg_read_data(freg_read_data),
      .reg_write_valid(reg_write_valid),
      .reg_write_addr(reg_write_addr),
      .reg_write_data(reg_write_data),
      .async_rd_valid(async_rd_valid),
      .async_rd_addr(async_rd_bits_addr),
      .async_rd_data(async_rd_bits_data),
      .async_rd_ready(async_rd_ready),
      .async_frd_valid(async_frd_valid),
      .async_frd_addr(async_frd_bits_addr),
      .async_frd_data(async_frd_bits_data),
      .async_frd_ready(async_frd_ready),
      .uop_lsu_valid_rvv2lsu(uop_lsu_valid_rvv2lsu),
      .uop_lsu_idx_valid_rvv2lsu(uop_lsu_idx_valid_rvv2lsu),
      .uop_lsu_idx_addr_rvv2lsu(uop_lsu_idx_addr_rvv2lsu),
      .uop_lsu_idx_data_rvv2lsu(uop_lsu_idx_data_rvv2lsu),
      .uop_lsu_vregfile_valid_rvv2lsu(uop_lsu_vregfile_valid_rvv2lsu),
      .uop_lsu_vregfile_addr_rvv2lsu(uop_lsu_vregfile_addr_rvv2lsu),
      .uop_lsu_vregfile_data_rvv2lsu(uop_lsu_vregfile_data_rvv2lsu),
      .uop_lsu_v0_valid_rvv2lsu(uop_lsu_v0_valid_rvv2lsu),
      .uop_lsu_v0_data_rvv2lsu(uop_lsu_v0_data_rvv2lsu),
      .uop_lsu_ready_lsu2rvv(uop_lsu_ready_lsu2rvv),
      .uop_lsu_valid_lsu2rvv(uop_lsu_valid_lsu2rvv),
      .uop_lsu_addr_lsu2rvv(uop_lsu_addr_lsu2rvv),
      .uop_lsu_wdata_lsu2rvv(uop_lsu_wdata_lsu2rvv),
      .uop_lsu_last_lsu2rvv(uop_lsu_last_lsu2rvv),
      .uop_lsu_ready_rvv2lsu(uop_lsu_ready_rvv2lsu),
      .vcsr_valid(vcsr_valid),
      .vector_csr(vector_csr),
      .vcsr_ready(vcsr_ready),
      .config_state_valid(configStateValid),
      .config_state(config_state),
      .rvv_idle(rvv_idle),
      .queue_capacity(queue_capacity),
      .rd_rob2rt_o(rd_rob2rt_o),
      .trap_valid_o(trap_valid),
      .trap_data_o(trap_data),
      .wr_vxsat_valid_o(wr_vxsat_valid_o),
      .wr_vxsat_o(wr_vxsat_o)
  );
  assign rd_rob2rt_o_0_w_valid = rd_rob2rt_o[0].w_valid;
  assign rd_rob2rt_o_0_w_index = rd_rob2rt_o[0].w_index;
  assign rd_rob2rt_o_0_w_data = rd_rob2rt_o[0].w_data;
  assign rd_rob2rt_o_0_w_type = rd_rob2rt_o[0].w_type;
  assign rd_rob2rt_o_0_vd_type = rd_rob2rt_o[0].vd_type;
  assign rd_rob2rt_o_0_trap_flag = rd_rob2rt_o[0].trap_flag;
  assign rd_rob2rt_o_0_vector_csr_vl = rd_rob2rt_o[0].vector_csr.vl;
  assign rd_rob2rt_o_0_vector_csr_vstart = rd_rob2rt_o[0].vector_csr.vstart;
  assign rd_rob2rt_o_0_vector_csr_ma = rd_rob2rt_o[0].vector_csr.ma;
  assign rd_rob2rt_o_0_vector_csr_ta = rd_rob2rt_o[0].vector_csr.ta;
  assign rd_rob2rt_o_0_vector_csr_xrm = rd_rob2rt_o[0].vector_csr.xrm;
  assign rd_rob2rt_o_0_vector_csr_sew = rd_rob2rt_o[0].vector_csr.sew;
  assign rd_rob2rt_o_0_vector_csr_lmul = rd_rob2rt_o[0].vector_csr.lmul;
  assign rd_rob2rt_o_0_vector_csr_lmul_orig = rd_rob2rt_o[0].vector_csr.lmul_orig;
  assign rd_rob2rt_o_0_vector_csr_vill = rd_rob2rt_o[0].vector_csr.vill;
  assign rd_rob2rt_o_0_vxsaturate = rd_rob2rt_o[0].vxsaturate;
  assign rd_rob2rt_o_0_uop_pc = rd_rob2rt_o[0].uop_pc;
  assign rd_rob2rt_o_0_last_uop_valid = rd_rob2rt_o[0].last_uop_valid;
  assign rd_rob2rt_o_1_w_valid = rd_rob2rt_o[1].w_valid;
  assign rd_rob2rt_o_1_w_index = rd_rob2rt_o[1].w_index;
  assign rd_rob2rt_o_1_w_data = rd_rob2rt_o[1].w_data;
  assign rd_rob2rt_o_1_w_type = rd_rob2rt_o[1].w_type;
  assign rd_rob2rt_o_1_vd_type = rd_rob2rt_o[1].vd_type;
  assign rd_rob2rt_o_1_trap_flag = rd_rob2rt_o[1].trap_flag;
  assign rd_rob2rt_o_1_vector_csr_vl = rd_rob2rt_o[1].vector_csr.vl;
  assign rd_rob2rt_o_1_vector_csr_vstart = rd_rob2rt_o[1].vector_csr.vstart;
  assign rd_rob2rt_o_1_vector_csr_ma = rd_rob2rt_o[1].vector_csr.ma;
  assign rd_rob2rt_o_1_vector_csr_ta = rd_rob2rt_o[1].vector_csr.ta;
  assign rd_rob2rt_o_1_vector_csr_xrm = rd_rob2rt_o[1].vector_csr.xrm;
  assign rd_rob2rt_o_1_vector_csr_sew = rd_rob2rt_o[1].vector_csr.sew;
  assign rd_rob2rt_o_1_vector_csr_lmul = rd_rob2rt_o[1].vector_csr.lmul;
  assign rd_rob2rt_o_1_vector_csr_lmul_orig = rd_rob2rt_o[1].vector_csr.lmul_orig;
  assign rd_rob2rt_o_1_vector_csr_vill = rd_rob2rt_o[1].vector_csr.vill;
  assign rd_rob2rt_o_1_vxsaturate = rd_rob2rt_o[1].vxsaturate;
  assign rd_rob2rt_o_1_uop_pc = rd_rob2rt_o[1].uop_pc;
  assign rd_rob2rt_o_1_last_uop_valid = rd_rob2rt_o[1].last_uop_valid;
  assign rd_rob2rt_o_2_w_valid = rd_rob2rt_o[2].w_valid;
  assign rd_rob2rt_o_2_w_index = rd_rob2rt_o[2].w_index;
  assign rd_rob2rt_o_2_w_data = rd_rob2rt_o[2].w_data;
  assign rd_rob2rt_o_2_w_type = rd_rob2rt_o[2].w_type;
  assign rd_rob2rt_o_2_vd_type = rd_rob2rt_o[2].vd_type;
  assign rd_rob2rt_o_2_trap_flag = rd_rob2rt_o[2].trap_flag;
  assign rd_rob2rt_o_2_vector_csr_vl = rd_rob2rt_o[2].vector_csr.vl;
  assign rd_rob2rt_o_2_vector_csr_vstart = rd_rob2rt_o[2].vector_csr.vstart;
  assign rd_rob2rt_o_2_vector_csr_ma = rd_rob2rt_o[2].vector_csr.ma;
  assign rd_rob2rt_o_2_vector_csr_ta = rd_rob2rt_o[2].vector_csr.ta;
  assign rd_rob2rt_o_2_vector_csr_xrm = rd_rob2rt_o[2].vector_csr.xrm;
  assign rd_rob2rt_o_2_vector_csr_sew = rd_rob2rt_o[2].vector_csr.sew;
  assign rd_rob2rt_o_2_vector_csr_lmul = rd_rob2rt_o[2].vector_csr.lmul;
  assign rd_rob2rt_o_2_vector_csr_lmul_orig = rd_rob2rt_o[2].vector_csr.lmul_orig;
  assign rd_rob2rt_o_2_vector_csr_vill = rd_rob2rt_o[2].vector_csr.vill;
  assign rd_rob2rt_o_2_vxsaturate = rd_rob2rt_o[2].vxsaturate;
  assign rd_rob2rt_o_2_uop_pc = rd_rob2rt_o[2].uop_pc;
  assign rd_rob2rt_o_2_last_uop_valid = rd_rob2rt_o[2].last_uop_valid;
  assign rd_rob2rt_o_3_w_valid = rd_rob2rt_o[3].w_valid;
  assign rd_rob2rt_o_3_w_index = rd_rob2rt_o[3].w_index;
  assign rd_rob2rt_o_3_w_data = rd_rob2rt_o[3].w_data;
  assign rd_rob2rt_o_3_w_type = rd_rob2rt_o[3].w_type;
  assign rd_rob2rt_o_3_vd_type = rd_rob2rt_o[3].vd_type;
  assign rd_rob2rt_o_3_trap_flag = rd_rob2rt_o[3].trap_flag;
  assign rd_rob2rt_o_3_vector_csr_vl = rd_rob2rt_o[3].vector_csr.vl;
  assign rd_rob2rt_o_3_vector_csr_vstart = rd_rob2rt_o[3].vector_csr.vstart;
  assign rd_rob2rt_o_3_vector_csr_ma = rd_rob2rt_o[3].vector_csr.ma;
  assign rd_rob2rt_o_3_vector_csr_ta = rd_rob2rt_o[3].vector_csr.ta;
  assign rd_rob2rt_o_3_vector_csr_xrm = rd_rob2rt_o[3].vector_csr.xrm;
  assign rd_rob2rt_o_3_vector_csr_sew = rd_rob2rt_o[3].vector_csr.sew;
  assign rd_rob2rt_o_3_vector_csr_lmul = rd_rob2rt_o[3].vector_csr.lmul;
  assign rd_rob2rt_o_3_vector_csr_lmul_orig = rd_rob2rt_o[3].vector_csr.lmul_orig;
  assign rd_rob2rt_o_3_vector_csr_vill = rd_rob2rt_o[3].vector_csr.vill;
  assign rd_rob2rt_o_3_vxsaturate = rd_rob2rt_o[3].vxsaturate;
  assign rd_rob2rt_o_3_uop_pc = rd_rob2rt_o[3].uop_pc;
  assign rd_rob2rt_o_3_last_uop_valid = rd_rob2rt_o[3].last_uop_valid;
  assign trap_bits_pc = trap_data.pc;
  assign trap_bits_opcode = trap_data.opcode;
  assign trap_bits_bits = trap_data.bits;
  assign inst_0_ready = inst_ready[0];
  assign inst_1_ready = inst_ready[1];
  assign inst_2_ready = inst_ready[2];
  assign inst_3_ready = inst_ready[3];
  assign rd_0_valid = reg_write_valid[0];
  assign rd_0_bits_addr = reg_write_addr[0];
  assign rd_0_bits_data = reg_write_data[0];
  assign rd_1_valid = reg_write_valid[1];
  assign rd_1_bits_addr = reg_write_addr[1];
  assign rd_1_bits_data = reg_write_data[1];
  assign rd_2_valid = reg_write_valid[2];
  assign rd_2_bits_addr = reg_write_addr[2];
  assign rd_2_bits_data = reg_write_data[2];
  assign rd_3_valid = reg_write_valid[3];
  assign rd_3_bits_addr = reg_write_addr[3];
  assign rd_3_bits_data = reg_write_data[3];
  assign configVl = config_state.vl;
  assign configVstart = config_state.vstart;
  assign configMa = config_state.ma;
  assign configTa = config_state.ta;
  assign configXrm = config_state.xrm;
  assign configSew = config_state.sew;
  assign configLmul = config_state.lmul;
  assign configLmulOrig = config_state.lmul_orig;
  assign configVill = config_state.vill;
endmodule
// ----- 8< ----- FILE "./Sram_512x128.v" ----- 8< -----

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module Sram_512x128(
  input          clock,
  input          enable,
  input          write,
  input  [8:0]   addr,
  input  [127:0] wdata,
  input  [15:0] wmask,
  output [127:0] rdata
);

///////////////////////////
///// SRAM Selection //////
///////////////////////////
`ifdef USE_TSMC12FFC
///////////////////////////
///// TSMC12FFC SRAM //////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{~wmask[i]}};
      end
    endgenerate
    TS1N12FFCLLSBLVTD512X128M4SWBSHO u_12ffcp_sram
    (
      // Mode Control
      .BIST(1'b0),          // Built-In Self-Test (active high)
      // Normal Mode Input
      .SLP(1'b0),           // Sleep
      .DSLP(1'b0),          // Deep Sleep
      .SD(1'b0),            // Shut Down
      .CLK(clock),          // Clock
      .CEB(~enable),        // Chip Enable Bar (active low en)
      .WEB(~write),         // Write Enable Bar (active low WE)
      .A(addr),             // Address                               (input [8:0] DM)
      .D(wdata),            // Data                                  (input [127:0] DM)
      .BWEB(nwmask),        // Bit Write Enable Bar (active low BW)  (input [127:0])


      // BIST Mode Input
      .CEBM(1'b0),          // Chip Enable Bar for BIST Mode
      .WEBM(1'b0),          // Write Enable Bar for BIST Mode
      .AM(9'b0),            // Address for BIST Mode               (input [8:0])
      .DM(128'b0),          // Data Input for BIST Mode            (input [127:0] DM)
      .BWEBM({128{1'b1}}),  // Bit Write Enable Bar for BIST Mode  (input [127:0] DM)

      // Data Output
      .Q(rdata),            // Data Output                          (output [127:0])
      .PUDELAY(),           // Power-Up Delay - Connect for tuning timing in late stage design

      // Test Mode
`ifndef SIMULATION
      .RTSEL(2'b0),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
`else
      .RTSEL(2'b1),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
`endif
     );
`elsif USE_GF22
///////////////////////////
//////// GF22 SRAM ////////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{wmask[i]}};
      end
    endgenerate

    sasdulssd8LOW1p512x128m4b1w0c0p0d0l0rm3sdrw01 u_gf22_sram (
      .Q(rdata),
      .ADR(addr),
      .D(wdata),
      .WEM(nwmask),
      .WE(write),
      .ME(enable),
      .CLK(clock),
      .TEST1(1'b0),
      .TEST_RNM(1'b0),
      .RME(1'b0),
      .RM(4'b0),
      .WA(2'b0),
      .WPULSE(3'b0),
      .LS(1'b0),
      .BC0(1'b0),
      .BC1(1'b0),
      .BC2(1'b0)
    );
`else
///////////////////////////
////// Generic SRAM ///////
///////////////////////////
  reg [127:0] mem [0:511];
  reg [8:0] raddr;

  assign rdata = mem[raddr];

`ifndef SYNTHESIS
  task randomMemoryAll;
  for (int i = 0; i < 512; i++) begin
    // $random returns a 32-bit value, so four are concatenated to fill the 128-bit register.
    mem[i] = { $random, $random, $random, $random };
  end
  endtask

  initial begin
    randomMemoryAll;
  end
`endif

  always @(posedge clock) begin
    for (int i = 0; i < 16; i++) begin
      if (enable & write & wmask[i]) begin
        mem[addr][i*8 +: 8] <= wdata[8*i +: 8];
      end
    end

    if (enable & ~write) begin
      raddr <= addr;
    end
  end
`endif

endmodule
// ----- 8< ----- FILE "./Sram_2048x128.v" ----- 8< -----

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

module Sram_2048x128(
  input          clock,
  input          enable,
  input          write,
  input  [10:0]   addr,
  input  [127:0] wdata,
  input  [15:0] wmask,
  output [127:0] rdata
);

///////////////////////////
///// SRAM Selection //////
///////////////////////////
`ifdef USE_TSMC12FFC
///////////////////////////
///// TSMC12FFC SRAM //////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{~wmask[i]}};
      end
    endgenerate
    TS1N12FFCLLMBLVTD2048X128M4SWBSHO u_12ffcp_sram
    (
      // Mode Control
      .BIST(1'b0),          // Built-In Self-Test (active high)
      // Normal Mode Input
      .SLP(1'b0),           // Sleep
      .DSLP(1'b0),          // Deep Sleep
      .SD(1'b0),            // Shut Down
      .CLK(clock),          // Clock
      .CEB(~enable),        // Chip Enable Bar (active low en)
      .WEB(~write),         // Write Enable Bar (active low WE)
      .A(addr),             // Address                               (input [10:0] DM)
      .D(wdata),            // Data                                  (input [127:0] DM)
      .BWEB(nwmask),        // Bit Write Enable Bar (active low BW)  (input [127:0])


      // BIST Mode Input
      .CEBM(1'b0),          // Chip Enable Bar for BIST Mode
      .WEBM(1'b0),          // Write Enable Bar for BIST Mode
      .AM(11'b0),           // Address for BIST Mode               (input [10:0])
      .DM(128'b0),          // Data Input for BIST Mode            (input [127:0] DM)
      .BWEBM({128{1'b1}}),  // Bit Write Enable Bar for BIST Mode  (input [127:0] DM)

      // Data Output
      .Q(rdata),            // Data Output                          (output [127:0])
      .PUDELAY(),           // Power-Up Delay - Connect for tuning timing in late stage design

      // Test Mode
`ifndef SIMULATION
      .RTSEL(2'b0),         // Read Test Select                (input [1:0])
      .WTSEL(2'b0)          // Write Test Select               (input [1:0])
`else
      .RTSEL(2'b1),         // Read Test Select                (input [1:0])
      .WTSEL(2'b1)          // Write Test Select               (input [1:0])
`endif
     );
`elsif USE_GF22
///////////////////////////
//////// GF22 SRAM ////////
///////////////////////////
    wire [127:0] nwmask;
    genvar i;
    generate
      for (i = 0; i < 16; i++) begin
        assign nwmask[8*i +: 8] = {8{wmask[i]}};
      end
    endgenerate

    sasdulssd8LOW1p2048x128m4b2w0c0p0d0l0rm3sdrw01 u_gf22_sram (
      // Data Output
      .Q(rdata),            // Data Output [127:0]
      // Data Input
      .ADR(addr),           // Address [10:0]
      .D(wdata),            // Data Input [127:0]
      .WEM(nwmask),         // Write Enable Mask [127:0] (active high)
      .WE(write),           // Write Enable (active high)
      .ME(enable),          // Memory Enable (active high)
      .CLK(clock),          // Clock
      // Test and Power-saving pins - tied off
      .TEST1(1'b0),
      .TEST_RNM(1'b0),
      .RME(1'b0),
      .RM(4'b0),
      .WA(2'b0),
      .WPULSE(3'b0),
      .LS(1'b0),
      .BC0(1'b0),
      .BC1(1'b0),
      .BC2(1'b0)
    );
`else
///////////////////////////
////// Generic SRAM ///////
///////////////////////////
  reg [127:0] mem [0:2047];
  reg [10:0] raddr;

  assign rdata = mem[raddr];

`ifndef SYNTHESIS
  task randomMemoryAll;
  for (int i = 0; i < 2048; i++) begin
    // $random returns a 32-bit value, so four are concatenated to fill the 128-bit register.
    mem[i] = { $random, $random, $random, $random };
  end
  endtask

  initial begin
    randomMemoryAll;
  end
`endif

  always @(posedge clock) begin
    for (int i = 0; i < 16; i++) begin
      if (enable & write & wmask[i]) begin
        mem[addr][i*8 +: 8] <= wdata[8*i +: 8];
      end
    end

    if (enable & ~write) begin
      raddr <= addr;
    end
  end
`endif // FFCP12_SRAM

endmodule
